
---

title: 基础网络知识

urlname: ggqnsg

date: 2019-10-09 00:00:00 +0000

layout: post

comments: true

categories: 网络

tags: [Linux,网络]

keywords: 网络

description: 本文记录需要掌握的基础网络知识。

---


1. NO-CARRIER 表示网络接口未检测到线路上的信号。通常是因为网络电缆已拔出或断开。在极少数情况下，也可能是硬件故障或驱动程序错误。
1. 所有客户端与 WebSocket Server 建立进行通信时，都需要先发送 Http Get 请求完成握手过程，该 Http 请求头中包含 Upgrade: websocket 等必要字段，WebSocket Server 端必须能够处理该 Http 请求并在接受建立 WebSocket 连接时返回一个状态码为 101 的 Http 响应告诉客户端从现在开始把协议切换为 WebSocket。这样设计的一个好处时可以让 WebSocket 服务与已经存在的 Http 服务复用同一个端口，只需要一个后端进程处理两种通信协议。当然，也可以搭建一个纯粹的 WebSocket Server，只是依然需要能够响应握手时客户端发出的用以协议升级的 Http 请求，只不过对于其它的 Http 请求不会响应，亦即纯粹的 WebSocket Server 处理且仅处理用以协议升级 Http Get 的请求，之后的通信过程将全部使用 WebSocket 协议。更多解释参考：[https://stackoverflow.com/questions/47085281/do-websocket-implementations-use-http-protocol-internally](https://stackoverflow.com/questions/47085281/do-websocket-implementations-use-http-protocol-internally)
1. TCP Server 端初始处于 LISTEN 状态；TCP Client 端新建一个 TCP Socket （端口号由操作系统分配）并主动发起 SYNC 请求，其过程是向 Server 端发送一个标志位为 SYN=1 及 ACK=0 ，序列号为随机生成的 x，数据部分为空的 TCP 报文，其结果是 Client 端进入 SYN_SENT 状态；Server 端接收到 Client 端的报文，根据 SYN=1 及 ACK=0 确定这是发起连接请求的报文并据此进行响应，其过程是向 Client 端发送一个标志位为 SYN=1 及 ACK=1（确认与同步二合一），序列号为随机生成的 y，确认号为 x+1，数据部分为空的 TCP 报文，其结果是服务端进入 SYN_RECV 状态；Client 端接收到 Server 回复的报文，确认可以和服务端建立通信，因此进入 ESTABLISHED 状态，作为对服务端 SYNC 报文的回应，客户端向服务端发送一个标志位为 ACK=1，序列号为 x+1，确认号为 y+1，数据部分为空的 TCP 报文；服务端收到确认报文后才会进入 ESTABLISHED 状态。
1. TCP 连接建立过程中，最后一次客户端向服务端发送的确认报文除了作为对服务端同步报文的回应，也基于以下原因：在客户端刚开始发起连接时发出的 SYNC 请求报文如果迟迟没有收到服务端的确认报文，客户端会放弃该连接，重新发出 SYNC 请求报文；此时服务端有可能会收到两条 SYNC 报文（超时的报文和新的报文），如果没有最后一次客户端发送的确认报文，服务端直接进入 ESTABLISHED 状态，会建立起两条连接，从而会浪费一条连接开销。
1. 当 TCP 连接建立完成后，两方的角色将变成对称的，任何一端都无法识别自己为客户端还是服务端，因此任何一端都可以先发送 FIN 报文用以关闭连接。由于一旦 FIN 报文从某一端发出，则该端将无法向对端发送数据（接收不受影响），因此往往是由先确知自己无需再发送数据的一端首先发起关闭连接的请求，而对端无需在收到 FIN 报文后立即开始 FIN 过程，可以继续向发起端发送数据直到数据发送完毕后再开始 FIN 过程，因此 TCP 的关闭过程也被称为是半关闭过程，所谓的四次挥手也源于此。
1. FIN 开始之前两方都处于 ESTABLISHED 状态，直到有一方的应用层确认数据发送完毕，主动发起了关闭连接的过程，此时会向另一方（后称为被动方）发送 FIN 请求，其过程是发送一个标志位 FIN=1，序列号为 u ，数据部分为空（也可能不为空，稍后讨论）的 TCP 报文，其结果是主动方进入了 FIN_WAIT 状态；被动方接收到主动方发出的报文，会返回一个标志位为 ACK=1，序列号为 v，确认号为 u+1 ，数据部分为空的报文，结果是被动方进入 CLOSE_WAIT 状态；此后被动方可以继续发送数据直到数据发送完成；被动方完成数据发送，向主动方发送标志位为 FIN=1 及 ACK=1 ，序列号为 w ，确认号依然为 u+1 的，数据部分为空（也可能不为空，稍后讨论）的 TCP 报文，之后被动方进入 LAST_ACK 状态；主动方收到被动方的 FIN 报文后，返回一个标志位为 ACK=1 ，序列号为 u+1 ，确认号为 w+1，数据部分为空的报文，此后主动方进入 TIME_WAIT 状态进行超时等待；被动方收到主动方的确认报文后进入 CLOSED 状态，此时被动方已经先完成了关闭连接的过程。
1. FIN 主动方进入 TIME_WAIT 状态后，会等待 2 倍的最大报文生存时间即 2MSL，等待的原因主要有两个： ① 为了保证主动方发送的最后一个 ACK 报文段能够到达被动方。即如果最后这个确认报文丢失，被动方会超时重传 FIN 报文，然后主动方再一次确认，同时启动 2MSL 计时器，如此下去。如果主动方没有等待时间，发送完确认报文就立即释放连接的话，即使被动方重传了 FIN 报文，也会因主动方已关闭而使被动方无法收到确认报文，被动方就无法正常进入 CLOSE状态。 ② 防止已失效的连接请求报文出现在新的连接中。经过 2MSL，和该连接的相关的报文要么已经到达目的地，要么会被丢弃掉，不会滞留在网络中。这样的话，在下一个连接中就不会出现上一个连接遗留下来的请求报文了。
1. RFC 793 中规定 MSL 为 2 分钟，实际应用中常用的是 30 秒，1 分钟和 2 分钟等。Linux 系统下可通过以下命令查看：`cat /proc/sys/net/ipv4/tcp_fin_timeout` ，在我的 Deepin 和 Manjaro 系统中分别是 40s 和 60s。
1. FIN 报文中是可以携带数据的，携带数据时的连接关闭过程与不携带数据时并无本质区别，只不过与 FIN 报文对应的 ACK 报文中的确认号值需要加上 FIN 报文发来的数据长度 d ，如果 FIN 报文不携带数据时对应的 ACK 报文的确认号为 u+1，则 FIN 携带数据时确认号还要加上 d 用以表示被动方收到了长度为 d 的数据内容，此时确认号为 u+1+d 。 FIN 包携带数据往往是为了提高通信效率，因为这样做相当于将最后一个数据报文和 FIN 报文合二为一，节省了一个报文的发送过程。
1. FIN 谁先关闭的问题可以通过一个简单的抓包实验进行观察：通过启动一个 `python3 -mhttp.server` Http 服务器，使用 WireShark 进行抓包，执行 `curl 127.0.0.1:8000` 后观察抓取的数据包，可以发现服务端在发送 Http 响应的同时主动发起了关闭连接的过程，即最后一个数据报文和 FIN 报文合二为一。
1. 通过抓包观察，在数据传输过程中某一方应答报文的确认号为总是等于另一方发送的报文的序列号和报文数据长度之和，而这个和值也会变成发送方下一次发送报文时的序列号。序列号和确认号的初始值来源于建立连接时客户端和服务端分别获取的随机序列号值 x， y，在连接建立后，第一个数据报文的序列号和确认号分别是 x+1,y+1（客户端发送第一份数据）或者 y+1, x+1（服务端发送第一份数据）。
1. TCP 连接参考文档：[https://blog.csdn.net/guyuealian/article/details/52535294](https://blog.csdn.net/guyuealian/article/details/52535294) ，[https://stackoverflow.com/questions/289194/what-is-maximum-segment-lifetime/35000966](https://stackoverflow.com/questions/289194/what-is-maximum-segment-lifetime/35000966)， [https://www.wikiwand.com/en/Transmission_Control_Protocol](https://www.wikiwand.com/en/Transmission_Control_Protocol)，[https://stackoverflow.com/questions/4677925/who-first-sets-tcp-fin-flag-in-client-server-connection](https://stackoverflow.com/questions/4677925/who-first-sets-tcp-fin-flag-in-client-server-connection)
1. 一张助于理解的图：

![image.png](https://cdn.nlark.com/yuque/0/2019/png/182657/1571478423292-36b18cb8-3312-42ed-940e-40b15315d38d.png#align=left&display=inline&height=793&name=image.png&originHeight=793&originWidth=796&search=&size=62072&status=done&width=796)

14. Linux 内核网络相关函数调用关系图：

![linux-net.jpeg](https://cdn.nlark.com/yuque/0/2019/jpeg/182657/1571896927566-028e0063-6be9-4472-a446-66ac67ca17f5.jpeg#align=left&display=inline&height=1952&name=linux-net.jpeg&originHeight=1952&originWidth=3489&search=&size=1016557&status=done&width=3489)

15. Qdisc 在 Linux 网络栈中的位置：

![image.png](https://cdn.nlark.com/yuque/0/2019/png/182657/1571898730049-ed53082d-e336-42cd-aa59-7233ebb6d57c.png#align=left&display=inline&height=913&name=image.png&originHeight=1475&originWidth=1205&search=&size=325485&status=done&width=746)

16. 路由器与 NAT：

纯粹的路由过程并不会修改 IP 地址，路由过程会修改 MAC 地址，而家用路由器往往并不是纯粹的路由器，而是包含了 NAT 单元，所以家用路由器会修改 IP 从而实现一个局域网内的多个计算机同时连接外网。

17. 一个关于路由过程的说明：
```
The source and destination MAC address will change as the frame traverses the 
network to that of the next hop device and sending device port MAC, respectively.

EXAMPLE:

Three routers, A, B, C. They are connected in line (A connects to B, B connects to 
A and C and C only connects to B like this: A — B — C ) with Host 1 on router A and
Host 2 on Router C.

( 1 — A — B — C — 2 )

Host connected to router A wants to talk to host connected to router C. Host A
determines the IP address of the host and does an ARP lookup to see if it is local.
The host on A determines that it is not local so it looks for a default gateway IP
address. Once found, the IP of the default gateway is checked for an ARP entry and,
if not, broadcasts and ARP to determine the MAC address. Now that all this has been
done, Host 1 on Router A will forward the packet with the Source IP and MAC of its 
machine, Host 1. The Destination IP will be that of Host 2 on Router C and the 
Destination MAC will be the MAC address of the default gateway, which in this case,
if the network is setup properly, will be the interface on Router A connecting to 
the local LAN segment where Host 1 resides. Once Router A receives the frame, 
it will check the destination IP address to see if the IP Address is connected to 
a local LAN segment or not. In this case, we need to go through Router C to get
to Host 2, the router determines that the destination IP is NOT local and looks 
at the routing table for the next steps. This step will check for the BEST route 
available to the Destination IP address. If no route is found, it will check for 
a quad route (0.0.0.0 a.k.a. Default Route). Once the interface is determined based
on the route selection process, it will check for an ARP entry for the IP address 
of the next hop, in this case, Router B interface facing Router A. Router A will 
send the frame up to the CPU and have the source and dest MAC addresses updated to 
reflect the following. Router A egress interface will be the new Source MAC and
Router B interface facing toward router A will be the Destination MAC address. 
Once Router B gets the frame, it will do the same thing and forward the frame out 
toward router C with the Source MAC being the Router B interface facing Router C 
and the Destination MAC address being the interface of Router C. All the while, 
the Source and Destination IP addresses are the same. Since Host 2 would most 
likely be sent to a switch that connects all the users up, Router C will check 
its route table and see that the Destination IP address is locally connected via 
one of its interfaces. At that point,a final ARP check is done to find the MAC 
address of Host 2. The switch will respond with this information and report it 
back to Router C. Router C then replaces the Destination MAC to that of Host 2
(learned via ARP) and replaces the Source MAC as the interface of Router C 
connected to the LAN Segment/Switch. The switch, assuming it’s layer 2 only, 
will see the Destination MAC as that of Host 2 and forward the packet out the port
that Host 2 is connected. Host 2 then receives the frame and the initial journey 
is completed. All the while, these ARP entries are being cached and stored for the
return path as well.

In summary, ARP is used to map the IP to MAC addresses in a network for non-local
forwarding. This is done to prevent broadcasts from flooding the network. Imagine 
if you will, the Internet being one big flat network. All of the hosts on the 
Internet would be ARP-ing for the MAC address of the device it wants to talk to and,
we would never be able to load http://Quora.com as the Internet would be flooded 
with Broadcasts. The purpose of a router is just that, break up the broadcast
domains to prevent this from occuring. Back in the day, we had to design networks 
with this in mind as switching hadn’t been fully realized yet.

Last thing to note that is important. All communication happens at Layer 2, 
Layer 3 is just a way for us humans to organize the network in a way that makes 
logical sense using IP addressing.
```

18. 一个路由选择的例子：

[https://community.cisco.com/t5/networking-blogs/what-happens-when-router-receives-packet/ba-p/3105996](https://community.cisco.com/t5/networking-blogs/what-happens-when-router-receives-packet/ba-p/3105996)

