---
title: 数据结构-绪论
urlname: hqq7kk
date: '2019-11-24 00:00:00 +0800'
updated: 'Sun Nov 24 2019 00:00:00 GMT+0800 (China Standard Time)'
layout: post
comments: true
categories: 数据结构
tags:
  - 数据结构
  - Go
keywords: '数据结构,Go'
description: 邓俊辉的《数据结构(C++ 语言版)》课程与书籍学习笔记，本篇为绪论学习总结，相关代码均重新用 Go 语言实现并托管至 GitHub 。
abbrlink: 75bf7760
---

<a name="baPCt"></a>
### 计算与计算机
绳索计算机与尺规计算机举例，重点是想说明算法是由一系列基本操作组合而成的。

<a name="TkNuM"></a>
### 冒泡排序
计算机超过四分之一的时间都是在进行排序操作。所谓排序是按照某种给定的次序将给定的一组元素顺序排列，例如将 n 个整数按通常的大小次序排成一个非降序列（包含小于等于之意）。序列中相邻元素满足小于等于的关系则称之为顺序的，否则成为逆序，逆序对在随后的一些排序算法中将起到辅助算法设计与分析的功能。局部有序不能保证整体有序，整体有序则必局部有序。冒泡排序算法的实现如下：
```go
func BubbleSort(input []int) []int {
	// sorted 标志位引入是为了提早结束扫描
	sorted := false
	count := len(input)
	times := 0
	for !sorted {
		sorted = true
		for i := 1; i < count; i++ {
			if input[i-1] > input[i] {
				input[i-1], input[i] = input[i], input[i-1]
				sorted = false
			}
		}
		times++
		fmt.Printf("this is %d scan\n", times)
	}
	return input
}
```
冒泡排序属于原地排序，所以可以直接返回原切片作为排好序的序列。

<a name="x0qwr"></a>
### 算法
算法是指基于特定的计算模型，旨在解决某一信息处理问题而设计的一个指令序列。算法必须要具有确定性（由若干语义明确的基本操作组成的指令序列）、可行性（每一个基本操作均可兑现）、有穷性（有限次操作后终止并输出）、正确性（输出符合预设条件），考虑到具体实现还应当有较高的效率和鲁棒性。<br />证明算法有穷性和正确性的一个技巧是从适当的角度审视整个计算过程，找出算法所具有的某种不变性和单调性。冒泡排序的不变性和单调性可概括为：经过 k 趟扫描交换之后，最大的前 k 个元素必然就位（不再参与运算且满足预设条件）；经过 k 趟扫描之后，待求解问题的有效规模将会缩减至 n-k 。
<a name="j26KP"></a>
#### 算法复杂度
为了超脱于硬件平台和软件环境客观评价算法复杂度，可将算法执行时间定义为算法所执行的基本操作的总次数。大 O 标记法表示的算法复杂度界定了算法执行时间的上界，对应于最坏情况；大 Ω 标记界定算法的下界，对应于最好情况；大 θ 标记表明对于规模为 n 的任意输入，算法运行时间同阶，不存在所谓最坏或最好情况。多数情况下，更关注算法执行的最坏情况，所以大 O 标记最为常用。<br />空间复杂度往往关注较小是因为就渐进复杂度而言，在任一算法的任何一次运行过程中所消耗的存储空间都不会多于其间所执行的基本操作的总和。因为每次基本操作所涉及的存储空间都不会超过常数规模，就算每次基本操作设计的空间都是新开辟的，则整个算法所需的空间总量也不过与基本操作的次数同阶，因此可以说时间复杂度本身就是空间复杂度的一个天然上界。<br />除了输入数据之外，仅需常数规模辅助空间的算法称为就地算法。<br />在算法复杂度理论中，多项式时间复杂度被视为一个具有特殊意义的复杂度级别。多项式级别的运行时间成本，在实际应用中一般认为是可接受或可忍受的。某问题若存在一个复杂度在多项式范围内的算法，则称该问题为可求解的或易解的。相应地不存在多项式复杂度算法的问题称作难解的问题。

