---
title: 前端知识点滴
urlname: edn69z
date: '2019-11-14 00:00:00 +0800'
updated: 'Sun Nov 24 2019 00:00:00 GMT+0800 (China Standard Time)'
layout: post
comments: true
categories: 前端
tags:
  - 前端
keywords: FrontEnd
description: 开发过程中遇到的有趣及琐碎的前端知识。
abbrlink: a68ff6
---

<a name="Cmvxj"></a>
#### swagger-client
swagger-client 是一个 js 包，可以读取并解析 Swagger 2.0 和 OpenAPI 3 的 json 文档并生成可以对文档中定义的 API 进行调用的 client，简化 api 请求过程。

<a name="ZYwuU"></a>
#### 文件下载
服务端响应的 Header 中可以设置 `Content-Disposition: attachment; filename=test.txt`  指定文件名称，一般设置 `Content-Type: application/octet-stream` 对于小的文本文件也可以设置为 `Content-Type: text/plain; charset=utf-8`  告诉浏览器可以直接在浏览器窗口打开。 

<a name="J8dcQ"></a>
#### 更新依赖
npm-check-updates 可以帮助更新 package.json 中的所有依赖，其仍是通过 npm update 实现。
```go
npm i -g npm-check-updates
npm-check-updates -u
```

<a name="QukkD"></a>
#### Node.js 下载图片到本地
```javascript
function downloadPic(src, dest){
    request(src).pipe(fs.createWriteStream(dest)).on('close',function(){
        console.log('pic saved!')
    })
}
// 使用方式：
downloadPic(imgList[0],'./catpics/1.jpg');
```

<a name="0i9jz"></a>
#### Node.js 教程

- Node.js TypeScript 15 篇：[https://wanago.io/2019/03/18/node-js-typescript-6-sending-http-requests-understanding-multipart-form-data/](https://wanago.io/2019/03/18/node-js-typescript-6-sending-http-requests-understanding-multipart-form-data/) 篇介绍了如何在 Node.js 中使用 multipart/form-data 流式上传文件。
```javascript
import * as FormData from 'form-data';
import { request } from 'http';
import { createReadStream } from 'fs';
 
const readStream = createReadStream('./photo.jpg');
 
const form = new FormData();
form.append('photo', readStream);
form.append('firstName', 'Marcin');
form.append('lastName', 'Wanago');
 
const req = request(
  {
    host: 'localhost',
    port: '5000',
    path: '/upload',
    method: 'POST',
    headers: form.getHeaders(),
  },
  response => {
    console.log(response.statusCode); // 200
  }
);
 
form.pipe(req);
```

<a name="U3Nur"></a>
#### Node.js 流式转存图片
下载的同时开始上传到七牛云：
```javascript
import * as qiniu from 'qiniu';
const config: any = new qiniu.conf.Config();
config.zone = qiniu.zone.Zone_z2;
const formUploader = new qiniu.form_up.FormUploader(config);
const putExtra = new qiniu.form_up.PutExtra();

async uploadFiles(urls: any[], type: string, token?: string) {
  if (!token) {
    token = await get_token();
  }
  let keys = {};
  for (let url of urls) {
    let requestUrl = url.url.trim();
    if (!requestUrl || !/(https?|ftp|file):\/\/\w+\.\w+/.test(requestUrl)) {
      keys[url.id] = null;
      continue
    }
    const uploadFunc = async () => {
      return new Promise((resolve, reject) => {
        let readableStream = request(requestUrl);
        const key = `images/xxx_${Date.now()}.jpg`;
        try {
          formUploader.putStream(
            token,
            key,
            readableStream,
            putExtra,
            (respErr, respBody, respInfo) => {
              if (respInfo.statusCode == 200) {
                return resolve(respBody && respBody.key);
              } else {
                return resolve(null);
              }
            }
          );
        } catch (e) {
          return resolve(null);
        }
      })
    }
    const key = await uploadFunc();
    this.app.logger.info('key: ', key);
    keys[url.id] = key;
  }
  return keys;
}
```
<a name="uhkxS"></a>
#### 
<a name="INlLR"></a>
#### 从 Html 文本中匹配所有 img 的地址

1. 从字符串中匹配出所有的 img 标签
```javascript
const str = "this is test string <img src=\"http:baidu.com/test.jpg\" width='50' > 1 and the end <img src=\"所有地址也能匹配.jpg\" /> 33! <img src=\"/uploads/attached/image/20120426/20120426225658_92565.png\" alt=\"\" />"
const imgReg = /<img.*?(?:>|\/>)/gi;
const srcReg = /src=[\'\"]?([^\'\"]*)[\'\"]?/i;
const arr = str.match(imgReg);  // arr 为包含所有img标签的数组
```

2. 从数组中获取到所有的 src 地址
```javascript
for (var i = 0; i < arr.length; i++) {
 const src = arr[i].match(srcReg);
 //获取图片地址
  console.log('图片地址'+(i+1)+'：'+src[1]);
}
```



