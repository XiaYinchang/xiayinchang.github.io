---
title: 前端知识点滴
urlname: edn69z
date: '2019-11-14 00:00:00 +0800'
updated: 'Sat Nov 30 2019 00:00:00 GMT+0800 (China Standard Time)'
layout: post
comments: true
categories: 前端
tags:
  - 前端
keywords: 前端
description: 开发过程中遇到的有趣及琐碎的前端知识。
abbrlink: a68ff6
---

<a name="Cmvxj"></a>
#### swagger-client
swagger-client 是一个 js 包，可以读取并解析 Swagger 2.0 和 OpenAPI 3 的 json 文档并生成可以对文档中定义的 API 进行调用的 client，简化 api 请求过程。

<a name="ZYwuU"></a>
#### 文件下载
服务端响应的 Header 中可以设置 `Content-Disposition: attachment; filename=test.txt`  指定文件名称，一般设置 `Content-Type: application/octet-stream` 对于小的文本文件也可以设置为 `Content-Type: text/plain; charset=utf-8`  告诉浏览器可以直接在浏览器窗口打开。 

<a name="J8dcQ"></a>
#### 更新依赖
npm-check-updates 可以帮助更新 package.json 中的所有依赖，其仍是通过 npm update 实现。
```go
npm i -g npm-check-updates
npm-check-updates -u
```

<a name="QukkD"></a>
#### Node.js 下载图片到本地
```javascript
function downloadPic(src, dest){
    request(src).pipe(fs.createWriteStream(dest)).on('close',function(){
        console.log('pic saved!')
    })
}
// 使用方式：
downloadPic(imgList[0],'./catpics/1.jpg');
```

<a name="0i9jz"></a>
#### Node.js 教程

- Node.js TypeScript 15 篇：[https://wanago.io/2019/03/18/node-js-typescript-6-sending-http-requests-understanding-multipart-form-data/](https://wanago.io/2019/03/18/node-js-typescript-6-sending-http-requests-understanding-multipart-form-data/) 篇介绍了如何在 Node.js 中使用 multipart/form-data 流式上传文件。
```javascript
import * as FormData from 'form-data';
import { request } from 'http';
import { createReadStream } from 'fs';
 
const readStream = createReadStream('./photo.jpg');
 
const form = new FormData();
form.append('photo', readStream);
form.append('firstName', 'Marcin');
form.append('lastName', 'Wanago');
 
const req = request(
  {
    host: 'localhost',
    port: '5000',
    path: '/upload',
    method: 'POST',
    headers: form.getHeaders(),
  },
  response => {
    console.log(response.statusCode); // 200
  }
);
 
form.pipe(req);
```

<a name="U3Nur"></a>
#### Node.js 流式转存图片
下载的同时开始上传到七牛云：
```javascript
import * as qiniu from 'qiniu';
const config: any = new qiniu.conf.Config();
config.zone = qiniu.zone.Zone_z2;
const formUploader = new qiniu.form_up.FormUploader(config);
const putExtra = new qiniu.form_up.PutExtra();

async uploadFiles(urls: any[], type: string, token?: string) {
  if (!token) {
    token = await get_token();
  }
  let keys = {};
  for (let url of urls) {
    let requestUrl = url.url.trim();
    if (!requestUrl || !/(https?|ftp|file):\/\/\w+\.\w+/.test(requestUrl)) {
      keys[url.id] = null;
      continue
    }
    const uploadFunc = async () => {
      return new Promise((resolve, reject) => {
        let readableStream = request(requestUrl);
        const key = `images/xxx_${Date.now()}.jpg`;
        try {
          formUploader.putStream(
            token,
            key,
            readableStream,
            putExtra,
            (respErr, respBody, respInfo) => {
              if (respInfo.statusCode == 200) {
                return resolve(respBody && respBody.key);
              } else {
                return resolve(null);
              }
            }
          );
        } catch (e) {
          return resolve(null);
        }
      })
    }
    const key = await uploadFunc();
    this.app.logger.info('key: ', key);
    keys[url.id] = key;
  }
  return keys;
}
```

<a name="INlLR"></a>
#### 从 Html 文本中匹配所有 img 的地址

1. 从字符串中匹配出所有的 img 标签
```javascript
const str = "this is test string <img src=\"http:baidu.com/test.jpg\" width='50' > 1 and the end <img src=\"所有地址也能匹配.jpg\" /> 33! <img src=\"/uploads/attached/image/20120426/20120426225658_92565.png\" alt=\"\" />"
const imgReg = /<img.*?(?:>|\/>)/gi;
const srcReg = /src=[\'\"]?([^\'\"]*)[\'\"]?/i;
const arr = str.match(imgReg);  // arr 为包含所有img标签的数组
```

2. 从数组中获取到所有的 src 地址
```javascript
for (var i = 0; i < arr.length; i++) {
 const src = arr[i].match(srcReg);
 //获取图片地址
  console.log('图片地址'+(i+1)+'：'+src[1]);
}
```

<a name="Jf3qz"></a>
#### cookie 的工作原理

1. 需要 cookie 是因为 HTTP 协议本身是无状态的，但是需要用户登录的网站显然是需要记录用户的登录状态给后端使用的，而这个状态应该对同一个域（同源）下的所有请求都有效，所以设计了 cookie，cookie 的设置和发送一般是不需要前端人员介入的（当然前端是可以使用 js 增删改查 cookie 的），设置是浏览器根据 HTTP 响应头中的 set-cookie 信息自动设置，发送也是浏览器根据 HTTP 请求的 URL 自动匹配后添加的。
1. HTTP 请求，Cookie 的使用过程：server 通过 HTTP Response 中的 "Set-Cookie: header" 把 cookie 发送给 client；client（用户的浏览器） 把 cookie 通过 HTTP Request 中的 “Cookie: header” 发送给 server；每次 HTTP 请求，Cookie 都会被发送。
1. HTTP 请求发送 Cookies 的条件：本地已经缓存有 cookies；根据请求的 URL 来匹配 cookies 的 domain、path 属性，如果都符合才会发送。
1. 如下为HTTP 响应头中设置 cookie 的示例，Expires 和 Max-Age 同时设置时后者优先级高，如果均未设置则默认有效期为 session，当浏览器关闭时失效，设置 Max-Age 为 0 使 cookie 立即失效即删除cookie，HttpOnly 指明只允许浏览器自动处理，不允许使用 JavaScrit 操作该 cookie，Path 指定对哪些 Path 自动发送该 cookie，默认为 ／ 代表对所有路径有效，设置 domain 为顶级域名时可以在各子域名之间共享 cookie，如 Set-Cookie: name=value; domain=mydomain.com ，则可以在 sub1.mydomain.com／sub2.mydomain.com／subsub.subdomain.mydomain.com 之间共享该 cookie，无论最初的 set-cookie 响应头源自哪个 sub domain：
```
Set-Cookie: KEYCLOAK_SESSION=umstor/fe2ff4f2-6b3c-4d03-aaf1-0e79f09568c5/9e4adcbc-cfec-4f57-9eb9-4bcc16877a23; Version=1; Expires=Sat, 30-Nov-2019 14:52:40 GMT; Max-Age=36000; Path=/keycloak/realms/umstor/
Set-Cookie: KEYCLOAK_REMEMBER_ME=; Version=1; Comment=Expiring cookie; Expires=Thu, 01-Jan-1970 00:00:10 GMT; Max-Age=0; Path=/keycloak/realms/umstor/; HttpOnly
```

5. session 是服务端记录用户登录状态的机制，只不过需要借助 cookie 机制在浏览器每次发起请求时带上 session id。
5. 使用 cookie 不是必须的，也可以将信息存在 localStorage 并通过 url 或 formdata 传输也是可行的，cookie 只不过因为是在协议层面支持因而使用起来可以更方便一些（自动设置和发送）。


