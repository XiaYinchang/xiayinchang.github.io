<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>ArchLinux 常用命令</title>
    <url>/post/bda105fe.html</url>
    <content><![CDATA[<h4 id="更新系统"><a href="#更新系统" class="headerlink" title="更新系统"></a>更新系统</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo pacman -Sy archlinux-keyring</span><br><span class="line">sudo pacman -Syuu</span><br><span class="line">sudo pacman -S systemd --overwrite &#39;*&#39;</span><br><span class="line">sudo pacman -S systemd-sysvcompat --overwrite &#39;*&#39;</span><br><span class="line">&#x2F;&#x2F; 自动获取最快的镜像源</span><br><span class="line">sudo reflector --verbose -c &#39;China&#39; -l 20 -p http --sort rate --save &#x2F;etc&#x2F;pacman.d&#x2F;mirrorlist</span><br></pre></td></tr></table></figure><a id="more"></a>

<h4 id="yay-使用相关"><a href="#yay-使用相关" class="headerlink" title="yay 使用相关"></a>yay 使用相关</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装包时覆盖本地已存在文件</span></span><br><span class="line">yay deluge --force</span><br><span class="line"><span class="comment"># 查看所有安装的文件及其路径</span></span><br><span class="line">yay -Ql deluge</span><br><span class="line"><span class="comment"># 查找时按照指定 filed 排序</span></span><br><span class="line">yay wechat --sortby &lt;votes|popularity|id|baseid|name|base|submitted|modified&gt;</span><br></pre></td></tr></table></figure>

<h4 id="Network-Manage-使用-SSTP-VPN"><a href="#Network-Manage-使用-SSTP-VPN" class="headerlink" title="Network-Manage 使用  SSTP VPN"></a>Network-Manage 使用  SSTP VPN</h4><p>需要安装客户端软件： <code>network-manager-sstp</code></p>
<h4 id="配置-javaws-Web-端访问物理服务器终端"><a href="#配置-javaws-Web-端访问物理服务器终端" class="headerlink" title="配置 javaws Web 端访问物理服务器终端"></a>配置 javaws Web 端访问物理服务器终端</h4><p>到<a href="https://github.com/frekele/oracle-java/releases" target="_blank" rel="external nofollow noopener noreferrer">这里</a>下载 Oracle JDK 并解压，将解压得到的文件夹移动至 jvm 目录，例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">wget https:<span class="comment">//github.com/frekele/oracle-java/releases/download/8u212-b10/jre-8u212-linux-x64.tar.gz</span></span><br><span class="line">tar zxvf jre<span class="number">-8</span>u212-linux-x64.tar.gz</span><br><span class="line">sudo mv /home/xyc/Downloads/jre1<span class="number">.8</span><span class="number">.0</span>_212 /usr/lib/jvm/</span><br></pre></td></tr></table></figure>

<p>查看已有的 JDK：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">➜  Downloads archlinux-java status</span><br><span class="line">Available Java environments:</span><br><span class="line">  java<span class="number">-13</span>-openjdk</span><br><span class="line">  java<span class="number">-8</span>-openjdk/jre</span><br><span class="line">  jre1<span class="number">.8</span><span class="number">.0</span>_212 (<span class="keyword">default</span>)</span><br></pre></td></tr></table></figure>

<p>设置默认 Java 环境为新添加的 JDK：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">sudo archlinux-java <span class="keyword">set</span> jre1.8.0_212</span><br></pre></td></tr></table></figure>

<p>修改  <code>/usr/lib/jvm/jre1.8.0_212/lib/security/java.security</code> 文件调整设置为：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">jdk.tls.disabledAlgorithms = NULL;</span><br></pre></td></tr></table></figure>

<p>打开  <code>jcontrol</code> 程序将物理机终端地址加入白名单，如：<code>http://192.168.181.134:80</code>。<br>重新打开浏览器即可。</p>
<h4 id="pacman-查看软件包安装的文件"><a href="#pacman-查看软件包安装的文件" class="headerlink" title="pacman 查看软件包安装的文件"></a>pacman 查看软件包安装的文件</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo pacman -Ql cni-plugins</span><br><span class="line">cni-plugins &#x2F;usr&#x2F;</span><br><span class="line">cni-plugins &#x2F;usr&#x2F;lib&#x2F;</span><br><span class="line">cni-plugins &#x2F;usr&#x2F;lib&#x2F;cni&#x2F;</span><br><span class="line">...</span><br><span class="line">&#x2F;&#x2F; 查看文件属于哪个包</span><br><span class="line">sudo pacman -Qo &#x2F;bin&#x2F;pacman-mirrors</span><br></pre></td></tr></table></figure>

<p>更多参考：<a href="https://note.yuchaoshui.com/blog/post/yuziyue/pacman-%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3" target="_blank" rel="external nofollow noopener noreferrer">https://note.yuchaoshui.com/blog/post/yuziyue/pacman-%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3</a></p>
<h4 id="清理系统缓存"><a href="#清理系统缓存" class="headerlink" title="清理系统缓存"></a>清理系统缓存</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo paccache -r</span><br><span class="line">sudo paccache -ruk0</span><br><span class="line">sudo pacman -Scc</span><br><span class="line">sudo journalctl --vacuum-size&#x3D;50M</span><br><span class="line">sudo rm &#x2F;var&#x2F;lib&#x2F;systemd&#x2F;coredump&#x2F;*</span><br></pre></td></tr></table></figure>

<h4 id="安装-Deepin-桌面-sogou-qimpanel"><a href="#安装-Deepin-桌面-sogou-qimpanel" class="headerlink" title="安装 Deepin 桌面 sogou-qimpanel"></a>安装 Deepin 桌面 sogou-qimpanel</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pacman -S xorg xorg-server deepin deepin-extra</span><br><span class="line">vim /etc/lightdm/lightdm.conf</span><br><span class="line">greeter-session=lightdm-deepin-greeter</span><br><span class="line">systemctl <span class="built_in">enable</span> lightdm.service</span><br><span class="line">systemctl <span class="built_in">enable</span> NetworkManager</span><br><span class="line">useradd -m -g users -G wheel -s /bin/bash xyc</span><br><span class="line">passwd xyc</span><br></pre></td></tr></table></figure>

<h4 id="Manjaro-升级内核"><a href="#Manjaro-升级内核" class="headerlink" title="Manjaro 升级内核"></a>Manjaro 升级内核</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 列出可用内核</span><br><span class="line">sudo mhwd-kernel -l</span><br><span class="line">// 列出已安装内核</span><br><span class="line">sudo mhwd-kernel -li</span><br><span class="line">// 安装新内核并移除当前内核</span><br><span class="line">sudo mkwd-kernel -i linux44 rmc</span><br></pre></td></tr></table></figure>

<h4 id="Manjaro-免密-sudo"><a href="#Manjaro-免密-sudo" class="headerlink" title="Manjaro 免密 sudo"></a>Manjaro 免密 sudo</h4><p>除了更改 <code>/etc/sudoers</code> 还要删除 <code>/etc/sudoers.d/10-installer</code>。</p>
<h4 id="安装-yay"><a href="#安装-yay" class="headerlink" title="安装 yay"></a>安装 yay</h4><p>在 <code>/etc/pacman.conf</code> 中添加以下内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[archlinuxcn]</span><br><span class="line">SigLevel &#x3D; Never</span><br><span class="line">Server &#x3D; https:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;archlinuxcn&#x2F;$arch</span><br></pre></td></tr></table></figure>

<p>然后执行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo pacman -S archlinuxcn-keyring</span><br><span class="line">sudo pacman -S yay</span><br></pre></td></tr></table></figure>

<h4 id="zsh-手动保存历史记录到本地"><a href="#zsh-手动保存历史记录到本地" class="headerlink" title="zsh 手动保存历史记录到本地"></a>zsh 手动保存历史记录到本地</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">fc</span> -W</span><br></pre></td></tr></table></figure>

<h4 id="软件降级"><a href="#软件降级" class="headerlink" title="软件降级"></a>软件降级</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo pacman -S downgrade</span><br><span class="line">sudo downgrade wine</span><br></pre></td></tr></table></figure>

<h4 id="桌面快捷方式的存储位置"><a href="#桌面快捷方式的存储位置" class="headerlink" title="桌面快捷方式的存储位置"></a>桌面快捷方式的存储位置</h4><p>/usr/share/applications/</p>
<h4 id="安装微信和企业微信"><a href="#安装微信和企业微信" class="headerlink" title="安装微信和企业微信"></a>安装微信和企业微信</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yay -S deepin-wine deepin-wine-wechat deepin-wxwork</span><br></pre></td></tr></table></figure>

<p>如果企业微信无法启动，则可尝试将 wine 降级至 5.3 版本，降级后仍有错误可参考：<a href="https://forum.winehq.org/viewtopic.php?f=8&t=30964#p117330" target="_blank" rel="external nofollow noopener noreferrer">https://forum.winehq.org/viewtopic.php?f=8&amp;t=30964#p117330</a></p>
<h4 id="字体配置"><a href="#字体配置" class="headerlink" title="字体配置"></a>字体配置</h4><p>参考：<a href="http://panqiincs.me/2019/06/05/after-installing-manjaro/" target="_blank" rel="external nofollow noopener noreferrer">http://panqiincs.me/2019/06/05/after-installing-manjaro/</a></p>
<h4 id="错误及解决方法"><a href="#错误及解决方法" class="headerlink" title="错误及解决方法"></a>错误及解决方法</h4><ul>
<li>Cannot find the strip binary required for object file stripping</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo pacman -S base-devel</span><br></pre></td></tr></table></figure>

<ul>
<li>搜狗输入法候选栏乱码</li>
</ul>
<p>参考：<a href="https://www.lulinux.com/archives/5526" target="_blank" rel="external nofollow noopener noreferrer">https://www.lulinux.com/archives/5526</a> ，修复措施不起作用时可执行  <code>sogou-qimpanel</code> 查看错误输出，安装相应的包解决问题。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>ArchLinux</tag>
      </tags>
  </entry>
  <entry>
    <title>Centos 编译安装 zfs</title>
    <url>/post/dc552b49.html</url>
    <content><![CDATA[<ul>
<li>安装依赖</li>
</ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum groupinstall <span class="string">"Development Tools"</span></span><br><span class="line">yum install zlib-devel libuuid-devel libattr-devel libblkid-devel libselinux-devel libudev-devel</span><br><span class="line">yum install parted lsscsi ksh openssl-devel elfutils-libelf-devel</span><br><span class="line">yum install kernel-devel-$(uname -r)</span><br></pre></td></tr></table></figure><a id="more"></a>


<ul>
<li>从<a href="https://github.com/zfsonlinux/zfs/releases" target="_blank" rel="external nofollow noopener noreferrer">这里</a>下载源代码并解压</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://github.com/zfsonlinux/zfs/releases/download/zfs-0.8.1/zfs-0.8.1.tar.gz &amp;&amp; tar zxf zfs-0.8.1.tar.gz</span><br></pre></td></tr></table></figure>

<ul>
<li>编译安装</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ../zfs-0.8.1</span><br><span class="line">sh autogen.sh</span><br><span class="line">./configure</span><br><span class="line">make -s -j$(nproc)</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>

<ul>
<li>重启系统</li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Centos</tag>
        <tag>存储</tag>
      </tags>
  </entry>
  <entry>
    <title>Ceph 对接 Kubernetes 的两种方式</title>
    <url>/post/466a6051.html</url>
    <content><![CDATA[<h4 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h4><ul>
<li>创建 rbd 存储池</li>
</ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ceph osd pool create rbd 128 128</span><br><span class="line">rbd pool init rbd</span><br></pre></td></tr></table></figure><ul>
<li>获取 ceph 集群基本信息</li>
</ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 执行 cat 查看 ceph 配置文件</span><br><span class="line">cat &#x2F;etc&#x2F;ceph&#x2F;ceph.conf</span><br><span class="line"></span><br><span class="line">[global]</span><br><span class="line">bluestore block db size &#x3D; 10737418240</span><br><span class="line">bluestore block fast create &#x3D; False</span><br><span class="line">bluestore block fast size &#x3D; 10737418240</span><br><span class="line">cluster network &#x3D; 10.10.0.0&#x2F;16</span><br><span class="line">fsid &#x3D; 5db6cfe0-e485-4884-89eb-8f926fd6d677</span><br><span class="line">mon allow pool delete &#x3D; True</span><br><span class="line">mon health preluminous compat warning &#x3D; False</span><br><span class="line">mon host &#x3D; [v2:10.10.46.236:3300,v1:10.10.46.236:6789],[v2:10.10.66.143:3300,v1:10.10.66.143:6789],[v2:10.10.178.231:3300,v1:10.10.178.231:6789]</span><br><span class="line">mon initial members &#x3D; u1,u2,u3</span><br><span class="line">mon_max_pg_per_osd &#x3D; 400</span><br><span class="line">osd pool default crush rule &#x3D; -1</span><br><span class="line">public network &#x3D; 10.10.0.0&#x2F;16</span><br></pre></td></tr></table></figure><a id="more"></a>





<p>由上述信息可知，ceph 集群 clusterid 为  5db6cfe0-e485-4884-89eb-8f926fd6d677，monitor 节点信息为：10.10.46.236:6789，10.10.66.143:6789，10.10.178.231:6789。</p>
<ul>
<li>获取 client.admin keyring</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">➜  ~ cat &#x2F;etc&#x2F;ceph&#x2F;ceph.client.admin.keyring</span><br><span class="line">[client.admin]</span><br><span class="line">	key &#x3D; AQAheXddCD0xBhAA3KEps1mbPzcJbFVKVpIdMQ&#x3D;&#x3D;</span><br><span class="line">	caps mds &#x3D; &quot;allow *&quot;</span><br><span class="line">	caps mgr &#x3D; &quot;allow *&quot;</span><br><span class="line">	caps mon &#x3D; &quot;allow *&quot;</span><br><span class="line">	caps osd &#x3D; &quot;allow *&quot;</span><br></pre></td></tr></table></figure>

<p>记录 admin 用户的 key 为  AQAheXddCD0xBhAA3KEps1mbPzcJbFVKVpIdMQ==。</p>
<h4 id="In-tree"><a href="#In-tree" class="headerlink" title="In-tree"></a>In-tree</h4><p>In-tree 插件是比较早和成熟的方式，调用不同存后端的代码包含在 Kubernetes 核心代码中，缺乏灵活性，不利于更新迭代，而且使用起来比较麻烦，需要在每个需要 PV 的命名空间都创建 role 和 secret key，不建议使用。如需使用，参见  <a href="https://medium.com/velotio-perspectives/an-innovators-guide-to-kubernetes-storage-using-ceph-a4b919f4e469" target="_blank" rel="external nofollow noopener noreferrer">An Innovator’s Guide to Kubernetes Storage Using Ceph</a> 。</p>
<h4 id="Out-tree"><a href="#Out-tree" class="headerlink" title="Out-tree"></a>Out-tree</h4><p>Out-tree 存储插件主要是 CSI ，Kubernetes 核心代码定义了调用接口，具体的实现由第三方插件开发商自行维护，是未来主流的使用方式，目前 Ceph-CSI rbd 相关功能已经 GA。</p>
<ul>
<li>下载最新的 ceph-csi 代码，地址：<a href="https://github.com/ceph/ceph-csi/archive/v1.2.0.tar.gz" target="_blank" rel="external nofollow noopener noreferrer">https://github.com/ceph/ceph-csi/archive/v1.2.0.tar.gz</a></li>
<li>解压后目录结构如下：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">➜  ceph-csi-1.2.0 tree -L 1</span><br><span class="line">.</span><br><span class="line">├── assets</span><br><span class="line">├── cmd</span><br><span class="line">├── deploy</span><br><span class="line">├── deploy.sh</span><br><span class="line">├── docs</span><br><span class="line">├── e2e</span><br><span class="line">├── examples</span><br><span class="line">├── Gopkg.lock</span><br><span class="line">├── Gopkg.toml</span><br><span class="line">├── LICENSE</span><br><span class="line">├── Makefile</span><br><span class="line">├── pkg</span><br><span class="line">├── README.md</span><br><span class="line">├── scripts</span><br><span class="line">├── troubleshooting</span><br><span class="line">└── vendor</span><br></pre></td></tr></table></figure>

<ul>
<li>以 rbd 配置为例，先修改  deploy/rbd/kubernetes/v1.14+/csi-config-map.yaml 文件内容，将 ceph 集群信息填写进去：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: ConfigMap</span><br><span class="line">data:</span><br><span class="line">  config.json: |-</span><br><span class="line">    [</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;clusterID&quot;: &quot;5db6cfe0-e485-4884-89eb-8f926fd6d677&quot;,</span><br><span class="line">        &quot;monitors&quot;: [</span><br><span class="line">          &quot;10.10.46.236&quot;,</span><br><span class="line">          &quot;10.10.66.143&quot;,</span><br><span class="line">          &quot;10.10.178.231&quot;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">metadata:</span><br><span class="line">  name: ceph-csi-config</span><br></pre></td></tr></table></figure>

<ul>
<li>执行以下脚本进行部署</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;examples&#x2F;rbd&#x2F;plugin-deploy.sh</span><br></pre></td></tr></table></figure>

<ul>
<li>创建 rbd-secret</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl create secret generic csi-rbd-secret --from-literal&#x3D;adminID&#x3D;&quot;admin&quot; --from-literal&#x3D;adminKey&#x3D;&quot;AQAheXddCD0xBhAA3KEps1mbPzcJbFVKVpIdMQ&#x3D;&#x3D;&quot; --from-literal&#x3D;userID&#x3D;&quot;admin&quot; --from-literal&#x3D;userKey&#x3D;&quot;AQAheXddCD0xBhAA3KEps1mbPzcJbFVKVpIdMQ&#x3D;&#x3D;&quot;</span><br></pre></td></tr></table></figure>

<ul>
<li>修改 examples/rbd/storageclass.yaml 文件，主要是填上 clusterID</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apiVersion: storage.k8s.io&#x2F;v1</span><br><span class="line">kind: StorageClass</span><br><span class="line">metadata:</span><br><span class="line">   name: csi-rbd-sc</span><br><span class="line">provisioner: rbd.csi.ceph.com</span><br><span class="line">parameters:</span><br><span class="line">   # String representing a Ceph cluster to provision storage from.</span><br><span class="line">   # Should be unique across all Ceph clusters in use for provisioning,</span><br><span class="line">   # cannot be greater than 36 bytes in length, and should remain immutable for</span><br><span class="line">   # the lifetime of the StorageClass in use.</span><br><span class="line">   # Ensure to create an entry in the config map named ceph-csi-config, based on</span><br><span class="line">   # csi-config-map-sample.yaml, to accompany the string chosen to</span><br><span class="line">   # represent the Ceph cluster in clusterID below</span><br><span class="line">   clusterID: 5db6cfe0-e485-4884-89eb-8f926fd6d677</span><br><span class="line"></span><br><span class="line">   # Ceph pool into which the RBD image shall be created</span><br><span class="line">   pool: rbd</span><br><span class="line"></span><br><span class="line">   # RBD image format. Defaults to &quot;2&quot;.</span><br><span class="line">   imageFormat: &quot;2&quot;</span><br><span class="line"></span><br><span class="line">   # RBD image features. Available for imageFormat: &quot;2&quot;</span><br><span class="line">   # CSI RBD currently supports only &#96;layering&#96; feature.</span><br><span class="line">   imageFeatures: layering</span><br><span class="line"></span><br><span class="line">   # The secrets have to contain Ceph credentials with required access</span><br><span class="line">   # to the &#39;pool&#39;.</span><br><span class="line">   csi.storage.k8s.io&#x2F;provisioner-secret-name: csi-rbd-secret</span><br><span class="line">   csi.storage.k8s.io&#x2F;provisioner-secret-namespace: default</span><br><span class="line">   csi.storage.k8s.io&#x2F;node-stage-secret-name: csi-rbd-secret</span><br><span class="line">   csi.storage.k8s.io&#x2F;node-stage-secret-namespace: default</span><br><span class="line">   # Specify the filesystem type of the volume. If not specified,</span><br><span class="line">   # csi-provisioner will set default as &#96;ext4&#96;.</span><br><span class="line">   csi.storage.k8s.io&#x2F;fstype: xfs</span><br><span class="line">   # uncomment the following to use rbd-nbd as mounter on supported nodes</span><br><span class="line">   # mounter: rbd-nbd</span><br><span class="line">reclaimPolicy: Delete</span><br><span class="line">mountOptions:</span><br><span class="line">   - discard</span><br></pre></td></tr></table></figure>

<ul>
<li>创建 storage-class</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl apply -f examples&#x2F;rbd&#x2F;storageclass.yaml</span><br></pre></td></tr></table></figure>

<ul>
<li>设置该 storage-class 为默认</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl patch storageclass csi-rbd-sc -p &#39;&#123;&quot;metadata&quot;: &#123;&quot;annotations&quot;:&#123;&quot;storageclass.kubernetes.io&#x2F;is-default-class&quot;:&quot;true&quot;&#125;&#125;&#125;&#39;</span><br></pre></td></tr></table></figure>

<ul>
<li>以上部署主要使用了默认值，相关插件都部署在 default 命名空间，可以根据需要进行调整。</li>
</ul>
]]></content>
      <categories>
        <category>Kubernetes</category>
      </categories>
      <tags>
        <tag>Ceph</tag>
        <tag>Kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker 卷和文件系统权限</title>
    <url>/post/86bd2460.html</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th align="center">Date</th>
<th align="center">Log</th>
</tr>
</thead>
<tbody><tr>
<td align="center">17/10/2019</td>
<td align="center">初始版本.</td>
</tr>
</tbody></table><h3 id="原文"><a href="#原文" class="headerlink" title="原文"></a>原文</h3><p><a href="https://medium.com/@nielssj/docker-volumes-and-file-system-permissions-772c1aee23ca" target="_blank" rel="external nofollow noopener noreferrer">Docker volumes and file system permissions</a><br>Docker 卷和文件系统权限</p><h3 id="译文"><a href="#译文" class="headerlink" title="译文"></a>译文</h3><p>Docker 容器的文件系统是临时存在的（不要在运行期间持久化数据到容器内的文件目录）。但是很多容器存在持久化数据的需求。Docker 的卷挂载功能提供了一种满足数据持久化需求的能力，但是使用时往往存在一些有关文件系统权限的陷阱。</p><a id="more"></a>


<p>在生产环境中你一般会使用一些公有云提供商的容器编排工具和持久化存储，提供商已经帮助解决了文件权限的设置问题。在大多数已部署的设置中，您将使用容器编排机制，并且某些公共云产品提供了永久性存储，它们可能具有自己配置权限的方式。但是，在本地开发期间或在产品的早期迭代中，最简单的方法是将宿主机目录挂载为 Docker 卷的形式暴露给容器内服务使用。</p>
<p>将主机目录配置为 Docker 卷时需要注意以下内容：</p>
<ul>
<li>对卷中的内容设置的文件权限在容器和宿主机看来是一样的。</li>
<li>仅 UID（用户 ID）和 GID（组 ID）会影响文件权限。例如，用户和组的名称和密码不需要匹配，甚至不需要在主机和容器中真实存在。</li>
<li>容器 OS 根据其自身的配置对容器内的文件进行操作。例如，如果在主机和容器中都存在用户 A，如果仅在宿主机上将用户 A 添加到组 B，则在容器内用户 A 仍将无法拥有读写归属于组 B 的文件的权限，除非在容器内也创建了组 B 并将用户 A 添加到其中。</li>
<li>默认情况下，容器的命令以 root 身份运行</li>
<li>可以（在基于 unix 的系统上）将文件 / 目录所有权设置为不属于任何实际存在的组的 GID</li>
</ul>
<p>如果你牢记上述事实，则应该能够正确配置容器和卷，并不会对文件读写权限的各种情况感到意外。如果你不熟悉 UNIX 文件权限，可以阅读该<a href="https://help.ubuntu.com/community/FilePermissions" target="_blank" rel="external nofollow noopener noreferrer">页面</a>关于文件权限的描述。</p>
<p>下面举例说明本地开发时如何快速配置文件权限：</p>
<p>在宿主机上将要用作卷的目录的归属组设置为未被任何已存在的组使用的 GID（此例中设置为 1024）</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">chown :<span class="number">1024</span> /data/myvolume</span><br></pre></td></tr></table></figure>

<p>更改目录权限以授予组成员完全访问权限（读 + 写 + 执行）</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">chmod <span class="number">775</span> /data/myvolume</span><br></pre></td></tr></table></figure>

<p>确保文件夹中所有新建内容都将继承归属组</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">chmod g+s /data/myvolume</span><br></pre></td></tr></table></figure>

<p>在 Dockerfile 中创建一个用户，该用户是 1024 组的成员</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">RUN addgroup --gid <span class="number">1024</span> mygroup</span><br><span class="line">RUN adduser --disabled-password --gecos <span class="string">""</span> --force-badname --ingroup <span class="number">1024</span> myuser</span><br><span class="line">USER myuser</span><br></pre></td></tr></table></figure>

<p>（可选）在宿主机将当前用户添加到 1024 组中，从而可以方便地在宿主机上操作挂载为容器卷的目录的内容</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">adduser ubuntu <span class="number">1024</span></span><br></pre></td></tr></table></figure>

<p>上面的示例是一个很简单的配置，可以使得不需要使用 root 用户在容器内运行程序，也可以在主机上操作挂载为容器卷的目录的内容而无需使用主机 root 用户。这些设置过程硬编码到 Docker 镜像打包过程中使得无法在容器运行时调整 GID。如果调整，则需将 GID 作为环境变量传递到容器内，并编写一个通用的初始化脚本在容器启动时进行权限配置。DeniBertović 的这篇博客  <a href="https://denibertovic.com/posts/handling-permissions-with-docker-volumes/" target="_blank" rel="external nofollow noopener noreferrer">https://denibertovic.com/posts/handling-permissions-with-docker-volumes/</a>  提供了完成此类设置的指南。</p>
]]></content>
      <categories>
        <category>译文</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>译文</tag>
      </tags>
  </entry>
  <entry>
    <title>Ceph 常用操作</title>
    <url>/post/e8bac896.html</url>
    <content><![CDATA[<h4 id="删除-rbd-image-时提示有-watcher"><a href="#删除-rbd-image-时提示有-watcher" class="headerlink" title="删除 rbd image 时提示有 watcher"></a>删除 rbd image 时提示有 watcher</h4><p>查看该 image 信息</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@openstack-compute-02:~<span class="comment"># rbd info vm-109-cloudinit --pool cloud-disk</span></span><br><span class="line">rbd image <span class="string">'vm-109-cloudinit'</span>:</span><br><span class="line">        size 4 MiB <span class="keyword">in</span> 1 objects</span><br><span class="line">        order 22 (4 MiB objects)</span><br><span class="line">        snapshot_count: 0</span><br><span class="line">        id: 85a71142d8c136</span><br><span class="line">        block_name_prefix: rbd_data.85a71142d8c136</span><br><span class="line">        format: 2</span><br><span class="line">        features: layering, exclusive-lock, object-map, fast-diff, deep-flatten</span><br><span class="line">        op_features:</span><br><span class="line">        flags:</span><br><span class="line">        create_timestamp: Wed Aug 28 10:04:09 2019</span><br><span class="line">        access_timestamp: Mon Sep  2 13:59:31 2019</span><br><span class="line">        modify_timestamp: Mon Sep  2 13:59:31 2019</span><br></pre></td></tr></table></figure><a id="more"></a>


<p>从 info 中  block_name_prefix: rbd_data.85a71142d8c136 获知 rados 对象名称为 rbd_header.85a71142d8c136 ，然后列出对象所有 watcher：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@openstack-compute-02:~<span class="comment"># rados listwatchers --pool cloud-disk rbd_header.85a71142d8c136</span></span><br><span class="line">watcher=192.168.180.116:0/2072981162 client.27537920 cookie=139876735669120</span><br></pre></td></tr></table></figure>

<p>或者直接通过 rbd 命令列出 watcher：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@openstack-compute-02:~<span class="comment"># rbd status --pool cloud-disk vm-109-cloudinit</span></span><br><span class="line">Watchers:</span><br><span class="line">        watcher=192.168.180.116:0/2072981162 client.27537920 cookie=139876735669120</span><br></pre></td></tr></table></figure>

<p>将 watcher 加入黑名单：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ceph osd blacklist add 192.168.180.116:0/2072981162</span><br></pre></td></tr></table></figure>

<p>此时再次查看 image 的 watcher ：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@openstack-compute-02:~<span class="comment"># rbd status --pool cloud-disk vm-109-cloudinit</span></span><br><span class="line">Watchers: none</span><br></pre></td></tr></table></figure>

<p>没有了 watcher 我们就可以继续删除该 image ：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rbd rm --pool cloud-disk vm-109-cloudinit</span><br></pre></td></tr></table></figure>

<p>然后将 watcher 从黑名单剔除或者不手动操作，默认 1 个小时后自动恢复：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@openstack-compute-02:~<span class="comment"># ceph osd blacklist ls</span></span><br><span class="line">listed 1 entries</span><br><span class="line">192.168.180.116:0/2072981162 2019-09-03 11:19:24.466205</span><br><span class="line">root@openstack-compute-02:~<span class="comment"># ceph osd blacklist rm 192.168.180.116:0/2072981162</span></span><br><span class="line">un-blacklisting 192.168.180.116:0/2072981162</span><br><span class="line">root@openstack-compute-02:~<span class="comment"># ceph osd blacklist clear</span></span><br><span class="line"> removed all blacklist entries</span><br><span class="line">root@openstack-compute-02:~<span class="comment"># ceph osd blacklist ls</span></span><br><span class="line">listed 0 entries</span><br></pre></td></tr></table></figure>

<h4 id="scrub-errors-修复"><a href="#scrub-errors-修复" class="headerlink" title="scrub errors 修复"></a>scrub errors 修复</h4><p>错误如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@umstor21:~<span class="comment"># ceph -s</span></span><br><span class="line">  cluster:</span><br><span class="line">    id:     d6aadfd6-9e08-4000-98bd-a5a14f59ef97</span><br><span class="line">    health: HEALTH_ERR</span><br><span class="line">            30 scrub errors</span><br><span class="line">            Reduced data availability: 25 pgs inactive</span><br><span class="line">            Possible data damage: 1 pg inconsistent</span><br><span class="line">            Degraded data redundancy: 60273/2821944 objects degraded (2.136%), 68 pgs degraded, 57 pgs undersized</span><br><span class="line"></span><br><span class="line">  services:</span><br><span class="line">    mon: 3 daemons, quorum openstack-compute-04,openstack-compute-02,openstack-compute-03 (age 63m)</span><br><span class="line">    mgr: openstack-compute-02(active, since 8d), standbys: openstack-compute-04, openstack-compute-03</span><br><span class="line">    mds: cephfs:1 &#123;0=openstack-compute-04=up:active&#125; 2 up:standby</span><br><span class="line">    osd: 19 osds: 18 up (since 8m), 18 <span class="keyword">in</span> (since 53m); 57 remapped pgs</span><br><span class="line"></span><br><span class="line">  data:</span><br><span class="line">    pools:   12 pools, 1076 pgs</span><br><span class="line">    objects: 1.41M objects, 5.3 TiB</span><br><span class="line">    usage:   4.9 TiB used, 11 TiB / 16 TiB avail</span><br><span class="line">    pgs:     2.323% pgs not active</span><br><span class="line">             60273/2821944 objects degraded (2.136%)</span><br><span class="line">             1006 active+clean</span><br><span class="line">             32   active+undersized+degraded+remapped+backfill_wait</span><br><span class="line">             18   undersized+degraded+remapped+backfill_wait+peered</span><br><span class="line">             11   active+recovery_wait+degraded</span><br><span class="line">             7    undersized+degraded+remapped+backfilling+peered</span><br><span class="line">             1    active+recovery_wait</span><br><span class="line">             1    active+clean+inconsistent</span><br><span class="line"></span><br><span class="line">  io:</span><br><span class="line">    recovery: 40 MiB/s, 21 objects/s</span><br></pre></td></tr></table></figure>

<p>查看详细信息：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@umstor21:~<span class="comment"># ceph health detail</span></span><br><span class="line">HEALTH_ERR 30 scrub errors; Reduced data availability: 25 pgs inactive; Possible data damage: 1 pg inconsistent; Degraded data redundancy: 59572/2821944 objects degraded (2.111%), 68 pgs degraded, 57 pgs undersized</span><br><span class="line">OSD_SCRUB_ERRORS 30 scrub errors</span><br><span class="line">PG_AVAILABILITY Reduced data availability: 25 pgs inactive</span><br><span class="line">    pg 1.1 is stuck inactive <span class="keyword">for</span> 3867.682789, current state undersized+degraded+remapped+backfill_wait+peered, last acting [26]</span><br><span class="line">    pg 1.1b is stuck inactive <span class="keyword">for</span> 3867.800588, current state undersized+degraded+remapped+backfill_wait+peered, last acting [24]</span><br><span class="line">    pg 1.26 is stuck inactive <span class="keyword">for</span> 3867.806862, current state undersized+degraded+remapped+backfill_wait+peered, last acting [6]</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<p>修复 pg</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ceph pg repair &lt;pg_id&gt;</span><br></pre></td></tr></table></figure>

<h4 id="删除-Monitor"><a href="#删除-Monitor" class="headerlink" title="删除 Monitor"></a>删除 Monitor</h4><p>更复杂情况参考：<a href="https://www.jianshu.com/p/b78cf33e558f" target="_blank" rel="external nofollow noopener noreferrer">https://www.jianshu.com/p/b78cf33e558f</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl stop ceph-mon@openstack-compute-02.service</span><br><span class="line">&#x2F;&#x2F; 如果停止一个 ceph-mon 后无法执行 ceph 命令，则应当先删除 mon 再停止 ceph-mon 服务</span><br><span class="line">ceph mon remove openstack-compute-02</span><br><span class="line">&#x2F;&#x2F; 移除 ceph.conf 中的相关信息</span><br></pre></td></tr></table></figure>

<h4 id="添加-Monitor"><a href="#添加-Monitor" class="headerlink" title="添加 Monitor"></a>添加 Monitor</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 预先安装 ceph-common ，再安装 ceph-mon</span><br><span class="line">yum -y install ceph-common</span><br><span class="line">&#x2F;&#x2F; 在目标节点上创建 mon 目录，一般使用 hostname 作为 mon-id</span><br><span class="line">mkdir -p &#x2F;var&#x2F;lib&#x2F;ceph&#x2F;mon&#x2F;ceph-&#96;hostname&#96;</span><br><span class="line">&#x2F;&#x2F; 从已有 ceph 节点复制 ceph 配置</span><br><span class="line">scp 192.168.180.7:&#x2F;etc&#x2F;ceph&#x2F;* &#x2F;etc&#x2F;ceph&#x2F;</span><br><span class="line">&#x2F;&#x2F; 获取 mon keyring</span><br><span class="line">ceph auth get mon. -o &#x2F;tmp&#x2F;mon.keyring</span><br><span class="line">&#x2F;&#x2F; 获取 mon map</span><br><span class="line">ceph mon getmap -o &#x2F;tmp&#x2F;mon.map</span><br><span class="line">&#x2F;&#x2F; 格式化 mon 数据目录</span><br><span class="line">ceph-mon -i &#96;hostname&#96; --mkfs --monmap &#x2F;tmp&#x2F;mon.map --keyring &#x2F;tmp&#x2F;mon.keyring</span><br><span class="line">&#x2F;&#x2F; 更改目录所属用户为 ceph</span><br><span class="line">chown -R ceph:ceph &#x2F;etc&#x2F;ceph &#x2F;var&#x2F;lib&#x2F;ceph</span><br><span class="line">&#x2F;&#x2F; 启动 ceph-mon 服务</span><br><span class="line">systemctl enable --now ceph-mon@&#96;hostname&#96;</span><br></pre></td></tr></table></figure>

<h4 id="ceph-ansible-部署"><a href="#ceph-ansible-部署" class="headerlink" title="ceph-ansible 部署"></a>ceph-ansible 部署</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/ceph/ceph-ansible.git</span><br><span class="line">git checkout v4.0.9</span><br><span class="line">// 在部署节点安装</span><br><span class="line">yum install -y python-paramiko sshpass</span><br><span class="line">rpm -i https://releases.ansible.com/ansible/rpm/release/epel-7-x86_64/ansible-2.8.9-1.el7.ans.noarch.rpm</span><br><span class="line">// 在所有 ceph 节点安装</span><br><span class="line">yum install -y python-netaddr</span><br></pre></td></tr></table></figure>

<p>cd  到 ceph-ansible ， 创建 hosts 文件如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[CephGroup:children]</span><br><span class="line">mons</span><br><span class="line">osds</span><br><span class="line"><span class="comment">#mdss</span></span><br><span class="line">mgrs</span><br><span class="line">rgws</span><br><span class="line">[CephGroup:vars]</span><br><span class="line">ansible_ssh_user=root</span><br><span class="line">ansible_ssh_pass=<span class="built_in">test</span></span><br><span class="line">ansible_port=22</span><br><span class="line"></span><br><span class="line">[mons]</span><br><span class="line">ceph-csi-01 ansible_host=10.8.107.149</span><br><span class="line">ceph-csi-02 ansible_host=10.8.185.232</span><br><span class="line">ceph-csi-03 ansible_host=10.8.143.178</span><br><span class="line">[osds]</span><br><span class="line">ceph-csi-01 ansible_host=10.8.107.149</span><br><span class="line">ceph-csi-02 ansible_host=10.8.185.232</span><br><span class="line">ceph-csi-03 ansible_host=10.8.143.178</span><br><span class="line"><span class="comment">#[mdss]</span></span><br><span class="line"><span class="comment">#ceph-csi-01 ansible_host=10.8.107.149</span></span><br><span class="line"><span class="comment">#ceph-csi-02 ansible_host=10.8.185.232</span></span><br><span class="line"><span class="comment">#ceph-csi-03 ansible_host=10.8.143.178</span></span><br><span class="line">[mgrs]</span><br><span class="line">ceph-csi-01 ansible_host=10.8.107.149</span><br><span class="line">ceph-csi-02 ansible_host=10.8.185.232</span><br><span class="line">ceph-csi-03 ansible_host=10.8.143.178</span><br><span class="line">[rgws]</span><br><span class="line">ceph-csi-01 ansible_host=10.8.107.149</span><br><span class="line">ceph-csi-02 ansible_host=10.8.185.232</span><br><span class="line">ceph-csi-03 ansible_host=10.8.143.178</span><br><span class="line">[grafana-server]</span><br><span class="line">ceph-csi-01 ansible_host=10.8.107.149</span><br><span class="line">ceph-csi-02 ansible_host=10.8.185.232</span><br><span class="line">ceph-csi-03 ansible_host=10.8.143.178</span><br></pre></td></tr></table></figure>

<p>cd 到  group_vars 目录：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cp all.yml.sample all.yml</span><br><span class="line">// 填入以下内容并修改 public_network 与当前网络匹配</span><br><span class="line">ceph_origin: repository</span><br><span class="line">ceph_repository: community</span><br><span class="line">ceph_mirror: https://mirrors.aliyun.com/ceph</span><br><span class="line">ceph_stable_key: https://mirrors.aliyun.com/ceph/keys/release.asc</span><br><span class="line">ceph_stable_release: nautilus</span><br><span class="line">monitor_interface: eth0</span><br><span class="line">public_network: 10.23.0.0/16</span><br><span class="line">radosgw_interface: eth0</span><br><span class="line"></span><br><span class="line">cp osds.yml.sample osds.yml</span><br><span class="line">// 添加安装盘信息</span><br><span class="line">devices:</span><br><span class="line">  - /dev/vdb</span><br><span class="line">  - /dev/vdc</span><br><span class="line">  - /dev/vdd</span><br></pre></td></tr></table></figure>

<p>回到项目根目录执行安装:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cp site.yml.sample site.yml</span><br><span class="line">ansible-playbook -i hosts -v site.yml</span><br></pre></td></tr></table></figure>

<p>删除集群：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ansible-playbook -i hosts infrastructure-playbooks/purge-cluster.yml</span><br></pre></td></tr></table></figure>

<h4 id="ceph-ansible-添加-osd"><a href="#ceph-ansible-添加-osd" class="headerlink" title="ceph-ansible 添加 osd"></a>ceph-ansible 添加 osd</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &#x2F;opt&#x2F;ceph-ansible</span><br><span class="line">cp infrastructure-playbooks&#x2F;add-osd.yml .&#x2F;</span><br><span class="line">&#x2F;&#x2F; 修改 group_vars&#x2F;osd.yml 磁盘信息</span><br><span class="line">ansible-playbook -vv -i hosts --limit 192.168.203.143 add-osd.yml</span><br><span class="line">&#x2F;&#x2F; 新增一个 osd 宿主节点和在已有的 osd 节点上增加一块盘步骤一样</span><br><span class="line">&#x2F;&#x2F; 添加完 osd 如果卡在 restart osd daemon 可通过执行以下命令解决</span><br><span class="line">ceph osd unset noup</span><br></pre></td></tr></table></figure>

<h4 id="rbd-image-使用"><a href="#rbd-image-使用" class="headerlink" title="rbd image 使用"></a>rbd image 使用</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 创建大小为 1G 的 image</span><br><span class="line">rbd create rbd&#x2F;myimage --size 1024</span><br><span class="line">rbd map rbd&#x2F;myimage</span><br><span class="line">mkfs.xfs &#x2F;dev&#x2F;rbd0</span><br><span class="line">mkdir &#x2F;data</span><br><span class="line">mount &#x2F;dev&#x2F;rbd0 &#x2F;data</span><br><span class="line">&#x2F;&#x2F; 扩容</span><br><span class="line">rbd resize --image&#x3D;rbd&#x2F;myimage --size 10G</span><br><span class="line">xfs_growfs &#x2F;data</span><br><span class="line">&#x2F;&#x2F; 卸载</span><br><span class="line">umount &#x2F;data</span><br><span class="line">&#x2F;&#x2F; 检查占用设备的进程</span><br><span class="line">fuser -m -v &#x2F;dev&#x2F;rbd0</span><br><span class="line">rbd unmap &#x2F;dev&#x2F;rbd0</span><br><span class="line">rbd rm rbd&#x2F;myimage</span><br><span class="line">&#x2F;&#x2F; rbd image 转换 format，也可用于 image 复制</span><br><span class="line">rbd export rbd&#x2F;myrbd - | rbd import --image-format 2 - rbd&#x2F;myrbd_v2</span><br><span class="line">&#x2F;&#x2F; rbd bench</span><br><span class="line">rados bench -p rbd 20 -b 4K write -t 1 --no-cleanup</span><br><span class="line">rbd create --size 4G test</span><br><span class="line">rbd bench-write test</span><br></pre></td></tr></table></figure>

<h4 id="Cinder-创建-Volume-副本并-Boot-with-it"><a href="#Cinder-创建-Volume-副本并-Boot-with-it" class="headerlink" title="Cinder 创建 Volume 副本并 Boot with it"></a>Cinder 创建 Volume 副本并 Boot with it</h4><p>OpenStack: import existing Ceph volumes in Cinder：<a href="https://ceph.com/geen-categorie/openstack-import-existing-ceph-volumes-in-cinder/" target="_blank" rel="external nofollow noopener noreferrer">https://ceph.com/geen-categorie/openstack-import-existing-ceph-volumes-in-cinder/</a></p>
<h4 id="查看并修改-crushmap"><a href="#查看并修改-crushmap" class="headerlink" title="查看并修改 crushmap"></a>查看并修改 crushmap</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 获取集群 crushmap</span><br><span class="line">ceph osd getcrushmap -o &#123;file1&#125;</span><br><span class="line">&#123;file1&#125; 为自定义的文件名，该文件为二进制文件，不可编辑。要想编辑此文件，需要用工具将其反编译解析，如 crushtool 工具。</span><br><span class="line"></span><br><span class="line">2 反编译 crushmap</span><br><span class="line">crushtool -d &#123;file1&#125; -o &#123;file2&#125;</span><br><span class="line">反编译二进制文件 &#123;file1&#125; 得到可编辑文件 &#123;file2&#125;</span><br><span class="line"></span><br><span class="line">3. 编辑 crushmap</span><br><span class="line">按自我需求修改可编辑文件 &#123;file2&#125;</span><br><span class="line"></span><br><span class="line">4. 编译 crushmap</span><br><span class="line">要想编辑后的文件机器能够识别，必须用工具编译它生成二进制文件。</span><br><span class="line">crushtool -c &#123;file2&#125; -o &#123;file3&#125;</span><br><span class="line"></span><br><span class="line">5. 注入 crushmap</span><br><span class="line">要想新的 crushmap 在集群中生效，必须将其注入要集群。</span><br><span class="line">ceph osd setcrushmap -i &#123;file3&#125;</span><br></pre></td></tr></table></figure>

<p>基本理解：<a href="https://www.dovefi.com/post/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3crush1%E7%90%86%E8%A7%A3crush_map%E6%96%87%E4%BB%B6/" target="_blank" rel="external nofollow noopener noreferrer">深入理解 ceph crush (1)—- 理解 crush map 文件</a>／Crush 算法：<a href="http://www.xuxiaopang.com/2016/11/08/easy-ceph-CRUSH/" target="_blank" rel="external nofollow noopener noreferrer">大话 Ceph–CRUSH 那点事儿</a>／Crush 查看：<a href="https://www.jianshu.com/p/2355701459e9" target="_blank" rel="external nofollow noopener noreferrer">Ceph 实践之 Crushmap 相关</a>。</p>
<h4 id="OSD-过度使用内存"><a href="#OSD-过度使用内存" class="headerlink" title="OSD 过度使用内存"></a>OSD 过度使用内存</h4><p>在使用  Bluestore 时，bluestore_cache_autotune 默认已经启用，Bluestore 会将 OSD 堆内存使用量保持在指定的大小之下，通过配置选项 osd_memory_target 来控制，默认为 4G。对于内存较少但 OSD 节点较多的情况，仍然会可能造成内存几乎全部被 OSD 所用，最终致使宿主机死机。可以通过两种方式来缓解这种情况，一种是在启用自动配置时调小  osd_memory_target 值，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[osd]</span><br><span class="line">osd memory target &#x3D; 2147483648</span><br></pre></td></tr></table></figure>

<p>另一种是禁用自动配置并手动指定缓存大小：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[osd]</span><br><span class="line">bluestore_cache_autotune &#x3D; False</span><br><span class="line">bluestore_min_alloc_size_ssd &#x3D; 32768</span><br><span class="line">bluestore_min_alloc_size_hdd &#x3D; 32768</span><br><span class="line">bluestore_min_alloc_size &#x3D; 32768</span><br><span class="line">bluestore_cache_kv_max &#x3D; 6442450944</span><br><span class="line">bluestore_cache_kv_ratio &#x3D; 0.990000</span><br><span class="line">bluestore_cache_meta_ratio &#x3D; 0.010000</span><br><span class="line">bluestore_cache_size &#x3D; 12884901888</span><br><span class="line">bluestore_cache_size_hdd &#x3D; 12884901888</span><br><span class="line">bluestore_cache_size_ssd &#x3D; 12884901888</span><br></pre></td></tr></table></figure>

<h4 id="ceph-查看存储池-IO"><a href="#ceph-查看存储池-IO" class="headerlink" title="ceph 查看存储池 IO"></a>ceph 查看存储池 IO</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ceph osd pool stats</span><br></pre></td></tr></table></figure>

<h4 id="ceph-总体及各存储池使用量"><a href="#ceph-总体及各存储池使用量" class="headerlink" title="ceph 总体及各存储池使用量"></a>ceph 总体及各存储池使用量</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ceph df detail</span><br></pre></td></tr></table></figure>

<h4 id="删除存储池"><a href="#删除存储池" class="headerlink" title="删除存储池"></a>删除存储池</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ceph tell mon.\* injectargs <span class="string">'--mon-allow-pool-delete=true'</span></span><br><span class="line"><span class="comment">## The following will delete the pool</span></span><br><span class="line">$ ceph osd pool delete &lt;pool-name&gt; &lt;pool-name&gt; --yes-i-really-really-mean-it</span><br><span class="line">$ ceph tell mon.\* injectargs <span class="string">'--mon-allow-pool-delete=false'</span></span><br></pre></td></tr></table></figure>

<h4 id="rados-对象操作"><a href="#rados-对象操作" class="headerlink" title="rados 对象操作"></a>rados 对象操作</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 上传文件</span><br><span class="line">rados -p &lt;pool-name&gt; put &lt;object-name&gt; &lt;file&gt;</span><br><span class="line">// 下载文件</span><br><span class="line">rados -p &lt;pool-name&gt; get &lt;object-name&gt; &lt;file&gt;</span><br><span class="line">// 列出文件</span><br><span class="line">rados -p &lt;pool-name&gt; ls</span><br><span class="line">// 删除文件</span><br><span class="line">rados -p &lt;pool-name&gt; rm &lt;object-name&gt;</span><br></pre></td></tr></table></figure>

<h4 id="挂载-cephfs-到本地"><a href="#挂载-cephfs-到本地" class="headerlink" title="挂载 cephfs 到本地"></a>挂载 cephfs 到本地</h4><p>用户态挂载</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install ceph-fuse -y</span><br><span class="line">mkdir -p /mnt/cephfs</span><br><span class="line">ceph-fuse -n client.admin --key AQBvN8lbCuTBFhAAJPMWYwu+Jho8B1QGt80jAA== --host 10.23.229.102,10.23.109.25 /mnt/cephfs</span><br></pre></td></tr></table></figure>

<p>内核态挂载</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mount -t ceph 192.168.0.1:6789,192.168.0.2:6789:/ /mnt/cephfs -o name=admin,secret=AQATSKdNGBnwLhAAnNDKnH65FmVKpXZJVasUeQ==</span><br></pre></td></tr></table></figure>

<p>写入到 fstab 中，开机自动挂载</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">192.168.180.125:6789,192.168.180.115:6789:&#x2F; &#x2F;mnt&#x2F;cephfs ceph name&#x3D;admin,secret&#x3D;AQAoDAZdss8dEhAA1IQSOpkYbJrUN8vTceYKMw&#x3D;&#x3D;,_netdev,noatime     0 0</span><br></pre></td></tr></table></figure>

<h4 id="开启存储池-pg-num-自动调整"><a href="#开启存储池-pg-num-自动调整" class="headerlink" title="开启存储池 pg_num 自动调整"></a>开启存储池 pg_num 自动调整</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 启用自动调整模块</span><br><span class="line">ceph mgr module enable pg_autoscaler</span><br><span class="line">&#x2F;&#x2F; 为已经存在的存储池开启自动调整</span><br><span class="line">ceph osd pool ls | xargs -I &#123;&#125; ceph osd pool set &#123;&#125; pg_autoscale_mode on</span><br><span class="line">&#x2F;&#x2F; 为后续新创建的存储池默认开启</span><br><span class="line">ceph config set global osd_pool_default_pg_autoscale_mode on</span><br><span class="line">&#x2F;&#x2F; 查看自动增加的 pg 数量</span><br><span class="line">ceph osd pool autoscale-status</span><br></pre></td></tr></table></figure>

<h4 id="删除-OSD-节点"><a href="#删除-OSD-节点" class="headerlink" title="删除 OSD 节点"></a>删除 OSD 节点</h4><p>参考先删后增节点时如何减少数据迁移：<a href="https://www.cnblogs.com/schangech/p/8036191.html" target="_blank" rel="external nofollow noopener noreferrer">https://www.cnblogs.com/schangech/p/8036191.html</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 停止指定 OSD 进程</span><br><span class="line">systemctl stop ceph-osd@15</span><br><span class="line">// out 指定 OSD</span><br><span class="line">ceph osd out 15</span><br><span class="line">// crush remove 指定 OSD</span><br><span class="line">ceph osd crush remove osd.15</span><br><span class="line">// 删除 osd 对应的 auth</span><br><span class="line">ceph auth del osd.15</span><br><span class="line">// 删除 osd</span><br><span class="line">ceph osd rm 15</span><br><span class="line">// 按照上述步骤删除节点上所有 osd 后，crush remove 指定节点</span><br><span class="line">ceph osd crush rm osd-host</span><br></pre></td></tr></table></figure>

<h4 id="CentOS-安装-ceph-common"><a href="#CentOS-安装-ceph-common" class="headerlink" title="CentOS 安装 ceph-common"></a>CentOS 安装 ceph-common</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rpm -Uvh https:&#x2F;&#x2F;download.ceph.com&#x2F;rpm-nautilus&#x2F;el7&#x2F;noarch&#x2F;ceph-release-1-1.el7.noarch.rpm</span><br><span class="line">&#x2F;&#x2F; 或使用镜像源</span><br><span class="line">rpm -Uvh https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;ceph&#x2F;rpm-nautilus&#x2F;el7&#x2F;noarch&#x2F;ceph-release-1-1.el7.noarch.rpm</span><br><span class="line">sed -i &#39;s+download.ceph.com+mirrors.tuna.tsinghua.edu.cn&#x2F;ceph+&#39; &#x2F;etc&#x2F;yum.repos.d&#x2F;ceph.repo</span><br><span class="line">yum -y install epel-release</span><br><span class="line">yum -y install ceph-common</span><br></pre></td></tr></table></figure>

<h4 id="查看使用-ceph-volume-创建的-osd-信息"><a href="#查看使用-ceph-volume-创建的-osd-信息" class="headerlink" title="查看使用 ceph-volume 创建的 osd 信息"></a>查看使用 ceph-volume 创建的 osd 信息</h4><p>ceph-volume 使用逻辑卷创建 osd，ceph-disk 使用物理盘创建 osd，物理盘创建的 osd 与 盘符对应关系往往一目了然，逻辑卷创建的 osd 与盘符的对应关系需要执行以下命令查询：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ceph-volume inventory &#x2F;dev&#x2F;sda</span><br></pre></td></tr></table></figure>

<h4 id="var-lib-ceph-osd-ceph-x-使用内存盘"><a href="#var-lib-ceph-osd-ceph-x-使用内存盘" class="headerlink" title="/var/lib/ceph/osd/ceph-x 使用内存盘"></a>/var/lib/ceph/osd/ceph-x 使用内存盘</h4><p>使用 bluestore 的 OSD，所有需要持久化的数据均存储在 LVM metadata 中，所以  /var/lib/ceph/osd/ceph-x 使用 tmpfs 是预期行为， OSD 启动时会从 metadata 中取出相关数据填充到 tmpfs 文件中。参见：<a href="http://lists.ceph.com/pipermail/ceph-users-ceph.com/2019-February/032797.html" target="_blank" rel="external nofollow noopener noreferrer">http://lists.ceph.com/pipermail/ceph-users-ceph.com/2019-February/032797.html</a></p>
<h4 id="osd-near-full-的解决方法"><a href="#osd-near-full-的解决方法" class="headerlink" title="osd (near) full 的解决方法"></a>osd (near) full 的解决方法</h4><p>根本解决之道是添加 osd，临时解决方法是删除无用数据，osd full 时所有的读写操作都无法进行，可通过两种方法恢复读写后再执行删除数据的命令：</p>
<ul>
<li>一是调整 full osd 的权重：<code>ceph osd crush reweight osd.33 0.7</code>  或者 <code>ceph osd reweight-by-utilization</code></li>
<li>二是调高 full 的上限：<code>ceph osd set-full-ratio 0.98</code>，参见：<a href="https://docs.ceph.com/docs/master/rados/troubleshooting/troubleshooting-osd/#no-free-drive-space" target="_blank" rel="external nofollow noopener noreferrer">no-free-drive-space</a></li>
</ul>
<h4 id="ceph-dashboard-303-状态码"><a href="#ceph-dashboard-303-状态码" class="headerlink" title="ceph dashboard 303 状态码"></a>ceph dashboard 303 状态码</h4><p>需要代理网关的后端服务设置为处于 active 状态的 mgr 节点，参考：<a href="https://docs.ceph.com/docs/master/mgr/dashboard/#proxy-configuration" target="_blank" rel="external nofollow noopener noreferrer">https://docs.ceph.com/docs/master/mgr/dashboard/#proxy-configuration</a></p>
<h4 id="pools-have-many-more-objects-per-pg-than-average"><a href="#pools-have-many-more-objects-per-pg-than-average" class="headerlink" title="pools have many more objects per pg than average"></a>pools have many more objects per pg than average</h4><p>反应的问题是各个存储池 pg 数据量不均衡，可参考：<a href="https://www.dazhuanlan.com/2019/08/23/5d5f27fe6de04/" target="_blank" rel="external nofollow noopener noreferrer">https://www.dazhuanlan.com/2019/08/23/5d5f27fe6de04/</a>，<a href="https://blog.csdn.net/ygtlovezf/article/details/60778091" target="_blank" rel="external nofollow noopener noreferrer">https://blog.csdn.net/ygtlovezf/article/details/60778091</a><br>临时解决，关闭不均衡告警，参考：<a href="https://github.com/rook/rook/issues/4739" target="_blank" rel="external nofollow noopener noreferrer">https://github.com/rook/rook/issues/4739</a></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">ceph</span> <span class="string">config</span> <span class="string">set</span> <span class="string">mgr</span> <span class="string">mon_pg_warn_max_object_skew</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>

<h4 id="rgw-多个存储池的数据分布情况"><a href="#rgw-多个存储池的数据分布情况" class="headerlink" title="rgw 多个存储池的数据分布情况"></a>rgw 多个存储池的数据分布情况</h4><p>参考：<a href="https://docs.ceph.com/docs/master/radosgw/layout/" target="_blank" rel="external nofollow noopener noreferrer">https://docs.ceph.com/docs/master/radosgw/layout/</a><br>如果需要快速清除所有 rgw 数据，可手动删除并重建 default.rgw.meta , default.rgw.buckets.index, default.rgw.buckets.data 存储池，需要执行 application enable 并重建用户和存储桶。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ceph osd pool application <span class="built_in">enable</span> default.rgw.buckets.data rgw</span><br><span class="line">ceph osd pool ls detail</span><br><span class="line">radosgw-admin -n client.admin user create --uid=<span class="built_in">test</span> --access-key=<span class="built_in">test</span> --secret-key=<span class="built_in">test</span> --display-name=<span class="built_in">test</span></span><br></pre></td></tr></table></figure>

<h4 id="设置日志等级"><a href="#设置日志等级" class="headerlink" title="设置日志等级"></a>设置日志等级</h4><p>参考：<a href="https://access.redhat.com/documentation/en-us/red_hat_ceph_storage/3/html/troubleshooting_guide/configuring-logging" target="_blank" rel="external nofollow noopener noreferrer">https://access.redhat.com/documentation/en-us/red_hat_ceph_storage/3/html/troubleshooting_guide/configuring-logging</a><br>设置 osd 日志等级时，除了 debug_osd 选项，还有一些其它选项也要跟随调整：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">debug_ms &#x3D; 5</span><br><span class="line">debug_osd &#x3D; 20</span><br><span class="line">debug_filestore &#x3D; 20</span><br><span class="line">debug_journal &#x3D; 20</span><br></pre></td></tr></table></figure>

<h4 id="导出-Cephfs-为-NFS"><a href="#导出-Cephfs-为-NFS" class="headerlink" title="导出 Cephfs 为 NFS"></a>导出 Cephfs 为 NFS</h4><p>参考：<a href="https://documentation.suse.com/ses/6/html/ses-all/cha-ceph-nfsganesha.html" target="_blank" rel="external nofollow noopener noreferrer">https://documentation.suse.com/ses/6/html/ses-all/cha-ceph-nfsganesha.html</a></p>
<h4 id="集群网络配置"><a href="#集群网络配置" class="headerlink" title="集群网络配置"></a>集群网络配置</h4><p>网络配置选项不是必需的， Ceph 假设所有主机都运行于公共网（public network），除非你特意配置了一个集群网（cluster network）。</p>
]]></content>
      <categories>
        <category>Ceph</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Ceph</tag>
      </tags>
  </entry>
  <entry>
    <title>Envoy 知识汇总</title>
    <url>/post/111604be.html</url>
    <content><![CDATA[<h3 id="基本理解"><a href="#基本理解" class="headerlink" title="基本理解"></a>基本理解</h3><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><h4 id="编写-Lua-脚本"><a href="#编写-Lua-脚本" class="headerlink" title="编写 Lua 脚本"></a>编写 Lua 脚本</h4><ul>
<li>一个简单的案例，使用 Lua 脚本为 Http 请求添加了 Authorization 请求头：<a href="https://segmentfault.com/a/1190000020650955" target="_blank" rel="external nofollow noopener noreferrer">https://segmentfault.com/a/1190000020650955</a></li>
</ul>]]></content>
      <categories>
        <category>Envoy</category>
      </categories>
      <tags>
        <tag>Envoy</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker 知识点与命令集合</title>
    <url>/post/f8a08eb2.html</url>
    <content><![CDATA[<h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>参考：<a href="https://mirrors.tuna.tsinghua.edu.cn/help/docker-ce/" target="_blank" rel="external nofollow noopener noreferrer">清华镜像源</a>，<a href="https://developer.aliyun.com/mirror/docker-ce?spm=a2c6h.13651102.0.0.3e221b11R2we8Y" target="_blank" rel="external nofollow noopener noreferrer">阿里镜像源</a></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum remove docker docker-common docker-selinux docker-engine</span><br><span class="line">yum install -y yum-utils device-mapper-persistent-data lvm2</span><br><span class="line">wget -O /etc/yum.repos.d/docker-ce.repo https://download.docker.com/linux/centos/docker-ce.repo</span><br><span class="line">sed -i <span class="string">'s+download.docker.com+mirrors.tuna.tsinghua.edu.cn/docker-ce+'</span> /etc/yum.repos.d/docker-ce.repo</span><br><span class="line">yum install docker-ce docker-ce-cli containerd.io</span><br><span class="line">systemctl <span class="built_in">enable</span> --now docker</span><br></pre></td></tr></table></figure><a id="more"></a>


<h4 id="按指定格式输出-Images-信息"><a href="#按指定格式输出-Images-信息" class="headerlink" title="按指定格式输出 Images 信息"></a>按指定格式输出 Images 信息</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker images --format <span class="string">"&#123;&#123;.ID&#125;&#125;: &#123;&#123;.Repository&#125;&#125;"</span></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="left">Placeholder</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>.ID</code></td>
<td align="left">Image ID</td>
</tr>
<tr>
<td align="left"><code>.Repository</code></td>
<td align="left">Image repository</td>
</tr>
<tr>
<td align="left"><code>.Tag</code></td>
<td align="left">Image tag</td>
</tr>
</tbody></table>
<h4 id="使用镜像源下载-docker-image"><a href="#使用镜像源下载-docker-image" class="headerlink" title="使用镜像源下载 docker image"></a>使用镜像源下载 docker image</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker pull golang:1.13.0 =&gt; docker pull docker.mirrors.ustc.edu.cn/library/golang:1.13.0</span><br><span class="line">docker pull rook/ceph:v1.0.6 =&gt; docker pull dockerhub.azk8s.cn/rook/ceph:v1.0.6</span><br><span class="line">docker pull gcr.io/kubernetes-helm/tiller:v2.9.1 =&gt; docker pull gcr.azk8s.cn/kubernetes-helm/tiller:v2.9.1</span><br><span class="line">docker pull k8s.gcr.io/kube-apiserver:v1.14.1 =&gt; docker pull gcr.azk8s.cn/google-containers/kube-apiserver:v1.14.1</span><br><span class="line">docker pull quay.io/k8scsi/csi-node-driver-registrar:v1.1.0 =&gt; docker pull quay-mirror.qiniu.com/k8scsi/csi-node-driver-registrar:v1.1.0</span><br></pre></td></tr></table></figure>

<h4 id="新建容器时加入已有容器网络"><a href="#新建容器时加入已有容器网络" class="headerlink" title="新建容器时加入已有容器网络"></a>新建容器时加入已有容器网络</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run --name b2 -it --network container:b1 --rm busybox:latest</span><br></pre></td></tr></table></figure>

<h4 id="docker-容器的四种网络模型"><a href="#docker-容器的四种网络模型" class="headerlink" title="docker 容器的四种网络模型"></a>docker 容器的四种网络模型</h4><p>Bridge, Host, Container, None，参考： <a href="https://zhuanlan.zhihu.com/p/98788162" target="_blank" rel="external nofollow noopener noreferrer">Docker 的网络模式详解</a></p>
<h4 id="查看-docker-registry-中的镜像信息"><a href="#查看-docker-registry-中的镜像信息" class="headerlink" title="查看 docker registry 中的镜像信息"></a>查看 docker registry 中的镜像信息</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -X GET https:&#x2F;&#x2F;myregistry:5000&#x2F;v2&#x2F;_catalog</span><br><span class="line">curl -X GET https:&#x2F;&#x2F;myregistry:5000&#x2F;v2&#x2F;ubuntu&#x2F;tags&#x2F;list</span><br></pre></td></tr></table></figure>

<h4 id="docker-指定-tcp-监听地址"><a href="#docker-指定-tcp-监听地址" class="headerlink" title="docker 指定 tcp 监听地址"></a>docker 指定 tcp 监听地址</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 修改 &#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;docker.service</span><br><span class="line">ExecStart&#x3D;&#x2F;usr&#x2F;bin&#x2F;dockerd -H tcp:&#x2F;&#x2F;0.0.0.0:2375 -H fd:&#x2F;&#x2F; --containerd&#x3D;&#x2F;run&#x2F;containerd&#x2F;containerd.sock</span><br></pre></td></tr></table></figure>

<h4 id="删除私有-registry-中损坏的镜像"><a href="#删除私有-registry-中损坏的镜像" class="headerlink" title="删除私有 registry 中损坏的镜像"></a>删除私有 registry 中损坏的镜像</h4><p>docker pull 时报错如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@umstor01 ~]<span class="comment"># docker pull registry.umstor.io:5050/umplus/umstor-elasticsearch:6.7.1</span></span><br><span class="line">...</span><br><span class="line">filesystem layer verification failed <span class="keyword">for</span> digest sha256:08f62e37e0f75961adcf1b87778f8c25412a2865742ffe4d79cde83ac08987ca</span><br></pre></td></tr></table></figure>

<p>先到仓库目录  <code>registry/v2/repositories/umplus</code> 删除  <code>umstor-elasticsearch</code> 镜像，再到  <code>docker/registry/v2/blobs/sha256</code> 目录删除  <code>08f62e37e0f75961adcf1b87778f8c25412a2865742ffe4d79c</code>。之后重启 docker registry 。</p>
<h4 id="docker-push-时报错-file-integrity-checksum-failed"><a href="#docker-push-时报错-file-integrity-checksum-failed" class="headerlink" title="docker push 时报错 file integrity checksum failed"></a>docker push 时报错 file integrity checksum failed</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  umstorlcm git:(dev) ✗ sudo docker push registry.umstor.io:5050/umplus/umstor-elasticsearch:6.7.1</span><br><span class="line">...</span><br><span class="line">file integrity checksum failed <span class="keyword">for</span> <span class="string">"usr/share/elasticsearch/plugins/opendistro_security/jjwt-api-0.10.5.jar"</span></span><br></pre></td></tr></table></figure>

<p>可尝试执行 <code>sudo docker system prune -a</code> 后重新打包或拉取镜像 retag 重试 push。</p>
<h4 id="允许非-root-用户使用-docker"><a href="#允许非-root-用户使用-docker" class="headerlink" title="允许非 root 用户使用 docker"></a>允许非 root 用户使用 docker</h4><p>参考：<a href="https://docs.docker.com/engine/install/linux-postinstall/" target="_blank" rel="external nofollow noopener noreferrer">https://docs.docker.com/engine/install/linux-postinstall/</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo groupadd docker</span><br><span class="line">sudo usermod -aG docker $USER</span><br><span class="line">newgrp docker</span><br></pre></td></tr></table></figure>

<h4 id="使用远程服务器的-docker-服务"><a href="#使用远程服务器的-docker-服务" class="headerlink" title="使用远程服务器的 docker 服务"></a>使用远程服务器的 docker 服务</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker context create my-remote-docker-machine --docker &quot;host&#x3D;ssh:&#x2F;&#x2F;username@host:port&quot;</span><br></pre></td></tr></table></figure>

<h4 id="限制容器-rootfs-可用的磁盘大小"><a href="#限制容器-rootfs-可用的磁盘大小" class="headerlink" title="限制容器 rootfs 可用的磁盘大小"></a>限制容器 rootfs 可用的磁盘大小</h4><p>参见：<a href="https://fabianlee.org/2020/01/15/docker-use-overlay2-with-an-xfs-backing-filesystem-to-limit-rootfs-size/" target="_blank" rel="external nofollow noopener noreferrer">https://fabianlee.org/2020/01/15/docker-use-overlay2-with-an-xfs-backing-filesystem-to-limit-rootfs-size/</a>，<a href="https://www.thegeekdiary.com/how-to-enable-disk-quotas-on-an-xfs-file-system/" target="_blank" rel="external nofollow noopener noreferrer">https://www.thegeekdiary.com/how-to-enable-disk-quotas-on-an-xfs-file-system/</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 首先 /var/lib/docker 所在分区挂载时应添加 pquota 选项</span></span><br><span class="line">UUID=.... /home xfs defaults,uquota,pquota 0 0</span><br><span class="line"><span class="comment"># 在创建容器时添加指定相关参数</span></span><br><span class="line">$ sudo docker run -it --storage-opt size=12m alpine:latest /bin/df -h | grep overlay</span><br><span class="line">overlay 12.0M 8.0K 12.0M 0% /</span><br></pre></td></tr></table></figure>

<h4 id="volume-bind-mount-tmpfs"><a href="#volume-bind-mount-tmpfs" class="headerlink" title="volume/bind-mount/tmpfs"></a>volume/bind-mount/tmpfs</h4><p>volume 由 docker 单独管理，存在于 /var/lib/docker/volumes/ 目录，独立于镜像分层，可视为通过硬链接给指定容器使用，因为 stat 看到的 inode 的 link 数量确实大于 1 ，但似乎对目录建立硬链接是不允许的，所以此处存疑。<br>bind mount 是 Kubernetes 中给容器挂载各种存储卷统一使用的形式。<br>tmpfs 在 Kubernetes 中用于保存 service token 到临时文件，之后仍然通过 bind mount 挂载给容器使用。</p>
<h4 id="使用-xfs-作为-overlay2-的基础文件系统"><a href="#使用-xfs-作为-overlay2-的基础文件系统" class="headerlink" title="使用 xfs 作为 overlay2 的基础文件系统"></a>使用 xfs 作为 overlay2 的基础文件系统</h4><p>d_type (directory type) 是 Linux 内核的一个术语，表示 “目录类型”，是文件系统上目录信息的一个数据结构。d_type，就是这个数据结构的一个字段，这个字段用来表示文件的类型，是文件，还是管道，还是目录还是套接字等。内核从 Linux 2.6 版本开始支持，但有的文件系统未实现。对于 xfs，初始化文件系统时需要传入如下参数（可能在高版本内核中已默认开启？）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkfs.xfs -n ftype=1 /path/to/your/device</span><br></pre></td></tr></table></figure>

<h4 id="overlay2"><a href="#overlay2" class="headerlink" title="overlay2"></a>overlay2</h4><p>以一个容器为例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker inspect 6a7bbe23dee7 | jq &#39;.[0].GraphDriver&#39;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;Data&quot;: &#123;</span><br><span class="line">    &quot;LowerDir&quot;: &quot;&#x2F;data&#x2F;docker&#x2F;overlay2&#x2F;15283905a66bcb3cee77c9b03aae27c2d299356ad4a86383f833a218dd924aca-init&#x2F;diff:&#x2F;data&#x2F;docker&#x2F;overlay2&#x2F;8f864615b27aff6f4bae9898ac47fd42f567b2abb2bd57f0767bf53af7470cd3&#x2F;diff:&#x2F;data&#x2F;docker&#x2F;overlay2&#x2F;26ae8de5b32541349d625f7fa86dbe9b17dc304a406a5a557a0565f4df311546&#x2F;diff:&#x2F;data&#x2F;docker&#x2F;overlay2&#x2F;be0892cc29599a864b40f886f766a6042a785cdf6a5c9e046661e60c512cb5eb&#x2F;diff&quot;,</span><br><span class="line">    &quot;MergedDir&quot;: &quot;&#x2F;data&#x2F;docker&#x2F;overlay2&#x2F;15283905a66bcb3cee77c9b03aae27c2d299356ad4a86383f833a218dd924aca&#x2F;merged&quot;,</span><br><span class="line">    &quot;UpperDir&quot;: &quot;&#x2F;data&#x2F;docker&#x2F;overlay2&#x2F;15283905a66bcb3cee77c9b03aae27c2d299356ad4a86383f833a218dd924aca&#x2F;diff&quot;,</span><br><span class="line">    &quot;WorkDir&quot;: &quot;&#x2F;data&#x2F;docker&#x2F;overlay2&#x2F;15283905a66bcb3cee77c9b03aae27c2d299356ad4a86383f833a218dd924aca&#x2F;work&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;Name&quot;: &quot;overlay2&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上图中可以看到使用了 overlay2，MergedDir 是最终的统一视图，通过 findmnt 命令可进一步查看：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ findmnt -T &#x2F;data&#x2F;docker&#x2F;overlay2&#x2F;15283905a66bcb3cee77c9b03aae27c2d299356ad4a86383f833a218dd924aca&#x2F;merged --notruncate</span><br><span class="line">TARGET                                                                                        SOURCE  FSTYPE  OPTIONS</span><br><span class="line">&#x2F;data&#x2F;docker&#x2F;overlay2&#x2F;15283905a66bcb3cee77c9b03aae27c2d299356ad4a86383f833a218dd924aca&#x2F;merged overlay overlay rw,relatime,lowerdir&#x3D;&#x2F;data&#x2F;docker&#x2F;overlay2&#x2F;l&#x2F;65ULPACJJ5HPW6N7X7O4EYT3FV:&#x2F;data&#x2F;docker&#x2F;overlay2&#x2F;l&#x2F;NJSWN22VUADQPGUNVHOTOLFIYO:&#x2F;data&#x2F;docker&#x2F;overlay2&#x2F;l&#x2F;ST6G6NDPWCA7DOPGPP6YY5ZQTR:&#x2F;data&#x2F;docker&#x2F;overlay2&#x2F;l&#x2F;T5DURVHXWM4P7NNCW4H4TYYVSR,upperdir&#x3D;&#x2F;data&#x2F;docker&#x2F;overlay2&#x2F;15283905a66bcb3cee77c9b03aae27c2d299356ad4a86383f833a218dd924aca&#x2F;diff,workdir&#x3D;&#x2F;data&#x2F;docker&#x2F;overlay2&#x2F;15283905a66bcb3cee77c9b03aae27c2d299356ad4a86383f833a218dd924aca&#x2F;work</span><br></pre></td></tr></table></figure>

<p>可以看到 MergedDir 是挂载点，其它的目录分别以 lowerdir/upperdir/workdir 等挂载参数的形式传入，MergedDir/UpperDir/WorkDir 位于同一层，即可写层。进一步查看 overlay2 下的各层信息：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 顶层，即可写层，该层写入的内容在 diff 目录下</span></span><br><span class="line">$ ls /data/docker/overlay2/15283905a66bcb3cee77c9b03aae27c2d299356ad4a86383f833a218dd924aca</span><br><span class="line">diff  link  lower  merged  work</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看下层信息，显示的是下层的短 ID</span></span><br><span class="line">$ cat /data/docker/overlay2/15283905a66bcb3cee77c9b03aae27c2d299356ad4a86383f833a218dd924aca/lower</span><br><span class="line">l/65ULPACJJ5HPW6N7X7O4EYT3FV:l/NJSWN22VUADQPGUNVHOTOLFIYO:l/ST6G6NDPWCA7DOPGPP6YY5ZQTR:l/T5DURVHXWM4P7NNCW4H4TYYVS</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过短 ID 可以分别找到具体的下层，可以看到与 docker inspect 和 findmnt 中显示的层信息一致</span></span><br><span class="line">$ realpath /data/docker/overlay2/l/65ULPACJJ5HPW6N7X7O4EYT3FV</span><br><span class="line">/data/docker/overlay2/15283905a66bcb3cee77c9b03aae27c2d299356ad4a86383f833a218dd924aca-init/diff</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看下层的目录结构，和顶层类似但没有 merged 目录</span></span><br><span class="line">$ ls /data/docker/overlay2/15283905a66bcb3cee77c9b03aae27c2d299356ad4a86383f833a218dd924aca-init/</span><br><span class="line">diff  link  lower  work</span><br><span class="line"></span><br><span class="line"><span class="comment"># 继续查看下层信息，可以看到是记录的下层短 ID 和顶层 lower 记录的剩余 ID 是一致的</span></span><br><span class="line">$ cat /data/docker/overlay2/15283905a66bcb3cee77c9b03aae27c2d299356ad4a86383f833a218dd924aca-init/lower</span><br><span class="line">l/NJSWN22VUADQPGUNVHOTOLFIYO:l/ST6G6NDPWCA7DOPGPP6YY5ZQTR:l/T5DURVHXWM4P7NNCW4H4TYYVSR</span><br><span class="line"></span><br><span class="line"><span class="comment"># 继续查看下层目录，发现是一样的</span></span><br><span class="line"><span class="comment"># 只有最下层略有不同，没有 lower 和 work 目录</span></span><br><span class="line">$ ls /data/docker/overlay2/be0892cc29599a864b40f886f766a6042a785cdf6a5c9e046661e60c512cb5eb</span><br><span class="line">diff  link</span><br></pre></td></tr></table></figure>

<p>根据社区文档说明，link 文件中存放当前层的短 ID，lower 文件记录更下层的短 ID，diff 目录存放当前层的内容，work 目录由 OverlayFS 内部使用。</p>
<h4 id="从源码编译-docker-二进制文件"><a href="#从源码编译-docker-二进制文件" class="headerlink" title="从源码编译 docker 二进制文件"></a>从源码编译 docker 二进制文件</h4><p>参考：<a href="https://ops.tips/blog/compiling-your-own-forked-docker-release/" target="_blank" rel="external nofollow noopener noreferrer">Compiling and running your own forked Docker release</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;docker&#x2F;docker-ce.git</span><br><span class="line">&#x2F;&#x2F; 检出目标版本</span><br><span class="line">git checkout v18.09.2</span><br><span class="line">&#x2F;&#x2F; 按需修改源码</span><br><span class="line">&#x2F;&#x2F; 执行编译命令</span><br><span class="line">make static DOCKER_BUILD_PKGS&#x3D;static-linux</span><br><span class="line">&#x2F;&#x2F; 查看编译结果</span><br><span class="line">tree .&#x2F;components&#x2F;packaging&#x2F;static&#x2F;build&#x2F;linux</span><br><span class="line"></span><br><span class="line">.&#x2F;components&#x2F;packaging&#x2F;static&#x2F;build&#x2F;linux</span><br><span class="line">├── docker</span><br><span class="line">│   ├── docker</span><br><span class="line">│   ├── containerd</span><br><span class="line">│   ├── containerd-ctr</span><br><span class="line">│   ├── containerd-shim</span><br><span class="line">│   ├── dockerd</span><br><span class="line">│   ├── docker-init</span><br><span class="line">│   ├── docker-proxy</span><br><span class="line">│   └── docker-runc</span><br><span class="line">└── docker-18.09.2.tgz</span><br></pre></td></tr></table></figure>

<h4 id="减少镜像体积的方式"><a href="#减少镜像体积的方式" class="headerlink" title="减少镜像体积的方式"></a>减少镜像体积的方式</h4><p>将多个 RUN 语句组合在一行命令中；使用多阶段构建；使用 Alpine 作为基础镜像；使用 Go 等静态编译语言代替 Java 等动态解释语言。</p>
<h4 id="COPY-与-ADD"><a href="#COPY-与-ADD" class="headerlink" title="COPY 与 ADD"></a>COPY 与 ADD</h4><p>COPY 比 ADD 多两个特性：可以自动解压 src 为 gzip 等压缩格式的文件到 dst 目录；src 路径可以是一个远程 URL 链接。</p>
<h4 id="ENTRYPOINT-与-CMD"><a href="#ENTRYPOINT-与-CMD" class="headerlink" title="ENTRYPOINT 与 CMD"></a>ENTRYPOINT 与 CMD</h4><p>ENTRYPOINT 必须是可执行的程序，CMD 作为参数传递给 ENTRYPOINT。</p>
<h4 id="清理-Docker-所有容器和镜像"><a href="#清理-Docker-所有容器和镜像" class="headerlink" title="清理 Docker 所有容器和镜像"></a>清理 Docker 所有容器和镜像</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker ps -aq</span><br><span class="line">docker stop $(docker ps -aq)</span><br><span class="line">docker rm $(docker ps -aq)</span><br><span class="line">docker rmi $(docker images -q)</span><br></pre></td></tr></table></figure>

<h4 id="设置-HTTP-代理"><a href="#设置-HTTP-代理" class="headerlink" title="设置 HTTP 代理"></a>设置 HTTP 代理</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir -p /etc/systemd/system/docker.service.d</span><br><span class="line"><span class="built_in">echo</span> <span class="string">'</span></span><br><span class="line"><span class="string">[Service]</span></span><br><span class="line"><span class="string">Environment="HTTP_PROXY=http://10.20.47.147:3128"</span></span><br><span class="line"><span class="string">Environment="HTTPS_PROXY=http://10.20.47.147:3128"</span></span><br><span class="line"><span class="string">Environment="NO_PROXY=localhost,127.0.0.1,10.0.0.0/8,172.0.0.0/8,100.0.0.0/8,10.8.10.222,*.some.org"</span></span><br><span class="line"><span class="string">'</span> | tee /etc/systemd/system/docker.service.d/http-proxy.conf</span><br><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag> 云计算</tag>
      </tags>
  </entry>
  <entry>
    <title>Go Rate Limit</title>
    <url>/post/6b64a72a.html</url>
    <content><![CDATA[<h4 id="限流算法"><a href="#限流算法" class="headerlink" title="限流算法"></a>限流算法</h4><p>在各种限流工具包中，最为常见的是令牌桶算法。除此外，还有漏桶算法等。<br>令牌桶算法的初始化参数一般包括桶大小和令牌投放速率，桶大小为零则意味着不允许突发流量。</p><h4 id="golang-org-x-time-rate"><a href="#golang-org-x-time-rate" class="headerlink" title="golang.org/x/time/rate"></a>golang.org/x/time/rate</h4><p>实现令牌桶算法，主要提供了 Allow, Reserve, and Wait 三个方法，它们的区别在于没有令牌可用后的行为：Allow 返回一个布尔值 false，Reserve 预定一个令牌并返回需要等待的时间，Wait 会一直阻塞到获取令牌。参见：<a href="https://pkg.go.dev/golang.org/x/time/rate#NewLimiter" target="_blank" rel="external nofollow noopener noreferrer">https://pkg.go.dev/golang.org/x/time/rate#NewLimiter</a>。</p><a id="more"></a>

<h4 id="github-com-juju-ratelimit"><a href="#github-com-juju-ratelimit" class="headerlink" title="github.com/juju/ratelimit"></a>github.com/juju/ratelimit</h4><p>同样实现令牌桶算法，不同的是提供了 TakeAvailable 方法，可以尝试取出指定数量的令牌，实际取出的令牌数可能少于期望数量，根据实际数量执行下一步操作，另外提供了针对 Reader 和 Writer 的封装。参见：<a href="https://github.com/juju/ratelimit" target="_blank" rel="external nofollow noopener noreferrer">https://github.com/juju/ratelimit</a>。</p>
<h4 id="其它实现"><a href="#其它实现" class="headerlink" title="其它实现"></a>其它实现</h4><p><a href="https://github.com/andrewstuart/limio" target="_blank" rel="external nofollow noopener noreferrer">https://github.com/andrewstuart/limio</a></p>
]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>Git 常用命令</title>
    <url>/post/5fddf106.html</url>
    <content><![CDATA[<h4 id="修改历史-commit-信息"><a href="#修改历史-commit-信息" class="headerlink" title="修改历史 commit 信息"></a>修改历史 commit 信息</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git rebase -i HEAD~2</span><br><span class="line">pick -&gt; edit</span><br><span class="line">git commit --amend</span><br><span class="line">git rebase --continue</span><br></pre></td></tr></table></figure><h4 id="修改-commit-时间"><a href="#修改-commit-时间" class="headerlink" title="修改 commit 时间"></a>修改 commit 时间</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 设置为当前时间</span><br><span class="line">GIT_COMMITTER_DATE&#x3D;&quot;$(date &#39;+%Y-%m-%d %H:%M:%S&#39;)&quot; git commit --amend --no-edit --date &quot;$(date)&quot;</span><br><span class="line"># 设置为指定时间</span><br><span class="line">GIT_COMMITTER_DATE&#x3D;&quot;2021-03-19 17:54:27 GMT+8&quot; git commit --amend --no-edit --date &quot;2021-03-19 17:54:27 GMT+8&quot;</span><br></pre></td></tr></table></figure><a id="more"></a>



<h4 id="比较两个分支的不同"><a href="#比较两个分支的不同" class="headerlink" title="比较两个分支的不同"></a>比较两个分支的不同</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git diff branch_1..branch_2</span><br></pre></td></tr></table></figure>

<h4 id="列出不同分支之间的所有-commit"><a href="#列出不同分支之间的所有-commit" class="headerlink" title="列出不同分支之间的所有 commit"></a>列出不同分支之间的所有 commit</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">log</span> --left-right --cherry-pick --oneline v1.14.6..v1.14.10</span><br></pre></td></tr></table></figure>

<h4 id="比较两个分支中指定文件或目录"><a href="#比较两个分支中指定文件或目录" class="headerlink" title="比较两个分支中指定文件或目录"></a>比较两个分支中指定文件或目录</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git diff mybranch master -- myfile.cs</span><br></pre></td></tr></table></figure>

<h4 id="merge-时使用指定方代码解决冲突"><a href="#merge-时使用指定方代码解决冲突" class="headerlink" title="merge 时使用指定方代码解决冲突"></a>merge 时使用指定方代码解决冲突</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">git merge -X theirs origin/dev</span><br><span class="line">git merge -X ours origin/dev</span><br></pre></td></tr></table></figure>

<h4 id="查看一个文件完整的修改历史"><a href="#查看一个文件完整的修改历史" class="headerlink" title="查看一个文件完整的修改历史"></a>查看一个文件完整的修改历史</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git log --follow -p -- _config.yml</span><br></pre></td></tr></table></figure>

<h4 id="将当前分支下子目录内容提交至另一个分支"><a href="#将当前分支下子目录内容提交至另一个分支" class="headerlink" title="将当前分支下子目录内容提交至另一个分支"></a>将当前分支下子目录内容提交至另一个分支</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git subtree push --prefix dist origin gh-pages</span><br></pre></td></tr></table></figure>

<h4 id="删除-submodule"><a href="#删除-submodule" class="headerlink" title="删除 submodule"></a>删除 submodule</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git submodule deinit &lt;path_to_submodule&gt;</span><br><span class="line">git rm &lt;path_to_submodule&gt;</span><br><span class="line">git commit -m &quot;Removed submodule &quot;</span><br></pre></td></tr></table></figure>

<h4 id="合并所有-commit-为一个"><a href="#合并所有-commit-为一个" class="headerlink" title="合并所有 commit 为一个"></a>合并所有 commit 为一个</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git rebase --root -i</span><br><span class="line">&#x2F;&#x2F; 使用以下命令可以将需要 rebase 的 commit 的时间全部设置为当前时间</span><br><span class="line">git rebase --ignore-date 303a824f46b497f71582e2e5d493c132b85e3e0a</span><br></pre></td></tr></table></figure>

<h4 id="删除所有没有远程分支的本地分支"><a href="#删除所有没有远程分支的本地分支" class="headerlink" title="删除所有没有远程分支的本地分支"></a>删除所有没有远程分支的本地分支</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git fetch -p &amp;&amp; git branch -vv | awk &#39;&#x2F;: gone]&#x2F;&#123;print $1&#125;&#39; | xargs git branch -d</span><br></pre></td></tr></table></figure>

<h4 id="撤销某个-commit"><a href="#撤销某个-commit" class="headerlink" title="撤销某个 commit"></a>撤销某个 commit</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git revert --strategy resolve &lt;commit&gt;</span><br></pre></td></tr></table></figure>

<h4 id="使用-ssh-替代-https-访问"><a href="#使用-ssh-替代-https-访问" class="headerlink" title="使用 ssh 替代 https 访问"></a>使用 ssh 替代 https 访问</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global url.<span class="string">"git@git.ucloudadmin.com:"</span>.insteadOf <span class="string">"https://git.ucloudadmin.com/"</span></span><br></pre></td></tr></table></figure>

<h4 id="查看-commit-内容"><a href="#查看-commit-内容" class="headerlink" title="查看 commit 内容"></a>查看 commit 内容</h4><p>查看指定 commit id 的提交内容</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">git</span> <span class="string">show</span> <span class="string">67cebafce9c45a1d65fddd3d1742c4cb42851d10</span></span><br></pre></td></tr></table></figure>

<p>查看最近 n 次提交内容</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">git</span> <span class="string">log</span> <span class="string">-p</span> <span class="string">-n</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h4 id="创建和删除-tag"><a href="#创建和删除-tag" class="headerlink" title="创建和删除 tag"></a>创建和删除 tag</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 删除本地 tag</span><br><span class="line">git tag -d v0.0.1</span><br><span class="line">// 删除远程仓库 tag</span><br><span class="line">git push --delete origin v0.0.1</span><br><span class="line">// 创建本地 tag</span><br><span class="line">git tag v0.0.1 -m <span class="string">"Release version 0.0.1"</span></span><br><span class="line">// 以某个 commit 为基础创建 tag</span><br><span class="line">git tag -a v0.0.1 30728cab -m <span class="string">"Release version 0.0.1"</span></span><br><span class="line">// 推送指定 tag 到远程</span><br><span class="line">git push origin v0.0.1</span><br><span class="line">// 推送所有 tag 到远程</span><br><span class="line">git push --tags</span><br></pre></td></tr></table></figure>

<h4 id="获取最近的-tag"><a href="#获取最近的-tag" class="headerlink" title="获取最近的 tag"></a>获取最近的 tag</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 获取最新的 tag</span><br><span class="line">git describe --tags $(git rev-list --tags --max-count=1)</span><br><span class="line">// 获取最新 commit 对应的 tag</span><br><span class="line">git describe --abbrev=0</span><br><span class="line">git describe --tags</span><br></pre></td></tr></table></figure>

<h4 id="创建和应用-patch"><a href="#创建和应用-patch" class="headerlink" title="创建和应用 patch"></a>创建和应用 patch</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 生成 git patch</span><br><span class="line">git diff c78bca..709fcfe &gt; /tmp/cloudprovider.patch</span><br><span class="line">// 应用 patch</span><br><span class="line">git apply /tmp/cloudprovider.patch</span><br></pre></td></tr></table></figure>

<h4 id="gitlab-创建-tag-和发布附件流程"><a href="#gitlab-创建-tag-和发布附件流程" class="headerlink" title="gitlab 创建 tag 和发布附件流程"></a>gitlab 创建 tag 和发布附件流程</h4><p>参考：<a href="https://stackoverflow.com/a/55415383" target="_blank" rel="external nofollow noopener noreferrer">https://stackoverflow.com/a/55415383</a></p>
<h4 id="cherry-pick-时移除不需要的修改"><a href="#cherry-pick-时移除不需要的修改" class="headerlink" title="cherry-pick 时移除不需要的修改"></a>cherry-pick 时移除不需要的修改</h4><p>参考：<a href="https://stackoverflow.com/questions/5717026/how-to-git-cherry-pick-only-changes-to-certain-files" target="_blank" rel="external nofollow noopener noreferrer">https://stackoverflow.com/questions/5717026/how-to-git-cherry-pick-only-changes-to-certain-files</a><br>如果需要移除的修改较少，可使用以下方式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git cherry-pick -n 1683355bf81435ffdcbf332ad3558cb92853c9eb</span><br><span class="line">&#x2F;&#x2F; 丢弃该 commit 对 go.mod 文件的修改</span><br><span class="line">git restore --staged go.mod</span><br><span class="line">&#x2F;&#x2F; 或者</span><br><span class="line">git checkout HEAD go.mod</span><br><span class="line">&#x2F;&#x2F; 直接提交即可, commit 信息使用上述 commit 的</span><br><span class="line">git commit</span><br></pre></td></tr></table></figure>

<p>如果大部分修改都需要移除，可采用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git cherry-pick -n 1683355bf81435ffdcbf332ad3558cb92853c9eb</span><br><span class="line">git reset HEAD</span><br><span class="line">&#x2F;&#x2F; 添加需要保留的修改</span><br><span class="line">git add &lt;path&gt;</span><br><span class="line">&#x2F;&#x2F; 移除所有不需要保存的修改</span><br><span class="line">git clean -f</span><br></pre></td></tr></table></figure>

<p>如果仅有一两项文件或目录的修改需要保留，可执行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 应用对文件或目录下文件的修改</span><br><span class="line">git show SHA -- file1.txt file2.txt | git apply -</span><br><span class="line">git show SHA -- dir1 dir2 | git apply -</span><br><span class="line">&#x2F;&#x2F; 保存修改</span><br><span class="line">git add file1.txt file2.txt</span><br><span class="line">git commit -c SHA</span><br><span class="line">&#x2F;&#x2F; 或者二合一</span><br><span class="line">git show SHA -- file1.txt file2.txt | git apply --cached -</span><br></pre></td></tr></table></figure>

<h4 id="使用指定-commit-中的内容覆盖指定文件或目录"><a href="#使用指定-commit-中的内容覆盖指定文件或目录" class="headerlink" title="使用指定 commit 中的内容覆盖指定文件或目录"></a>使用指定 commit 中的内容覆盖指定文件或目录</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout c5f567 -- file1/to/restore file2/to/restore</span><br></pre></td></tr></table></figure>

<h4 id="github-actions"><a href="#github-actions" class="headerlink" title="github actions"></a>github actions</h4><ul>
<li>自动创建发布：<a href="https://github.com/actions/upload-release-asset" target="_blank" rel="external nofollow noopener noreferrer">https://github.com/actions/upload-release-asset</a></li>
</ul>
<h4 id="clone-all-projects-in-group"><a href="#clone-all-projects-in-group" class="headerlink" title="clone all projects in group"></a>clone all projects in group</h4><p><a href="https://github.com/gabrie30/ghorg" target="_blank" rel="external nofollow noopener noreferrer">https://github.com/gabrie30/ghorg</a><br>或者</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> repo <span class="keyword">in</span> $(curl -s --header <span class="string">"PRIVATE-TOKEN: your_private_token"</span> https://&lt;your-host&gt;/api/v4/groups/&lt;group_id&gt; | jq <span class="string">".projects[].ssh_url_to_repo"</span> | tr -d <span class="string">'"'</span>); <span class="keyword">do</span> git <span class="built_in">clone</span> <span class="variable">$repo</span>; <span class="keyword">done</span>;</span><br></pre></td></tr></table></figure>

<h4 id="设置代理"><a href="#设置代理" class="headerlink" title="设置代理"></a>设置代理</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">git config --global http.proxy http:<span class="comment">//127.0.0.1:1080</span></span><br><span class="line">git config --global http.proxy socks5h:<span class="comment">//127.0.0.1:1080</span></span><br><span class="line">git config --global --unset http.proxy</span><br><span class="line"><span class="comment">//#只对GitHub设置代理</span></span><br><span class="line">git config --global http.https:<span class="comment">//github.com.proxy socks5h://127.0.0.1:1080</span></span><br><span class="line">git config --global --unset http.https:<span class="comment">//github.com.proxy</span></span><br></pre></td></tr></table></figure>

<h4 id="查看所有分支的最后活跃时间"><a href="#查看所有分支的最后活跃时间" class="headerlink" title="查看所有分支的最后活跃时间"></a>查看所有分支的最后活跃时间</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> branch <span class="keyword">in</span> `git branch -a`;</span><br><span class="line"><span class="keyword">do</span>;</span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$branch</span> != <span class="string">"*"</span> ]; <span class="keyword">then</span>;</span><br><span class="line">    hasAct=$(git <span class="built_in">log</span> --abbrev-commit --date=relative -1 <span class="variable">$branch</span>);</span><br><span class="line">    lastActivity=$(<span class="built_in">echo</span> <span class="string">"<span class="variable">$hasAct</span>"</span> | grep Date: | sed <span class="string">'s/Date: //'</span>);</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"<span class="variable">$branch</span> last activity was\033[1;31m<span class="variable">$lastActivity</span>\033[0m"</span>;</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">""</span></span><br><span class="line"><span class="keyword">fi</span>;</span><br><span class="line"><span class="keyword">done</span>;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>开发工具</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>开发工具</tag>
      </tags>
  </entry>
  <entry>
    <title>Go 值得关注的开源项目</title>
    <url>/post/5d0690ba.html</url>
    <content><![CDATA[<h4 id="ipfs"><a href="#ipfs" class="headerlink" title="ipfs"></a>ipfs</h4><p>peer to peer web 传输协议：<a href="https://ipfs.io/" target="_blank" rel="external nofollow noopener noreferrer">https://ipfs.io/</a>。</p><h4 id="QUIC-协的-Golang-实现"><a href="#QUIC-协的-Golang-实现" class="headerlink" title="QUIC 协的 Golang 实现"></a>QUIC 协的 Golang 实现</h4><ol>
<li><a href="https://github.com/lucas-clemente/quic-go" target="_blank" rel="external nofollow noopener noreferrer">https://github.com/lucas-clemente/quic-go</a> 是标准的 QUIC 协议实现，基于 IETF QUIC 草稿协议。</li>
<li><a href="https://github.com/pion/quic" target="_blank" rel="external nofollow noopener noreferrer">Pion QUIC</a> 基于 quic-go，可用于 Peer To Peer 通信。</li>
</ol>]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>Go 实现长轮询：一个服务端超时设置的实例</title>
    <url>/post/f5f8beb0.html</url>
    <content><![CDATA[<h3 id="原文"><a href="#原文" class="headerlink" title="原文"></a>原文</h3><p><a href="https://lucasroesler.com/2018/07/golang-long-polling-a-tale-of-server-timeouts/" target="_blank" rel="external nofollow noopener noreferrer">Golang long-polling: a tale of server timeouts</a></p><p>我最近花了一周时间来实现 HTTP 长轮询。和软件开发中经常发生的一样，经过漫长的 debug 过程，我最终的修复方案涉及到的代码只有一行。</p><p>在现代 Web 应用开发中实时更新正变得很常见。正好，我最近就在我的一个服务上实现了长轮询。Web 应用获取实时更新有以下几种方式：</p><a id="more"></a>


<ol>
<li>短轮询：Web 应用按照指定的时间间隔不断的发出请求，比如每秒一次。</li>
<li>长轮询：Web 应用重复地进行 HTTP 请求，但是每个请求的存活时间比较长。只有服务端有更新或者请求超时，该请求才会被响应，随后 Web 应用立即发起一个新的请求。</li>
<li>HTTP 流：Web 应用发起一个持久的 HTTP 请求，且请求不会被关闭。一旦服务端有更新就会立即发送部分响应，可以使用类似 ndjson 的形式。</li>
<li>WebSocket：同样地 Web 应用发起一个持久的允许双向通信的请求。</li>
</ol>
<p>有很多原因告诫我们永远不要用第一种方式，而是选择 2-4 中的某一种。在我们的使用场景中，我们想要给已经存在的 REST API 添加只读的获取实时更新的特性，所以长轮询看起来是一种非常自然和简单的实现方式。<br>不幸的是，基本上没有关于长轮询的标准或规范。这意味着一切只能自己动手。我们设计了如下的请求序列：<br><img src="https://cdn.nlark.com/yuque/0/2019/png/182657/1575783155078-b299a29e-2114-4667-ad30-947580207315.png#align=left&display=inline&height=526&margin=%5Bobject%20Object%5D&name=image.png&originHeight=526&originWidth=579&size=95727&status=done&style=none&width=579" alt="image.png"><br>注意请求超时时我们返回 304（未改变） 状态码而不是 504（服务端超时）。我们使用了请求头 prefer 来发送轮询参数。<br>下面是一个实现了上述轮询序列的简单例子（只是使用了 URL 传递查询参数）：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"context"</span></span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"io/ioutil"</span></span><br><span class="line">	<span class="string">"log"</span></span><br><span class="line">	<span class="string">"math/rand"</span></span><br><span class="line">	<span class="string">"net/http"</span></span><br><span class="line">	<span class="string">"net/http/httptest"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getLongPollDuration</span><span class="params">(r *http.Request)</span> <span class="title">time</span>.<span class="title">Duration</span></span> &#123;</span><br><span class="line">	timeout, err := time.ParseDuration(r.URL.Query().Get(<span class="string">"wait"</span>))</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">15</span> * time.Second</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	log.Printf(<span class="string">"found custom timeout: %s"</span>, timeout)</span><br><span class="line">	<span class="keyword">return</span> timeout</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getResource</span><span class="params">(ctx context.Context)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">"&#123;\"id\": 1, \"updatedAt\": \""</span> + time.Now().Format(time.RFC3339) + <span class="string">"\"&#125;"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">waitForResource</span><span class="params">(ctx context.Context, wait time.Duration)</span> <span class="title">string</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// randomly wait up to 15 seconds for a "resource changed event"</span></span><br><span class="line">	r := rand.Intn(<span class="number">15</span>)</span><br><span class="line">	ticker := time.Tick(time.Duration(r) * time.Second)</span><br><span class="line">	waiter := time.Tick(wait)</span><br><span class="line"></span><br><span class="line">	log.Printf(<span class="string">"will wait up to %s for the resource"</span>, wait)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">		log.Printf(<span class="string">"Received context cancel"</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="string">""</span></span><br><span class="line">	<span class="keyword">case</span> ts := &lt;-waiter:</span><br><span class="line">		log.Printf(<span class="string">"Received method timeout: %s"</span>, ts)</span><br><span class="line">		<span class="keyword">return</span> <span class="string">""</span></span><br><span class="line">	<span class="keyword">case</span> ts := &lt;-ticker:</span><br><span class="line">		log.Printf(<span class="string">"Received resource update at: %s"</span>, ts)</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"&#123;\"id\": 1, \"updatedAt\": \""</span> + ts.Format(time.RFC3339) + <span class="string">"\"&#125;"</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">resourceFunc</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">	index := r.URL.Query().Get(<span class="string">"index"</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> index != <span class="string">""</span> &#123;</span><br><span class="line">		timeout := getLongPollDuration(r)</span><br><span class="line">		response := waitForResource(r.Context(), timeout)</span><br><span class="line">		<span class="keyword">if</span> response == <span class="string">""</span> &#123;</span><br><span class="line">			<span class="comment">// write long poll timeout</span></span><br><span class="line">			w.WriteHeader(http.StatusNotModified)</span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Fprintf(w, response)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	response := getResource(r.Context())</span><br><span class="line">	fmt.Fprintf(w, response)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ts := httptest.NewServer(http.HandlerFunc(resourceFunc))</span><br><span class="line">	<span class="keyword">defer</span> ts.Close()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// you should always set these timeouts, otherwise requests</span></span><br><span class="line">	<span class="comment">// can never timeout</span></span><br><span class="line">	ts.Config.ReadTimeout = <span class="number">10</span> * time.Second</span><br><span class="line">	ts.Config.WriteTimeout = <span class="number">10</span> * time.Second</span><br><span class="line"></span><br><span class="line">	res, err := http.Get(ts.URL + <span class="string">"?index=2&amp;wait=15s"</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">	resourceResp, err := ioutil.ReadAll(res.Body)</span><br><span class="line">	res.Body.Close()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Printf(<span class="string">"%s\n"</span>, res.Status)</span><br><span class="line">	fmt.Printf(<span class="string">"%s"</span>, resourceResp)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当使用 Nginx 作为代理暴露这个服务时，问题由于下面一行代码变得麻烦起来：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ts.Config.WriteTimeout = <span class="number">10</span> * time.Second</span><br></pre></td></tr></table></figure>

<p>在我们最初的 API 的实现中，我们将服务端超时时间设置为了 10 秒，但是在我实现长轮询的时候我把超时时间设置为了 15 秒。这导致了 Nginx 偶发性地返回 502 错误。Nginx 会报出如下错误：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">upstream prematurely closed connection while reading response header from upstream</span><br></pre></td></tr></table></figure>

<p>最终发现，这个错误消息是准确的并且指向了确切的问题（go 由于超时时间到达关闭了请求，但是我的处理函数仍然在请求关闭后尝试去写入内容），但是在网上搜索的结果并没有提供太多帮助。最后，我断断续续花了一周时间跟踪调试直到确定是配置问题。WriteTimeout 最短也需要设置为与允许的长轮询等待时间一样长，在我们的场景中是 60 秒。<br>但愿其他陷入同样 Nginx 错误的人能够先再次检查他们的服务端超时时间设置。另外，可以查阅<a href="https://blog.cloudflare.com/the-complete-guide-to-golang-net-http-timeouts/" target="_blank" rel="external nofollow noopener noreferrer">这篇文章</a>关于 go 中各种服务端超时的详情。</p>
]]></content>
      <categories>
        <category>译文</category>
      </categories>
      <tags>
        <tag>译文</tag>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>Go 常用开源库</title>
    <url>/post/2ebf5f2a.html</url>
    <content><![CDATA[<h4 id="按列格式化输出-columnize"><a href="#按列格式化输出-columnize" class="headerlink" title="按列格式化输出 columnize"></a>按列格式化输出 columnize</h4><p><a href="http://github.com/ryanuber/columnize" target="_blank" rel="external nofollow noopener noreferrer">github.com/ryanuber/columnize</a></p><h4 id="命令行工具框架-cobra"><a href="#命令行工具框架-cobra" class="headerlink" title="命令行工具框架 cobra"></a>命令行工具框架 cobra</h4><p><a href="https://github.com/spf13/cobra" target="_blank" rel="external nofollow noopener noreferrer">github.com/spf13/cobra</a></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在子命令的 Run 函数执行前执行初始化任务</span></span><br><span class="line">cobra.OnInitialize(initConfig)</span><br></pre></td></tr></table></figure><h4 id="发送邮件"><a href="#发送邮件" class="headerlink" title="发送邮件"></a>发送邮件</h4><p><a href="https://github.com/scorredoira/email" target="_blank" rel="external nofollow noopener noreferrer">github.com/scorredoira/email</a></p><a id="more"></a>




<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 发送 HTML 格式的邮件</span></span><br><span class="line">m := email.NewHTMLMessage(subject, content)</span><br><span class="line"><span class="comment"># 添加附件</span></span><br><span class="line">m.AttachBuffer(attach.Filename, attach.Data, <span class="literal">false</span>)</span><br></pre></td></tr></table></figure>

<h4 id="从字符串解析-bytesize"><a href="#从字符串解析-bytesize" class="headerlink" title="从字符串解析 bytesize"></a>从字符串解析 bytesize</h4><p><a href="https://github.com/docker/go-units" target="_blank" rel="external nofollow noopener noreferrer">github.com/docker/go-units</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 从字符串解析出以字节为单位的大小</span></span><br><span class="line"> b, _ := units.RAMInBytes(<span class="string">"1m"</span>)</span><br><span class="line">fmt.Printf(<span class="string">"%d\n"</span>, uint64(b))</span><br><span class="line"> <span class="comment"># 从字符串解析出时间间隔</span></span><br><span class="line">duration, _ := time.ParseDuration(<span class="string">"1m"</span>)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>Go snippets</title>
    <url>/post/beea4a6b.html</url>
    <content><![CDATA[<h4 id="生成-csv-文件"><a href="#生成-csv-文件" class="headerlink" title="生成 csv 文件"></a>生成 csv 文件</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">file, err := os.OpenFile(<span class="string">"test.csv"</span>, os.O_CREATE|os.O_WRONLY, <span class="number">0777</span>)</span><br><span class="line"><span class="keyword">defer</span> file.Close()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">	os.Exit(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line">data := [][]<span class="keyword">string</span>&#123;&#123;<span class="string">"Line1"</span>, <span class="string">"Hello"</span>&#125;, &#123;<span class="string">"Line2"</span>, <span class="string">"World"</span>&#125;&#125;</span><br><span class="line">csvWriter := csv.NewWriter(file)</span><br><span class="line">csvWriter.WriteAll(data)</span><br><span class="line">csvWriter.Flush()</span><br><span class="line"></span><br><span class="line">dataBuf := bytes.NewBuffer(<span class="literal">nil</span>)</span><br><span class="line">writer := csv.NewWriter(dataBuf)</span><br><span class="line"><span class="keyword">for</span> _, str := <span class="keyword">range</span> data &#123;</span><br><span class="line">    writer.Write(str)</span><br><span class="line">&#125;</span><br><span class="line">writer.Flush()</span><br></pre></td></tr></table></figure><a id="more"></a>

<h4 id="结合使用-klog-和-cobra"><a href="#结合使用-klog-和-cobra" class="headerlink" title="结合使用 klog 和 cobra"></a>结合使用 klog 和 cobra</h4><p>一个更完整的模板：<a href="https://github.com/physcat/klog-cobra" target="_blank" rel="external nofollow noopener noreferrer">https://github.com/physcat/klog-cobra</a></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"flag"</span></span><br><span class="line">	<span class="string">"github.com/spf13/cobra"</span></span><br><span class="line">	<span class="string">"k8s.io/klog/v2"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewRootCmd</span><span class="params">()</span> *<span class="title">cobra</span>.<span class="title">Command</span></span> &#123;</span><br><span class="line">	globalConfig := config.GetGlobalConfig()</span><br><span class="line"></span><br><span class="line">	cmd := &amp;cobra.Command&#123;</span><br><span class="line">		Use:   <span class="string">"test"</span>,</span><br><span class="line">		Short: <span class="string">"\ntest"</span>,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	klog.InitFlags(<span class="literal">nil</span>)</span><br><span class="line">	cmd.PersistentFlags().AddGoFlagSet(flag.CommandLine)</span><br><span class="line"></span><br><span class="line">	cmd.AddCommand(newSubCmd())</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> cmd</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="从切片中删除元素"><a href="#从切片中删除元素" class="headerlink" title="从切片中删除元素"></a>从切片中删除元素</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 重新构造一个切片</span></span><br><span class="line">func deleteItem(strSlice []string, index int) []string &#123;</span><br><span class="line">	newSlice := []string&#123;&#125;</span><br><span class="line">	<span class="keyword">for</span> i, v := range strSlice &#123;</span><br><span class="line">		<span class="keyword">if</span> i != index &#123;</span><br><span class="line">			newSlice = append(newSlice, v)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">return</span> newSlice</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 使用最后一个元素覆盖欲删除的元素，破坏了顺序</span></span><br><span class="line">func deleteItem1(strSlice []string, index int) []string &#123;</span><br><span class="line">	strSlice[index] = strSlice[len(strSlice)-1]</span><br><span class="line">	<span class="built_in">return</span> strSlice[:len(strSlice)-1]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 将待删除元素之后的元素整体向前平移一个位置</span></span><br><span class="line">func deleteItem2(strSlice []string, index int) []string &#123;</span><br><span class="line">	copy(strSlice[index:len(strSlice)-1], strSlice[index+1:])</span><br><span class="line">	<span class="built_in">return</span> strSlice[:len(strSlice)-1]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="生成-UUID"><a href="#生成-UUID" class="headerlink" title="生成 UUID"></a>生成 UUID</h4><p>一种是使用开源库：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"github.com/google/uuid"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    guid := uuid.New()</span><br><span class="line">    fmt.Println(guid)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一种是直接读取随机数生成 uuid：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"math/rand"</span></span><br><span class="line">	<span class="string">"encoding/hex"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"># 生成的不是标准 UUID，但思路是一样的，第一种方法底层也是类似实现</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">uuid</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	u := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">16</span>)</span><br><span class="line">	_, err := rand.Read(u)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">""</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	u[<span class="number">8</span>] = (u[<span class="number">8</span>] | <span class="number">0x80</span>) &amp; <span class="number">0xBF</span></span><br><span class="line">	u[<span class="number">6</span>] = (u[<span class="number">6</span>] | <span class="number">0x40</span>) &amp; <span class="number">0x4F</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> hex.EncodeToString(u)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(uuid())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一种是调用系统的 uuidgen 工具：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">    <span class="string">"os/exec"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    out, err := exec.Command(<span class="string">"uuidgen"</span>).Output()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">"%s \n"</span>, out)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="检查字符串是否符合-base64-编码"><a href="#检查字符串是否符合-base64-编码" class="headerlink" title="检查字符串是否符合 base64 编码"></a>检查字符串是否符合 base64 编码</h4><p>参考：<a href="https://stackoverflow.com/questions/8571501/how-to-check-whether-a-string-is-base64-encoded-or-not" target="_blank" rel="external nofollow noopener noreferrer">https://stackoverflow.com/questions/8571501/how-to-check-whether-a-string-is-base64-encoded-or-not</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">func CheckValidBase64(src string) bool &#123;</span><br><span class="line">	matched, _ := regexp.Match(`^([A-Za-z0-9+/]&#123;4&#125;)*([A-Za-z0-9+/]&#123;3&#125;=|[A-Za-z0-9+/]&#123;2&#125;==)?$`, []byte(src))</span><br><span class="line">	<span class="built_in">return</span> matched</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="检查环境变量是否存在"><a href="#检查环境变量是否存在" class="headerlink" title="检查环境变量是否存在"></a>检查环境变量是否存在</h4><p>一般情况下，我们只需要获取环境变量的值，所以使用  <code>username := os.Getenv(&quot;USERNAME&quot;)</code> 即可，当获取到的值为空时，有可能环境变量存在且值为空，也有可能环境变量并不存在，若我们需要知道到底是哪种情况，则可使用 <code>path, exists := os.LookupEnv(&quot;PATH&quot;)</code> 返回的布尔值进行判断。</p>
<h4 id="HTTP-Response-Status"><a href="#HTTP-Response-Status" class="headerlink" title="HTTP Response Status"></a>HTTP Response Status</h4><p>有两种标准写法可用：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// WriteHeader 用以返回指定状态码的 http 响应。如果在调用 Write 方法前没有显式指定状态码，</span></span><br><span class="line"><span class="comment">// 则第一次调用 Write 时会触发一个隐式的设定状态码操作 WriteHeader(http.StatusOK)。因此，</span></span><br><span class="line"><span class="comment">// 一般不需要显式去设置状态码，大多数情况下只是在出现错误时显式调用 WriteHeader 用以返回错误</span></span><br><span class="line"><span class="comment">// 状态。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ServeHTTP</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    w.WriteHeader(http.StatusInternalServerError)</span><br><span class="line">    w.Write([]<span class="keyword">byte</span>(<span class="string">"500 - Something bad happened!"</span>))</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 另一种写法,其实也是调用了 WriteHeader 方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">yourFuncHandler</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    http.Error(w, <span class="string">"my own error message"</span>, http.StatusForbidden)</span><br><span class="line">    <span class="comment">// or using the default message error</span></span><br><span class="line">    http.Error(w, http.StatusText(http.StatusNotFound), http.StatusNotFound)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="获取变量类型"><a href="#获取变量类型" class="headerlink" title="获取变量类型"></a>获取变量类型</h4><ul>
<li>fmt</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    v := <span class="string">"hello world"</span></span><br><span class="line">    fmt.Println(typeof(v))</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">typeof</span><span class="params">(v <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fmt.Sprintf(<span class="string">"%T"</span>, v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>reflect</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"reflect"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    v := <span class="string">"hello world"</span></span><br><span class="line">    fmt.Println(typeof(v))</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">typeof</span><span class="params">(v <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> reflect.TypeOf(v).String()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><a href="https://golang.org/ref/spec#Type_assertions" target="_blank" rel="external nofollow noopener noreferrer">类型断言</a></li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    v := <span class="string">"hello world"</span></span><br><span class="line">    fmt.Println(typeof(v))</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">typeof</span><span class="params">(v <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> t := v.(<span class="keyword">type</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">int</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"int"</span></span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">float64</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"float64"</span></span><br><span class="line">    <span class="comment">//... etc</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        _ = t</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"unknown"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实前两个都是用了反射，fmt.Printf (“% T”) 里最终调用的还是 <code>reflect.TypeOf()</code>。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *pp)</span> <span class="title">printArg</span><span class="params">(arg <span class="keyword">interface</span>&#123;&#125;, verb <span class="keyword">rune</span>)</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">	<span class="comment">// Special processing considerations.</span></span><br><span class="line">	<span class="comment">// %T (the value's type) and %p (its address) are special; we always do them first.</span></span><br><span class="line">	<span class="keyword">switch</span> verb &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">'T'</span>:</span><br><span class="line">		p.fmt.fmt_s(reflect.TypeOf(arg).String())</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	<span class="keyword">case</span> <span class="string">'p'</span>:</span><br><span class="line">		p.fmtPointer(reflect.ValueOf(arg), <span class="string">'p'</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>reflect.TypeOf () 的参数是 <code>v interface{}</code>，golang 的反射是怎么做到的呢？在 golang 中，interface 也是一个结构体，记录了 2 个指针：</p>
<ul>
<li>指针 1，指向该变量的类型</li>
<li>指针 2，指向该变量的 value</li>
</ul>
<h4 id="获取变量地址"><a href="#获取变量地址" class="headerlink" title="获取变量地址"></a>获取变量地址</h4><p>输入：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"reflect"</span></span><br><span class="line">	<span class="string">"unsafe"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	intarr := [<span class="number">5</span>]<span class="keyword">int</span>&#123;<span class="number">12</span>, <span class="number">34</span>, <span class="number">55</span>, <span class="number">66</span>, <span class="number">43</span>&#125;</span><br><span class="line">	slice := intarr[:]</span><br><span class="line">	fmt.Printf(<span class="string">"the len is %d and cap is %d \n"</span>, <span class="built_in">len</span>(slice), <span class="built_in">cap</span>(slice))</span><br><span class="line">	fmt.Printf(<span class="string">"%p   %p   %p   %p\n"</span>, &amp;slice[<span class="number">0</span>], &amp;intarr, slice, &amp;slice)</span><br><span class="line">	fmt.Printf(<span class="string">"underlay: %#x\n"</span>, (*reflect.SliceHeader)(unsafe.Pointer(&amp;slice)).Data)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">the len is 5 and cap is 5</span><br><span class="line">0x456000   0x456000   0x456000   0x40a0e0</span><br><span class="line">underlay: 0x456000</span><br></pre></td></tr></table></figure>

<h4 id="按行读取文本"><a href="#按行读取文本" class="headerlink" title="按行读取文本"></a>按行读取文本</h4><p>如果是对一个多行的字符串按行读取，则可以：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> _, line := <span class="keyword">range</span> strings.Split(strings.TrimSuffix(x, <span class="string">"\n"</span>), <span class="string">"\n"</span>) &#123;</span><br><span class="line">    fmt.Println(line)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果是从文件或者流式管道中按行读取，则可以：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">scanner := bufio.NewScanner(f) <span class="comment">// f is the *os.File</span></span><br><span class="line"><span class="keyword">for</span> scanner.Scan() &#123;</span><br><span class="line">    fmt.Println(scanner.Text()) <span class="comment">// Println will add back the final '\n'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err := scanner.Err(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">   <span class="comment">// handle error</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 另一个例子</span></span><br><span class="line">args := <span class="string">"-E -eNEW,DESTROY -ptcp --any-nat --buffer-size 1024000 --dport "</span> + fmt.Sprintf(<span class="string">"%d"</span>, serviceNodePort)</span><br><span class="line">cmd := exec.Command(<span class="string">"conntrack"</span>, strings.Split(args, <span class="string">" "</span>)...)</span><br><span class="line"></span><br><span class="line">stdout, _ := cmd.StdoutPipe()</span><br><span class="line">err := cmd.Start()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    common.ZapClient.Fatalf(<span class="string">"start conntrack failed: %s"</span>, err.Error())</span><br><span class="line">    errChan &lt;- err</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">scanner := bufio.NewScanner(stdout)</span><br><span class="line"><span class="keyword">for</span> scanner.Scan() &#123;&#125;</span><br></pre></td></tr></table></figure>

<h4 id="从-http-request-body-中解析出-go-对象"><a href="#从-http-request-body-中解析出-go-对象" class="headerlink" title="从 http request body 中解析出 go 对象"></a>从 http request body 中解析出 go 对象</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> info MyLocalType</span><br><span class="line">data, err := ioutil.ReadAll(req.Body)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    w.WriteHeader(http.StatusBadRequest)</span><br><span class="line">    w.Write([]<span class="keyword">byte</span>(<span class="string">"read data from request body failed!"</span>))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err = json.Unmarshal(data, &amp;info); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    w.WriteHeader(http.StatusBadRequest)</span><br><span class="line">    w.Write([]<span class="keyword">byte</span>(<span class="string">"parse info from request body failed!"</span>))</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 简单点的</span></span><br><span class="line"><span class="keyword">if</span> err := json.NewDecoder(req.Body).Decode(&amp;info); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    w.WriteHeader(http.StatusBadRequest)</span><br><span class="line">    w.Write([]<span class="keyword">byte</span>(<span class="string">"parse info from request body failed!"</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="从静态文件生成-go-code-并-serve"><a href="#从静态文件生成-go-code-并-serve" class="headerlink" title="从静态文件生成 go code 并 serve"></a>从静态文件生成 go code 并 serve</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 使用两个开源库</span><br><span class="line">go get github.com/jteeuwen/go-bindata</span><br><span class="line">go get github.com/elazarl/go-bindata-assetfs</span><br><span class="line"></span><br><span class="line">// 从本地目录生成 go code</span><br><span class="line">// 会在当前目录生成 bindata.go</span><br><span class="line">go-bindata-assetfs swagger-ui/</span><br></pre></td></tr></table></figure>

<p>之后就可以使用该文件创建一个 http 静态站点：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这里以 swagger-ui 编译之后的文件为例</span></span><br><span class="line"><span class="comment">// 假设生成的 go 代码所属包名为 swagger</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"log"</span></span><br><span class="line">	<span class="string">"net/http"</span></span><br><span class="line"></span><br><span class="line">	<span class="string">"github.com/elazarl/go-bindata-assetfs"</span></span><br><span class="line">  	<span class="string">"fake.local.com/test/swagger"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// FileServer 会自动尝试获取目录下的 index.html 文件返回给用户</span></span><br><span class="line"><span class="comment">// 从而使得一个静态站点能够正常工作</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// Use binary asset FileServer</span></span><br><span class="line">	http.Handle(<span class="string">"/"</span>,</span><br><span class="line">		http.FileServer(&amp;assetfs.AssetFS&#123;</span><br><span class="line">		Asset:    swagger.Asset,</span><br><span class="line">		AssetDir: swagger.AssetDir,</span><br><span class="line">		Prefix:   <span class="string">"swagger-ui"</span>,</span><br><span class="line">	&#125;))</span><br><span class="line"></span><br><span class="line">	log.Println(<span class="string">"http server started on :8000"</span>)</span><br><span class="line">	err := http.ListenAndServe(<span class="string">":8000"</span>, <span class="literal">nil</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(<span class="string">"ListenAndServe: "</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="生成-zip-文件并返回给-http-response"><a href="#生成-zip-文件并返回给-http-response" class="headerlink" title="生成 zip 文件并返回给 http response"></a>生成 zip 文件并返回给 http response</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">zipHandler</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    filename := <span class="string">"randomfile.jpg"</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// var buf bytes.Buffer</span></span><br><span class="line">    <span class="comment">// 直接声明一个 buffer 即可用，buffer 开箱即用是因为当调用 Write 写入内容时会自动判断</span></span><br><span class="line">    <span class="comment">// 底层切片是否为 nil，如果为 nil 则会分配一个容量为 smallBufferSize = 64 ,长度</span></span><br><span class="line">    <span class="comment">// 为待写入切片的长度 n （如果满足 n &lt; smallBufferSize，否则转入其它处理逻辑）</span></span><br><span class="line">    buf := <span class="built_in">new</span>(bytes.Buffer)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其实没有必要使用 Buffer ，可以直接使用 w，如下：</span></span><br><span class="line">    <span class="comment">// writer := zip.NewWriter(w)</span></span><br><span class="line">    <span class="comment">// 因为 net/http 内部类型 *response 实现了 http.ResponseWriter ，而 reponse 内部</span></span><br><span class="line">    <span class="comment">// 使用的 bufferio.Writer 本身就已经有缓冲区</span></span><br><span class="line">    writer := zip.NewWriter(buf)</span><br><span class="line"></span><br><span class="line">    data, err := ioutil.ReadFile(filename)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    f, err := writer.Create(filename)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    _, err = f.Write([]<span class="keyword">byte</span>(data))</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    err = writer.Close()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 实测可以使用 w.Header().Set("Content-Type", "application/octet-stream")</span></span><br><span class="line">    w.Header().Set(<span class="string">"Content-Type"</span>, <span class="string">"application/zip"</span>)</span><br><span class="line">    w.Header().Set(<span class="string">"Content-Disposition"</span>, fmt.Sprintf(<span class="string">"attachment; filename=\"%s.zip\""</span>, filename))</span><br><span class="line">    <span class="comment">//io.Copy(w, buf)</span></span><br><span class="line">    w.Write(buf.Bytes())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另一种简单的写法：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handleZip</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    f, err := os.Open(<span class="string">"main.go"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> err := f.Close(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            log.Fatal(err)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// write straight to the http.ResponseWriter</span></span><br><span class="line">    zw := zip.NewWriter(w)</span><br><span class="line">    cf, err := zw.Create(f.Name())</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    w.Header().Set(<span class="string">"Content-Type"</span>, <span class="string">"application/zip"</span>)</span><br><span class="line">    w.Header().Set(<span class="string">"Content-Disposition"</span>, fmt.Sprintf(<span class="string">"attachment; filename=\"%s.zip\""</span>, f.Name()))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// copy the file contents to the zip Writer</span></span><br><span class="line">    _, err = io.Copy(cf, f)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// close the zip Writer to flush the contents to the ResponseWriter</span></span><br><span class="line">    err = zw.Close()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h4><p>在 Go 语言中可以很方便地构建反向代理服务器：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Serve a reverse proxy for a given url</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">serveReverseProxy</span><span class="params">(target <span class="keyword">string</span>, res http.ResponseWriter, req *http.Request)</span></span> &#123;</span><br><span class="line">	<span class="comment">// parse the url</span></span><br><span class="line">	url, _ := url.Parse(target)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// create the reverse proxy</span></span><br><span class="line">	proxy := httputil.NewSingleHostReverseProxy(url)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Update the headers to allow for SSL redirection</span></span><br><span class="line">	req.URL.Host = url.Host</span><br><span class="line">	req.URL.Scheme = url.Scheme</span><br><span class="line">	req.Header.Set(<span class="string">"X-Forwarded-Host"</span>, req.Header.Get(<span class="string">"Host"</span>))</span><br><span class="line">	req.Host = url.Host</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Note that ServeHttp is non blocking and uses a go routine under the hood</span></span><br><span class="line">	proxy.ServeHTTP(res, req)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="写入文件"><a href="#写入文件" class="headerlink" title="写入文件"></a>写入文件</h4><p>当待写入的文件已经存在时，应该以可写模式打开它进行写入；当待写入文件不存在时，应该创建该文件并进行写入。直觉上，我们应当首先判断文件是否存在，可以使用如下代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> _, err := os.Stat(<span class="string">"/path/to/whatever"</span>); os.IsNotExist(err) &#123;</span><br><span class="line">  <span class="comment">// path/to/whatever does not exist</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过跟踪 <code>os.IsNotExist</code> 函数的实现可以发现，它主要处理两类错误： <code>os.ErrNotExist</code> 和 <code>syscall.ENOENT</code> ，也就是只有这两种错误才会使得 <code>os.IsNotExist(err)</code> 返回 <code>true</code>。实际上，仅仅这两种错误是无法确定文件是不存在的，有时 <code>os.Stat</code> 返回 <code>ENOTDIR</code> 而不是  <code>ENOENT</code> ，例如，如果 <code>/etc/bashrc</code> 文件存在，则使用 <code>os.Stat</code> 检查 <code>/etc/bashrc/foobar</code> 是否存在时会返回 <code>ENOTDIR</code> 错误表明 <code>/etc/bashrc</code> 不是一个目录，因此上述写法是有问题的。实际上使用 <code>os.Stat</code> 的可能结果如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> _, err := os.Stat(<span class="string">"/path/to/whatever"</span>); err == <span class="literal">nil</span> &#123;</span><br><span class="line">  <span class="comment">// path/to/whatever exists</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> os.IsNotExist(err) &#123;</span><br><span class="line">  <span class="comment">// path/to/whatever does *not* exist</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// Schrodinger: file may or may not exist. See err for details.</span></span><br><span class="line">  <span class="comment">// Therefore, do *NOT* use !os.IsNotExist(err) to test for file existence</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也就是说使用 <code>os.Stat</code> 无法确定文件是否存在，因此写入文件时先使用 <code>os.Stat</code> 判断文件是否存在，不存在时则使用 <code>os.Create</code> 创建文件的写法是错误的（尽管大多数时候能够成功写入）。正确的写入文件的方法是 <code>os.OpenFile(path, os.O_RDWR|os.O_CREATE, 0666)</code> ，这个函数通过 sys_openat 系统调用依据传入的 Flag 打开文件，如果文件不存在则创建，如果文件存在则直接打开，使用这个函数的另一个好处是不会产生竞争条件（即使另外一个操作正在创建该文件？），参见 <a href="https://stackoverflow.com/questions/12518876/how-to-check-if-a-file-exists-in-go" target="_blank" rel="external nofollow noopener noreferrer">https://stackoverflow.com/questions/12518876/how-to-check-if-a-file-exists-in-go</a> 中的一系列回答和讨论。<br>另一种选择是使用 <code>ioutil.WriteFile()</code> ，其内部同样是调用了 <code>os.OpenFile</code>，只不过只适用于一次性全量写入。</p>
<h4 id="监听系统信号实现优雅退出"><a href="#监听系统信号实现优雅退出" class="headerlink" title="监听系统信号实现优雅退出"></a>监听系统信号实现优雅退出</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ctx, cancel := context.WithCancel(context.Background())</span><br><span class="line">sigc := <span class="built_in">make</span>(<span class="keyword">chan</span> os.Signal, <span class="number">1</span>)</span><br><span class="line">signal.Notify(sigc, syscall.SIGHUP, syscall.SIGINT, syscall.SIGTERM, syscall.SIGQUIT)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">	&lt;-sigc</span><br><span class="line">	cancel()</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure>

<h4 id="流式下载并保存文件"><a href="#流式下载并保存文件" class="headerlink" title="流式下载并保存文件"></a>流式下载并保存文件</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (<span class="string">"net/http"</span>; <span class="string">"io"</span>; <span class="string">"os"</span>)</span><br><span class="line">...</span><br><span class="line">out, err := os.Create(<span class="string">"output.txt"</span>)</span><br><span class="line"><span class="keyword">defer</span> out.Close()</span><br><span class="line">...</span><br><span class="line">resp, err := http.Get(<span class="string">"http://example.com/"</span>)</span><br><span class="line"><span class="keyword">defer</span> resp.Body.Close()</span><br><span class="line">...</span><br><span class="line">n, err := io.Copy(out, resp.Body)</span><br></pre></td></tr></table></figure>

<h4 id="打印-context-中的键值对"><a href="#打印-context-中的键值对" class="headerlink" title="打印 context 中的键值对"></a>打印 context 中的键值对</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PrintContextInternals</span><span class="params">(ctx <span class="keyword">interface</span>&#123;&#125;, inner <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">	contextValues := reflect.ValueOf(ctx).Elem()</span><br><span class="line">	contextKeys := reflect.TypeOf(ctx).Elem()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> !inner &#123;</span><br><span class="line">		fmt.Printf(<span class="string">"\nFields for %s.%s\n"</span>, contextKeys.PkgPath(), contextKeys.Name())</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> contextKeys.Kind() == reflect.Struct &#123;</span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; contextValues.NumField(); i++ &#123;</span><br><span class="line">			reflectValue := contextValues.Field(i)</span><br><span class="line">			reflectValue = reflect.NewAt(reflectValue.Type(), unsafe.Pointer(reflectValue.UnsafeAddr())).Elem()</span><br><span class="line"></span><br><span class="line">			reflectField := contextKeys.Field(i)</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> reflectField.Name == <span class="string">"Context"</span> &#123;</span><br><span class="line">				PrintContextInternals(reflectValue.Interface(), <span class="literal">true</span>)</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				fmt.Printf(<span class="string">"field name: %+v\n"</span>, reflectField.Name)</span><br><span class="line">				fmt.Printf(<span class="string">"value: %+v\n"</span>, reflectValue.Interface())</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">"context is empty (int)\n"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="对耗时操作添加超时处理"><a href="#对耗时操作添加超时处理" class="headerlink" title="对耗时操作添加超时处理"></a>对耗时操作添加超时处理</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    errChan := <span class="built_in">make</span>(<span class="keyword">chan</span> error, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        _, err := doSomethingNeedLongTime()</span><br><span class="line">        errChan &lt;- err</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> &lt;-time.After(<span class="number">10</span> * time.Second):</span><br><span class="line">            log.Error(<span class="string">"timeout"</span>)</span><br><span class="line">            state.Set(fail)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">case</span> err := &lt;-errChan:</span><br><span class="line">            <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                log.Error(<span class="string">"error"</span>)</span><br><span class="line">                state.Set(fail)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            state.Set(success)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure>

<h4 id="封装-Reader-为-ReadCloser"><a href="#封装-Reader-为-ReadCloser" class="headerlink" title="封装 Reader 为 ReadCloser"></a>封装 Reader 为 ReadCloser</h4><p>如果确定 Reader 不需要进行真实的关闭操作，而接口又需要传入一个 ReadCloser，则可以使用以下方法进行简单封装：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">stringReader := strings.NewReader(<span class="string">"shiny!"</span>)</span><br><span class="line">stringReadCloser := io.NopCloser(stringReader)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>Go 开发与调试工具与方法</title>
    <url>/post/a36d54e2.html</url>
    <content><![CDATA[<h4 id="staticcheck"><a href="#staticcheck" class="headerlink" title="staticcheck"></a>staticcheck</h4><p>可用于代码静态检查，发现未被使用的变量、类型和函数等，以及不规范的代码：<a href="https://github.com/dominikh/go-tools" target="_blank" rel="external nofollow noopener noreferrer">https://github.com/dominikh/go-tools</a>。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">staticcheck --unused.whole-program&#x3D;true -- .&#x2F;...</span><br></pre></td></tr></table></figure><h4 id="在-VSCode-中以-root-权限进行-debug"><a href="#在-VSCode-中以-root-权限进行-debug" class="headerlink" title="在 VSCode 中以 root 权限进行 debug"></a>在 VSCode 中以 root 权限进行 debug</h4><a id="more"></a>


<p><a href="https://fatdragon.me/blog/2020/06/debug-golang-vs-code-linux-root" target="_blank" rel="external nofollow noopener noreferrer">Debug Golang in VS Code in Linux as root</a></p>
<h4 id="查看编译二进制文件使用的-Go-版本"><a href="#查看编译二进制文件使用的-Go-版本" class="headerlink" title="查看编译二进制文件使用的 Go 版本"></a>查看编译二进制文件使用的 Go 版本</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go version /usr/<span class="built_in">local</span>/bin/kubelet</span><br><span class="line">// 或者</span><br><span class="line">strings /usr/<span class="built_in">local</span>/bin/kubelet | grep <span class="string">'go1\.'</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>Go 测试相关</title>
    <url>/post/f918c9e0.html</url>
    <content><![CDATA[<h4 id="单测中-Mock-数据库"><a href="#单测中-Mock-数据库" class="headerlink" title="单测中 Mock 数据库"></a>单测中 Mock 数据库</h4><p>Mock 数据库大概有以下几种方式：</p><ol>
<li>用容器部署一个真实的数据库实例，前提是 CI 平台能够支持。</li>
<li>提供数据库驱动包的第三方库同时提供了 mock 包。</li>
<li>数据库驱动以 interface 而不是 struct 的形式提供功能 API，则可以基于 interface 编写 mock，此时可以在 mock 的结构体中嵌入数据库驱动 interface ，从而只 mock 使用到的相关接口，而不是全部。</li>
<li>如果数据库驱动直接通过 struct 提供功能 API，则应当在使用数据库驱动时封装一层 DAO interface，之后依据 DAO interface 编写 mock 代码，实际上增加一层 DAO 并没有带来特别的收益，除非后续有切换数据库的可能，否则也只是方便进行 mock 测试，在现代编程中，层层封装过于泛滥。</li>
<li>如果单测实现特别困难，则需考虑是不是应该在集成测试中对目标功能进行测试。</li>
</ol><a id="more"></a>

<h4 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 通过不同颜色更清晰显示测试结果</span><br><span class="line">go get -u github.com/rakyll/gotest</span><br><span class="line">// 根据前缀匹配测试用例</span><br><span class="line">gotest -v -run TestHelloE</span><br><span class="line">// 指定测试文件</span><br><span class="line">go <span class="built_in">test</span> -v hello_test.go</span><br><span class="line">// 输出测试覆盖率</span><br><span class="line">go <span class="built_in">test</span> -cover</span><br><span class="line">gp <span class="built_in">test</span> -coverprofile=cover.txt</span><br><span class="line">// 转换为 html</span><br><span class="line">go tool cover -html=cover.txt -o /tmp/cover.html</span><br><span class="line">// 测试当前目录及子目录下所有 package</span><br><span class="line">go <span class="built_in">test</span> ./...</span><br><span class="line">// 测试当前目录下 package</span><br><span class="line">go <span class="built_in">test</span> .</span><br><span class="line">// 打印测试信息</span><br><span class="line">t.Log(<span class="string">"hi"</span>)</span><br><span class="line">// go <span class="built_in">test</span> 会自动多线程执行测试用例</span><br><span class="line">// 有时候涉及到数据库操作的用例可能希望单线程执行</span><br><span class="line">go <span class="built_in">test</span> -p 1 ./...</span><br></pre></td></tr></table></figure>

<h4 id="自动生成-mock-代码"><a href="#自动生成-mock-代码" class="headerlink" title="自动生成 mock 代码"></a>自动生成 mock 代码</h4><p><a href="https://github.com/vektra/mockery" target="_blank" rel="external nofollow noopener noreferrer">https://github.com/vektra/mockery</a></p>
<h4 id="nolint-忽略部分代码的-lint"><a href="#nolint-忽略部分代码的-lint" class="headerlink" title="nolint 忽略部分代码的 lint"></a>nolint 忽略部分代码的 lint</h4><p><a href="https://golangci-lint.run/usage/false-positives/" target="_blank" rel="external nofollow noopener noreferrer">https://golangci-lint.run/usage/false-positives/</a></p>
<h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ol>
<li><a href="https://betterprogramming.pub/unit-testing-code-using-the-mongo-go-driver-in-golang-7166d1aa72c0" target="_blank" rel="external nofollow noopener noreferrer">https://betterprogramming.pub/unit-testing-code-using-the-mongo-go-driver-in-golang-7166d1aa72c0</a></li>
<li><a href="https://medium.com/rungo/unit-testing-made-easy-in-go-25077669318" target="_blank" rel="external nofollow noopener noreferrer">https://medium.com/rungo/unit-testing-made-easy-in-go-25077669318</a></li>
<li><a href="https://adrianhesketh.com/2020/02/21/mocking-aws-sdk-calls-in-go/" target="_blank" rel="external nofollow noopener noreferrer">https://adrianhesketh.com/2020/02/21/mocking-aws-sdk-calls-in-go/</a></li>
</ol>
]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>测试</tag>
      </tags>
  </entry>
  <entry>
    <title>Go 的一些为什么</title>
    <url>/post/7dd960ec.html</url>
    <content><![CDATA[<h4 id="调度器为什么引入-P"><a href="#调度器为什么引入-P" class="headerlink" title="调度器为什么引入 P"></a>调度器为什么引入 P</h4><p>将原先与 M 相绑定的资源（比如 mcache）转移给 P，减少内存浪费；将全局状态（如 grunnable 队列）分解给 P，减少锁的争用，提高调度效率。参考：<a href="https://www.zhihu.com/question/63906375/answer/496840262" target="_blank" rel="external nofollow noopener noreferrer">goroutine 调度过程中 P 到底扮演什么角色？</a></p>]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>Go 整洁架构实践</title>
    <url>/post/6ff15df0.html</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th align="center">Date</th>
<th align="center">Log</th>
</tr>
</thead>
<tbody><tr>
<td align="center">17/09/2018</td>
<td align="center">初始版本.</td>
</tr>
</tbody></table><h3 id="原文"><a href="#原文" class="headerlink" title="原文"></a>原文</h3><p><a href="https://medium.com/@hatajoe/clean-architecture-in-go-4030f11ec1b1" target="_blank" rel="external nofollow noopener noreferrer">Clean Architecture in Go</a></p><p>本文讲述了一个使用 Go 和 gRPC 实践整洁架构的案例。</p><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>整洁架构现在已为人熟知，但是很多人可能并不了解如何去实现。本文尝试使用 Go 和 Grpc 提供一种清晰明了的实现方法。文中案例源码已放在<a href="https://github.com/hatajoe/8am" target="_blank" rel="external nofollow noopener noreferrer">基站</a>，这个小项目演示了用户注册业务的实现，有任何问题可以随时反馈。</p><a id="more"></a>



<h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p>8am 基于整洁架构，其目录结构如下:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">%</span><span class="bash"> tree</span></span><br><span class="line">.</span><br><span class="line">├── Makefile</span><br><span class="line">├── README.md</span><br><span class="line">├── app</span><br><span class="line">│   ├── domain</span><br><span class="line">│   │   ├── model</span><br><span class="line">│   │   ├── repository</span><br><span class="line">│   │   └── service</span><br><span class="line">│   ├── interface</span><br><span class="line">│   │   ├── persistence</span><br><span class="line">│   │   └── rpc</span><br><span class="line">│   ├── registry</span><br><span class="line">│   └── usecase</span><br><span class="line">├── cmd</span><br><span class="line">│   └── 8am</span><br><span class="line">│       └── main.go</span><br><span class="line">└── vendor</span><br><span class="line">    ├── vendor packages</span><br><span class="line">    |...</span><br></pre></td></tr></table></figure>

<p>顶级目录包含了三个子目录，分别是：</p>
<ul>
<li>app ： 应用包根目录</li>
<li>cmd：main 包目录</li>
<li>vendor ：第三方包目录</li>
</ul>
<p>整洁架构的概念分层如下图所示：<br><img src="https://cdn.nlark.com/yuque/0/2019/png/182657/1575442901636-ce111580-647a-485d-adfd-bed678fc98ee.png#align=left&display=inline&height=567&margin=%5Bobject%20Object%5D&name=image.png&originHeight=567&originWidth=772&size=383132&status=done&style=none&width=772" alt="image.png"><br>整个架构共有四层，从外到内依次为蓝绿红黄层，除了作为应用目录的蓝色层，其余各层分别表示了：</p>
<ul>
<li>interface: 绿色层</li>
<li>usercase: 红色层</li>
<li>domain: 黄色层</li>
</ul>
<p>整洁架构的核心就是在各层之间构建接口。</p>
<h3 id="实体层-黄色层"><a href="#实体层-黄色层" class="headerlink" title="实体层-黄色层"></a>实体层-黄色层</h3><p>在作者看来，实体层和领域层在分层架构中的含义是类似的。这里称之为领域层是为了避免和 DDD 中实体的概念混淆。</p>
<p>领域层包含三个包：</p>
<ul>
<li>model: 具有聚合，实体和值对象</li>
<li>repository: 具有聚合的存储库接口</li>
<li>service: 具有依赖于多个模型的应用程序服务</li>
</ul>
<p>下面介绍各个包的实现细节：</p>
<h4 id="model"><a href="#model" class="headerlink" title="model"></a>model</h4><p>model 描述的用户聚合如下：</p>
<blockquote>
<p>这实际上还不是一个聚合，在这里视为聚合的前提是未来还会添加更多实体和值对象。</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> model</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">	id    <span class="keyword">string</span></span><br><span class="line">	email <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewUser</span><span class="params">(id, email <span class="keyword">string</span>)</span> *<span class="title">User</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;User&#123;</span><br><span class="line">		id:    id,</span><br><span class="line">		email: email,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u *User)</span> <span class="title">GetID</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> u.id</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u *User)</span> <span class="title">GetEmail</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> u.email</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>聚合是事务的边界，用以保持业务规则的一致性。因此，需要有一个仓储对应一个聚合。</p>
<h4 id="repository"><a href="#repository" class="headerlink" title="repository"></a>repository</h4><p>repository 只负责提供实体集合的操作接口而不必关心持久化的具体实现。其代码实现如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> repository</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"github.com/hatajoe/8am/app/domain/model"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> UserRepository <span class="keyword">interface</span> &#123;</span><br><span class="line">	FindAll() ([]*model.User, error)</span><br><span class="line">        FindByEmail(email <span class="keyword">string</span>) (*model.User, error)</span><br><span class="line">        Save(*model.User) error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>FindAll 方法获取所有存储在系统中的用户。Save 方法保存用户。再次强调，该层不应该获知对象是怎样被存储或序列化的。</p>
<h4 id="service"><a href="#service" class="headerlink" title="service"></a>service</h4><p>service 由各种业务逻辑组成。业务逻辑不应该包含在 model 中。例如，应用不允许已经存在的邮箱重复进行注册。如果把校验逻辑放在 model 中，会感到很别扭，如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u *User)</span> <span class="title">Duplicated</span><span class="params">(email <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">        <span class="comment">// Find user by email from persistence layer...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Duplicated function 实际上和 User 模型是无关的。<br>为了解决这个问题，我们可以添加如下的服务层：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> UserService <span class="keyword">struct</span> &#123;</span><br><span class="line">        repo repository.UserRepository</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *UserService)</span> <span class="title">Duplicated</span><span class="params">(email <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">        user, err := s.repo.FindByEmail(email)</span><br><span class="line">        <span class="keyword">if</span> user != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> fmt.Errorf(<span class="string">"%s already exists"</span>, email)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> err</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实体层包含业务逻辑以及与其它层的接口。业务逻辑仅应涉及 model 和 service， 而不应该依赖于其它任何层级。如果需要访问其它层，则应当使用 repository 穿透层级。通过这种依赖倒置的形式，各个包之间会有更好的隔离性，并且更方便测试和维护。</p>
<h3 id="用例层-红色层"><a href="#用例层-红色层" class="headerlink" title="用例层-红色层"></a>用例层-红色层</h3><p>用例指的是应用的单一可操作单元。在该项目中， 获取用户列表和注册新用户被定义为用例。这些用例使用如下接口表示：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> UserUsecase <span class="keyword">interface</span> &#123;</span><br><span class="line">    ListUser() ([]*User, error)</span><br><span class="line">    RegisterUser(email <span class="keyword">string</span>) error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为什么使用接口表示呢？这是因为用例将会被接口层（绿色层）使用。跨越层级的操作应通过定义的接口完成。</p>
<p>UserUsecase 的简单实现如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> userUsecase <span class="keyword">struct</span> &#123;</span><br><span class="line">    repo    repository.UserRepository</span><br><span class="line">    service *service.UserService</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewUserUsecase</span><span class="params">(repo repository.UserRepository, service *service.UserService)</span> *<span class="title">userUsecase</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;userUsecase &#123;</span><br><span class="line">        repo:    repo,</span><br><span class="line">        service: service,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u *userUsecase)</span> <span class="title">ListUser</span><span class="params">()</span> <span class="params">([]*User, error)</span></span> &#123;</span><br><span class="line">    users, err := u.repo.FindAll()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> toUser(users), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u *userUsecase)</span> <span class="title">RegisterUser</span><span class="params">(email <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    uid, err := uuid.NewRandom()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> err := u.service.Duplicated(email); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    user := model.NewUser(uid.String(), email)</span><br><span class="line">    <span class="keyword">if</span> err := u.repo.Save(user); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>userUsercase 依赖两个包： repository.UserRepository 接口 和 *service.UserService 结构。这两个包必须在用例初始化的时候由用例使用者进行注入。这些依赖关系通常由依赖注入容器解决，文中后面将会提及。ListUser 会获取所有已注册用户，RegisterUser 会将注册邮箱未重复的用户注册到系统中。</p>
<p>有一点要指出，这里的 User 并不是 model.User。model.User 可能拥有很多商业信息，但是其它层级不应该了解太多。 因此，这里专门为用例中的用户定义了 DAO 来屏蔽更具体的信息。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">    ID    <span class="keyword">string</span></span><br><span class="line">    Email <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">toUser</span><span class="params">(users []*model.User)</span> []*<span class="title">User</span></span> &#123;</span><br><span class="line">    res := <span class="built_in">make</span>([]*User, <span class="built_in">len</span>(users))</span><br><span class="line">    <span class="keyword">for</span> i, user := <span class="keyword">range</span> users &#123;</span><br><span class="line">        res[i] = &amp;User&#123;</span><br><span class="line">            ID:    user.GetID(),</span><br><span class="line">            Email: user.GetEmail(),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你可能会想，为什么这个服务不使用接口而是直接实现呢？这是因为该服务不依赖于任何其它服务。<br>相反，当仓储穿透层和具体实现依赖于其它层不应知道太多细节的设备时，就需要定义一个接口来实现。作者认为这是整洁架构中最重要的一点。</p>
<h3 id="接口层-绿色层"><a href="#接口层-绿色层" class="headerlink" title="接口层-绿色层"></a>接口层-绿色层</h3><p>该层放置具体对象，如 API 端点的处理程序，RDB 的存储库或接口的其他边界。在这个案例中，添加了内存存储访问器和 gRPC 服务两个对象。</p>
<h4 id="内存存储访问器"><a href="#内存存储访问器" class="headerlink" title="内存存储访问器"></a>内存存储访问器</h4><p>作者使用用户存储库作为内存存储访问器。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> userRepository <span class="keyword">struct</span> &#123;</span><br><span class="line">    mu    *sync.Mutex</span><br><span class="line">    users <span class="keyword">map</span>[<span class="keyword">string</span>]*User</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewUserRepository</span><span class="params">()</span> *<span class="title">userRepository</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;userRepository&#123;</span><br><span class="line">        mu:    &amp;sync.Mutex&#123;&#125;,</span><br><span class="line">        users: <span class="keyword">map</span>[<span class="keyword">string</span>]*User&#123;&#125;,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *userRepository)</span> <span class="title">FindAll</span><span class="params">()</span> <span class="params">([]*model.User, error)</span></span> &#123;</span><br><span class="line">    r.mu.Lock()</span><br><span class="line">    <span class="keyword">defer</span> r.mu.Unlock()</span><br><span class="line">    users := <span class="built_in">make</span>([]*model.User, <span class="built_in">len</span>(r.users))</span><br><span class="line">    i := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _, user := <span class="keyword">range</span> r.users &#123;</span><br><span class="line">        users[i] = model.NewUser(user.ID, user.Email)</span><br><span class="line">        i++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> users, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *userRepository)</span> <span class="title">FindByEmail</span><span class="params">(email <span class="keyword">string</span>)</span> <span class="params">(*model.User, error)</span></span> &#123;</span><br><span class="line">    r.mu.Lock()</span><br><span class="line">    <span class="keyword">defer</span> r.mu.Unlock()</span><br><span class="line">    <span class="keyword">for</span> _, user := <span class="keyword">range</span> r.users &#123;</span><br><span class="line">        <span class="keyword">if</span> user.Email == email &#123;</span><br><span class="line">            <span class="keyword">return</span> model.NewUser(user.ID, user.Email), <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *userRepository)</span> <span class="title">Save</span><span class="params">(user *model.User)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    r.mu.Lock()</span><br><span class="line">    <span class="keyword">defer</span> r.mu.Unlock()</span><br><span class="line">    r.users[user.GetID()] = &amp;User&#123;</span><br><span class="line">        ID:    user.GetID(),</span><br><span class="line">        Email: user.GetEmail(),</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是存储库的具体实现。如果我们需要将用户持久保存到 RDB 或其他，我们将需要另一个实现。但即使在这种情况下，我们也不需要更改模型层。模型层仅依赖于存储库接口，并对实现细节毫不关心。这很鹅妹子嘤。<br>这里的 User 仅在当前包中定义，用于实现跨越层级的信息解封。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">    ID    <span class="keyword">string</span></span><br><span class="line">    Email <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="gRPC-service"><a href="#gRPC-service" class="headerlink" title="gRPC service"></a>gRPC service</h4><p>作者认为 gRPC 服务也应当包括在接口层中。gRPC 服务的目录结构如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">% tree</span><br><span class="line">.</span><br><span class="line">├── rpc.go</span><br><span class="line">└── v1.0</span><br><span class="line">    ├── protocol</span><br><span class="line">    │   ├── user_service.pb.go</span><br><span class="line">    │   └── user_service.proto</span><br><span class="line">    ├── user_service.go</span><br><span class="line">    └── v1.go</span><br></pre></td></tr></table></figure>

<p>protocol 目录包含协议缓冲区 DSL 文件（user_service.proto）和生成的 RPC 服务代码（user_service.pb.go）。<br>user_service.go 是 gRPC 端点处理程序的包装器：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> userService <span class="keyword">struct</span> &#123;</span><br><span class="line">    userUsecase usecase.UserUsecase</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewUserService</span><span class="params">(userUsecase usecase.UserUsecase)</span> *<span class="title">userService</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;userService&#123;</span><br><span class="line">        userUsecase: userUsecase,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *userService)</span> <span class="title">ListUser</span><span class="params">(ctx context.Context, in *protocol.ListUserRequestType)</span> <span class="params">(*protocol.ListUserResponseType, error)</span></span> &#123;</span><br><span class="line">    users, err := s.userUsecase.ListUser()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    res := &amp;protocol.ListUserResponseType&#123;</span><br><span class="line">        Users: toUser(users),</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *userService)</span> <span class="title">RegisterUser</span><span class="params">(ctx context.Context, in *protocol.RegisterUserRequestType)</span> <span class="params">(*protocol.RegisterUserResponseType, error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> err := s.userUsecase.RegisterUser(in.GetEmail()); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> &amp;protocol.RegisterUserResponseType&#123;&#125;, err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &amp;protocol.RegisterUserResponseType&#123;&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">toUser</span><span class="params">(users []*usecase.User)</span> []*<span class="title">protocol</span>.<span class="title">User</span></span> &#123;</span><br><span class="line"> res := <span class="built_in">make</span>([]*protocol.User, <span class="built_in">len</span>(users))</span><br><span class="line">    <span class="keyword">for</span> i, user := <span class="keyword">range</span> users &#123;</span><br><span class="line">        res[i] = &amp;protocol.User&#123;</span><br><span class="line">            Id:    user.ID,</span><br><span class="line">            Email: user.Email,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>userService 仅依赖用例接口。如果你想在其它层级（例如，终端）中使用用例，你可以在接口层中按照需求实现该服务。<br>v1.go 使用 DI 容器解析对象依赖项：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Apply</span><span class="params">(server *grpc.Server, ctn *registry.Container)</span></span> &#123;</span><br><span class="line">    protocol.RegisterUserServiceServer(server, NewUserService(ctn.Resolve(<span class="string">"user-usecase"</span>).(usecase.UserUsecase)))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>v1.go 将从* registry.Container 检索到的包应用于 gRPC 服务。</p>
<p>最后，简单看一下 DI 容器的实现。</p>
<h3 id="registry"><a href="#registry" class="headerlink" title="registry"></a>registry</h3><p>registry 是一个 DI 容器用以解析对象依赖。这里使用了 <a href="https://github.com/sarulabs/di" target="_blank" rel="external nofollow noopener noreferrer">github.com/sarulabs/di</a> 作为 DI 容器。</p>
<p>github.com/surulabs/di   使用起来很简单：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Container <span class="keyword">struct</span> &#123;</span><br><span class="line">    ctn di.Container</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewContainer</span><span class="params">()</span> <span class="params">(*Container, error)</span></span> &#123;</span><br><span class="line">    builder, err := di.NewBuilder()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> err := builder.Add([]di.Def&#123;</span><br><span class="line">        &#123;</span><br><span class="line">            Name:  <span class="string">"user-usecase"</span>,</span><br><span class="line">            Build: buildUserUsecase,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;...); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &amp;Container&#123;</span><br><span class="line">        ctn: builder.Build(),</span><br><span class="line">    &#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Container)</span> <span class="title">Resolve</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">    <span class="keyword">return</span> c.ctn.Get(name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Container)</span> <span class="title">Clean</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> c.ctn.Clean()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">buildUserUsecase</span><span class="params">(ctn di.Container)</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span></span> &#123;</span><br><span class="line">    repo := memory.NewUserRepository()</span><br><span class="line">    service := service.NewUserService(repo)</span><br><span class="line">    <span class="keyword">return</span> usecase.NewUserUsecase(repo, service), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例如，在上面，将 user-usecase 字符串通过 buildUserUsecase 函数与具体用例实现关联起来。由此，我们可以在注册文件中任意替换用例的具体实现。</p>
]]></content>
      <categories>
        <category>译文</category>
      </categories>
      <tags>
        <tag>译文</tag>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>Go 语言流式 IO</title>
    <url>/post/d2033f7a.html</url>
    <content><![CDATA[<h3 id="原文"><a href="#原文" class="headerlink" title="原文"></a>原文</h3><p><a href="https://medium.com/learning-the-go-programming-language/streaming-io-in-go-d93507931185" target="_blank" rel="external nofollow noopener noreferrer">Streaming IO in Go</a></p><p>在 Go 语言中，实现输入输出操作有专门的原语，这些原语将数据构建为可读写的字节流。Go 语言标准库中 io 包提供了 <code>io.Reader</code> 和 <code>io.Write</code>r 接口，分别用于数据输入和输出操作，如下图所示：</p><p><img src="https://cdn.nlark.com/yuque/0/2019/png/182657/1574581234981-aab516f1-5c45-4c94-a275-5291faa2e23b.png#align=left&display=inline&height=186&name=image.png&originHeight=372&originWidth=2772&size=89243&status=done&width=1386" alt="image.png"></p><p>Go 提供了许多 api，支持来自于内存、文件、网络连接等资源的流式 IO。本文主要讲解如何使用 <code>io.Reader</code> 和 <code>io. Writer</code> 接口创建能够处理流式数据的 Go 程序，分别提供了基于标准库和自定义类型的实现。</p><a id="more"></a>



<h3 id="io-Reader-接口"><a href="#io-Reader-接口" class="headerlink" title="io.Reader 接口"></a>io.Reader 接口</h3><p>reader 由 io.Reader 接口定义，可以从数据源读取数据到传输缓冲区，缓冲区中的数据可以继续被流式处理或者直接消费，如下图所示：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2019/png/182657/1574582203043-67900870-30e2-4c99-bd30-da4717c937b5.png#align=left&display=inline&height=206&name=image.png&originHeight=412&originWidth=1858&size=60329&status=done&width=929" alt="image.png"><br>如果要把一个 Go 语言类型作为 reader 来使用，这个类型必须实现 <code>io.Reader</code> 所定义的 <code>Read(p []byte)</code> 方法，如下所示：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Reader <span class="keyword">interface</span> &#123;</span><br><span class="line">    Read(p []<span class="keyword">byte</span>) (n <span class="keyword">int</span>, err error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Read()</code>  方法需要返回读取的字节数，如果发生错误则同时返回 error ，如果数据源的所有内容已被读取完毕，则 <code>Read()</code> 方法应当返回 <code>io.EOF</code> 错误。</p>
<h3 id="读取规则（新增）"><a href="#读取规则（新增）" class="headerlink" title="读取规则（新增）"></a>读取规则（新增）</h3><p>根据 Reddit 上的反馈，我决定新增这部分内容帮助理解读取操作。一个 reader 的行为取决于它的具体实现，但是 <code>io.Reader</code> 的文档中定义了一些基本的规则，在使用 reader 的时候你应当首先阅读这些说明文档：</p>
<ol>
<li><code>Read()</code>  方法会尽可能但最多读取 len(p) 个字节到 p 中。</li>
<li>调用 <code>Read()</code> 方法读取的字节数 n 可能小于 len(p)。</li>
<li>在发生读取错误的时候，<code>Read()</code>  仍然有可能已经成功读取了 n 个字节的数据到缓冲区 p 中。例如，正在从一个 TCP 套接字中读取数据时套接字突然关闭。根据使用场景的不同，你可以保留这些成功读取的数据或者丢掉它们重新尝试读取。</li>
<li>当数据源中的可用数据被读完时，<code>Read()</code>  方法有可能返回一个非零的 n 和 <code>err = io.EOF</code>。但是，根据具体的实现，reader 也可以选择在读取结束时返回一个非零的 n 和 <code>err = nil</code>。在这种情况下，所有后续的读取操作必须返回 <code>n = 0</code> 和 <code>err = io.EOF</code>。</li>
<li>最后，<code>Read()</code> 调用返回 <code>n = 0</code> 和 <code>err = nil</code> 并不意味着 EOF 因为下一次调用 <code>Read()</code> 方法可能会返回数据。</li>
</ol>
<p>正如你所看到的，有时候直接从 reader 中读取数据有些棘手。但幸运的是，标准库中实现的 reader 都遵循符合常理的方法使得可以比较容易地实现流式操作。尽管如此，在使用一个 reader 之前仍然应当仔细查阅它的文档。</p>
<h3 id="流式读取数据"><a href="#流式读取数据" class="headerlink" title="流式读取数据"></a>流式读取数据</h3><p>从一个 reader 中流式读取数据很容易。<code>Read()</code> 方法被设计为在循环中调用，在每一次迭代中，<code>Read()</code> 方法会从数据源读取一个数据 chunk 并将其放入到缓冲区 p 中。循环过程一直进行直到 <code>Read()</code> 方法返回 <code>io.EOF</code> 错误。<br>下面是一个简单的例子：使用 strings.NewReader(string) 创建了一个字符串 reader，对一个源字符串中的字节进行流式处理：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	reader := strings.NewReader(<span class="string">"Clear is better than clever"</span>)</span><br><span class="line">	p := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		n, err := reader.Read(p)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span>&#123;</span><br><span class="line">		    <span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">			fmt.Println(<span class="keyword">string</span>(p[:n])) <span class="comment">//should handle any remainding bytes.</span></span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		    &#125;</span><br><span class="line">		    fmt.Println(err)</span><br><span class="line">		    os.Exit(<span class="number">1</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Println(<span class="keyword">string</span>(p[:n]))</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码使用 <code>make([]byte, 4)</code> 创建了一个容量和长度均为 4 个字节的字节切片作为缓冲区 p。这个缓冲区长度被故意设置为小于源字符串的长度，用来演示如何流式处理长度大于缓冲区长度的数据源。</p>
<h3 id="实现自定义-io-Reader"><a href="#实现自定义-io-Reader" class="headerlink" title="实现自定义 io.Reader"></a>实现自定义 io.Reader</h3><p>上面的例子使用了标准库的 reader ，现在我们尝试自定义实现一个 reader。下面的代码定义了一个 rader 类型实现了 io.Reader 接口，作用是过滤掉数据源中所有的非字母字符。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> alphaReader <span class="keyword">struct</span> &#123;</span><br><span class="line">	src <span class="keyword">string</span></span><br><span class="line">	cur <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newAlphaReader</span><span class="params">(src <span class="keyword">string</span>)</span> *<span class="title">alphaReader</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;alphaReader&#123;src: src&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">alpha</span><span class="params">(r <span class="keyword">byte</span>)</span> <span class="title">byte</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (r &gt;= <span class="string">'A'</span> &amp;&amp; r &lt;= <span class="string">'Z'</span>) || (r &gt;= <span class="string">'a'</span> &amp;&amp; r &lt;= <span class="string">'z'</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> r</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *alphaReader)</span> <span class="title">Read</span><span class="params">(p []<span class="keyword">byte</span>)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> a.cur &gt;= <span class="built_in">len</span>(a.src) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>, io.EOF</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	x := <span class="built_in">len</span>(a.src) - a.cur</span><br><span class="line">	n, bound := <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">	<span class="keyword">if</span> x &gt;= <span class="built_in">len</span>(p) &#123;</span><br><span class="line">		bound = <span class="built_in">len</span>(p)</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> x &lt;= <span class="built_in">len</span>(p) &#123;</span><br><span class="line">		bound = x</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//译者注</span></span><br><span class="line">    <span class="comment">//下面的代码改成这个样子比较合适</span></span><br><span class="line">    <span class="comment">//这段代码可以保证每次都读到 4 个字母再返回</span></span><br><span class="line">    <span class="comment">//所以返回的序列是： Hell oIts amwh erei sthe sun</span></span><br><span class="line">    <span class="comment">//而下面的代码返回的序列是：Hell oI ts am ...</span></span><br><span class="line">    <span class="comment">//之所以能正常工作是因为 byte 零值打印出来为空字符串</span></span><br><span class="line">    <span class="comment">//buf := make([]byte, bound)</span></span><br><span class="line">	<span class="comment">//for n &lt; bound &amp;&amp; a.cur &lt; len(a.src) &#123;</span></span><br><span class="line">	<span class="comment">//	if char := alpha(a.src[a.cur]); char != 0 &#123;</span></span><br><span class="line">	<span class="comment">//		buf[n] = char</span></span><br><span class="line">	<span class="comment">//		n++</span></span><br><span class="line">	<span class="comment">//	&#125;</span></span><br><span class="line">	<span class="comment">//	a.cur++</span></span><br><span class="line">	<span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">	buf := <span class="built_in">make</span>([]<span class="keyword">byte</span>, bound)</span><br><span class="line">	<span class="keyword">for</span> n &lt; bound &#123;</span><br><span class="line">		<span class="keyword">if</span> char := alpha(a.src[a.cur]); char != <span class="number">0</span> &#123;</span><br><span class="line">			buf[n] = char</span><br><span class="line">		&#125;</span><br><span class="line">		n++</span><br><span class="line">		a.cur++</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">copy</span>(p, buf)</span><br><span class="line">	<span class="keyword">return</span> n, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	reader := newAlphaReader(<span class="string">"Hello! It's 9am, where is the sun?"</span>)</span><br><span class="line">	p := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">4</span>)</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		n, err := reader.Read(p)</span><br><span class="line">		<span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Print(<span class="keyword">string</span>(p[:n]))</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当程序执行时会输出：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">$&gt; <span class="keyword">go</span> run alpha_reader.<span class="keyword">go</span></span><br><span class="line">HelloItsamwhereisthesun</span><br></pre></td></tr></table></figure>

<h3 id="链式读取"><a href="#链式读取" class="headerlink" title="链式读取"></a>链式读取</h3><p>标准库中有很多 reader 已经实现了链式读取。使用一个 reader 作为另一个 reader 的数据源是一种常见的做法。reader 的链式组合使得一个 reader 可以复用另一个 reader 已经实现的逻辑，就像下面代码的做法：更新了  <code>alphaReader</code> 的实现使其可以接受一个 <code>io.Reader</code> 作为数据源。这样的做法通过复用已有 reader 的工作来降低代码的复杂性。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> alphaReader <span class="keyword">struct</span> &#123;</span><br><span class="line">	reader io.Reader</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newAlphaReader</span><span class="params">(reader io.Reader)</span> *<span class="title">alphaReader</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;alphaReader&#123;reader: reader&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">alpha</span><span class="params">(r <span class="keyword">byte</span>)</span> <span class="title">byte</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (r &gt;= <span class="string">'A'</span> &amp;&amp; r &lt;= <span class="string">'Z'</span>) || (r &gt;= <span class="string">'a'</span> &amp;&amp; r &lt;= <span class="string">'z'</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> r</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *alphaReader)</span> <span class="title">Read</span><span class="params">(p []<span class="keyword">byte</span>)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span> &#123;</span><br><span class="line">	n, err := a.reader.Read(p)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> n, err</span><br><span class="line">	&#125;</span><br><span class="line">	buf := <span class="built_in">make</span>([]<span class="keyword">byte</span>, n)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">		<span class="keyword">if</span> char := alpha(p[i]); char != <span class="number">0</span> &#123;</span><br><span class="line">			buf[i] = char</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">copy</span>(p, buf)</span><br><span class="line">	<span class="keyword">return</span> n, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// use an io.Reader as source for alphaReader</span></span><br><span class="line">	reader := newAlphaReader(strings.NewReader(<span class="string">"Hello! It's 9am, where is the sun?"</span>))</span><br><span class="line">	p := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">4</span>)</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		n, err := reader.Read(p)</span><br><span class="line">		<span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Print(<span class="keyword">string</span>(p[:n]))</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="io-Writer-接口"><a href="#io-Writer-接口" class="headerlink" title="io.Writer 接口"></a>io.Writer 接口</h3><p>writer 由 <code>io.Writer</code> 接口定义，实现流式地将数据从缓冲区写入到目标资源中，如下图所示：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2019/png/182657/1574586722093-9d4d9479-da59-446d-a748-e38a16b37d77.png#align=left&display=inline&height=213&name=image.png&originHeight=426&originWidth=1902&size=62060&status=done&width=951" alt="image.png"><br>writer 必须实现 <code>io.Write</code>r 接口的 <code>Write(p []byte)</code> 方法。<code>Wirte()</code>)方法被设计为从缓冲区 p 中读取数据并将其写入到指定的目标资源中。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Writer <span class="keyword">interface</span> &#123;</span><br><span class="line">    Write(p []<span class="keyword">byte</span>) (n <span class="keyword">int</span>, err error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Write()</code> 方法的实现应该返回写入的字节数，发生错误时返回 <code>error</code>。</p>
<h3 id="使用-writers"><a href="#使用-writers" class="headerlink" title="使用 writers"></a>使用 writers</h3><p>标准库中有很多预先实现了 <code>io.Writer</code> 的类型。使用 writers 也是比较简单的，下面的代码演示了使用 <code>bytes.Buffer</code> 作为一个 writer 向内存中写入数据。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	proverbs := []<span class="keyword">string</span>&#123;</span><br><span class="line">		<span class="string">"Channels orchestrate mutexes serialize"</span>,</span><br><span class="line">		<span class="string">"Cgo is not Go"</span>,</span><br><span class="line">		<span class="string">"Errors are values"</span>,</span><br><span class="line">		<span class="string">"Don't panic"</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">var</span> writer bytes.Buffer</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> _, p := <span class="keyword">range</span> proverbs &#123;</span><br><span class="line">		n, err := writer.Write([]<span class="keyword">byte</span>(p))</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Println(err)</span><br><span class="line">			os.Exit(<span class="number">1</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> n != <span class="built_in">len</span>(p) &#123;</span><br><span class="line">			fmt.Println(<span class="string">"failed to write data"</span>)</span><br><span class="line">			os.Exit(<span class="number">1</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Println(writer.String())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="实现自定义-io-Writer"><a href="#实现自定义-io-Writer" class="headerlink" title="实现自定义 io.Writer"></a>实现自定义 io.Writer</h3><p>下面的代码展示了如何实现一个名为  chanWriter 的自定义<code>io.Writer</code> 用来将缓冲区中的内容作为字节序列写入到一个 Go channel 中。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> chanWriter <span class="keyword">struct</span> &#123;</span><br><span class="line">	ch <span class="keyword">chan</span> <span class="keyword">byte</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newChanWriter</span><span class="params">()</span> *<span class="title">chanWriter</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;chanWriter&#123;<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">byte</span>, <span class="number">1024</span>)&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *chanWriter)</span> <span class="title">Chan</span><span class="params">()</span> &lt;-<span class="title">chan</span> <span class="title">byte</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> w.ch</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *chanWriter)</span> <span class="title">Write</span><span class="params">(p []<span class="keyword">byte</span>)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span> &#123;</span><br><span class="line">	n := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> _, b := <span class="keyword">range</span> p &#123;</span><br><span class="line">		w.ch &lt;- b</span><br><span class="line">		n++</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> n, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *chanWriter)</span> <span class="title">Close</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="built_in">close</span>(w.ch)</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	writer := newChanWriter()</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">defer</span> writer.Close()</span><br><span class="line">		writer.Write([]<span class="keyword">byte</span>(<span class="string">"Stream "</span>))</span><br><span class="line">		writer.Write([]<span class="keyword">byte</span>(<span class="string">"me!"</span>))</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">for</span> c := <span class="keyword">range</span> writer.Chan() &#123;</span><br><span class="line">		fmt.Printf(<span class="string">"%c"</span>, c)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 writer 也非常简单，在 main() 函数中调用（在一个单独的 goroutine 中） <code>writer.Write()</code> 方法即可。 chanWriter 也实现了 <code>io.Closer</code> 接口，写入完成后调用 <code>writer.Close()</code> 方法关闭 channel 防止访问 channel 陷入死锁。</p>
<h3 id="IO-操作常用的类型和包"><a href="#IO-操作常用的类型和包" class="headerlink" title="IO 操作常用的类型和包"></a>IO 操作常用的类型和包</h3><p>之前提到，Go 语言标准库中提供了很多有用的函数和类型使得操作流式 IO 变得非常简单。</p>
<h4 id="os-File"><a href="#os-File" class="headerlink" title="os.File"></a>os.File</h4><p>os.File 类型表示本地系统的一个文件。它同时实现了 <code>io.Reader</code> 和 <code>io.Writer</code> 接口，所以可以被用在任何流式 IO 操作的场景。例如，下面的代码展示了如何将字符串切片直接写入到文件中：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	proverbs := []<span class="keyword">string</span>&#123;</span><br><span class="line">		<span class="string">"Channels orchestrate mutexes serialize\n"</span>,</span><br><span class="line">		<span class="string">"Cgo is not Go\n"</span>,</span><br><span class="line">		<span class="string">"Errors are values\n"</span>,</span><br><span class="line">		<span class="string">"Don't panic\n"</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	file, err := os.Create(<span class="string">"./proverbs.txt"</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(err)</span><br><span class="line">		os.Exit(<span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> file.Close()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> _, p := <span class="keyword">range</span> proverbs &#123;</span><br><span class="line">		n, err := file.Write([]<span class="keyword">byte</span>(p))</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Println(err)</span><br><span class="line">			os.Exit(<span class="number">1</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> n != <span class="built_in">len</span>(p) &#123;</span><br><span class="line">			fmt.Println(<span class="string">"failed to write data"</span>)</span><br><span class="line">			os.Exit(<span class="number">1</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">"file write done"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外， <code>io.File</code> 也可以作为 reader 使用实现流式读取本地文件中的内容。例如，下面的代码演示了读取一个文件并将其内容打印出来：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	file, err := os.Open(<span class="string">"./proverbs.txt"</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(err)</span><br><span class="line">		os.Exit(<span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> file.Close()</span><br><span class="line"></span><br><span class="line">	p := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">4</span>)</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		n, err := file.Read(p)</span><br><span class="line">		<span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Print(<span class="keyword">string</span>(p[:n]))</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="标准输出、输入和错误"><a href="#标准输出、输入和错误" class="headerlink" title="标准输出、输入和错误"></a>标准输出、输入和错误</h4><p>os 包提供了三个变量：<code>os.Stdout</code>、<code>os.Stdin</code> 和 <code>os.Stderr</code> 。它们都是 <code>*os.File</code> 类型，分别表示操作系统的标准输出、输入和错误的文件句柄。例如，下面的代码展示直接向标准输出写入内容：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	proverbs := []<span class="keyword">string</span>&#123;</span><br><span class="line">		<span class="string">"Channels orchestrate mutexes serialize\n"</span>,</span><br><span class="line">		<span class="string">"Cgo is not Go\n"</span>,</span><br><span class="line">		<span class="string">"Errors are values\n"</span>,</span><br><span class="line">		<span class="string">"Don't panic\n"</span>,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> _, p := <span class="keyword">range</span> proverbs &#123;</span><br><span class="line">		n, err := os.Stdout.Write([]<span class="keyword">byte</span>(p))</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Println(err)</span><br><span class="line">			os.Exit(<span class="number">1</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> n != <span class="built_in">len</span>(p) &#123;</span><br><span class="line">			fmt.Println(<span class="string">"failed to write data"</span>)</span><br><span class="line">			os.Exit(<span class="number">1</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="io-Copy"><a href="#io-Copy" class="headerlink" title="io.Copy()"></a>io.Copy()</h4><p>使用 <code>io.Copy()</code> 函数可以很容易地流式地从源 reader 向目标 writer 拷贝数据。它抽象了 <code>for-loop</code> 模式和正确处理 <code>io.EOF</code> 及字节数的过程。<br>下面的代码展示了一个之前代码的简化版本，拷贝 proverbs 中的内容到 file 文件中：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	proverbs := <span class="built_in">new</span>(bytes.Buffer)</span><br><span class="line">	proverbs.WriteString(<span class="string">"Channels orchestrate mutexes serialize\n"</span>)</span><br><span class="line">	proverbs.WriteString(<span class="string">"Cgo is not Go\n"</span>)</span><br><span class="line">	proverbs.WriteString(<span class="string">"Errors are values\n"</span>)</span><br><span class="line">	proverbs.WriteString(<span class="string">"Don't panic\n"</span>)</span><br><span class="line"></span><br><span class="line">	file, err := os.Create(<span class="string">"./proverbs.txt"</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(err)</span><br><span class="line">		os.Exit(<span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> file.Close()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// copy from reader data into writer file</span></span><br><span class="line">	<span class="keyword">if</span> _, err := io.Copy(file, proverbs); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(err)</span><br><span class="line">		os.Exit(<span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">"file created"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类似地，我们可以重写之前的程序使用 <code>io.Copy()</code> 将本地文件中的内容流式地写入到标准输出：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	file, err := os.Open(<span class="string">"./proverbs.txt"</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(err)</span><br><span class="line">		os.Exit(<span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> file.Close()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> _, err := io.Copy(os.Stdout, file); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(err)</span><br><span class="line">		os.Exit(<span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="io-WriteString"><a href="#io-WriteString" class="headerlink" title="io.WriteString()"></a>io.WriteString()</h4><p><code>io.WriteString()</code> 为写入字符串到指定 writer 提供了便利：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	file, err := os.Create(<span class="string">"./magic_msg.txt"</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(err)</span><br><span class="line">		os.Exit(<span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> file.Close()</span><br><span class="line">	<span class="keyword">if</span> _, err := io.WriteString(file, <span class="string">"Go is fun!"</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(err)</span><br><span class="line">		os.Exit(<span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="管道-writers-and-readers"><a href="#管道-writers-and-readers" class="headerlink" title="管道 writers and readers"></a>管道 writers and readers</h4><p><code>io.PipeWrite</code>r 和 <code>io.PipeReade</code>r 将 IO 操作建模为基于内存的管道。数据被写入到管道的写端并在另外一个 goroutine 中从读端读出。下面的代码使用 <code>io.Pipe()</code> 创建了一个管道 reader/writer 对用来从 proverbs 缓冲区中拷贝数据到 <code>io.Stdout</code>：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	proverbs := <span class="built_in">new</span>(bytes.Buffer)</span><br><span class="line">	proverbs.WriteString(<span class="string">"Channels orchestrate mutexes serialize\n"</span>)</span><br><span class="line">	proverbs.WriteString(<span class="string">"Cgo is not Go\n"</span>)</span><br><span class="line">	proverbs.WriteString(<span class="string">"Errors are values\n"</span>)</span><br><span class="line">	proverbs.WriteString(<span class="string">"Don't panic\n"</span>)</span><br><span class="line"></span><br><span class="line">	piper, pipew := io.Pipe()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// write in writer end of pipe</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">defer</span> pipew.Close()</span><br><span class="line">		io.Copy(pipew, proverbs)</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// read from reader end of pipe.</span></span><br><span class="line">	io.Copy(os.Stdout, piper)</span><br><span class="line">	piper.Close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Buffered-IO"><a href="#Buffered-IO" class="headerlink" title="Buffered IO"></a>Buffered IO</h4><p>Go 通过 <code>bufio</code> 包支持 Buffered IO 使得操作文本内容更加方便。例如，下面的代码使用 <code>&#39;\n&#39;</code> 作为分隔符一行一行地读取文件的内容：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	file, err := os.Open(<span class="string">"./planets.txt"</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(err)</span><br><span class="line">		os.Exit(<span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> file.Close()</span><br><span class="line">	reader := bufio.NewReader(file)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		line, err := reader.ReadString(<span class="string">'\n'</span>)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				fmt.Println(err)</span><br><span class="line">				os.Exit(<span class="number">1</span>)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Print(line)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Util-包"><a href="#Util-包" class="headerlink" title="Util 包"></a>Util 包</h4><p>ioutil 包是 io 包的一个子包，它提供了几个方便的函数用于执行 IO 操作。例如，下面的代码使用 <code>ReadFile</code> 函数读取文件的所有内容到一个 <code>[]byte</code> 中:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">"io/ioutil"</span></span><br><span class="line">   ...</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	bytes, err := ioutil.ReadFile(<span class="string">"./planets.txt"</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(err)</span><br><span class="line">		os.Exit(<span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">"%s"</span>, bytes)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这篇文章展示了如何使用 <code>io.Reader</code> 和 <code>io.Writer</code> 接口实现流式 IO 操作。读过这篇文章后你应该理解了如何使用 io 包写程序处理流式 IO。<br>这里只对支持流式 IO 的包进行了简单的讨论，并没有深入探讨文件 IO 、缓冲 IO、网络 IO 和格式化 IO 等。我希望这篇文章能给你一些关于 Go 语言流式 IO 编程范式的启发。</p>
]]></content>
      <categories>
        <category>译文</category>
      </categories>
      <tags>
        <tag>译文</tag>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>Go 知识点汇总</title>
    <url>/post/defe85e8.html</url>
    <content><![CDATA[<h4 id="关于-slice-的初始化"><a href="#关于-slice-的初始化" class="headerlink" title="关于 slice 的初始化"></a>关于 slice 的初始化</h4><p>执行代码：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> tmpSlice []<span class="keyword">int</span></span><br><span class="line">	fmt.Printf(<span class="string">"value: %[1]v   type: %[1]T    len: %d    cap: %d    underlay: %p\n"</span>, tmpSlice, <span class="built_in">len</span>(tmpSlice), <span class="built_in">cap</span>(tmpSlice), tmpSlice)</span><br><span class="line">	tmpSlice = <span class="built_in">append</span>(tmpSlice, <span class="number">1</span>)</span><br><span class="line">	fmt.Printf(<span class="string">"value: %[1]v   type: %[1]T    len: %d    cap: %d    underlay: %p\n"</span>, tmpSlice, <span class="built_in">len</span>(tmpSlice), <span class="built_in">cap</span>(tmpSlice), tmpSlice)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a>


<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">value: []   type: []int    len: 0    cap: 0    underlay: 0x0</span><br><span class="line">value: [1]   type: []int    len: 1    cap: 2    underlay: 0x414028</span><br></pre></td></tr></table></figure>

<p>上述示例说明 slice 可以不进行初始化，在 append 调用中会自动创建底层数组分配空间，即所谓懒初始化。一般情况下， slice 可通过以下方式产生：<br>输入：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	slice1 := []<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">	printSlice(slice1)</span><br><span class="line"></span><br><span class="line">	slice2 := []<span class="keyword">int</span>&#123;<span class="number">6</span>:<span class="number">1</span>&#125;</span><br><span class="line">	printSlice(slice2)</span><br><span class="line"></span><br><span class="line">	underlayArr :=[...]<span class="keyword">int</span>&#123;<span class="number">15</span>:<span class="number">1</span>&#125;</span><br><span class="line">	slice3 := underlayArr[<span class="number">12</span>:]</span><br><span class="line">	printSlice(slice3)</span><br><span class="line"></span><br><span class="line">	slice4 := <span class="built_in">make</span>([]<span class="keyword">int</span>,<span class="number">3</span>)</span><br><span class="line">	printSlice(slice4)</span><br><span class="line"></span><br><span class="line">	slice5 := <span class="built_in">make</span>([]<span class="keyword">int</span>,<span class="number">3</span>,<span class="number">8</span>)</span><br><span class="line">	printSlice(slice5)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printSlice</span><span class="params">(s []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">"value: %[1]v   type: %[1]T    len: %d    cap: %d    underlay: %p\n"</span>, s, <span class="built_in">len</span>(s), <span class="built_in">cap</span>(s), s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">value: [1 2 3]   type: []int    len: 3    cap: 3    underlay: 0x414020</span><br><span class="line">value: [0 0 0 0 0 0 1]   type: []int    len: 7    cap: 7    underlay: 0x45e020</span><br><span class="line">value: [0 0 0 1]   type: []int    len: 4    cap: 4    underlay: 0x4300f0</span><br><span class="line">value: [0 0 0]   type: []int    len: 3    cap: 3    underlay: 0x4140a0</span><br><span class="line">value: [0 0 0]   type: []int    len: 3    cap: 8    underlay: 0x45e040</span><br></pre></td></tr></table></figure>

<h4 id="切片拷贝"><a href="#切片拷贝" class="headerlink" title="切片拷贝"></a>切片拷贝</h4><p>以下代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	arr := [<span class="number">20</span>]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">	slice1 := arr[<span class="number">2</span>:<span class="number">5</span>]</span><br><span class="line">	fmt.Printf(<span class="string">"%+v\n"</span>, slice1)</span><br><span class="line">	slice2 := slice1</span><br><span class="line">	slice2[<span class="number">1</span>] = <span class="number">3</span></span><br><span class="line"></span><br><span class="line">	slice2 = <span class="built_in">append</span>(slice2, []<span class="keyword">int</span>&#123;<span class="number">1</span>&#125;...)</span><br><span class="line">	fmt.Printf(<span class="string">"%+v\n"</span>, slice1)</span><br><span class="line">	fmt.Printf(<span class="string">"%+v\n"</span>, slice2)</span><br><span class="line">	slice2[<span class="number">2</span>] = <span class="number">5</span></span><br><span class="line">	fmt.Printf(<span class="string">"%+v\n"</span>, slice1)</span><br><span class="line">	fmt.Printf(<span class="string">"%+v\n"</span>, slice2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[0 0 0]</span><br><span class="line">[0 3 0]</span><br><span class="line">[0 3 0 1]</span><br><span class="line">[0 3 5]</span><br><span class="line">[0 3 5 1]</span><br></pre></td></tr></table></figure>

<p>以上输出说明，整个过程中两个切片的底层数组仍然是同一个，这是因为切片复制完成的瞬间新切片和原切片的底层数组一定是同一个，之后随着 append 操作有可能会造成切片各自的底层数组发生变化，而这种变化并不是一定会出现，只有底层数组的容量不足以容纳新的元素时才会发生，而上面的输出结果表明，由于底层数组的容量仍然足以容纳新的元素，所以切片 append 操作后底层数组仍未变化，也就是说原切片和新切片之间仍然有可能相互影响。<br>下面的例子恰好是由于新切片 append 元素时底层数组不足以容纳新的元素造成底层数组的变化，之后两个切片再无关系：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	slice1 := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">10</span>: <span class="number">0</span>&#125;</span><br><span class="line">	fmt.Printf(<span class="string">"%+v\n"</span>, slice1)</span><br><span class="line">	slice2 := slice1</span><br><span class="line">	slice2[<span class="number">1</span>] = <span class="number">3</span></span><br><span class="line"></span><br><span class="line">	slice2 = <span class="built_in">append</span>(slice2, []<span class="keyword">int</span>&#123;<span class="number">1</span>&#125;...)</span><br><span class="line">	fmt.Printf(<span class="string">"%+v\n"</span>, slice1)</span><br><span class="line">	fmt.Printf(<span class="string">"%+v\n"</span>, slice2)</span><br><span class="line">	slice2[<span class="number">3</span>]=<span class="number">5</span></span><br><span class="line">	fmt.Printf(<span class="string">"%+v\n"</span>, slice1)</span><br><span class="line">	fmt.Printf(<span class="string">"%+v\n"</span>, slice2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</span><br><span class="line">[<span class="number">1</span> <span class="number">3</span> <span class="number">3</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</span><br><span class="line">[<span class="number">1</span> <span class="number">3</span> <span class="number">3</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span>]</span><br><span class="line">[<span class="number">1</span> <span class="number">3</span> <span class="number">3</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</span><br><span class="line">[<span class="number">1</span> <span class="number">3</span> <span class="number">3</span> <span class="number">5</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<p>综上，我们不能依靠拷贝切片之间的联系来获取排序后的元素值（除非是原地排序，不需要增加切片大小），即不能像 C 语言使用指针一样，而应当每次返回一个新的切片存储排好序的值。</p>
<h4 id="包导入过程"><a href="#包导入过程" class="headerlink" title="包导入过程"></a>包导入过程</h4><p><img src="https://cdn.nlark.com/yuque/0/2019/png/182657/1572858912878-86d89e2a-168b-43ad-9e9b-70068b16e723.png#align=left&display=inline&height=424&margin=%5Bobject%20Object%5D&name=image.png&originHeight=424&originWidth=953&size=146883&status=done&style=none&width=953" alt="image.png"></p>
<h4 id="godoc-与-go-doc"><a href="#godoc-与-go-doc" class="headerlink" title="godoc 与 go doc"></a>godoc 与 go doc</h4><p>从 go 1.12 开始， godoc 不再提供各种子命令，仅作为一个 http server 提供 GOPATH 和 GOROOT 下 pkg 的在线文档，而 go doc 命令可以用来查看本地程序的文档。</p>
<h4 id="GOPRIVATE"><a href="#GOPRIVATE" class="headerlink" title="GOPRIVATE"></a>GOPRIVATE</h4><p>从 go 1.13 开始，增加了  GOPRIVATE 环境变量的配置用以跳过对私有仓库的 checksum 检查：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> GOPRIVATE=<span class="string">"git.ucloudadmin.com/*,git.umcloud.io/*"</span></span><br><span class="line"><span class="comment"># 设置完之后，通过 go env 可以看到 GONOSUMDB 和 GONOPROXY 环境变量也被自动更新了</span></span><br><span class="line">GO111MODULE=<span class="string">"on"</span></span><br><span class="line">GOARCH=<span class="string">"amd64"</span></span><br><span class="line">GOBIN=<span class="string">""</span></span><br><span class="line">GOCACHE=<span class="string">"/home/xyc/.cache/go-build"</span></span><br><span class="line">GOENV=<span class="string">"/home/xyc/.config/go/env"</span></span><br><span class="line">GOEXE=<span class="string">""</span></span><br><span class="line">GOFLAGS=<span class="string">""</span></span><br><span class="line">GOHOSTARCH=<span class="string">"amd64"</span></span><br><span class="line">GOHOSTOS=<span class="string">"linux"</span></span><br><span class="line">GONOPROXY=<span class="string">"git.ucloudadmin.com/*,git.umcloud.io/*"</span></span><br><span class="line">GONOSUMDB=<span class="string">"git.ucloudadmin.com/*,git.umcloud.io/*"</span></span><br><span class="line">GOOS=<span class="string">"linux"</span></span><br><span class="line">GOPATH=<span class="string">"/home/xyc/go"</span></span><br><span class="line">GOPRIVATE=<span class="string">"git.ucloudadmin.com/*,git.umcloud.io/*"</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h4 id="Template-中判断-range-最后一个元素"><a href="#Template-中判断-range-最后一个元素" class="headerlink" title="Template 中判断 range 最后一个元素"></a>Template 中判断 range 最后一个元素</h4><p>template 中可以使用 if 判断值是否为 0 ，不像在 Go 语法只能对 bool 值执行 if 操作，因此判断是否为第一个元素相对容易一些，使用 <code>{\{if $index\}\},\{\{end\}\}</code> 即可，而且 <code>index</code> 不需要专门声明。判断是否为最后一个元素则需要自定义函数如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">    <span class="string">"reflect"</span></span><br><span class="line">    <span class="string">"text/template"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fns = template.FuncMap&#123;</span><br><span class="line">    <span class="string">"last"</span>: <span class="function"><span class="keyword">func</span><span class="params">(x <span class="keyword">int</span>, a <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">        <span class="keyword">return</span> x == reflect.ValueOf(a).Len() - <span class="number">1</span></span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    t := template.Must(template.New(<span class="string">"abc"</span>).Funcs(fns).Parse(<span class="string">`\&#123;\&#123;range  $i, $e := .\&#125;\&#125;\&#123;\&#123;if $i\&#125;\&#125;, \&#123;\&#123;end\&#125;\&#125;\&#123;\&#123;if last $i $\&#125;\&#125;and \&#123;\&#123;end\&#125;\&#125;\&#123;\&#123;$e\&#125;\&#125;\&#123;\&#123;end\&#125;\&#125;.`</span>))</span><br><span class="line">    a := []<span class="keyword">string</span>&#123;<span class="string">"one"</span>, <span class="string">"two"</span>, <span class="string">"three"</span>&#125;</span><br><span class="line">    t.Execute(os.Stdout, a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于 Template 的使用可以参考：<a href="https://github.com/grpc-ecosystem/grpc-gateway/blob/master/protoc-gen-grpc-gateway/gengateway/template.go" target="_blank" rel="external nofollow noopener noreferrer">https://github.com/grpc-ecosystem/grpc-gateway/blob/master/protoc-gen-grpc-gateway/gengateway/template.go</a></p>
<h4 id="json-unmarshal-时保留-raw-message"><a href="#json-unmarshal-时保留-raw-message" class="headerlink" title="json unmarshal 时保留 raw message"></a>json unmarshal 时保留 raw message</h4><p>保留 raw message 的一个用途是，针对不同版本的返回值同一字段的结构可能不一样，因此可以先保留 raw message 然后根据版本进行进一步处理。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	<span class="string">"encoding/json"</span></span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"strconv"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">var jsonStrVersion1 = []byte(`&#123;</span><br><span class="line">    <span class="string">"id"</span>  : 15,</span><br><span class="line">    <span class="string">"version"</span> : 1,</span><br><span class="line">    <span class="string">"foo"</span> : &#123; <span class="string">"foo"</span>: 123, <span class="string">"bar"</span>: <span class="string">"baz"</span> &#125;</span><br><span class="line">&#125;`)</span><br><span class="line">var jsonStrVersion2 = []byte(`&#123;</span><br><span class="line">    <span class="string">"id"</span>  : 16,</span><br><span class="line">    <span class="string">"version"</span> : 2,</span><br><span class="line">    <span class="string">"foo"</span> : 124</span><br><span class="line">&#125;`)</span><br><span class="line"></span><br><span class="line"><span class="built_in">type</span> Bar struct &#123;</span><br><span class="line">	Id      int64           `json:<span class="string">"id"</span>`</span><br><span class="line">	Version int64           `json:<span class="string">"version"</span>`</span><br><span class="line">	Foo     json.RawMessage `json:<span class="string">"foo"</span>`</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">type</span> Foo struct &#123;</span><br><span class="line">	Foo int64  `json:<span class="string">"foo"</span>`</span><br><span class="line">	Bar string `json:<span class="string">"bar"</span>`</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">	var bar Bar</span><br><span class="line">	err := json.Unmarshal(jsonStrVersion1, &amp;bar)</span><br><span class="line">	<span class="keyword">if</span> err != nil &#123;</span><br><span class="line">		panic(err)</span><br><span class="line">	&#125;</span><br><span class="line">	getFoo(bar)</span><br><span class="line">	err = json.Unmarshal(jsonStrVersion2, &amp;bar)</span><br><span class="line">	<span class="keyword">if</span> err != nil &#123;</span><br><span class="line">		panic(err)</span><br><span class="line">	&#125;</span><br><span class="line">	getFoo(bar)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func getFoo(bar Bar) &#123;</span><br><span class="line">	var num int64</span><br><span class="line">	switch bar.Version &#123;</span><br><span class="line">	<span class="keyword">case</span> 1:</span><br><span class="line">		var foo Foo</span><br><span class="line">		_ = json.Unmarshal(bar.Foo, &amp;foo)</span><br><span class="line">		num = foo.Foo</span><br><span class="line">	<span class="keyword">case</span> 2:</span><br><span class="line">		num, _ = strconv.ParseInt(string(bar.Foo), 10, 64)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(num)</span><br><span class="line">&#125;</span><br><span class="line">//输出</span><br><span class="line">//123</span><br><span class="line">//124</span><br></pre></td></tr></table></figure>

<h4 id="json-unmarshal-时会保留对象已有的值"><a href="#json-unmarshal-时会保留对象已有的值" class="headerlink" title="json unmarshal 时会保留对象已有的值"></a>json unmarshal 时会保留对象已有的值</h4><p>结论：<br>json unmarshal 会忽略结构体中小写字母开头的字段；对同一对象执行多次 unmarshal 会覆盖与前一次 unmarshal 同名的字段，前一次 unmarshal 得到的非同名字段会被保留。示例如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"encoding/json"</span></span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Foo <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// 如果是 val1，将无法在 json.unmarshal 时被赋值成功</span></span><br><span class="line">	Val1 <span class="keyword">string</span></span><br><span class="line">	Val2 <span class="keyword">string</span></span><br><span class="line">	Val3Ptr *<span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> foo Foo</span><br><span class="line">	foo.Val1 = <span class="string">"val1"</span></span><br><span class="line">	foo.Val2 = <span class="string">"val2"</span></span><br><span class="line">	fmt.Printf(<span class="string">"%+v\n"</span>, foo)</span><br><span class="line">	fooBytes, _ := json.Marshal(foo)</span><br><span class="line">	fmt.Printf(<span class="string">"%+v\n"</span>, fooBytes)</span><br><span class="line">	fmt.Printf(<span class="string">"%s\n"</span>, fooBytes)</span><br><span class="line">	json.Unmarshal([]<span class="keyword">byte</span>(<span class="string">`&#123;"Val1": "val1"&#125;`</span>), &amp;foo)</span><br><span class="line">	fmt.Printf(<span class="string">"%+v\n"</span>, foo)</span><br><span class="line">	json.Unmarshal([]<span class="keyword">byte</span>(<span class="string">`&#123;"val1": "val1-1", "val2": "val2", "val3ptr": "val3"&#125;`</span>), &amp;foo)</span><br><span class="line">	fmt.Printf(<span class="string">"%s\n"</span>, *foo.Val3Ptr)</span><br><span class="line">	fmt.Printf(<span class="string">"%+v\n"</span>, foo)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&#123;Val1:val1 Val2:val2 Val3Ptr:&lt;nil&gt;&#125;</span><br><span class="line">[123 34 86 97 108 49 34 58 34 118 97 108 49 34 44 34 86 97 108 50 34 58 34 118 97 108 50 34 44 34 86 97 108 51 80 116 114 34 58 110 117 108 108 125]</span><br><span class="line">&#123;<span class="string">"Val1"</span>:<span class="string">"val1"</span>,<span class="string">"Val2"</span>:<span class="string">"val2"</span>,<span class="string">"Val3Ptr"</span>:null&#125;</span><br><span class="line">&#123;Val1:val1 Val2:val2 Val3Ptr:&lt;nil&gt;&#125;</span><br><span class="line">val3</span><br><span class="line">&#123;Val1:val1-1 Val2:val2 Val3Ptr:0xc000010370&#125;</span><br></pre></td></tr></table></figure>

<h4 id="json-unmarshal-时传入什么类型的值"><a href="#json-unmarshal-时传入什么类型的值" class="headerlink" title="json unmarshal 时传入什么类型的值"></a>json unmarshal 时传入什么类型的值</h4><p>json.Unmarshal 的第二个参数必须是指针，且指针值不为 nil，但是指针可以指向一个值为 nil 的指针，此时 unmarshal 会自动分配对象并赋值给此值为 nil 的指针，unmarshal 得到的内容保存在该对象中，因此也支持目标结构体中含有指针类型字段。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"encoding/json"</span></span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Result <span class="keyword">struct</span> &#123;</span><br><span class="line">	Foo *<span class="keyword">string</span> <span class="string">`json:"foo"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	content := []<span class="keyword">byte</span>(<span class="string">`&#123;"foo": "bar"&#125;`</span>)</span><br><span class="line">	<span class="keyword">var</span> result1 Result</span><br><span class="line">	err := json.Unmarshal(content, &amp;result1) <span class="comment">// this is fine</span></span><br><span class="line">	fmt.Println(err)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> result2 = <span class="built_in">new</span>(Result)</span><br><span class="line">	err = json.Unmarshal(content, result2) <span class="comment">// and this</span></span><br><span class="line">	fmt.Println(err)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> result3 = &amp;Result&#123;&#125;</span><br><span class="line">	err = json.Unmarshal(content, result3) <span class="comment">// this is also fine</span></span><br><span class="line">	fmt.Println(err)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> result4 *Result</span><br><span class="line">	err = json.Unmarshal(content, result4) <span class="comment">// err json: Unmarshal(nil *main.Result)</span></span><br><span class="line">	fmt.Println(err)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> result5 *Result</span><br><span class="line">	err = json.Unmarshal(content, &amp;result5) <span class="comment">// this is fine, because unmarshal allocates a new value</span></span><br><span class="line">	fmt.Println(err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="编译时自动添加版本和日期信息"><a href="#编译时自动添加版本和日期信息" class="headerlink" title="编译时自动添加版本和日期信息"></a>编译时自动添加版本和日期信息</h4><p>简单的做法是把版本信息放到 main 包中，如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">var</span> GitCommit <span class="keyword">string</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  fmt.Printf(<span class="string">"Hello world, version: %s\n"</span>, GitCommit)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在编译时加上如下参数：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> GIT_COMMIT=$(git rev-list -1 HEAD)</span><br><span class="line"><span class="comment"># go build -ldflags="-X 'package_path.variable_name=new_value'"</span></span><br><span class="line">go build -ldflags <span class="string">"-X main.GitCommit=<span class="variable">$GIT_COMMIT</span>"</span></span><br></pre></td></tr></table></figure>

<p>如果将 version 信息放到一个单独的包中，如 app/version，如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    <span class="string">"app/build"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">var Version = <span class="string">"development"</span></span><br><span class="line"></span><br><span class="line">func <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">    fmt.Println(<span class="string">"Version:\t"</span>, Version)</span><br><span class="line">    fmt.Println(<span class="string">"build.Time:\t"</span>, build.Time)</span><br><span class="line">    fmt.Println(<span class="string">"build.User:\t"</span>, build.User)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>则添加参数时就需要先找到 version 包的路径，可通过如下方式寻找：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 先编译得到 app 可执行文件</span></span><br><span class="line">go build</span><br><span class="line"><span class="comment"># 再通过工具找到包的信息</span></span><br><span class="line">go tool nm ./app | grep app</span><br><span class="line"><span class="comment"># 输出如下：</span></span><br><span class="line">Output</span><br><span class="line">  55d2c0 D app/build.Time</span><br><span class="line">  55d2d0 D app/build.User</span><br><span class="line">  4069a0 T runtime.appendIntStr</span><br><span class="line">  462580 T strconv.appendEscapedRune</span><br><span class="line"><span class="comment"># 之后就可以使用以下方式添加编译参数</span></span><br><span class="line">go build -v -ldflags=<span class="string">"-X 'main.Version=v1.0.0' -X 'app/build.User=<span class="variable">$(id -u -n)</span>' -X 'app/build.Time=<span class="variable">$(date)</span>'"</span></span><br></pre></td></tr></table></figure>

<p>常用的版本相关信息有：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">now=$(date +<span class="string">'%Y-%m-%d_%T'</span>)</span><br><span class="line">commit=$(git rev-parse HEAD)</span><br></pre></td></tr></table></figure>

<h4 id="go-编译相关问题"><a href="#go-编译相关问题" class="headerlink" title="go 编译相关问题"></a>go 编译相关问题</h4><p>etcd 编译时 GO 依赖包版本报错的解决方法: <a href="https://aiops.red/archives/571" target="_blank" rel="external nofollow noopener noreferrer">https://aiops.red/archives/571</a><br>编译完成的程序在容器内运行时提示：<code>exec user process caused &quot;no such file or directory&quot;</code>，一般是因为程序编译时没有禁用 CGO :  <code>CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build -o bin/csi-resizer ./cmd/csi-resizer/main.go</code>。<br>在已经指定使用 <code>-mod=vendor</code> 进行编译时仍提示  <code>build uk8s/uk8s-report: cannot load github.com/montanaflynn/stats: no Go source files</code>，可能是因为  <code>github.com/montanaflynn/stats</code> 是个 subemodule。</p>
<h4 id="Unicode-字符编码"><a href="#Unicode-字符编码" class="headerlink" title="Unicode 字符编码"></a>Unicode 字符编码</h4><p>Unicode 定义了一种编码规则，为每个（语言或表情）符号指定了一个数值。而  UTF-8 是该编码规则在计算机上进行存储时的一种实现。在使用 UTF-8 进行编解码时依据的仍然是 Unicode 编码规则。参见  <a href="http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html" target="_blank" rel="external nofollow noopener noreferrer">字符编码笔记：ASCII，Unicode 和 UTF-8</a>。在 Go 语言中，字符编码使用 UTF-8。在下述代码中，<code>你好</code> 在计算机中使用 UTF-8 编码进行存储时保存的是 <code>E4BDA0E5A5BD</code> 二进制值，而在解释这个二进制值时会按照 UTF-8 规则转换后得到 <code>4F60597D</code> ，然后根据 Unicode 编码表，最后获知这是中文字符 <code>你好</code> 。可使用该工具观察编码转换：<a href="https://www.qqxiuzi.cn/bianma/Unicode-UTF.php" target="_blank" rel="external nofollow noopener noreferrer">https://www.qqxiuzi.cn/bianma/Unicode-UTF.php</a>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">string([]byte&#123;&#39;\xe4&#39;, &#39;\xbd&#39;, &#39;\xa0&#39;, &#39;\xe5&#39;, &#39;\xa5&#39;, &#39;\xbd&#39;&#125;) &#x2F;&#x2F; 你好</span><br><span class="line">string([]rune&#123;&#39;\u4F60&#39;, &#39;\u597D&#39;&#125;) &#x2F;&#x2F; 你好</span><br></pre></td></tr></table></figure>

<h4 id="使用-dlv-调试-Go-程序"><a href="#使用-dlv-调试-Go-程序" class="headerlink" title="使用 dlv 调试 Go 程序"></a>使用 dlv 调试 Go 程序</h4><p>参考：<a href="https://github.com/go-delve/delve/blob/master/Documentation/cli/expr.md" target="_blank" rel="external nofollow noopener noreferrer">https://github.com/go-delve/delve/blob/master/Documentation/cli/expr.md</a>，<a href="https://github.com/go-delve/delve/tree/master/Documentation/cli" target="_blank" rel="external nofollow noopener noreferrer">https://github.com/go-delve/delve/tree/master/Documentation/cli</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 安装 dlv</span><br><span class="line">go get github.com/go-delve/delve/cmd/dlv</span><br><span class="line">// 编译带有 Debug 信息的程序</span><br><span class="line">CGO_ENABLED=0 go build -mod vendor -gcflags=<span class="string">"all=-N -l"</span> -o <span class="built_in">test</span> main.go</span><br><span class="line">// 带参数启动调试</span><br><span class="line">dlv <span class="built_in">exec</span> ./<span class="built_in">test</span> -- --<span class="built_in">log</span>-level debug --config conf/config.toml</span><br><span class="line">// 查看文件路径</span><br><span class="line">sources</span><br><span class="line">// 通过文件名设置断点</span><br><span class="line">b /home/xyc/Development/<span class="built_in">test</span>/main.go:34</span><br><span class="line">// 通过函数名设置断点</span><br><span class="line">// 在函数入口处设置断点</span><br><span class="line">b logic.getClusterInfo</span><br><span class="line">// 在函数内第一行代码处设置断点</span><br><span class="line">b logic.getClusterInfo:1</span><br><span class="line">// 打印当前执行环境的所有局部变量</span><br><span class="line">locals</span><br><span class="line">// 打印指定的变量</span><br><span class="line">p tmpBytes</span><br><span class="line">// []byte转换为字符串打印</span><br><span class="line">p string(tmpBytes)</span><br><span class="line">// 每次执行到断点 1 处自动执行某种操作</span><br><span class="line">on 1 <span class="built_in">print</span> tmpBytes</span><br><span class="line">// 当满足某个条件时触发断点</span><br><span class="line">condition 1 tmpTimes &gt; 6</span><br></pre></td></tr></table></figure>

<h4 id="关于应用配置的思考"><a href="#关于应用配置的思考" class="headerlink" title="关于应用配置的思考"></a>关于应用配置的思考</h4><p>配置的最佳方式是使用环境变量，这是最符合 <strong><em>十二因素应用</em></strong> （Twelve-Factor App）的配置方式；但我们写程序时很多时候会考虑到不同的部署方式和配置方式，所以会有兼容命令行参数配置和配置文件（如 json/yaml ）的需求。使用  <a href="https://github.com/spf13/viper" target="_blank" rel="external nofollow noopener noreferrer">github.com/spf13/viper</a> 能够满足我们的需求（参考：<a href="https://medium.com/@bnprashanth256/reading-configuration-files-and-environment-variables-in-go-golang-c2607f912b63" target="_blank" rel="external nofollow noopener noreferrer">Reading Configuration Files and Environment Variables in GO </a>），但是对于同一参数的不同配置方式的优先级如何安排需要考虑一下，一般而言配置文件作为静态数据我们认为其优先级最低，但环境变量和命令行参数谁的优先级更多似乎并无定论（在 viper 中可以确定的是环境变量的优先级高于配置文件，但命令行参数还未明确测试），我的考虑是命令行参数的优先级应当高于环境变量，因为命令参数属于更细粒度的控制参数，就像我们在使用常用的 Linux 工具一样，环境变量往往只设置一次且只设置诸如 Token 一类的短期不变且有一定安全需求的配置，而命令行参数则可能每次运行程序都会略作调整，所以命令行参数的优先级更高一些。基于此，结合 viper 库写一些辅助代码可以实现这个需求。<br>补充：后续在 viper 源代码中看到了，确实也是命令行参数的优先级更高，官方文档也有描述，如下<br><img src="https://cdn.nlark.com/yuque/0/2020/png/182657/1592419877483-67f0c574-00b4-4e50-9b21-801a6ee24604.png#align=left&display=inline&height=591&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1182&originWidth=1918&size=270747&status=done&style=none&width=959" alt="image.png"></p>
<h4 id="当结构体内嵌套的结构体字段重名时"><a href="#当结构体内嵌套的结构体字段重名时" class="headerlink" title="当结构体内嵌套的结构体字段重名时"></a>当结构体内嵌套的结构体字段重名时</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Test1 <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Test2 <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Test <span class="keyword">struct</span> &#123;</span><br><span class="line">	Test1</span><br><span class="line">	Test2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	test := Test&#123;&#125;</span><br><span class="line">	test.Test1.Name = <span class="string">"test1"</span></span><br><span class="line">	test.Test2.Name = <span class="string">"test2"</span></span><br><span class="line">	fmt.Println(test.Test1.Name)</span><br><span class="line">	fmt.Println(test.Test2.Name)</span><br><span class="line"><span class="comment">//	以下代码报错： ambiguous selector test.Name</span></span><br><span class="line"><span class="comment">//	fmt.Println(test.Name)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="panic-的过程与捕获"><a href="#panic-的过程与捕获" class="headerlink" title="panic 的过程与捕获"></a>panic 的过程与捕获</h4><p>panic 会被层层向上传播，直到 main 函数；在其中每一个调用层级都可以使用 recover 去捕获，需要注意的是 recover 只能在 defer 中被调用（defer 正常在外围函数 return 后执行，因此有时可以用来修改函数的返回值），因为当程序出现 panic 时原有的执行逻辑会被打断（<strong>特别要注意，recover 只能恢复上层调用者的后续执行，recover 所在外围函数的执行逻辑不能继续进行，外围函数此时返回值为返回类型的默认值即零值</strong>），只有 defer 中的逻辑可以继续执行。当我们想要程序捕获 panic，然后仅打印日志信息后正常退出，仅仅使用 recover 是不够的，需要配合 os.Exit(0) 进行退出。<br>panic 只能被同一 goroutine 中的 recover 捕获。当在一个 goroutine 中发生 panic 时，会层层向上返回并执行各层调用中的 defer 逻辑，如果中途 panic 未被捕获，则一直返回到生成 goroutine 时调用的函数，并执行该函数中的 defer 逻辑，随后终止程序并报告错误。<br>参考：<a href="https://blog.golang.org/defer-panic-and-recover" target="_blank" rel="external nofollow noopener noreferrer">https://blog.golang.org/defer-panic-and-recover</a>，<a href="https://medium.com/rungo/defer-panic-and-recover-in-go-689dfa7f8802" target="_blank" rel="external nofollow noopener noreferrer">https://medium.com/rungo/defer-panic-and-recover-in-go-689dfa7f8802</a>，<a href="https://yourbasic.org/golang/recover-from-panic/" target="_blank" rel="external nofollow noopener noreferrer">https://yourbasic.org/golang/recover-from-panic/</a>，<a href="https://stackoverflow.com/a/50409138" target="_blank" rel="external nofollow noopener noreferrer">https://stackoverflow.com/a/50409138</a></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"end of main"</span>) <span class="comment">// push the call to the stack</span></span><br><span class="line">        <span class="comment">// 注意，如果注释掉下面一行代码则程序退出码仍然为非 0 ，有可能是 2</span></span><br><span class="line">        <span class="comment">// 在使用 k8s 部署程序的时候，我们可能想要捕获所有的异常，只有对于可重入的异常我们才允许退出码为非 0 ，从而通过 Job Controller 自动重试</span></span><br><span class="line">        <span class="comment">// 对于非可重入的异常则打印日志信息后作为正常程序退出</span></span><br><span class="line">		os.Exit(<span class="number">0</span>)</span><br><span class="line">	&#125;()</span><br><span class="line">	fmt.Println(<span class="string">"begining of main"</span>)</span><br><span class="line">	<span class="built_in">panic</span>(<span class="string">"stop here"</span>)</span><br><span class="line">	<span class="comment">// the deffered functions are called as if they are here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="TeeReader"><a href="#TeeReader" class="headerlink" title="TeeReader"></a>TeeReader</h4><p><code>TeeReader(r Reader, w Writer) Reader</code> 提供了复制 Reader 的能力。一般无法从 Reader 中重复读取数据，一次读取完成则 Reader 会被清空，而 TeeReader 可以包装原始 Reader 后返回一个特殊的 Reader，在对该特殊 Reader 进行读取的同时，将成功读到的内容复制写入 Writer 中。我们可以使用 bytes.Buffer 作为 Writer，由于 bytes.Buffer 同时也实现了 Reader 接口，所以可以再次从中读取原始 Reader 的内容。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	r := strings.NewReader(<span class="string">"some io.Reader stream to be read\n"</span>)</span><br><span class="line">	<span class="keyword">var</span> buf bytes.Buffer</span><br><span class="line">	tee := io.TeeReader(r, &amp;buf)</span><br><span class="line"></span><br><span class="line">	printall := <span class="function"><span class="keyword">func</span><span class="params">(r io.Reader)</span></span> &#123;</span><br><span class="line">		b, err := ioutil.ReadAll(r)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Fatal(err)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		fmt.Printf(<span class="string">"%s"</span>, b)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	printall(tee)</span><br><span class="line">	printall(&amp;buf)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="h2c-h2"><a href="#h2c-h2" class="headerlink" title="h2c/h2"></a>h2c/h2</h4><p>虽然 HTTP/2 协议本身和 TLS 协议并无绑定关系，但现在的很多反向代理工具仅支持在 HTTPS 模式下使用 HTTP/2，而在 Go 语言扩展库 <code>golang.org/x/net/http2</code> 的实现中，构建 HTTP/2 服务端也必须传入 TLS 配置，否则 HTTP/2 服务端将退化为只支持 HTTP/1.x 的协议，如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"html"</span></span><br><span class="line">    <span class="string">"net/http"</span></span><br><span class="line"></span><br><span class="line">    <span class="string">"golang.org/x/net/http2"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> server http.Server</span><br><span class="line">    http2.VerboseLogs = <span class="literal">true</span></span><br><span class="line">    server.Addr = <span class="string">":8080"</span></span><br><span class="line">    http2.ConfigureServer(&amp;server, &amp;http2.Server&#123;&#125;)</span><br><span class="line">    http.HandleFunc(<span class="string">"/"</span>, <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">        fmt.Fprintf(w, <span class="string">"URL: %q\n"</span>, html.EscapeString(r.URL.Path))</span><br><span class="line">        ShowRequestInfoHandler(w, r)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    server.ListenAndServe() <span class="comment">//不启用 https 则默认只支持http1.x</span></span><br><span class="line">    <span class="comment">//log.Fatal(server.ListenAndServeTLS("localhost.cert", "localhost.key"))</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ShowRequestInfoHandler</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    w.Header().Set(<span class="string">"Content-Type"</span>, <span class="string">"text/plain"</span>)</span><br><span class="line">    fmt.Fprintf(w, <span class="string">"Method: %s\n"</span>, r.Method)</span><br><span class="line">    fmt.Fprintf(w, <span class="string">"Protocol: %s\n"</span>, r.Proto)</span><br><span class="line">    fmt.Fprintf(w, <span class="string">"Host: %s\n"</span>, r.Host)</span><br><span class="line">    fmt.Fprintf(w, <span class="string">"RemoteAddr: %s\n"</span>, r.RemoteAddr)</span><br><span class="line">    fmt.Fprintf(w, <span class="string">"RequestURI: %q\n"</span>, r.RequestURI)</span><br><span class="line">    fmt.Fprintf(w, <span class="string">"URL: %#v\n"</span>, r.URL)</span><br><span class="line">    fmt.Fprintf(w, <span class="string">"Body.ContentLength: %d (-1 means unknown)\n"</span>, r.ContentLength)</span><br><span class="line">    fmt.Fprintf(w, <span class="string">"Close: %v (relevant for HTTP/1 only)\n"</span>, r.Close)</span><br><span class="line">    fmt.Fprintf(w, <span class="string">"TLS: %#v\n"</span>, r.TLS)</span><br><span class="line">    fmt.Fprintf(w, <span class="string">"\nHeaders:\n"</span>)</span><br><span class="line">    r.Header.Write(w)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>HTTP/2 客户端可通过启用 AllowHTTP 选项和更改 DialTLS 逻辑实现无需 TLS 的 HTTP/2 请求传输，但由于服务端存在问题，仅仅调整了客户端仍无法工作，以下客户端的请求会导致服务端向客户端响应一个 HTTP/1.1 的请求同时关闭 TCP 连接：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"crypto/tls"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"io/ioutil"</span></span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">    <span class="string">"net"</span></span><br><span class="line">    <span class="string">"net/http"</span></span><br><span class="line"></span><br><span class="line">    <span class="string">"golang.org/x/net/http2"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    url := <span class="string">"http://localhost:8080/"</span></span><br><span class="line">    client(url)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">client</span><span class="params">(url <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    log.SetFlags(log.Llongfile)</span><br><span class="line">    tr := &amp;http2.Transport&#123; <span class="comment">//可惜服务端 退化成了 http1.x</span></span><br><span class="line">        AllowHTTP: <span class="literal">true</span>, <span class="comment">//充许非加密的链接</span></span><br><span class="line">        <span class="comment">// TLSClientConfig: &amp;tls.Config&#123;</span></span><br><span class="line">        <span class="comment">//     InsecureSkipVerify: true,</span></span><br><span class="line">        <span class="comment">// &#125;,</span></span><br><span class="line">        DialTLS: <span class="function"><span class="keyword">func</span><span class="params">(netw, addr <span class="keyword">string</span>, cfg *tls.Config)</span> <span class="params">(net.Conn, error)</span></span> &#123;</span><br><span class="line">            <span class="keyword">return</span> net.Dial(netw, addr)</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    httpClient := http.Client&#123;Transport: tr&#125;</span><br><span class="line"></span><br><span class="line">    resp, err := httpClient.Get(url)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> resp.Body.Close()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> resp.StatusCode != http.StatusOK &#123;</span><br><span class="line">        fmt.Println(<span class="string">"resp StatusCode:"</span>, resp.StatusCode)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    body, err := ioutil.ReadAll(resp.Body)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">"resp.Body:\n"</span>, <span class="keyword">string</span>(body))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是因为客户端发送了 HTTP/2 的请求，而服务端已退化为仅支持 HTTP/1.x。 一种自然而然的做法是改造服务端使其支持无需 TLS 的 HTTP/2 传输，使用 h2c 是可行的解决方案：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"log"</span></span><br><span class="line">	<span class="string">"net/http"</span></span><br><span class="line">	<span class="string">"golang.org/x/net/http2"</span></span><br><span class="line">	<span class="string">"golang.org/x/net/http2/h2c"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	handler := http.HandlerFunc(<span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">		fmt.Fprint(w, <span class="string">"Hello world"</span>)</span><br><span class="line">	&#125;)</span><br><span class="line">	h2s := &amp;http2.Server&#123;</span><br><span class="line">        IdleTimeout: <span class="number">1</span> * time.Minute,</span><br><span class="line">	&#125;</span><br><span class="line">	h1s := &amp;http.Server&#123;</span><br><span class="line">		Addr: <span class="string">":8972"</span>,</span><br><span class="line">		Handler: h2c.NewHandler(handler, h2s),</span><br><span class="line">	&#125;</span><br><span class="line">	log.Fatal(h1s.ListenAndServe())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述方案的特点是同时支持 HTTP/2 和 HTTP/1.x ，对于客户端来说，可以有三种可能：仅通过 HTTP/1.1 通信；先通过 HTTP/1.1 建立连接，再通过升级协议升级至 HTTP/2；一开始就通过 HTTP/2 建立连接。如果我们本身不需要 HTTP/1.x ，则有更直接的写法：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"log"</span></span><br><span class="line">	<span class="string">"net/http"</span></span><br><span class="line">	<span class="string">"golang.org/x/net/http2"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    server := http2.Server&#123;&#125;</span><br><span class="line">    l, err := net.Listen(<span class="string">"tcp"</span>, <span class="string">"0.0.0.0:1010"</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		level.Error(logger).Log(<span class="string">"msg"</span>, fmt.Sprintf(<span class="string">"start listen failed: %v"</span>, err))</span><br><span class="line">		os.Exit(<span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> l.Close()</span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">"Listening [0.0.0.0:1010]...\n"</span>)</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        conn, err := l.Accept()</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			level.Warn(logger).Log(<span class="string">"msg"</span>, fmt.Sprintf(<span class="string">"accept a new connection failed: %v"</span>, err))</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">        <span class="keyword">go</span> server.ServeConn(conn, &amp;http2.ServeConnOpts&#123;</span><br><span class="line">            Handler: http.HandlerFunc(<span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">                fmt.Fprintf(w, <span class="string">"Hello, %v, http: %v"</span>, r.URL.Path, r.TLS == <span class="literal">nil</span>)</span><br><span class="line">            &#125;),</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="HTTP-1-1-Keep-Alive"><a href="#HTTP-1-1-Keep-Alive" class="headerlink" title="HTTP/1.1 Keep-Alive"></a>HTTP/1.1 Keep-Alive</h4><p>Go 标准库 net/http 提供的 http.DefaultClient 默认启用了 Keep-Alive，但想要真正复用 TCP 连接，还要在处理请求时注意及时关闭 Response Body，如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">resp, err := http.Post(<span class="string">"https://api.some-web.com/v2/events"</span>, <span class="string">"application/json"</span>, bytes.NewBuffer(eventJson))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">	log.Println(<span class="string">"err"</span>, err)</span><br><span class="line">	<span class="keyword">return</span> defaultErrStatus, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在 Go 1.7 之前需要手动在关闭之前将 Body 中的内容读完，1.7 以后调用 Body.Close() 时会自动处理</span></span><br><span class="line"><span class="comment">// io.Copy(ioutil.Discard, resp.Body)</span></span><br><span class="line"><span class="comment">// 只有及时关闭 response.Body 才能有效复用 TCP 连接</span></span><br><span class="line"><span class="comment">// Go 语言标准库已经确保 resp.Body 不会是 nil，即使并没有数据从对端返回</span></span><br><span class="line"><span class="keyword">defer</span> resp.Body.Close()</span><br></pre></td></tr></table></figure>

<h4 id="errors-after-go-1-13"><a href="#errors-after-go-1-13" class="headerlink" title="errors after go 1.13"></a>errors after go 1.13</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"># 使用 fmt.Errorf %w 格式化 可以返回一个 wrap 后的 error</span><br><span class="line"># 使用 errors.Is 和 errors.As 均是遍历错误链，调用 Unwrap 方法</span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"errors"</span></span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MyError <span class="keyword">struct</span> &#123;</span><br><span class="line">	msg <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *MyError)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> e.msg</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> generalErr = &amp;MyError&#123;</span><br><span class="line">	msg: <span class="string">"general error"</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	err := fmt.Errorf(<span class="string">"this is new error: %w"</span>, generalErr)</span><br><span class="line">	fmt.Printf(<span class="string">"%#v\n"</span>, err)</span><br><span class="line">	<span class="keyword">if</span> errors.Is(err, generalErr) &#123;</span><br><span class="line">		fmt.Println(<span class="string">"this is a wrapped generalErr"</span>)</span><br><span class="line">		fmt.Printf(<span class="string">"%#v\n"</span>, generalErr)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">var</span> myError *MyError</span><br><span class="line">	<span class="keyword">if</span> errors.As(err, &amp;myError) &#123;</span><br><span class="line">		fmt.Println(<span class="string">`this is an error with type "MyError"`</span>)</span><br><span class="line">		fmt.Printf(<span class="string">"%#v\n"</span>, myError)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码输出如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&amp;fmt.wrapError&#123;msg:&quot;this is new error: general error&quot;, err:(*main.MyError)(0x564880)&#125;</span><br><span class="line">this is a wrapped generalErr</span><br><span class="line">&amp;main.MyError&#123;msg:&quot;general error&quot;&#125;</span><br><span class="line">this is an error with type &quot;MyError&quot;</span><br><span class="line">&amp;main.MyError&#123;msg:&quot;general error&quot;&#125;</span><br></pre></td></tr></table></figure>

<p>应当何时对错误进行 wrap</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"># 如下定义的一个全局变量可视为一个哨兵错误，如果调用方需要依据错误类型进行分类错误处理，则应当对错误进行 wrap，否则出于隐藏底层细节的需要不应 wrap</span><br><span class="line"><span class="keyword">var</span> ErrPermission = errors.New(<span class="string">"permission denied"</span>)</span><br><span class="line"><span class="comment">// DoSomething returns an error wrapping ErrPermission if the user</span></span><br><span class="line"><span class="comment">// does not have permission to do something.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DoSomething</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> !userHasPermission() &#123;</span><br><span class="line">        <span class="comment">// If we return ErrPermission directly, callers might come</span></span><br><span class="line">        <span class="comment">// to depend on the exact error value, writing code like this:</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">//     if err := pkg.DoSomething(); err == pkg.ErrPermission &#123; … &#125;</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// This will cause problems if we want to add additional</span></span><br><span class="line">        <span class="comment">// context to the error in the future. To avoid this, we</span></span><br><span class="line">        <span class="comment">// return an error wrapping the sentinel so that users must</span></span><br><span class="line">        <span class="comment">// always unwrap it:</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">//     if err := pkg.DoSomething(); errors.Is(err, pkg.ErrPermission) &#123; ... &#125;</span></span><br><span class="line">        <span class="keyword">return</span> fmt.Errorf(<span class="string">"%w"</span>, ErrPermission)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="WebAssembly"><a href="#WebAssembly" class="headerlink" title="WebAssembly"></a>WebAssembly</h4><ol>
<li>作者通过一系列 hack 过程成功实现了将一个 go 语言写的工具 <a href="https://github.com/pdfcpu/pdfcpu" target="_blank" rel="external nofollow noopener noreferrer">pdfcpu</a>  编译为  wasm 文件并运行在浏览器中，其中有使用到一个浏览器端基于内存的文件系统 <a href="https://github.com/jvilk/BrowserFS" target="_blank" rel="external nofollow noopener noreferrer">BrowserFS</a> （实现了 Node JS 的 fs 库的 API）对 pdf 文件进行操作，很有意思。博客地址：<a href="https://dev.to/wcchoi/browser-side-pdf-processing-with-go-and-webassembly-13hn" target="_blank" rel="external nofollow noopener noreferrer">https://dev.to/wcchoi/browser-side-pdf-processing-with-go-and-webassembly-13hn</a>，代码地址：<a href="https://github.com/wcchoi/go-wasm-pdfcpu" target="_blank" rel="external nofollow noopener noreferrer">https://github.com/wcchoi/go-wasm-pdfcpu</a>。</li>
<li>vugu 使用 go 实现的类似于 vue 的前端框架，用 go 替代 JavaScript 写逻辑：<a href="https://github.com/vugu/vugu" target="_blank" rel="external nofollow noopener noreferrer">https://github.com/vugu/vugu</a>。</li>
</ol>
<h4 id="TCP-与-UDP-编程"><a href="#TCP-与-UDP-编程" class="headerlink" title="TCP 与 UDP 编程"></a>TCP 与 UDP 编程</h4><p>参考：<a href="https://www.linode.com/docs/development/go/developing-udp-and-tcp-clients-and-servers-in-go/" target="_blank" rel="external nofollow noopener noreferrer">https://www.linode.com/docs/development/go/developing-udp-and-tcp-clients-and-servers-in-go/</a></p>
<h4 id="context-用法"><a href="#context-用法" class="headerlink" title="context 用法"></a>context 用法</h4><p>参考：<a href="https://www.sohamkamani.com/golang/2018-06-17-golang-using-context-cancellation/" target="_blank" rel="external nofollow noopener noreferrer">https://www.sohamkamani.com/golang/2018-06-17-golang-using-context-cancellation/</a></p>
<h4 id="Linux-伪终端用法"><a href="#Linux-伪终端用法" class="headerlink" title="Linux 伪终端用法"></a>Linux 伪终端用法</h4><p>参考：<a href="https://www.jianshu.com/p/11c01003211b" target="_blank" rel="external nofollow noopener noreferrer">https://www.jianshu.com/p/11c01003211b</a></p>
<h4 id="channel-引发资源泄漏"><a href="#channel-引发资源泄漏" class="headerlink" title="channel 引发资源泄漏"></a>channel 引发资源泄漏</h4><p>channel 引发资源泄漏的场景是： goroutine 操作 channel 后，处于发送或接收阻塞状态，而 channel 处于满或空的状态，一直得不到改变。同时，垃圾回收器也不会回收此类资源，进而导致 gouroutine 会一直处于等待队列中。<br>另外，程序运行过程中，对于一个 channel，如果没有任何 goroutine 引用了，gc 会对其进行回收操作，不会引起内存泄漏，所以在多生产者多消费者通过一个 channel 进行通信时，可以通过一个中间的信号 channel 停止发送和接收而不去关闭数据 channel，而由 gc 回收数据 channel，从而避免无法确定何时关闭 channel 而造成多次关闭同一 channel 引发 panic。</p>
<h4 id="操作-channel-panic"><a href="#操作-channel-panic" class="headerlink" title="操作 channel panic"></a>操作 channel panic</h4><p>发生 panic 的情况有三种：向一个关闭的 channel 进行写操作；关闭一个 nil 的 channel；重复关闭一个 channel。读、写一个 nil channel 都会被阻塞。</p>
<h4 id="结构体作为-map-的-key"><a href="#结构体作为-map-的-key" class="headerlink" title="结构体作为 map 的 key"></a>结构体作为 map 的 key</h4><p>当结构体的成员都是可以判等时（使用 == ），该结构体也可以判等（结构体所有字段的值相等时两个结构体视为相等），就可以作为 map 的 key ，否则就不可以。下述程序中，a1 和 a2 可判等且相等，a3 和 a4 不可判等，程序无法通过编译。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">type Test1 struct &#123;</span><br><span class="line">	Name  string</span><br><span class="line">	Value int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Test2 struct &#123;</span><br><span class="line">	Name    string</span><br><span class="line">	Value   int</span><br><span class="line">	Handler func() error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	a1 :&#x3D; Test1&#123;</span><br><span class="line">		Name:  &quot;a1&quot;,</span><br><span class="line">		Value: 0,</span><br><span class="line">	&#125;</span><br><span class="line">	a2 :&#x3D; Test1&#123;</span><br><span class="line">		Name:  &quot;a1&quot;,</span><br><span class="line">		Value: 0,</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(a1 &#x3D;&#x3D; a2)</span><br><span class="line">	a3 :&#x3D; Test2&#123;</span><br><span class="line">		Name:  &quot;a1&quot;,</span><br><span class="line">		Value: 0,</span><br><span class="line">	&#125;</span><br><span class="line">	a4 :&#x3D; Test2&#123;</span><br><span class="line">		Name:  &quot;a1&quot;,</span><br><span class="line">		Value: 0,</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(a3 &#x3D;&#x3D; a4)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="amp-操作符"><a href="#amp-操作符" class="headerlink" title="&amp;^ 操作符"></a>&amp;^ 操作符</h4><p>此运算符是双目运算符，按位计算，将运算符左边数据相异的位保留，相同位清零。其特点是：① 如果右侧是 0 ，则左侧数保持不变；② 如果右侧是 1 ，则左侧数一定清零；③ 功能同 a&amp;(^b) 相同。</p>
<h4 id="Go-内存垃圾回收的触发条件"><a href="#Go-内存垃圾回收的触发条件" class="headerlink" title="Go 内存垃圾回收的触发条件"></a>Go 内存垃圾回收的触发条件</h4><p>从上次垃圾回收结束到现在时间已经超过两分钟则触发垃圾回收；从上次垃圾回收到现在堆内存增长了 100% 后触发回收，该比例可通过 GOGC 调整。</p>
<h4 id="基于信号的抢占"><a href="#基于信号的抢占" class="headerlink" title="基于信号的抢占"></a>基于信号的抢占</h4><p>每个 M 新建时都会监听 SIGURG 信号，用于接收抢占信号。</p>
<h4 id="开源库"><a href="#开源库" class="headerlink" title="开源库"></a>开源库</h4><ol>
<li>Linux 操作系统功能调用  <a href="https://github.com/tredoe/osutil" target="_blank" rel="external nofollow noopener noreferrer">osutil</a>， 可以用以生成 Linux 用户密码的 Hash。</li>
<li>一个强大的请求限速库  <a href="https://github.com/didip/tollbooth" target="_blank" rel="external nofollow noopener noreferrer">https://github.com/didip/tollbooth</a>，可以根据请求头或者源 IP 限速。</li>
<li>Go 社区提供的实现了令牌桶算法的限速包  <a href="https://godoc.org/golang.org/x/time/rate" target="_blank" rel="external nofollow noopener noreferrer">https://godoc.org/golang.org/x/time/rate</a>，一个简单的例子  <a href="https://pliutau.com/rate-limit-http-requests/" target="_blank" rel="external nofollow noopener noreferrer">https://pliutau.com/rate-limit-http-requests/</a> 。</li>
<li>一个创建和解压 zip 文件的库，在调用标准库 <code>archive/zip</code>  基础上做了些友好封装：<a href="https://github.com/pierrre/archivefile" target="_blank" rel="external nofollow noopener noreferrer">https://github.com/pierrre/archivefile</a>。</li>
<li>一个 Markdown 转 PDF 的库，只是不支持中文字符：<a href="https://github.com/mandolyte/mdtopdf" target="_blank" rel="external nofollow noopener noreferrer">https://github.com/mandolyte/mdtopdf</a>。</li>
<li>可以从文件中加载环境变量的库  <a href="https://github.com/joho/godotenv" target="_blank" rel="external nofollow noopener noreferrer">github.com/joho/godotenv</a> ，不过使用 <a href="https://github.com/spf13/viper" target="_blank" rel="external nofollow noopener noreferrer">github.com/spf13/viper</a> 可能更佳，参考：<a href="https://levelup.gitconnected.com/a-no-nonsense-guide-to-environment-variables-in-go-55d7661f09b0" target="_blank" rel="external nofollow noopener noreferrer">https://levelup.gitconnected.com/a-no-nonsense-guide-to-environment-variables-in-go-55d7661f09b0</a>，<a href="https://towardsdatascience.com/use-environment-variable-in-your-next-golang-project-39e17c3aaa66" target="_blank" rel="external nofollow noopener noreferrer">https://towardsdatascience.com/use-environment-variable-in-your-next-golang-project-39e17c3aaa66</a>。</li>
<li>获取文件系统事件通知：<a href="https://github.com/fsnotify/fsnotify" target="_blank" rel="external nofollow noopener noreferrer">https://github.com/fsnotify/fsnotify</a>。</li>
<li>获取内核事件：<a href="https://github.com/euank/go-kmsg-parser/" target="_blank" rel="external nofollow noopener noreferrer">https://github.com/euank/go-kmsg-parser/</a>。</li>
</ol>
<h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ol>
<li><a href="https://github.com/thrawn01/h2c-golang-example" target="_blank" rel="external nofollow noopener noreferrer">HTTP/2 Cleartext (H2C) golang example</a></li>
<li><a href="https://mrwaggel.be/post/golang-transfer-a-file-over-a-tcp-socket/" target="_blank" rel="external nofollow noopener noreferrer">https://mrwaggel.be/post/golang-transfer-a-file-over-a-tcp-socket/</a></li>
<li><a href="http://networkbit.ch/golang-ssh-client/#multiple_commands" target="_blank" rel="external nofollow noopener noreferrer">http://networkbit.ch/golang-ssh-client/#multiple_commands</a></li>
</ol>
<h4 id="书籍"><a href="#书籍" class="headerlink" title="书籍"></a>书籍</h4><ol>
<li>《Go 语言从入门到进阶实战》名字俗了点，但是内容还是值得一读，作者对 Go 语言的使用还是很熟练的。</li>
<li>《Go 语言高级编程》 <a href="https://github.com/chai2010/advanced-go-programming-book" target="_blank" rel="external nofollow noopener noreferrer">https://github.com/chai2010/advanced-go-programming-book</a> rpc 相关的内容可以一读。</li>
<li>Concurrency in Go</li>
</ol>
<p><a href="https://www.yuque.com/attachments/yuque/0/2019/pdf/182657/1571297377193-45707879-2de2-41bf-930f-47146ce64c1b.pdf" target="_blank" rel="external nofollow noopener noreferrer">Concurrency in Go.pdf</a></p>
<ol start="4">
<li><a href="https://tumregels.github.io/Network-Programming-with-Go/" target="_blank" rel="external nofollow noopener noreferrer">Network-Programming-with-Go</a></li>
</ol>
]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>IO 同步、异步及阻塞、非阻塞</title>
    <url>/post/d830a7d8.html</url>
    <content><![CDATA[<h4 id="网络-IO"><a href="#网络-IO" class="headerlink" title="网络 IO"></a>网络 IO</h4><p>一般情况下，一次网络 IO 读操作会涉及两个系统对象：(1) 用户进程 (线程) Process；(2) 内核对象 kernel，两个处理阶段：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[1] Waiting for the data to be ready - 等待数据准备好</span><br><span class="line">[2] Copying the data from the kernel to the process - 将数据从内核空间的buffer拷贝到用户空间进程的buffer</span><br></pre></td></tr></table></figure><a id="more"></a>


<p>阻塞与非阻塞指的是用户进程在发起调用后等待调用结果的状态，同步与异步指的是内核如何处理用户调用并如何将结果返回给用户进程。<br>阻塞与非阻塞关注的是单个进程（线程）的执行状态，同步和异步关注的是程序之间的协作关系（这里主要是用户进程与内核之间）。<br>异步一定不会造成阻塞，因此只有同步时才有阻塞与非阻塞之分。异步的实现一般是通过函数回调来实现，例如 Node.js 的回调函数，参见：<a href="https://www.cnblogs.com/chenyangyao/p/libuv_threadpool.html" target="_blank" rel="external nofollow noopener noreferrer">https://www.cnblogs.com/chenyangyao/p/libuv_threadpool.html</a>。<br>同步与异步的一个区别是，同步函数调用时返回的即为最终数据，异步调用不立即返回数据，可以在执行一些其他任务之后再来查看调用结果或者是在接到事件通知后查看结果。<br>异步 IO 中内核会负责将数据拷贝到用户态（或者使用内存映射），然后通知用户进程使用即可，而同步 IO 需要用户进程自行通过系统调用从内核拷贝数据。<br>同步 IO 中，对同一个描述符的操作必须是有序的。异步 IO 中，可以允许多方同时对同一个描述符发送 IO 请求，或者一次发送多个请求，当然需要有机制去区分这些请求。同步是线性的，异步可以认为是并发的（联想到 HTTP/1.1 和 HTTP/2 在发起大量 HTTP 请求时的不同表现）。<br>从总体的 CPU 效率来看，非阻塞不一定比阻塞更好，如果非阻塞是通过轮询查询数据是否准备好，虽然轮询的过程中可能穿插一些其它工作，但大概率会因为数据没有 ready 而致使 CPU 空转，虽然当前进程获取的时间片多了，但却存在大量的浪费，还不如进程阻塞被挂起，CPU 忙其它的工作。<br>阻塞、非阻塞、多路 IO 复用，都是同步 IO。真正的异步 IO 需要内核的深度参与。换句话说，只有用户线程在操作 IO 的时候根本不去考虑 IO 的执行全部都交给内核去完成，而自己只等待一个完成信号的时候，才是真正的异步 IO。所以，拉一个子线程去轮询、去死循环，或者使用 select、poll、epool，都不是异步。<br>Linux 中不存在完全异步的网络 IO，AIO 由于没有完善的网络 API，目前主要用于文件 IO，例如数据库或分布式存储后端，参见：<a href="https://www.zhihu.com/question/26943558" target="_blank" rel="external nofollow noopener noreferrer">https://www.zhihu.com/question/26943558</a>。<br>虽然 Linux 中主流的网络 IO 模型都是同步 IO ，但是基于多路复用和回调机制的 epoll 也是够用的。</p>
<h4 id="五类-IO-模型"><a href="#五类-IO-模型" class="headerlink" title="五类 IO 模型"></a>五类 IO 模型</h4><ol>
<li>完全阻塞</li>
</ol>
<p>两个处理阶段均阻塞。一个线程只处理一个连接。<br><img src="https://cdn.nlark.com/yuque/0/2019/png/182657/1575800282968-bce27934-e535-49b8-8c25-2945f7d2ce70.png#align=left&display=inline&height=291&name=image.png&originHeight=291&originWidth=550&size=33321&status=done&style=none&width=550" alt="image.png"></p>
<ol start="2">
<li>非阻塞</li>
</ol>
<p>检查数据是否准备好的阶段即阶段一不阻塞（一般是通过轮询实现，虽然不阻塞，但是一样低效，此时调用方处于忙等待，不被挂起，消耗 CPU 资源），阶段二阻塞。一个线程处理一个连接。<br><img src="https://cdn.nlark.com/yuque/0/2019/png/182657/1575800363874-2e57da37-f74c-4dd4-b75c-6a7db13bb99d.png#align=left&display=inline&height=291&name=image.png&originHeight=291&originWidth=550&size=40341&status=done&style=none&width=550" alt="image.png"></p>
<ol start="3">
<li>IO 多路复用</li>
</ol>
<p>两个阶段均阻塞，但是一个线程可以处理多个连接。虽然阶段一阻塞，但是被阻塞线程可以被挂起，阻塞期间不消耗 CPU 资源。<br><img src="https://cdn.nlark.com/yuque/0/2019/png/182657/1575800468227-7354dc16-071b-459d-a472-33103ef6e76d.png#align=left&display=inline&height=299&name=image.png&originHeight=299&originWidth=550&size=42845&status=done&style=none&width=550" alt="image.png"></p>
<ol start="4">
<li>信号驱动 IO</li>
</ol>
<p>阶段一创建信号即可，不需要监测描述符，不阻塞，阶段二阻塞。<br><img src="https://cdn.nlark.com/yuque/0/2019/png/182657/1575800792427-fc0c4e8f-336a-4c86-a3b0-646238b5c2ca.png#align=left&display=inline&height=313&name=image.png&originHeight=313&originWidth=550&size=44205&status=done&style=none&width=550" alt="image.png"></p>
<ol start="5">
<li>异步 IO</li>
</ol>
<p>两个阶段均不阻塞。<br><img src="https://cdn.nlark.com/yuque/0/2019/png/182657/1575800815863-ec7fe271-d1a0-4e49-a4ba-8e5d5990e151.png#align=left&display=inline&height=327&name=image.png&originHeight=327&originWidth=550&size=41762&status=done&style=none&width=550" alt="image.png"></p>
<ol start="6">
<li>总体比较</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2019/png/182657/1575804118240-0ad5c30f-e984-45fc-b945-a6ca192fefa7.png#align=left&display=inline&height=328&name=image.png&originHeight=328&originWidth=587&size=87015&status=done&style=none&width=587" alt="image.png"></p>
<h4 id="IO-多路复用"><a href="#IO-多路复用" class="headerlink" title="IO 多路复用"></a>IO 多路复用</h4><p>IO 多路复用是 Linux 网络编程用到的主流的 IO 模型。select，poll，epoll 都是 IO 多路复用的机制。I/O 多路复用通过一种机制，可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。 select，poll，epoll 本质上都是同步 I/O，因为他们都需要在读写事件就绪后由用户进程负责执行读写，且读写过程是阻塞的，而异步 I/O 则无需用户进程负责读写，异步 I/O 的实现会负责把数据从内核拷贝到用户空间。可以查阅三个分别使用 <a href="http://www.cnblogs.com/Anker/archive/2013/08/14/3258674.html" target="_blank" rel="external nofollow noopener noreferrer">select</a>，<a href="http://www.cnblogs.com/Anker/archive/2013/08/15/3261006.html" target="_blank" rel="external nofollow noopener noreferrer">poll</a>，<a href="http://www.cnblogs.com/Anker/archive/2013/08/17/3263780.html" target="_blank" rel="external nofollow noopener noreferrer">epoll</a> 编写的 echo 示例程序帮助理解三种机制的工作过程。<br>select 仅仅知道有 IO 事件发生，却并不知道发生在哪个 socket 上（可能有一个，多个甚至全部），所以只能无差别轮询所有 socket 找出可读或可写的 socket 进行操作。由于是轮询所以是 O(n)  的时间复杂度，socket 越多则轮询时间越长。<br>select 主要有三个问题：① 被监控的描述符集合大小被宏控制为 1024 （64 位机是 2048），数量太少；② 描述符集合需要从用户空间拷贝到内核空间，我们希望不要拷贝；③ 当被监控的描述符中有 IO 事件发生时，我们希望通知更精细一点，可以直接从通知中获取存在可读事件的描述符集合，而不是需要遍历整个描述符集合。<br>poll 本质上和 select 没有区别，poll 只是解决了 select 的第一个问题即描述符集合大小限制的问题，poll 使用了 pollfd 结构而不是 select 的 fd_set 结构，基于链表来存储描述符，所以没有最大连接数的限制。但是，poll 并没有改变大量描述符被复制于用户态和内核态的地址空间之间，以及个别描述符就绪触发整体描述符集合的遍历的低效问题。poll 随着监控的 socket 集合的增加性能线性下降，poll 不适合用于大并发场景。<br>epoll 可以理解为 event poll，不同于无差别轮询，epoll 会把哪个 socket 发生了怎样的 IO 事件通知我们。所以我们说 epoll 实际上是事件驱动的（每个事件关联上 socket ），此时我们对这些 socket 的操作都是有意义的（复杂度降低到了 O(1)）。Epoll 最大的优点就在于它只管 “活跃” 的连接，而跟连接总数无关，因此在实际的网络环境中，Epoll 的效率就会远远高于 select 和 poll。<br>epoll 解决 select 遗留的问题时主要借助两种思想：引入中间层和变集中处理为分散处理。每次调用 select 时都会进行一次描述符集合从用户空间到内核空间的拷贝，但实际上由于连续两次调用时描述符集合的变化很小，没必要每次都重新准备整个描述符集合，所以在 epoll 中引入了 epoll_ctl 系统调用，将描述符的增删改和高频调用的 epoll_wait 隔离开，在最初通过 epoll_create 创建 epoll 描述符后，会立即将监听 socket 的描述符通过 epoll_ctl 调用加入到描述符集合中，随后只有在需要监控的描述符集合发生变化时才会通过 epoll_ctl 去增删改，而 epoll_wait 调用并不会重新复制描述符集合到内核空间，这样就将 select 中的大块的内存拷贝（集中处理）分散为了低频的小块内存拷贝（分散处理）。同时，对于高频 epoll_wait 调用返回可读就绪的描述符集合时的拷贝问题，epoll 通过内核与用户空间 mmap (内存映射) 同一块内存来解决。mmap 将用户空间的一块地址和内核空间的一块地址同时映射到相同的一块物理内存地址（不管是用户空间还是内核空间都是虚拟地址，最终要通过地址映射映射到物理地址），使得这块物理内存对内核和对用户均可见，减少用户态和内核态之间的数据交换。<br>另外，epoll 通过 epoll_ctl 来对监控的描述符集合来进行增、删、改，那么必须涉及到描述符的快速查找问题，于是，一个低时间复杂度的增、删、改、查的数据结构来组织被监控的描述符集合是必不可少的了。在 linux 2.6.8 之前的内核，epoll 使用散列表来组织描述符集合，于是在创建 epoll 描述符的时候，epoll 需要初始化散列表的大小。于是 epoll_create (int size) 有一个参数 size，以便内核根据 size 的大小来分配散列表的大小。在 linux 2.6.8 以后的内核中，epoll 使用红黑树来组织监控的描述符集合，于是 epoll_create (int size) 的参数 size 实际上已经没有意义了。<br>epoll 巧妙的引入一个中间层解决了大量监控 socket 的无效遍历问题。epoll 在中间层上为每个监控的 socket 准备了一个单独的回调函数 epoll_callback_sk，而对于 select，所有的 socket 都共用一个相同的回调函数。正是这个单独的回调 epoll_callback_sk 使得每个 socket 都能单独处理自身，当自己就绪的时候将自身 socket 挂入 epoll 的 ready_list。同时，epoll 引入了一个睡眠队列 single_epoll_wait_list，分割了两类睡眠等待。process 不再睡眠在所有的 socket 的睡眠队列上，而是睡眠在 epoll 的睡眠队列上等待“任意一个 socket 可读就绪”事件。而中间 wait_entry_sk 则代替 process 睡眠在具体的 socket 上，当 socket 就绪的时候，它就可以处理自身了。<br>关于更多 epoll 边沿触发和水平触发的内容参考：<a href="https://cloud.tencent.com/developer/article/1005481" target="_blank" rel="external nofollow noopener noreferrer">https://cloud.tencent.com/developer/article/1005481</a>。简单理解，边沿触发只有新的数据到达时会被触发（就算有未读完的数据也必须等到新数据到来后触发才能继续读），而水平触发只要有数据可读就会被触发（可能是上次触发后数据未读完）。而相对的，边沿触发由于只会在新的数据到来时才会通知到用户进程，所以 epoll_wait 返回的描述符集合可能会小于使用水平触发，所以有边沿触发效率更高的说法。但假如那些被边沿触发忽略掉的而被水平触发返回的可读描述符仍然是你需要读取的对象，那水平触发可能效率更高，因为你可以更快的读完剩余数据而不是必须等到新数据的到来。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>IO</tag>
      </tags>
  </entry>
  <entry>
    <title>IPVS 模式下 NodePort 的工作过程浅析</title>
    <url>/post/4c49613e.html</url>
    <content><![CDATA[<p>###</p>]]></content>
      <categories>
        <category>Kubernetes</category>
      </categories>
      <tags>
        <tag>kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>K8S PVC 在线扩容</title>
    <url>/post/99dfe25e.html</url>
    <content><![CDATA[<ol>
<li>创建 storageclass 时加入 allowVolumeExpansion: true 参数。</li>
</ol><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">storage.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">StorageClass</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">ceph-rbd</span></span><br><span class="line"><span class="attr">parameters:</span> <span class="string">...</span></span><br><span class="line"><span class="attr">provisioner:</span> <span class="string">kubernetes.io/rbd</span></span><br><span class="line"><span class="attr">allowVolumeExpansion:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">reclaimPolicy:</span> <span class="string">Delete</span></span><br><span class="line"><span class="attr">volumeBindingMode:</span> <span class="string">Immediate</span></span><br></pre></td></tr></table></figure><a id="more"></a>


<ol>
<li>在所有 master 节点上安装好 ceph-common 包，并且拷贝 ceph 配置文件到每个 master 节点的 /etc/ceph 目录，确保 <code>ceph -s</code> 能够输出正常的结果。</li>
<li>执行以下命令从某一 kube-controller-manager 容器中拷贝出 kube-controller-manager 可执行文件以备后用：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl -n kube-system cp kube-controller-manager-节点名:usr&#x2F;local&#x2F;bin&#x2F;kube-controller-manager .</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>基于 ceph 基础镜像重新打包一个包含有 rbd 命令的 kube-controller-manager 容器镜像。ceph 基础镜像的版本要和部署好的 ceph 集群的版本一致，通过 <code>ceph -v</code> 查看版本，例如 ceph 版本是 12.2.4 ，则通过 dockerhub 可以获取到 ceph 12.2.4 的基础镜像：<a href="https://hub.docker.com/r/ceph/ceph-amd64/tags" target="_blank" rel="external nofollow noopener noreferrer">https://hub.docker.com/r/ceph/ceph-amd64/tags</a>, 然后使用以下 Dockerfile 文件重新打包镜像：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FROM ceph&#x2F;ceph-amd64:v12.2.4-20190828</span><br><span class="line"># 将上一步获取的 kube-controller-manager 与此 Dockerfile 置于同一目录</span><br><span class="line">ADD kube-controller-manager &#x2F;usr&#x2F;local&#x2F;bin&#x2F;kube-controller-manager</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>使用上述 Dockerfile 执行以下命令打包，镜像名称和标签可以自定义，标签最好和原始的 kube-controller-manager 保持一致：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker build -t kube-controller-manager-ceph-v12.2.4:v1.13.3 .</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>执行以下命令导出镜像并上传至所有 master 节点后倒入：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 导出镜像</span><br><span class="line">docker save kube-controller-manager-ceph-v12.2.4:v1.13.3 | gzip -c &gt; kube-controller-manager.tar.gz</span><br><span class="line"># 上传至 master 节点</span><br><span class="line">scp kube-controller-manager.tar.gz root@master1:.</span><br><span class="line"># 登录至 master 节点并执行以下命令倒入镜像</span><br><span class="line">docker load &lt; kube-controller-manager.tar.gz</span><br><span class="line"># 以上步骤需要在所有 master 节点执行</span><br></pre></td></tr></table></figure>

<ol start="7">
<li>修改 kube-api-server / kube-controller-manager / kubelet 配置以启用 ExpandInUsePersistentVolumes:</li>
</ol>
<p>/etc/kubernetes/manifests/kube-apiserver.yaml 中添加 feature-gates 参数：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">...</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">command:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">kube-apiserver</span></span><br><span class="line">    <span class="string">...</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">--feature-gates=ExpandInUsePersistentVolumes=true</span></span><br></pre></td></tr></table></figure>

<p>/etc/kubernetes/manifests/kube-controller-manager.yaml 中添加 feature-gates 参数并替换镜像为之前重新制作的镜像，另外需要将宿主机上的 ceph 配置目录挂载到 kube-controller-manager 容器中：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">...</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">command:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">kube-controller-manager</span></span><br><span class="line">    <span class="string">...</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">--feature-gates=ExpandInUsePersistentVolumes=true</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">kube-controller-manager-ceph-v12.2.4:v1.13.3</span></span><br><span class="line">    <span class="string">...</span></span><br><span class="line">    <span class="attr">volumeMounts:</span></span><br><span class="line">    <span class="string">...</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">mountPath:</span> <span class="string">/etc/ceph</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">ceph-config</span></span><br><span class="line">      <span class="attr">readOnly:</span> <span class="literal">true</span></span><br><span class="line">  <span class="string">...</span></span><br><span class="line">  <span class="attr">volumes:</span></span><br><span class="line">  <span class="string">...</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">hostPath:</span></span><br><span class="line">      <span class="attr">path:</span> <span class="string">/etc/ceph</span></span><br><span class="line">      <span class="attr">type:</span> <span class="string">Directory</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">ceph-config</span></span><br></pre></td></tr></table></figure>

<p>以上关于 kube-apiserver 和 kube-controller-manager 的操作需要在所有 master 节点上执行，kubelet 会监听到相关文件的变化并自动应用这些更新。</p>
<p>/etc/systemd/system/kubelet.service.d/10-kubeadm.conf 中更改 ExecStart 项增加 feature-gates 参数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ExecStart&#x3D;&#x2F;usr&#x2F;bin&#x2F;kubelet --feature-gates&#x3D;ExpandInUsePersistentVolumes&#x3D;true ...</span><br></pre></td></tr></table></figure>

<p>修改后需要执行以下命令使更改生效：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl restart kubelet</span><br></pre></td></tr></table></figure>

<p>以上关于 kubelet 的修改需要再所有计算节点上执行。 8. 执行完所有以上操作后即可对使用该 storgeclass 的 PVC 进行动态在线扩容。</p>
]]></content>
      <categories>
        <category>Kubernetes</category>
      </categories>
      <tags>
        <tag>Ceph</tag>
        <tag>Kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>Keepalived 和 Kubeadm 部署高可用 Kubernetes</title>
    <url>/post/c9063311.html</url>
    <content><![CDATA[<h3 id="准备-k8s-离线安装包"><a href="#准备-k8s-离线安装包" class="headerlink" title="准备 k8s 离线安装包"></a>准备 k8s 离线安装包</h3><p>在 k8s Github 仓库的 <a href="https://github.com/kubernetes/kubernetes/releases" target="_blank" rel="external nofollow noopener noreferrer">Release 页面</a>  找到最新稳定版本，点击对应的如   <a href="https://github.com/kubernetes/kubernetes/blob/master/CHANGELOG-1.14.md#downloads-for-v1142" target="_blank" rel="external nofollow noopener noreferrer">CHANGELOG-1.14.md</a>  链接进入该版本的安装包下载页面。分别下载 AMD64 版本的 Server 和 Node 安装包  <a href="https://dl.k8s.io/v1.14.2/kubernetes-server-linux-amd64.tar.gz" target="_blank" rel="external nofollow noopener noreferrer">kubernetes-server-linux-amd64.tar.gz</a>  与  <a href="https://dl.k8s.io/v1.14.2/kubernetes-node-linux-amd64.tar.gz" target="_blank" rel="external nofollow noopener noreferrer">kubernetes-node-linux-amd64.tar.gz</a>。然后使用 tar 命令解压缩并将所有文件汇总到一个集中的目录，如下，其中 coredns、etcd 和 pause 的镜像不包含在上述两个压缩包中，需要自行下载：</p><a id="more"></a>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#tree -L 2 kubernetes-1.14.2</span></span><br><span class="line">kubernetes-1.14.2</span><br><span class="line">├── apiextensions-apiserver</span><br><span class="line">├── cloud-controller-manager</span><br><span class="line">├── hyperkube</span><br><span class="line">├── images</span><br><span class="line">│   ├── cloud-controller-manager.tar</span><br><span class="line">│   ├── coredns.tar</span><br><span class="line">│   ├── etcd.tar</span><br><span class="line">│   ├── kube-apiserver.tar</span><br><span class="line">│   ├── kube-controller-manager.tar</span><br><span class="line">│   ├── kube-proxy.tar</span><br><span class="line">│   ├── kube-scheduler.tar</span><br><span class="line">│   └── pause.tar</span><br><span class="line">├── kubeadm</span><br><span class="line">├── kube-apiserver</span><br><span class="line">├── kube-controller-manager</span><br><span class="line">├── kubectl</span><br><span class="line">├── kubelet</span><br><span class="line">├── kube-proxy</span><br><span class="line">├── kube-scheduler</span><br><span class="line">└── mounter</span><br></pre></td></tr></table></figure>

<h3 id="准备-ansible-环境和脚本"><a href="#准备-ansible-环境和脚本" class="headerlink" title="准备 ansible 环境和脚本"></a>准备 ansible 环境和脚本</h3>]]></content>
      <categories>
        <category>kubernetes</category>
      </categories>
      <tags>
        <tag>kubernetes</tag>
        <tag>云计算</tag>
      </tags>
  </entry>
  <entry>
    <title>K8S集成Keystone认证</title>
    <url>/post/699b195d.html</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th align="center">Date</th>
<th align="center">Log</th>
</tr>
</thead>
<tbody><tr>
<td align="center">12/02/2019</td>
<td align="center">初始版本.</td>
</tr>
</tbody></table><h3 id="解决什么问题"><a href="#解决什么问题" class="headerlink" title="解决什么问题"></a>解决什么问题</h3><p>本文尝试解决的问题有两个：</p><ul>
<li>K8S 中虽然有用户的概念，但 K8S 本身并不管理用户以及认证过程，而是提供了多种方式来接入外部用户管理系统。</li>
<li>K8S 并不能提供物理隔离的多租户能力，但软多租户的实现仍然是有意义的，在一定程度上可以解决每个用户独占一个集群的问题。</li>
</ul><a id="more"></a>


<p>上述问题的解决方案其实是很多的，也可以自己开发相应的功能组件，这里选择 Keystone 来解决该问题的原因主要有：</p>
<ul>
<li>Keystone 本身是一个非常完备的认证系统，具有完整的域、项目、用户、角色等概念体系和文档完善的 Restful API，可以省去大量的开发工作，尤其适合规模比较小的开发团队拿来即用。</li>
<li>大量私有云用户已经使用了 OpenStack 作为基础设施管理平台，在该平台基础上引入 K8S 时可以直接使用 OpenStack 中部署好的 Keystone。</li>
<li>社区为 K8S 开发了 cloud-provider-openstack，其中就包括对 Keystone 的大量支持性工作，大大降低了用户自行对接使用的难度。</li>
<li>我曾经从事过一段时间的基于 OpenStack 的云管平台的开发，对 Keystone 有一定使用经验。</li>
</ul>
<p>当然，使用 Keystone 的问题也不少，主要有以下几个方面：</p>
<ul>
<li>Keystone 本身具有一定的复杂性，有一定的学习成本，一些功能用不到。</li>
<li>Keystone 的部署也相对麻烦。整个 OpenStack 项目都有着部署麻烦的问题。</li>
<li>Keystone 在 R 版本之后只支持基于 Fernet 标准的 Token 生成方式。 Fernet token 虽然和 Json Web Token 类似也是一种非持久化 Token，但是其受众群体显然不如 JWT 广，不利于和集群中其它功能模块的集成。一个例子就是，目前 Istio 的认证过程只支持 JWT，这使得无法直接使用 Keystone 作为 Istio 的认证服务器。</li>
</ul>
<p>要完成整个系统的搭建，显然我们需要进行以下几个步骤：</p>
<ul>
<li>部署一个 K8S 集群；</li>
<li>部署 Keystone；</li>
<li>部署支撑 Keystone 与 K8S 集成的插件。</li>
</ul>
<p>在以上步骤中，部署 K8S 相对资料比较齐全，不再赘述，下面主要介绍剩余步骤。</p>
<h3 id="部署-Keystone"><a href="#部署-Keystone" class="headerlink" title="部署 Keystone"></a>部署 Keystone</h3><p>部署 Keystone 是假设用户本身并不具有处于可用状态的 Keystone 服务。</p>
<p>部署 Keystone 可以有多种形式，包括：</p>
<ul>
<li>直接在虚拟机或物理机中部署；</li>
<li>使用 Docker 进行容器化部署；</li>
<li>在 K8S 集群中部署。</li>
</ul>
<p>这里在 K8S 集群中部署 Keystone 服务。</p>
<h4 id="Keystone-镜像的构建"><a href="#Keystone-镜像的构建" class="headerlink" title="Keystone 镜像的构建"></a>Keystone 镜像的构建</h4><p>OpenStack 容器化部署一直是社区想要解决的问题，Kolla 项目就是为此而生并已经生产可用，但是由于 OpenStack 部署牵涉到的配置选项太多，使用 Kolla 部署仍然没有达到令人欢欣的简单。</p>
<p>我尝试通过 Kolla 生成 Keystone 项目的部署镜像，但是由于国内网络的种种问题以及 OpenStack 的庞大的 Python 依赖体系以及漏洞百出的官方部署文档，该过程并没有顺利完成。</p>
<p>基督徒无奈时应会求助于上帝，程序员无助时多会逛一逛 Github 撞撞运气。</p>
<p>幸运的是我真的找到了一个容器化部署 Keystone 的开源项目，地址<a href="https://github.com/dixudx/keystone-docker" target="_blank" rel="external nofollow noopener noreferrer">在此</a>，加上我刚点的星星，总共只有十颗星星，最近更新是 18 年 9 月，但文档写的很是详细，决定一试。</p>
<p>把文档读了一遍，开始动手，看到可以设置 Keystone 版本信息，本着不用最新版的程序员不是一个好极客的理念，果断使用 Keystone 最新发布版本 14.0.1。</p>
<p>另外数据库决定使用已经部署在集群中的 TiDB 分布式数据库，因为默认端口是 4000 这个莫名其妙的数字，所以需要改一下该项目中使用到数据库的代码，并在数据库中创建 keystone 用户。之后开始打包镜像，过程很顺利，打包好的镜像上传到了 dockerhub 上 xyc11223344/keystone.</p>
<h4 id="Keystone-部署"><a href="#Keystone-部署" class="headerlink" title="Keystone 部署"></a>Keystone 部署</h4><p>部署所用 yaml 文件如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Namespace</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">keystone</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">keystone</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">keystone</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">keystone</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">35357</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">internal</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">5000</span></span><br><span class="line">      <span class="attr">nodePort:</span> <span class="number">31221</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">public</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">keystone</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">NodePort</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">keystone</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">keystone</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">keystone</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">keystone</span></span><br><span class="line">  <span class="attr">strategy:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">Recreate</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">namespace:</span> <span class="string">keystone</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">keystone</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">xyc11223344/keystone</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">keystone</span></span><br><span class="line">          <span class="attr">imagePullPolicy:</span> <span class="string">Always</span></span><br><span class="line">          <span class="attr">ports:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">35357</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">5000</span></span><br><span class="line">          <span class="attr">env:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">KEYSTONE_DB_HOST</span></span><br><span class="line">              <span class="attr">value:</span> <span class="string">"test-tidb.test-tidb"</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">KEYSTONE_DB_ROOT_PASSWD_IF_REMOTED</span></span><br><span class="line">              <span class="attr">value:</span> <span class="string">"test"</span></span><br><span class="line">          <span class="attr">volumeMounts:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">tz-config</span></span><br><span class="line">              <span class="attr">mountPath:</span> <span class="string">/etc/localtime</span></span><br><span class="line">              <span class="attr">readOnly:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">volumes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">tz-config</span></span><br><span class="line">          <span class="attr">hostPath:</span></span><br><span class="line">            <span class="attr">path:</span> <span class="string">/etc/localtime</span></span><br></pre></td></tr></table></figure>

<p>首次部署后，Pod 一直起不来，kubectl logs 查看 Pod 日志，发现是初始化 Keystone 数据库时报错，提示 Alter database keystone charset 不支持，根据报错信息，发现相关操作在 TiDB 中不兼容，因为 Keystone 本来支持的是 MySQL 数据库，TiDB 虽然号称兼容 MySQL，但是仍然有一些不常用的 DML 操作不支持。</p>
<p>我尝试直接在 Keystone Python 代码中删除掉了该操作，但是再次部署时又出现了其它数据库操作兼容性问题。Keystone 数据库初始化是通过 keystone-manage db_sync 命令执行的，具体的代码我没有去分析，不过从 log 来看，它首先创建了一个空的数据库，然后生成老版本的各个 table ，之后再根据安装的目标版本一步一步升级到最新的，所以出现了大量的数据库变更 ALTER 操作，而不是直接初始化到目标版本完事儿。鉴于此，直接改 Python 代码貌似不可行，转念一想，决定重新部署一个 MySQL 数据库，然后使用该数据库完成初始化工作，获取到最终形态的数据库之后，dump 整个数据库到一个 sql 文件，再导入到 TiDB 数据库中，由于是最终形态，应当不会有 ALTER 操作出现。之后的尝试过程成功进行，获取到了最新版本的数据库 dump 文件，以后部署需要手动导入该文件而不能通过 Keystone 容器启动脚本中的 db_sync 命令完成，虽然解决了兼容性问题，显然该数据库只适应于当前 14.0.1 版本的 Keystone，以后每次更换版本仍然需要重新生成数据库 dump 文件。</p>
<p>解决了数据库问题之后，再次部署，又出现了新的问题，查看 keystone pod log 问题大概是找不到名为 uuid 的 token provider，猜测大概是 OpenStack 升级后配置也发生了一些变化，先到上述开源项目中找到 keystone 配置文件果然找到一段配置，如下：</p>
<figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="section">[token]</span></span><br><span class="line"><span class="attr">expiration</span> = <span class="number">3600</span></span><br><span class="line"><span class="attr">provider</span> = uuid</span><br><span class="line"><span class="attr">driver</span> = memcache</span><br><span class="line"><span class="attr">caching</span> = <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>显然，问题出在 provider = uuid 这项配置，Google 一下，根据官方文档的说法，从 R 版本开始不再支持 uuid 作为 token provider，目前支持 fernet，应当是基于安全和性能考虑作出的变更。</p>
<p>之后将配置更改为：</p>
<figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="section">[token]</span></span><br><span class="line"><span class="attr">expiration</span> = <span class="number">3600</span></span><br><span class="line"><span class="attr">provider</span> = fernet</span><br><span class="line"><span class="attr">driver</span> = memcache</span><br><span class="line"><span class="attr">caching</span> = <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>重新打包镜像后尝试部署，仍然报错，这次是找不到 fernet 相关的 key 文件，应当是 fernet 需要额外的一些部署操作，查看官方文档后，在镜像启动脚本中添加了以下命令:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">keystone-manage fernet_setup --keystone-user keystone --keystone-group keystone</span><br><span class="line">keystone-manage credential_setup --keystone-user keystone --keystone-group keystone</span><br></pre></td></tr></table></figure>

<p>再次重新打包镜像，重新部署，部署成功。curl 访问一下，结果如下：<br><img src="https://cdn.nlark.com/yuque/0/2019/png/182657/1575441061446-d961a9d8-bb54-44c9-ab3e-e63b839554bf.png#align=left&display=inline&height=780&name=image.png&originHeight=780&originWidth=1124&size=108671&status=done&style=none&width=1124" alt="image.png"></p>
<p>因为做了一些改动，所以将原来的 keystone 容器化部署开源项目做了一些修改，并提交到了<a href="https://github.com/XiaYinchang/keystone" target="_blank" rel="external nofollow noopener noreferrer">这里</a>.</p>
<h3 id="部署-K8S-与-Keystone-集成的支持插件"><a href="#部署-K8S-与-Keystone-集成的支持插件" class="headerlink" title="部署 K8S 与 Keystone 集成的支持插件"></a>部署 K8S 与 Keystone 集成的支持插件</h3><p>根据<a href="https://github.com/kubernetes/cloud-provider-openstack" target="_blank" rel="external nofollow noopener noreferrer">cloud-provider-openstack</a>的使用说明文档，我们这里主要使用到两个插件：</p>
<ul>
<li>k8s-keystone-auth: 实现了 Kubernetes webhook authentication 插件接口，将 Keystone 以 webhook 的形式接入到 K8S 认证过程。</li>
<li>client-keystone-auth: 用于在如 kubectl 等命令行工具端接入 Keystone 认证。</li>
</ul>
<h4 id="k8s-keystone-auth-的部署"><a href="#k8s-keystone-auth-的部署" class="headerlink" title="k8s-keystone-auth 的部署"></a>k8s-keystone-auth 的部署</h4><p>从配置项看，k8s-keystone-auth 的核心功能有三项：接入 Keystone 的认证、接入 Keystone 的鉴权和同步 Keystone 中的项目及角色绑定。其中，接入认证是必选项，其它两项可选。</p>
<p>这里，只使用接入 Keystone 认证和同步 Keystone 中项目及角色绑定两项，鉴权使用 K8S 本身的 RBAC。</p>
<p>同步功能的配置均以 configmap 的形式提供，如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ConfigMap</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">k8s-sync-config</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kube-system</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line">  <span class="attr">syncConfig:</span> <span class="string">|</span></span><br><span class="line">    <span class="string">data_types_to_sync":</span> <span class="string">["projects",</span> <span class="string">"role_assignments"</span><span class="string">]</span></span><br><span class="line">    <span class="attr">"namespace_format":</span> <span class="string">"%n-%i"</span></span><br><span class="line">    <span class="attr">"projects_black_list":</span> <span class="string">[]</span></span><br></pre></td></tr></table></figure>

<p>注意，k8s-keystone-auth 必须部署在 kube-system 命名空间中，因为我在查看源代码时发现命名空间被 hard coded 了。</p>
<p>由于 k8s-keystone-auth 需要使用到命名空间中的默认 serviceaccount 来操作 K8S 集群包括创建命名空间和 rolebinding 等，所以要为 kube-system:default 服务账户创建 clusterrolebinding，如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl create clusterrolebinding key-auth-cluster-admin --clusterrole=cluster-admin --serviceaccount=kube-system:default</span><br></pre></td></tr></table></figure>

<p>另外 K8S 使用 https 协议，所以需要提供 tls 认证证书，这里直接使用 master 节点宿主机上的证书创建一个 secret ，然后挂载到 k8s-keystone-auth pod 中使用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl create secret generic keystone-auth-certs --from-file&#x3D;cert-file&#x3D;&#x2F;etc&#x2F;kubernetes&#x2F;pki&#x2F;apiserver.crt --from-file&#x3D;key-file&#x3D;&#x2F;etc&#x2F;kubernetes&#x2F;pki&#x2F;apiserver.key -n kube-system</span><br></pre></td></tr></table></figure>

<p>然后，创建 k8s-keystone-auth 的部署文件如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">k8s-keystone-auth</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kube-system</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">k8s-keystone-auth</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">2</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">k8s-keystone-auth</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">k8s-keystone-auth</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">k8s-keystone-auth</span></span><br><span class="line">          <span class="attr">image:</span> <span class="string">xyc11223344/k8s-keystone-auth:v1.0</span></span><br><span class="line">          <span class="attr">imagePullPolicy:</span> <span class="string">Always</span></span><br><span class="line">          <span class="attr">args:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">/bin/k8s-keystone-auth</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">--v=10</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">--tls-cert-file</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">/etc/kubernetes/pki/cert-file</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">--tls-private-key-file</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">/etc/kubernetes/pki/key-file</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">--sync-configmap-name</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">k8s-sync-config</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">--keystone-url</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">http://keystone.keystone:5000/v3</span></span><br><span class="line">          <span class="attr">env:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">KEYSTONE_SYNC_CONFIGMAP_NAME</span></span><br><span class="line">              <span class="attr">value:</span> <span class="string">k8s-sync-config</span></span><br><span class="line">          <span class="attr">volumeMounts:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">mountPath:</span> <span class="string">/etc/kubernetes/pki</span></span><br><span class="line">              <span class="attr">name:</span> <span class="string">k8s-certs</span></span><br><span class="line">              <span class="attr">readOnly:</span> <span class="literal">true</span></span><br><span class="line">          <span class="attr">ports:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">8443</span></span><br><span class="line">      <span class="attr">volumes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">k8s-certs</span></span><br><span class="line">          <span class="attr">secret:</span></span><br><span class="line">            <span class="attr">secretName:</span> <span class="string">keystone-auth-certs</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">k8s-keystone-auth-service</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kube-system</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">k8s-keystone-auth</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">nodePort:</span> <span class="number">32189</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">8443</span></span><br><span class="line">      <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">      <span class="attr">targetPort:</span> <span class="number">8443</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">NodePort</span></span><br></pre></td></tr></table></figure>

<p>第一次部署时使用的是社区提供的 k8scloudprovider/k8s-keystone-auth 镜像，结果部署时一堆报错，先是无法识别 sync-configmap-name 传进去的参数，源代码一看有个很明显的错误，赋值时用错了变量。</p>
<p>没办法重新编译了镜像后尝试部署，又出现报错，干脆直接 panic。看了一下社区源码，有个指针声明一下，未赋值就拿来直接用了，再改了后重新编译，并将镜像传至 xyc11223344/k8s-keystone-auth:v1.0。</p>
<p>再次部署，成功运行起来。然后，需要修改 kube-apiserver 的配置文件，使用 webhook 来进行认证。首先，需要创建 webhook 的配置文件如下，需要注意的是 kube-apiserver 是以静态容器的形式启动的，无法访问集群内的服务 VIP，所以需要使用 NodePort 来访问刚刚部署好的 k8s-keystone-auth 服务：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Config</span></span><br><span class="line"><span class="attr">preferences:</span> <span class="string">&#123;&#125;</span></span><br><span class="line"><span class="attr">clusters:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">cluster:</span></span><br><span class="line">      <span class="attr">insecure-skip-tls-verify:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">server:</span> <span class="string">https://10.10.144.75:32189/webhook</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">webhook</span></span><br><span class="line"><span class="attr">users:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">webhook</span></span><br><span class="line"><span class="attr">contexts:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">context:</span></span><br><span class="line">      <span class="attr">cluster:</span> <span class="string">webhook</span></span><br><span class="line">      <span class="attr">user:</span> <span class="string">webhook</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">webhook</span></span><br><span class="line"><span class="attr">current-context:</span> <span class="string">webhook</span></span><br></pre></td></tr></table></figure>

<p>之后将 webhook 配置文件拷贝到每一个 master 节点的 /etc/kubernetes/pki/webhookconfig.yaml 路径， 这是因为该配置文件需要被 kube-apiserver 容器访问到，而 /etc/kubernetes 路径已经以 hostPath 的形式挂载到了 kube-apiserver 容器中，所以放到宿主机上该路径下的文件可以直接被容器访问到。</p>
<p>接下来，更改 kube-apiserver 的启动参数，编辑 /etc/kubernetes/manifests/kube-apiserver.yaml 如下，增加了一行内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--authentication-token-webhook-config-file&#x3D;&#x2F;etc&#x2F;kubernetes&#x2F;pki&#x2F;webhookconfig.yaml</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.nlark.com/yuque/0/2019/png/182657/1575441117777-1a84f269-f9cb-4f21-b149-f3a9979f981d.png#align=left&display=inline&height=1128&name=image.png&originHeight=1128&originWidth=1268&size=287983&status=done&style=none&width=1268" alt="image.png"></p>
<h4 id="client-keystone-auth-的部署"><a href="#client-keystone-auth-的部署" class="headerlink" title="client-keystone-auth 的部署"></a>client-keystone-auth 的部署</h4><p>先编译出 client-keystone-aut 可执行文件，并放到 master 任意路径，这里放在 /usr/local/bin/client-keystone-auth。然后，执行以下命令创建一个 user ：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl config set-credentials admin</span><br></pre></td></tr></table></figure>

<p>执行后，查看 ~/.kube/config，发现，多出一个 user，如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">users:</span><br><span class="line">- name: admin</span><br><span class="line">  user: &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>修改上述 config 文件如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">users:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">admin</span></span><br><span class="line">    <span class="attr">user:</span></span><br><span class="line">      <span class="attr">exec:</span></span><br><span class="line">        <span class="attr">apiVersion:</span> <span class="string">client.authentication.k8s.io/v1beta1</span></span><br><span class="line">        <span class="attr">command:</span> <span class="string">/usr/local/bin/client-keystone-auth</span></span><br></pre></td></tr></table></figure>

<p>接着执行以下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl config set-context --cluster&#x3D;kubernetes --user&#x3D;admin keystone-admin@kubernetes</span><br><span class="line">kubectl config use-context keystone-admin@kubernetes</span><br></pre></td></tr></table></figure>

<p>此时再执行 kubectl 命令会提示输入 Keystone 相关认证信息。也可以提前设置好如下环境变量：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export OS_DOMAIN_NAME&#x3D;Default</span><br><span class="line">export OS_PROJECT_NAME&#x3D;admin</span><br><span class="line">export OS_USERNAME&#x3D;admin</span><br><span class="line">export OS_PASSWORD&#x3D;test</span><br><span class="line">export OS_AUTH_URL&#x3D;http:&#x2F;&#x2F;10.10.144.75:31221&#x2F;v3</span><br><span class="line">export OS_IDENTITY_API_VERSION&#x3D;3</span><br></pre></td></tr></table></figure>

<p>设置好环境变量后使用 kubectl 依然会提示 unauthorized，这是因为 admin 用户并没有权限访问集群资源，admin 用户目前只有权限访问从 keystone 同步过来的项目。执行以下命令，切换 kubectl 认证信息为集群初始的管理员：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl config use-context kubernetes-admin@kubernetes</span><br></pre></td></tr></table></figure>

<p>此时执行 kubectl get ns 可以发现，keystone 中的项目已经同步过来了，列表中第一个命名空间就是从 Keystone 同步过来的项目，命名规则和我们设置的一致，即项目名-项目 ID：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2019/png/182657/1575441145645-fc76fed8-5251-442c-897c-ec854e8fbdf8.png#align=left&display=inline&height=204&name=image.png&originHeight=204&originWidth=792&size=37633&status=done&style=none&width=792" alt="image.png"></p>
<p>刚刚我们说到 keystone-admin<a href>@kubernetes </a> context 只有权限访问从 Keystone 同步过来的项目，也就是这个列表中的第一个命名空间，其它命名空间都是无权限访问的。</p>
<p>另外 kubernetes 中默认已经有 admin 、 edit 和 view 三个 clusterrole，而 keystone 默认的三种角色是 admin、 member 和 reader， 为了同步时的一致性，这里将 keystone 中的角色改为和 kubernetes 中一致，如下：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2019/png/182657/1575441171154-0092ca7c-9d67-46e0-8d07-752a98a02951.png#align=left&display=inline&height=614&name=image.png&originHeight=614&originWidth=778&size=107346&status=done&style=none&width=778" alt="image.png"></p>
<p>之后，到 admin-b97a1f63205743ce8e33356243774fbc 中查看 rolebinding ：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2019/png/182657/1575441193681-709aa70d-5835-46dc-a67a-57b10339e0da.png#align=left&display=inline&height=172&name=image.png&originHeight=172&originWidth=1316&size=66169&status=done&style=none&width=1316" alt="image.png"></p>
<h3 id="如何解决了问题"><a href="#如何解决了问题" class="headerlink" title="如何解决了问题"></a>如何解决了问题</h3><p>针对文章开篇提到的两个问题，一个是认证系统的问题，一个是软多租户的问题。</p>
<p>针对认证系统的问题，k8s-keystone-auth 插件提供了解决方案。</p>
<p>针对软多租户的问题，可以借由 keystone 的租户管理概念来实现。</p>
<p>而对于 kubectl 命令行工具，client-keystone-auth 插件提供了支持，通过对不同用户可访问命名空间的限制来实现命令行端的权限管控。</p>
]]></content>
      <categories>
        <category>Kubernetes</category>
      </categories>
      <tags>
        <tag>Kubernetes</tag>
        <tag>云计算</tag>
        <tag>Keystone</tag>
      </tags>
  </entry>
  <entry>
    <title>Keycloak 使用过程记录</title>
    <url>/post/e4c4afae.html</url>
    <content><![CDATA[<h4 id="keycloak-js-sdk"><a href="#keycloak-js-sdk" class="headerlink" title="keycloak js sdk"></a>keycloak js sdk</h4><p>Angular 版本的 SDK ：<a href="https://www.npmjs.com/package/keycloak-angular" target="_blank" rel="external nofollow noopener noreferrer">https://www.npmjs.com/package/keycloak-angular</a>。为了实现 Token 刷新可以采用以下方式：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">keycloak.onTokenExpired = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'token expired'</span>, keycloak.token);</span><br><span class="line">    keycloak.updateToken(<span class="number">30</span>).success(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'successfully get a new token'</span>, keycloak.token);</span><br><span class="line">        ...</span><br><span class="line">    &#125;).error(<span class="function"><span class="params">()</span> =&gt;</span> &#123;...&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a>


<h4 id="Keycloak-使用-LDAP"><a href="#Keycloak-使用-LDAP" class="headerlink" title="Keycloak 使用 LDAP"></a>Keycloak 使用 LDAP</h4><p><a href="https://codehumsafar.wordpress.com/tag/ldap-with-keycloak/" target="_blank" rel="external nofollow noopener noreferrer">https://codehumsafar.wordpress.com/tag/ldap-with-keycloak/</a></p>
<h4 id="导出-Realm-和-User"><a href="#导出-Realm-和-User" class="headerlink" title="导出 Realm 和 User"></a>导出 Realm 和 User</h4><p>参考：<a href="https://stackoverflow.com/questions/46281416/best-practices-of-export-import-keycloak-data-in-kubernetes" target="_blank" rel="external nofollow noopener noreferrer">https://stackoverflow.com/questions/46281416/best-practices-of-export-import-keycloak-data-in-kubernetes</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;standalone.sh -Dkeycloak.migration.realmName&#x3D;umstor -Dkeycloak.migration.action&#x3D;export -Dkeycloak.migration.usersExportStrategy&#x3D;REALM_FILE -Dkeycloak.migration.provider&#x3D;singleFile -Dkeycloak.migration.file&#x3D;&#x2F;opt&#x2F;jboss&#x2F;keycloak&#x2F;bin&#x2F;umstor-realm.json -Djboss.http.port&#x3D;8888 -Djboss.https.port&#x3D;9999 -Djboss.management.http.port&#x3D;7777</span><br></pre></td></tr></table></figure>

<h4 id="Admin-cli"><a href="#Admin-cli" class="headerlink" title="Admin cli"></a>Admin cli</h4><p>在 keycloak 容器镜像中 admin cli 位于<code>/opt/jboss/keycloak/bin/</code> 目录下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 配置授权信息</span><br><span class="line">.&#x2F;kcadm.sh config credentials --server http:&#x2F;&#x2F;localhost:8080&#x2F;keycloak --realm master --user root --password r00tme</span><br><span class="line">&#x2F;&#x2F; 根据之前导出的 json 创建 realm</span><br><span class="line">.&#x2F;kcadm.sh create realms -f realm-export.json</span><br></pre></td></tr></table></figure>

<h4 id="使用-PostgreSQL-创建数据库"><a href="#使用-PostgreSQL-创建数据库" class="headerlink" title="使用 PostgreSQL 创建数据库"></a>使用 PostgreSQL 创建数据库</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">psql -h 172.30.229.60 -U keycloak -p 5432 -d postgres</span><br><span class="line">&#x2F;&#x2F; 登录后创建新的数据库</span><br><span class="line">CREATE DATABASE keycloak WITH OWNER &#x3D; keycloak;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>认证</category>
      </categories>
      <tags>
        <tag>认证</tag>
      </tags>
  </entry>
  <entry>
    <title>Kubelet 工作过程简析</title>
    <url>/post/aad9c438.html</url>
    <content><![CDATA[<h4 id="syncLoop-处理哪些工作"><a href="#syncLoop-处理哪些工作" class="headerlink" title="syncLoop 处理哪些工作"></a>syncLoop 处理哪些工作</h4><p>watch apiserver 得到的 Pod 配置更新的事件；来自于 PLEG 产生的 Pod 状态变更事件，因为 Runtime 并没有提供事件通知的接口，所有现在 PLEG 采用定时轮询（默认 1s）的方式获取 Pod 状态并通过与上一次记录的状态比较计算变化产生事件，如果超过 3 分钟没有轮询成功的记录，则会认为 Runtime 出错，进而触发 Node NotReady；来自于 livenessManager 的事件，对于设置了 liveness 探针的 Pod，如果探针监测失败，则应处理相应事件；默认每两秒种执行一次的清理工作；默认每秒中执行一次 Pod sync 检查，检查队列中是否有需要执行 syncPod 操作的 Pod。除此外，还有一些如 evictionManager （默认 10 秒检测一次） 不通过 syncLoop 自行处理相关事件的控制循环。</p><a id="more"></a>
<h4 id="删除-Pod-过程"><a href="#删除-Pod-过程" class="headerlink" title="删除 Pod 过程"></a>删除 Pod 过程</h4><p>参考：<a href="https://blog.csdn.net/nangonghen/article/details/109305635" target="_blank" rel="external nofollow noopener noreferrer">https://blog.csdn.net/nangonghen/article/details/109305635</a></p>
]]></content>
      <categories>
        <category>Kubernetes</category>
      </categories>
      <tags>
        <tag>Kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>Kubernetes CNI</title>
    <url>/post/2e65e43b.html</url>
    <content><![CDATA[<h3 id="CNI-插件"><a href="#CNI-插件" class="headerlink" title="CNI 插件"></a>CNI 插件</h3><h4 id="antrea"><a href="#antrea" class="headerlink" title="antrea"></a>antrea</h4><p>基于  Open vSwitch 的 CNI 插件，<a href="https://github.com/vmware-tanzu/antrea" target="_blank" rel="external nofollow noopener noreferrer">github.com/vmware-tanzu/antrea</a>。</p>]]></content>
      <categories>
        <category>Kubernetes</category>
      </categories>
      <tags>
        <tag>Kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>Kubernetes 中使用 Nginx-Ingress 对外部请求进行认证</title>
    <url>/post/f901e5ff.html</url>
    <content><![CDATA[<h3 id="原文"><a href="#原文" class="headerlink" title="原文"></a>原文</h3><p><a href="https://medium.com/@ankit.wal/authenticate-requests-to-apps-on-kubernetes-using-nginx-ingress-and-an-authservice-37bf189670ee" target="_blank" rel="external nofollow noopener noreferrer">Authenticate requests to apps on kubernetes using Nginx-Ingress and an AuthService</a></p><p>在诸如 Kubernetes 的集群上部署微服务的一种常见模式是将认证过程委托给外部认证服务或者是将认证过程抽取为单独的微服务部署在当前集群，其基本结构如下图所示：</p><a id="more"></a>

<p><img src="https://cdn.nlark.com/yuque/0/2019/png/182657/1575344848404-ec7c7588-8044-46e0-a3f8-46d682a8329c.png#align=left&display=inline&height=1058&name=image.png&originHeight=1058&originWidth=1246&size=76582&status=done&style=none&width=1246" alt="image.png"></p>
<p>通过将对所有 API 调用的认证过程委托给独立的认证服务可以避免在每个业务微服务中都要实现认证插件，从而使得开发团队可以专注于业务逻辑的开发，避免重复的工作。本文介绍了使用  ingress-nginx 注解配置外部认证服务实现用户身份验证与授权。</p>
<h3 id="Authentication-Annotations"><a href="#Authentication-Annotations" class="headerlink" title="Authentication Annotations"></a>Authentication Annotations</h3><h4 id="auth-url"><a href="#auth-url" class="headerlink" title="auth-url"></a>auth-url</h4><p>Nginx-inkress 是一个相当成熟的为部署在 kubernetes 上的工作流提供外部入口的解决方案，它带有很多开箱即用的特性。这些特性大多数都可以通过简单地向服务的 ingress yaml 文件中添加注解来使用。这里需要使用其中专门用于对接外部认证的注解 ‘auth-url’ 。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">nginx.ingress.kubernetes.io/auth-url: <span class="string">"url to auth service"</span></span><br></pre></td></tr></table></figure>

<p>这个注解告诉 ingress-nginx 控制器先将传入的请求转发给认证服务，然后如果认证服务返回状态码为 200 OK 的响应，则将请求继续转发到下游服务。例如:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">apiVersion: extensions/v1beta1</span><br><span class="line">kind: Ingress</span><br><span class="line">metadata:</span><br><span class="line">  annotations:</span><br><span class="line">    nginx.ingress.kubernetes.io/auth-url: http:<span class="comment">//auth-service.prod.svc.cluster.local/authenticate</span></span><br><span class="line">  namespace: prod</span><br><span class="line">  name: ingress-<span class="keyword">with</span>-auth</span><br><span class="line">spec:</span><br><span class="line">  rules:</span><br><span class="line">   - host: api.microservice<span class="number">-1.</span>myapp.com</span><br><span class="line">      http:</span><br><span class="line">        paths:</span><br><span class="line">        - path: <span class="regexp">/secure/</span></span><br><span class="line">          backend:</span><br><span class="line">            serviceName: microservice<span class="number">-1</span></span><br><span class="line">            servicePort: <span class="number">8080</span></span><br></pre></td></tr></table></figure>

<p>上面的 ingress 配置指示 ingress-nginx 将所有路径为  <code>api.microservice-1.myapp.com/secure/</code> 的外部请求首先转发到部署在集群内的认证服务的  <code>/authenticate</code> 端点，其基本过程如下：</p>
<ol>
<li>客户端向  <code>api.microservice-1.myapp.com/secure/*</code> 发起 API 请求；</li>
<li>请求到达 ingress-nginx 控制器，控制器将其转给认证服务的  <code>/authenticate</code> 端点；</li>
<li>如果认证服务返回  <code>200 Ok</code> 则继续讲该请求转给  <code>microservice-1</code> 服务。</li>
</ol>
<h4 id="auth-response-headers"><a href="#auth-response-headers" class="headerlink" title="auth-response-headers"></a>auth-response-headers</h4><p>我们可以使用   auth-response-headers 注解让认证服务传递一些信息到下游的业务应用。例如，认证服务在进行认证的过程中可以解析出用户名或用户 ID ，并将用户信息传递给   <code>microservice-1</code> 服务：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">apiVersion: extensions/v1beta1</span><br><span class="line">kind: Ingress</span><br><span class="line">metadata:</span><br><span class="line">  annotations:</span><br><span class="line">    nginx.ingress.kubernetes.io/auth-url: http:<span class="comment">//auth-service.prod.svc.cluster.local/authenticate</span></span><br><span class="line">    nginx.ingress.kubernetes.io/auth-response-headers: UserID</span><br><span class="line">  namespace: prod</span><br><span class="line">  name: ingress-<span class="keyword">with</span>-auth</span><br><span class="line">spec:</span><br><span class="line">  rules:</span><br><span class="line">   - host: api.microservice<span class="number">-1.</span>myapp.com</span><br><span class="line">      http:</span><br><span class="line">        paths:</span><br><span class="line">        - path: <span class="regexp">/secure/</span></span><br><span class="line">          backend:</span><br><span class="line">            serviceName: microservice<span class="number">-1</span></span><br><span class="line">            servicePort: <span class="number">8080</span></span><br></pre></td></tr></table></figure>

<ol>
<li>客户端向 api.microservice-1.myapp.com/secure/* 发起 API 请求；</li>
<li>请求到达 ingress-nginx 控制器，控制器将其转给认证服务的 /authenticate 端点；</li>
<li>认证服务在认证过程中解析出  <code>UserID</code>，在返回的  <code>200 Ok</code> 响应中带上 <code>UserID</code> 头信息；</li>
<li>ingress-nginx 控制器从认证服务的响应中获取  UserID 信息并添加到初始的客户端请求头中，并将客户请求传递给  <code>microservice-1</code> 服务。</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2019/png/182657/1575347734772-e086bf98-4064-49c8-9f46-6f951898dc86.png#align=left&display=inline&height=1064&name=image.png&originHeight=1064&originWidth=1248&size=81349&status=done&style=none&width=1248" alt="image.png"></p>
<h3 id="译者补充"><a href="#译者补充" class="headerlink" title="译者补充"></a>译者补充</h3><h4 id="keycloak-auth"><a href="#keycloak-auth" class="headerlink" title="keycloak-auth"></a>keycloak-auth</h4><p>在看到这篇文章之前，我们已经进行了类似的实践，我们的认证中心基于 <a href="https://github.com/keycloak/keycloak" target="_blank" rel="external nofollow noopener noreferrer">keycloak</a> 实现，keycloak 部署于 Kubernetes 集群内，为了能够无侵入地为已有的业务微服务（实现所用的语言有 Go 和 Python）添加基于 keycloak 的认证过程，我们希望能够使用类似 <a href="https://github.com/keycloak/keycloak-gatekeeper" target="_blank" rel="external nofollow noopener noreferrer">keycloak-gatekeeper</a> 的机制在请求到达业务微服务之前实现认证和授权。keycloak-gatekeeper 实现了认证／授权／反向代理的功能，它可以根据配置的规则，针对每个 HTTP 请求（Method 和 URL）进行基于角色的授权，通过认证和授权的请求会代理向业务微服务发起请求。由于我们已经使用 ingress-nginx 作为服务入口即反向代理服务器，所以 keycloak-gatekeeper 反向代理的功能是我们不需要的，因此我对 keycloak-gatekeeper 做了一些裁剪形成了  <a href="https://github.com/XiaYinchang/nginx-ingress-keycloak-auth" target="_blank" rel="external nofollow noopener noreferrer">nginx-ingress-keycloak-auth</a>，主要完成了以下改造：</p>
<ol>
<li>移除反向代理相关代码。</li>
<li>与 ingress-nginx auth-url 接口对接起来，针对通过授权的请求直接返回 200（不再执行反向代理）。</li>
<li>在入口中间件中（EntrypointMiddleware）中将 <code>req *http.Request</code>  对象的 URL 和 Method 信息更改为从 ingress-nginx 传递的  “X-Original-Url” 和  “X-Original-Method” 请求头解析出的内容以便复用原有的认证和授权逻辑。</li>
<li>对代码结构进行了调整使其更符合 Go 项目的通用项目结构模式。</li>
</ol>
<h4 id="LDAP-对接-ingress-nginx"><a href="#LDAP-对接-ingress-nginx" class="headerlink" title="LDAP 对接 ingress-nginx"></a>LDAP 对接 ingress-nginx</h4><p><a href="https://github.com/kubernetes/ingress-nginx/issues/1676#issuecomment-427033748" target="_blank" rel="external nofollow noopener noreferrer">https://github.com/kubernetes/ingress-nginx/issues/1676#issuecomment-427033748</a></p>
<h4 id="ingress-nginx-生成配置的模板"><a href="#ingress-nginx-生成配置的模板" class="headerlink" title="ingress-nginx 生成配置的模板"></a>ingress-nginx 生成配置的模板</h4><p><a href="https://github.com/kubernetes/ingress-nginx/blob/b286c2a3364888de32cb60c4771e57a1ed8e5735/rootfs/etc/nginx/template/nginx.tmpl" target="_blank" rel="external nofollow noopener noreferrer">https://github.com/kubernetes/ingress-nginx/blob/b286c2a3364888de32cb60c4771e57a1ed8e5735/rootfs/etc/nginx/template/nginx.tmpl</a></p>
<h4 id="Go-实现的一个-JWT-Validator"><a href="#Go-实现的一个-JWT-Validator" class="headerlink" title="Go 实现的一个 JWT Validator"></a>Go 实现的一个 JWT Validator</h4><p><a href="https://github.com/carlpett/nginx-subrequest-auth-jwt" target="_blank" rel="external nofollow noopener noreferrer">https://github.com/carlpett/nginx-subrequest-auth-jwt</a></p>
]]></content>
      <categories>
        <category>译文</category>
      </categories>
      <tags>
        <tag>译文</tag>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>Kubernetes CSI</title>
    <url>/post/d1098827.html</url>
    <content><![CDATA[<h4 id="Volume"><a href="#Volume" class="headerlink" title="Volume"></a>Volume</h4><p>在 Kubernetes 中，容器运行结束后其文件系统也随即被销毁，因此无法在容器中直接存储需要持久化的数据；另一方面，Kubernetes 以 Pod 为单位管理多个有一定关联关系的容器，这些容器之间的数据共享也是一个需要解决的一个问题。为此，Kubernetes 中引入了 Volume 的概念，与 Docker 中 Volume 概念的不同之处在于 Kubernetes 中的 Volume 有着完善的生命周期管理，一个 Volume 的生命周期和对应的 Pod 的一致，因此 Pod 中的容器的重启不会造成 Volume 中数据的丢失，且多个容器可以通过挂载同一个 Volume 共享数据，另外单个 Pod 支持使用多个多种类型的 Volume。通过 Volume 的抽象，容器只需要挂载 Volume 到文件系统的某个目录使用它而不必关心 Volume 的存储后端到底是什么类型。</p><a id="more"></a>
<h4 id="存储插件"><a href="#存储插件" class="headerlink" title="存储插件"></a>存储插件</h4><p>Kubernetes 支持的 Volume 存储后端多种多样，包括 RBD/GlusterFS/NFS/azureDisk/awsElasticBlockStore 等各种开源的和来自云厂商的存储产品，为此 Kubernetes 中维护了大量协议相关或是厂商相关的存储插件代码（in-tree，即代码包含在 Kubernetes 核心代码中），它们和 Kubernetes 的核心可执行文件一同维护、编译、构建和交付，这对于 Kubernetes 的核心开发人员以及存储插件开发人员都是不友好的，使得开发和调试过程较为麻烦且存储插件的代码质量难以保证，为此社区最开始引入了  FlexVolume 插件机制（out-tree，Kubernetes 核心代码中只包含作为调用方相关的不变的代码，存储类型相关的代码由存储提供方自行维护），FlexVolume 等同于可被 Pod 直接使用的一种 Volume 后端存储，在执行 Volume 创建和挂载时 Kubernetes 中调用 FlexVolume 的代码依据不同的存储类型调用预先配置好路径的可执行文件完成相关操作，因此 FlexVolume 的工作过程依赖于一系列预先在每台宿主机上预先配置好的可执行文件（例如，使用 Ceph 需要在每个节点上装好 rbd），安装过程极其麻烦。</p>
<h4 id="CSI-的引入"><a href="#CSI-的引入" class="headerlink" title="CSI 的引入"></a>CSI 的引入</h4><p>CSI(Container Storage Interface) 可以看作是 FlexVolume 的一种升级，其典型区别是 CSI 使用 gRPC 协议调用第三方存储后端而不是直接调用可执行文件，并且 CSI 在接口的标准化和功能特性升级上做了更多优化，并为开发和部署存储插件提供了参考模型，使得存储插件开放人员可以更灵活地开发插件并以 Kubernetes 原生的形式（通过 Deployment 和 DaemonSet 等）来部署插件而不是在宿主机上安装程序包，对于开发和使用群体都更为友好。<br>CSI 已经被确认为 Kubernetes 主流的存储接口规范，In-tree 的存储插件将逐步迁移至 CSI 方式实现，新的特性将只在 CSI 中增加而不会增加到 FlexVolume 中，未来第三方存储插件将彻底从 Kubernetes 核心代码中移除。  目前 CSI 独有的新特性有：VolumeSnapshot（创建卷快照，并从快照恢复）、Volume clone（从已有卷复制一个新的卷）。<br>另外非要重要的是，CSI 是由来自 Kubernetes，Mesos， Docker 等社区的成员联合制定的一个行业标准接口规范，这意味存储提供商开发的 CSI 驱动只要稍加修改就可以在不同的平台上使用，大大扩展了 CSI 的用户群体。<br>CSI 在逻辑上将存储驱动分为两个组件 Controller Plugin 和 Node Plugin：从功能上看，Controller Plugin 与 Kubernetes 控制平面交互，实现 Volume 的创建，Node Plugin 与 Kubelet 协同实现将 Volume 挂载给容器使用；从部署的角度看，Controller Plugin 既可以部署在 Master 节点也可以部署在 Node 节点，一般使用 Deployment 或 StatefulSet 部署，Node Plugin 需要在所有需使用该存储的 Node 上部署，一般使用 DaemonSet 部署。</p>
<h4 id="CSI-接口规范"><a href="#CSI-接口规范" class="headerlink" title="CSI 接口规范"></a>CSI 接口规范</h4><p>存储驱动需要实现三种 gRPC 服务：Identity Service, Controller Service, Node Service。 Controller Plugin 需要实现  Identity Service 和  Controller Service； Node Plugin 需要实现  Identity Service 和  Node Service。 三种服务定义的基本接口如下：</p>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">service</span> <span class="title">Identity</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 获取插件的版本和名称</span></span><br><span class="line">  <span class="function"><span class="keyword">rpc</span> GetPluginInfo(GetPluginInfoRequest)</span></span><br><span class="line"><span class="function">    <span class="keyword">returns</span> (GetPluginInfoResponse) &#123;&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">  // 返回插件所支持的功能</span></span><br><span class="line"><span class="function">  // 主要检测插件是否实现 Controller Service 和是否支持卷访问拓扑限制</span></span><br><span class="line"><span class="function">  // 插件的相同版本的所有实例，必须返回相同的功能集</span></span><br><span class="line"><span class="function">  <span class="keyword">rpc</span> GetPluginCapabilities(GetPluginCapabilitiesRequest)</span></span><br><span class="line"><span class="function">    <span class="keyword">returns</span> (GetPluginCapabilitiesResponse) &#123;&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">  // 验证插件是否处于健康和就绪状态</span></span><br><span class="line"><span class="function">  <span class="keyword">rpc</span> Probe (ProbeRequest)</span></span><br><span class="line"><span class="function">    <span class="keyword">returns</span> (ProbeResponse) &#123;&#125;</span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">service Controller &#123;</span></span><br><span class="line"><span class="function">  // 创建卷</span></span><br><span class="line"><span class="function">  // 请求参数包括：名字、卷容量、卷功能（表明是块存储卷还是文件系统卷，以及访问模式）</span></span><br><span class="line"><span class="function">  // 、参数、数据源（snapshot,clone），以及卷拓扑限制等</span></span><br><span class="line"><span class="function">  <span class="keyword">rpc</span> CreateVolume (CreateVolumeRequest)</span></span><br><span class="line"><span class="function">    <span class="keyword">returns</span> (CreateVolumeResponse) &#123;&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">  // 删除指定 volume ID 的存储卷</span></span><br><span class="line"><span class="function">  <span class="keyword">rpc</span> DeleteVolume (DeleteVolumeRequest)</span></span><br><span class="line"><span class="function">    <span class="keyword">returns</span> (DeleteVolumeResponse) &#123;&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">  // 使存储卷在某个所需节点上可用即 volume attach</span></span><br><span class="line"><span class="function">  // 如 Ceph RBD 需要将卷 rbd map 到某个节点上</span></span><br><span class="line"><span class="function">  <span class="keyword">rpc</span> ControllerPublishVolume (ControllerPublishVolumeRequest)</span></span><br><span class="line"><span class="function">    <span class="keyword">returns</span> (ControllerPublishVolumeResponse) &#123;&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">  // 执行 ControllerPublishVolume 相反的操作</span></span><br><span class="line"><span class="function">  // 使卷在某个节点上不可用，例如将 volume 从某个节点 detach</span></span><br><span class="line"><span class="function">  <span class="keyword">rpc</span> ControllerUnpublishVolume (ControllerUnpublishVolumeRequest)</span></span><br><span class="line"><span class="function">    <span class="keyword">returns</span> (ControllerUnpublishVolumeResponse) &#123;&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">  // 验证预先配置的卷是否满足容器编排系统的需求</span></span><br><span class="line"><span class="function">  // 可以指定卷功能（表明是块存储卷还是文件系统卷，以及访问模式）、卷属性以及卷拓扑限制等进行验证</span></span><br><span class="line"><span class="function">  <span class="keyword">rpc</span> ValidateVolumeCapabilities (ValidateVolumeCapabilitiesRequest)</span></span><br><span class="line"><span class="function">    <span class="keyword">returns</span> (ValidateVolumeCapabilitiesResponse) &#123;&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">  // 返回所有可用的存储卷，支持分页</span></span><br><span class="line"><span class="function">  <span class="keyword">rpc</span> ListVolumes (ListVolumesRequest)</span></span><br><span class="line"><span class="function">    <span class="keyword">returns</span> (ListVolumesResponse) &#123;&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">  // 返回存储资源池总可用容量。如存储容量有限，则需要执行此操作</span></span><br><span class="line"><span class="function">  // 假设存储资源池只能提供 1TB 的存储空间,配置和创建新卷时，应检测存储资源池的可用存储容量</span></span><br><span class="line"><span class="function">  <span class="keyword">rpc</span> GetCapacity (GetCapacityRequest)</span></span><br><span class="line"><span class="function">    <span class="keyword">returns</span> (GetCapacityResponse) &#123;&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">  // 返回 Controller 插件支持的功能</span></span><br><span class="line"><span class="function">  // 比如有些 controller plugin 不支持 GetCapacity，有些则不支持 CreateSnapshot 等</span></span><br><span class="line"><span class="function">  <span class="keyword">rpc</span> ControllerGetCapabilities (ControllerGetCapabilitiesRequest)</span></span><br><span class="line"><span class="function">    <span class="keyword">returns</span> (ControllerGetCapabilitiesResponse) &#123;&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">  // 创建指定 volume ID 的存储快照，用来备份数据</span></span><br><span class="line"><span class="function">  <span class="keyword">rpc</span> CreateSnapshot (CreateSnapshotRequest)</span></span><br><span class="line"><span class="function">    <span class="keyword">returns</span> (CreateSnapshotResponse) &#123;&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">  // 删除指定 ID 的存储快照</span></span><br><span class="line"><span class="function">  <span class="keyword">rpc</span> DeleteSnapshot (DeleteSnapshotRequest)</span></span><br><span class="line"><span class="function">    <span class="keyword">returns</span> (DeleteSnapshotResponse) &#123;&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">  // 返回所有可用的存储快照，支持分页</span></span><br><span class="line"><span class="function">  <span class="keyword">rpc</span> ListSnapshots (ListSnapshotsRequest)</span></span><br><span class="line"><span class="function">    <span class="keyword">returns</span> (ListSnapshotsResponse) &#123;&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">  // 实现磁盘扩容</span></span><br><span class="line"><span class="function">  // 例如 rbd resize</span></span><br><span class="line"><span class="function">  <span class="keyword">rpc</span> ControllerExpandVolume (ControllerExpandVolumeRequest)</span></span><br><span class="line"><span class="function">    <span class="keyword">returns</span> (ControllerExpandVolumeResponse) &#123;&#125;</span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">service Node &#123;</span></span><br><span class="line"><span class="function">  // CO 调用此方法以将 volume mount 到指定路径,通常，此路径是节点上的全局路径</span></span><br><span class="line"><span class="function">  // 此方法调用必须在 NodePublishVolume 之前，NodeStageVolume 是每个卷/每节点执行一次</span></span><br><span class="line"><span class="function">  // 在 Kubernetes 中，RBD 卷在 attach 到节点后，会将其 mount 到全局目录，然后 mount 到 pod 目录（通过 NodePublishVolume）</span></span><br><span class="line"><span class="function">  // 两步 mount 操作的原因是因为 Kubernetes 允许多个 pod 使用单个卷</span></span><br><span class="line"><span class="function">  <span class="keyword">rpc</span> NodeStageVolume (NodeStageVolumeRequest)</span></span><br><span class="line"><span class="function">    <span class="keyword">returns</span> (NodeStageVolumeResponse) &#123;&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">  // 执行 NodeStageVolume 相反的操作，从指定目录 unmount 卷</span></span><br><span class="line"><span class="function">  <span class="keyword">rpc</span> NodeUnstageVolume (NodeUnstageVolumeRequest)</span></span><br><span class="line"><span class="function">    <span class="keyword">returns</span> (NodeUnstageVolumeResponse) &#123;&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">  // CO 调用此方法将卷从指定全局路径 mount 到目标路径</span></span><br><span class="line"><span class="function">  // 通常做的操作是 bind mount，bind mount 允许将路径 mount 到另一个路径</span></span><br><span class="line"><span class="function">  // 此方法调用必须在 NodeStageVolume 之后，NodePublishVolume 是每个卷/每个工作负载执行一次</span></span><br><span class="line"><span class="function">  <span class="keyword">rpc</span> NodePublishVolume (NodePublishVolumeRequest)</span></span><br><span class="line"><span class="function">    <span class="keyword">returns</span> (NodePublishVolumeResponse) &#123;&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">  // 执行 NodePublishVolume 相反操作，从目标路径 unmount 卷</span></span><br><span class="line"><span class="function">  <span class="keyword">rpc</span> NodeUnpublishVolume (NodeUnpublishVolumeRequest)</span></span><br><span class="line"><span class="function">    <span class="keyword">returns</span> (NodeUnpublishVolumeResponse) &#123;&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">  // 获取指定 Volume 的使用统计信息</span></span><br><span class="line"><span class="function">  // 包括总容量、可用容量和已用容量</span></span><br><span class="line"><span class="function">  // 如果 Volume 是以块设备模式使用则不返回可用容量和已用容量</span></span><br><span class="line"><span class="function">  <span class="keyword">rpc</span> NodeGetVolumeStats (NodeGetVolumeStatsRequest)</span></span><br><span class="line"><span class="function">    <span class="keyword">returns</span> (NodeGetVolumeStatsResponse) &#123;&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">  // 实现文件系统扩容</span></span><br><span class="line"><span class="function">  // 如 xfs_growfs</span></span><br><span class="line"><span class="function">  <span class="keyword">rpc</span> NodeExpandVolume(NodeExpandVolumeRequest)</span></span><br><span class="line"><span class="function">    <span class="keyword">returns</span> (NodeExpandVolumeResponse) &#123;&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">  // 返回 node plugin 支持的功能</span></span><br><span class="line"><span class="function">  <span class="keyword">rpc</span> NodeGetCapabilities (NodeGetCapabilitiesRequest)</span></span><br><span class="line"><span class="function">    <span class="keyword">returns</span> (NodeGetCapabilitiesResponse) &#123;&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">  // 获取 node 节点信息</span></span><br><span class="line"><span class="function">  // 返回值包括  node ID，节点上最多可发布的 volume 数量，以及 node 可访问的拓扑信息</span></span><br><span class="line"><span class="function">  <span class="keyword">rpc</span> NodeGetInfo (NodeGetInfoRequest)</span></span><br><span class="line"><span class="function">    <span class="keyword">returns</span> (NodeGetInfoResponse) &#123;&#125;</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="CSI-插件结构"><a href="#CSI-插件结构" class="headerlink" title="CSI 插件结构"></a>CSI 插件结构</h4><p>CSI 规范中要求 gRPC 通信基于 Unix Socket 完成，因此调用方和存储插件需要部署在同一台宿主机上。基于 Kubernetes 集群的安全性考虑，第三方存储厂商提供的驱动被视为不受信任的，因此一般不部署在 Master 节点，即存储驱动中的 Controller Plugin 往往不部署在 Master 节点，但 Kubernetes 控制平面是部署在 Master 节点上的，因此它们之间无法使用基于 Unix Socket 的  gRPC 进行通信，所以需要引入辅助组件实现 Controller Plugin 和 Kubernetes 的协同，辅助组件通过 Kubernetes HTTP API 监听相关对象的变化并通过 gRPC 调用 Controller Plugin 完成 Volume 的创建和删除等操作。而这部分辅助组件的功能对各种第三方存储驱动往往是通用的，所以 CSI 兴趣小组帮助完成了这些辅助组件的开发，存储驱动开发人员只需要将其以 sidecar 的形式引入到部署中即可。</p>
<p>CSI 社区提供的辅助组件如下：</p>
<ul>
<li>external-provisioner</li>
</ul>
<p>如果 CSI 插件提供 CREATE_DELETE_VOLUME 能力，则需实现 Controller Service 的 CreateVolume 和 DeleteVolume 接口。external-provisioner watch 到指定 StorageClass 的 PersistentVolumeClaim 资源状态变更，会自动调用这两个接口。</p>
<ul>
<li>external-attacher</li>
</ul>
<p>如果 CSI 插件提供 PUBLISH_UNPUBLISH_VOLUME 能力，则需实现 Controller Service 的 ControllerPublishVolume 和 ControllerUnpublishVolume 接口。external-attacher watch 到 VolumeAttachment 资源状态变更，会自动调用这两个接口。</p>
<ul>
<li>external-snapshotter</li>
</ul>
<p>如果 CSI 插件提供 CREATE_DELETE_SNAPSHOT 能力，则需实现 Controller Service 的 CreateSnapshot 和 DeleteSnapshot 接口。external-snapshotter watch 到指定 SnapshotClass 的 VolumeSnapshot 资源状态变更，会自动调用这两个接口。</p>
<ul>
<li>external-resizer</li>
</ul>
<p>如果 CSI 插件提供 EXPAND_VOLUME 能力，则需实现 Controller Service 的 ControllerExpandVolume 接口。external-resizer watch 到 PersistentVolumeClaim 资源的容量发生变更，会自动地调用这个接口。</p>
<ul>
<li>node-driver-registrar</li>
</ul>
<p>CSI 插件需实现 Node Service 的 NodeGetInfo 接口后。当 Node Plugin 部署到 kubernetes 的 node 节点时，该 sidecar 会自动调用接口获取 CSI 插件信息，并向 kubelet 进行注册。</p>
<ul>
<li>livenessprobe</li>
</ul>
<p>通过 livenessprobe 辅助组件，kubernetes 即可检测到 CSI 插件相关 pod 的健康状态，当不正常时自动重启相应 pod。<br>逻辑上独立的 Controller Plugin 和 Node Plugin 可以由一个可执行程序（可称为 CSI Plugin）实现，通过启动参数决定提供 Controller 相关的服务还是 Node 相关的服务，CSI 插件添加辅助组件后，其部署结构如下：<br><img src="https://cdn.nlark.com/yuque/0/2019/png/182657/1572510560003-83653de0-138b-4eff-b364-e99bc0d5b2db.png#align=left&display=inline&height=1080&name=image.png&originHeight=1080&originWidth=1920&size=357131&status=done&style=none&width=1920" alt="image.png"></p>
<h4 id="Ceph-CSI-的实现"><a href="#Ceph-CSI-的实现" class="headerlink" title="Ceph CSI 的实现"></a>Ceph CSI 的实现</h4><p>Ceph CSI 的源代码仓库地址：<a href="https://github.com/ceph/ceph-csi" target="_blank" rel="external nofollow noopener noreferrer">https://github.com/ceph/ceph-csi</a>，源码编译后只生成一个可执行文件  cephcsi，根据传入的 –type 参数确定启动 cephfs 还是 rbd 相关的服务， 通过传入的 –nodeserver=true 指明启动 Node Service，通过 –controllerserver=true 致命启动 Controller Service，因此 ceph-csi 通过单一可执行文件同时实现了分别针对 rbd 和 cephfs 提供的 Identity、Controller 和 Node 三种服务。其部署结构和上图基本一致， Controller Service 与社区提供的  csi-provisioner 、csi-snapshotter、csi-attacher 共同组成了一个 StatefulSet , Node Service 与社区提供的 csi-node-driver-registrar 共同组成了一个 Deployment。<br>Ceph CSI 的代码结构如下，除了一些辅助性的代码，核心代码主要在 cmd 和 pkg 目录下，在 Go 项目中 cmd 目录一般是 main 函数所在的目录，也就是程序的编译和运行入口，所以 ceph csi 最后编译生成一个可执行文件与 cephcsi.go 同名，pkg 目录下则是被 cephcsi 引用的各种包的具体实现，其中 cephfs 目录下包含针对 cephfs 提供的实现 CSI 接口规范的代码， rbd 目录下是针对块存储的代码，csi-common 是共用的代码和类型定义， liveness 是提供 csi 插件存活状态探针的代码：<br><img src="https://cdn.nlark.com/yuque/0/2019/png/182657/1572848810789-0d219333-3ddf-4f8d-bd76-11fb8ae4fcf3.png#align=left&display=inline&height=710&name=DeepinScreenshot_select-area_20191104142608.png&originHeight=710&originWidth=230&size=33434&status=done&style=none&width=230" alt="DeepinScreenshot_select-area_20191104142608.png"><br>cephcsi.go 的引用关系如下图所示， 首先通过 init 函数读取命令行参数并解析存入 config 变量，然后根据配置参数使用 NewDriver 创建不同的 Driver （cephfs 或者 rbd），并调用相关 Driver 的 Run 方法启动 rpc server：<br><img src="https://cdn.nlark.com/yuque/0/2019/png/182657/1572859417047-7bdd41d3-eb75-41bf-ac51-1a74c89d486b.png#align=left&display=inline&height=1649&name=image.png&originHeight=1649&originWidth=764&size=325870&status=done&style=none&width=764" alt="image.png"></p>
<p>以 rbd Driver 为例，Controller Service 相关接口的实现如下：</p>
<ul>
<li>CreateVolume：根据传入的参数执行 rbd create 命令创建 image；</li>
<li>DeleteVolume：根据传入的参数执行 rbd rm 命令删除 image；</li>
<li>CreateSnapshot：根据传入的参数先执行 rbd snap create 创建快照，再执行 rbd snap protect 对快照加保护，再通过 rbd snap ls 获取快照信息，取消保护，将快照信息返回给调用方；</li>
<li>DeleteSnapshot： 根据传入的参数执行 rbd snap rm 删除快照；</li>
<li>扩容相关接口未实现。</li>
</ul>
<p>Node Service 相关接口的实现如下：</p>
<ul>
<li>NodeStageVolume：根据传入的参数执行 rbd map 命令将 image 映射为指定节点上的块设备，通过 mkdir 系统调用在指定节点上创建全局挂载目录，根据传入的文件系统类型参数执行 mkfs.* (ext4, xfs) 命令在 rbd 设备上创建文件系统并将其 mount 到之前创建的全局挂载目录，并将挂载点权限设置为 0777 允许所有容器访问（不安全）。</li>
<li>NodePublishVolume：根据传入的参数创建针对某个容器的挂载路径，并将  NodeStageVolume 阶段创建的全局挂载路径 bind mount 到该容器路径。</li>
<li>NodeUnpublishVolume：NodePublishVolume 的逆操作，对容器挂载路径执行 umount 操作并删除路径。</li>
<li>NodeUnstageVolume：NodeStageVolume 的逆操作，对全局挂载路径执行 umount 操作并删除路径。</li>
</ul>
<p>Identity Service 接口实现：</p>
<ul>
<li>GetPluginCapabilities：返回 rbd Driver 的能力信息，这里返回  PluginCapability_Service_CONTROLLER_SERVICE，表明实现了 Controller Service，特别说明实现了 Controller Service 是因为 Node service 是必须的，而 Controller Service 被设计为可选的。</li>
</ul>
<h4 id="阅读材料"><a href="#阅读材料" class="headerlink" title="阅读材料"></a>阅读材料</h4><p>csi 社区文档：<a href="https://kubernetes-csi.github.io/docs/" target="_blank" rel="external nofollow noopener noreferrer">https://kubernetes-csi.github.io/docs/</a><br>csi 标准文档： <a href="https://github.com/container-storage-interface/spec/blob/master/spec.md" target="_blank" rel="external nofollow noopener noreferrer">https://github.com/container-storage-interface/spec/blob/master/spec.md</a></p>
]]></content>
      <categories>
        <category>Kubernetes</category>
      </categories>
      <tags>
        <tag>Kubernetes</tag>
        <tag>云计算</tag>
      </tags>
  </entry>
  <entry>
    <title>Kubernetes 周边工具</title>
    <url>/post/afef0f89.html</url>
    <content><![CDATA[<h4 id="octant"><a href="#octant" class="headerlink" title="octant"></a>octant</h4><p>一款 Kubernetes Dashboard：<a href="https://github.com/vmware-tanzu/octant" target="_blank" rel="external nofollow noopener noreferrer">github.com/vmware-tanzu/octant</a>。</p><h4 id="Sonobuoy"><a href="#Sonobuoy" class="headerlink" title="Sonobuoy"></a>Sonobuoy</h4><p>Kubernetes e2e 测试框架，默认运行 Kubernetes 一致性测试，可以自定义插件对 Kubernetes 集群进行测试：<a href="https://github.com/vmware-tanzu/sonobuoy" target="_blank" rel="external nofollow noopener noreferrer">github.com/vmware-tanzu/sonobuoy</a>。</p><a id="more"></a>

<h4 id="kubectl-aliases"><a href="#kubectl-aliases" class="headerlink" title="kubectl-aliases"></a>kubectl-aliases</h4><p>常用的 kubectl 缩略别名：<a href="https://github.com/ahmetb/kubectl-aliases" target="_blank" rel="external nofollow noopener noreferrer">github.com/ahmetb/kubectl-aliases</a>。</p>
<h4 id="velero"><a href="#velero" class="headerlink" title="velero"></a>velero</h4><p>备份工具，可以备份集群资源至 S3，并通过磁盘快照等形式备份 PV ：<a href="https://github.com/vmware-tanzu/velero" target="_blank" rel="external nofollow noopener noreferrer">https://github.com/vmware-tanzu/velero</a>。</p>
<h4 id="etcdkeeper"><a href="#etcdkeeper" class="headerlink" title="etcdkeeper"></a>etcdkeeper</h4><p>可通过 web 页面查看和修改 etcd 数据：<a href="https://github.com/evildecay/etcdkeeper" target="_blank" rel="external nofollow noopener noreferrer">https://github.com/evildecay/etcdkeeper</a>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">etcdkeeper -cacert &#x2F;etc&#x2F;kubernetes&#x2F;ssl&#x2F;ca.pem -cert &#x2F;etc&#x2F;kubernetes&#x2F;ssl&#x2F;etcd.pem -key &#x2F;etc&#x2F;kubernetes&#x2F;ssl&#x2F;etcd-key.pem</span><br></pre></td></tr></table></figure>

<h4 id="skopeo"><a href="#skopeo" class="headerlink" title="skopeo"></a>skopeo</h4><p>可用于不同镜像格式的转换和推送：<a href="https://github.com/containers/skopeo" target="_blank" rel="external nofollow noopener noreferrer">https://github.com/containers/skopeo</a>。</p>
<h4 id="pprof-文件转成火焰图"><a href="#pprof-文件转成火焰图" class="headerlink" title="pprof 文件转成火焰图"></a>pprof 文件转成火焰图</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/brendangregg/FlameGraph.git</span><br><span class="line"><span class="built_in">cd</span> FlameGraph/</span><br><span class="line">./stackcollapse-go.pl kubelet.pprof &gt; kubelet.out</span><br><span class="line">./flamegraph.pl kubelet.out &gt; kubelet.svg</span><br></pre></td></tr></table></figure>

<h4 id="TUF"><a href="#TUF" class="headerlink" title="TUF"></a>TUF</h4><p><a href="https://github.com/theupdateframework/tuf" target="_blank" rel="external nofollow noopener noreferrer">https://github.com/theupdateframework/tuf</a><br>一款通用的用于提升软件包分发安全性的框架，Harbor 将其应用到了 OCI 制品的分发中。</p>
<h4 id="基于-local-pv-的-storageclass-provisioner"><a href="#基于-local-pv-的-storageclass-provisioner" class="headerlink" title="基于 local pv 的 storageclass provisioner"></a>基于 local pv 的 storageclass provisioner</h4><p><a href="https://github.com/rancher/local-path-provisioner" target="_blank" rel="external nofollow noopener noreferrer">https://github.com/rancher/local-path-provisioner</a></p>
]]></content>
      <categories>
        <category>Kubernetes</category>
      </categories>
      <tags>
        <tag>Kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>Kubernetes 集群升级</title>
    <url>/post/67293294.html</url>
    <content><![CDATA[<h3 id="基本问题"><a href="#基本问题" class="headerlink" title="基本问题"></a>基本问题</h3><p>Kubernetes 小版本的升级要简单很多，一般只需要原地替换组件并重启组件即可，不会引发 Pod 重启，不会对业务造成影响，这是因为小版本更多的是维护性的 bug 修复，不会发生大的特性变更。相对的，大版本升级就会面临很多问题，尤其是 Pod 重启可能对业务造成的影响，另一个棘手的问题是资源对象所属资源组及版本的变更。目前查询资料获得的升级方案多是在解决第一个问题，第二个问题鲜有提及，本文也未有方案。</p><a id="more"></a>
<h3 id="常见方案"><a href="#常见方案" class="headerlink" title="常见方案"></a>常见方案</h3><h4 id="新旧节点替换"><a href="#新旧节点替换" class="headerlink" title="新旧节点替换"></a>新旧节点替换</h4><p>基本过程是：添加新节点 -&gt; 驱逐旧节点上的 Pod -&gt; Pod 在新节点上自动重建 -&gt; 删除旧节点；但是这个过程只完成了对 Node 节点的替换，对于 Master 节点的处理如何进行类似处理还需仔细考虑。这个过程中还有几个细节问题需要考虑：① Pod 的优雅终止，自研组件可以通过捕获 SIGTERM 信号进行优雅退出，对于在线服务应首先停止监听进程，然后等待所有已建立的连接完成通信后退出，而对于 Nginx 等第三方产品可以在 PreStop Hook 中调用其自身提供的退出接口进行退出；② 启动退出服务之前的延时等待，由于 kubelet 删除 Pod 和 kubeproxy 移除相应的 endpoint 是并行的过程，所以很有可能出现 Pod 先停止监听而 endpoint 后移除的情况，会造成新的用户请求被转发到一个已经停止监听的后端 Pod 上从而被拒绝处理的错误发生，影响线上业务，所以需要在 PreStop Hook 中添加一定时间的 sleep ，一般是 5s ；③ 在 Pod 驱逐过程中保持一定的可用量，通过 PodDisruptionBudget 配置相应的策略从而保证在同时对多个节点上的所有 Pod 进行驱逐时能够保持给定标签的 Pod 维持在保证服务可用的水平，从而避免出现同一个服务的所有后端 Pod 同时不可用的情况。</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol>
<li><a href="https://blog.gruntwork.io/zero-downtime-server-updates-for-your-kubernetes-cluster-902009df5b33" target="_blank" rel="external nofollow noopener noreferrer">Zero Downtime Server Updates For Your Kubernetes Cluster</a></li>
</ol>
]]></content>
      <categories>
        <category>Kubernetes</category>
      </categories>
      <tags>
        <tag>Kubernetes</tag>
        <tag>集群升级</tag>
      </tags>
  </entry>
  <entry>
    <title>Kubernetes 监控</title>
    <url>/post/b0106d49.html</url>
    <content><![CDATA[<p>Prometheus 是 Kubernetes 监控体系中的一等公民，也是云原生场景中监控体系的事实标准。Prometheus、Grafana、AlertManager 是云原生监控告警体系的标准配置。对于大规模分布式多集群系统的监控，Thanos 是一个强有力的补充。</p><h3 id="Kubernetes-中监控数据的来源"><a href="#Kubernetes-中监控数据的来源" class="headerlink" title="Kubernetes 中监控数据的来源"></a>Kubernetes 中监控数据的来源</h3><a id="more"></a>
<p>Kubernetes 中的监控数据，可分为以下几个部分：</p>
<h4 id="cAdvisor"><a href="#cAdvisor" class="headerlink" title="cAdvisor"></a>cAdvisor</h4><p>cAdvisor 提供容器层级的监控数据，包括容器的内存和 CPU 使用量等。cAdvisor 本身是一个可以独立使用的工具，在 Kubernetes 中 cAdvisor 已经被集成在 Kubelet 的代码中。cAdvisor 的基本原理是监测 cgroup (/sys/fs/cgroup/cpu) 目录下文件和目录的变化，为对应的容器增加 handler 去定期读取容器对应的 cgroup 统计信息；还有一些数据如网络收发字节数是从 <code>/proc/PID/net/dev</code> 中定期读取，参考：<a href="https://www.cnblogs.com/elnino/p/10346439.html" target="_blank" rel="external nofollow noopener noreferrer">https://www.cnblogs.com/elnino/p/10346439.html</a>。</p>
<h4 id="Kubernetes-Metrics-Server"><a href="#Kubernetes-Metrics-Server" class="headerlink" title="Kubernetes Metrics Server"></a>Kubernetes Metrics Server</h4><p>Metrics Server 汇集从 kubelet(cAdvisor) 收集到的容器信息，用于支持 Kubernetes 内部自动伸缩器和调度器的工作，并不建议作为外部监控体系的数据采集入口。Metrics Server 仅将数据临时保留于内存中，通过 kube-apiserver 将其作为标准的 Kubernetes 资源对象暴露出去，资源组为 <code>metrics.k8s.io</code>，用户可通过 kube-apiserver 访问 <code>/apis/metrics.k8s.io/v1beta1/nodes</code> 路径获取统计数据。</p>
<h4 id="Node-Exporter"><a href="#Node-Exporter" class="headerlink" title="Node Exporter"></a>Node Exporter</h4><p>Node Exporter 是 Prometheus 社区提供的主要用于 Linux 平台获取节点监控信息的工具，其主要工作是提取节点上硬件和系统内核提供的各种统计信息，并以 Prometheus 标准数据格式暴露出来。</p>
<h4 id="Kube-State-Metrics"><a href="#Kube-State-Metrics" class="headerlink" title="Kube-State-Metrics"></a>Kube-State-Metrics</h4><p>kube-state-metrics 是 Kubernetes 社区提供的对 Kubernetes 原生资源对象的状态信息进行统计的组件，通过它暴露的信息可以获知指定 Pod 的 CPU Request/Limit 值，可以获知 Pod 是处于 Running 或者 Failed 状态，获知 Deployment 预期副本数和当前实际副本数等，这些信息同样以 Prometheus 标准数据格式提供，方便与监控系统对接。</p>
<h4 id="Kubernetes-控制组件"><a href="#Kubernetes-控制组件" class="headerlink" title="Kubernetes 控制组件"></a>Kubernetes 控制组件</h4><p>Kubernetes 控制组件的控制组件 API Server, Scheduler, Controller, and Etcd 都提供了组件本身的监控信息。</p>
<h4 id="用户应用"><a href="#用户应用" class="headerlink" title="用户应用"></a>用户应用</h4><p>用户应用往往也会暴露一些统计信息，尤其是提供 Web 服务的 HTTP Server 端，经常借助于 Prometheus 成熟的 SDK 暴露 RED (Request Rate, Error Rate, and Duration) 数据和程序的堆栈用量。</p>
<h3 id="监控信息的分类"><a href="#监控信息的分类" class="headerlink" title="监控信息的分类"></a>监控信息的分类</h3><p>获取监控数据之后，可对数据按照分门别类地进行汇总和展示，便于运维人员观测系统性能和排故。Kubernetes 的监控数据可按照集群、节点、Pod（容器）、控制组件和应用进行划分。<br>集群信息包括集群整体的资源总量和使用量，如节点数量、容器数量，异常容器数量，命名空间数量，总的 CPU 核数和已用核数，总的内存大小和已用内存，集群网络吞吐等；节点信息包括每个节点的资源总量和用量，容器数量，网络和磁盘 IO 等；Pod 和容器的 CPU 及内存用量；控制组件的健康状态和 HTTP 及 GRPC 调用次数和成功率；应用内部的业务生成的统计信息。</p>
<h3 id="Prometheus"><a href="#Prometheus" class="headerlink" title="Prometheus"></a>Prometheus</h3><h4 id="yaml-部署"><a href="#yaml-部署" class="headerlink" title="yaml 部署"></a>yaml 部署</h4><p><a href="https://github.com/prometheus-operator/kube-prometheus" target="_blank" rel="external nofollow noopener noreferrer">https://github.com/prometheus-operator/kube-prometheus</a></p>
<h4 id="helm-chart-部署"><a href="#helm-chart-部署" class="headerlink" title="helm chart 部署"></a>helm chart 部署</h4><p>prometheus stack 部署以及一些 exporter：<a href="https://github.com/prometheus-community/helm-charts/tree/main/charts" target="_blank" rel="external nofollow noopener noreferrer">https://github.com/prometheus-community/helm-charts/tree/main/charts</a></p>
<h4 id="blackbox-exporter"><a href="#blackbox-exporter" class="headerlink" title="blackbox_exporter"></a>blackbox_exporter</h4><p>blackbox_exporter 是社区提供的黑盒监测机制，默认监听端口 9115，允许通过 HTTP 、 HTTPS 、DNS 、TCP 和 ICMP 探测端点。在 exporter 中，可以定义一系列执行特定检查的模块，例：检查正在运行的 web 服务器，或者 DNS 解析记录。黑盒监控主要用于探活，因为很多应用并没有提供内部 metrics 接口，无法获取应用内部更多的信息，应用对于我们来说是一个黑盒，只能利用存在已久的协议简单探测应用的存活状态。类似于 MySQL exporter 的采集模块则可以将 MySQL 内部本身提供的 metrics 信息导出成 Prometheus 支持的标准格式。实际上 exporter 多是为了将一些 Prometheus 出现之前的应用暴露的形式各异的监控信息导出为 Prometheus 标准格式。而在 Prometheus 广泛流行之后开发的应用，导出的监控信息基本都遵循 Prometheus 标准格式，不再需要 exporter 中转。</p>
<h4 id="relabel"><a href="#relabel" class="headerlink" title="relabel"></a>relabel</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 替换 address 端口</span><br><span class="line">- source_labels:</span><br><span class="line">  - __address__</span><br><span class="line">  separator:     &#39;:&#39;</span><br><span class="line">  regex:         &#39;(.*):(.*)&#39;</span><br><span class="line">  target_label:  &#39;__address__&#39;</span><br><span class="line">  replacement:   &#39;$&#123;1&#125;:10249&#39;</span><br></pre></td></tr></table></figure>

<h4 id="重新加载配置"><a href="#重新加载配置" class="headerlink" title="重新加载配置"></a>重新加载配置</h4><p>启动时添加  –web.enable-lifecycle 参数，重新加载配置使用 <code>curl -X POST http://localhost:9090/-/reload</code> 。</p>
<h4 id="校验配置的有效性"><a href="#校验配置的有效性" class="headerlink" title="校验配置的有效性"></a>校验配置的有效性</h4><p>从 <a href="https://github.com/prometheus/prometheus/releases" target="_blank" rel="external nofollow noopener noreferrer">Prometheus 仓库</a>下载的可执行文件包含了 promtool 工具用于校验配置和 rule 的有效性。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat &gt;prometheus.yml &lt;&lt;<span class="string">'EOF'</span></span><br><span class="line">scrape_configs:</span><br><span class="line">- job_name: prometehus</span><br><span class="line">static_configs:</span><br><span class="line">  - targets: [<span class="string">'localhost:9090'</span>]</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">./promtool check config prometheus.yml</span><br><span class="line">Checking prometheus.yml</span><br><span class="line">  FAILED: parsing YAML file prometheus.yml: yaml: unmarshal errors:</span><br><span class="line">  line 3: field static_configs not found <span class="keyword">in</span> <span class="built_in">type</span> config.plain</span><br></pre></td></tr></table></figure>

<h4 id="通过指定标签列出所有可用的监控指标"><a href="#通过指定标签列出所有可用的监控指标" class="headerlink" title="通过指定标签列出所有可用的监控指标"></a>通过指定标签列出所有可用的监控指标</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sum by(__name__)(&#123;app=<span class="string">"bar"</span>&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="PromQL-基础使用"><a href="#PromQL-基础使用" class="headerlink" title="PromQL 基础使用"></a>PromQL 基础使用</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 一个标签同时满足多个匹配条件</span></span><br><span class="line">varnish_main_client_req&#123;namespace=~<span class="string">".*3.*"</span>,namespace!~<span class="string">".*env4.*"</span>&#125;</span><br></pre></td></tr></table></figure>

<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol>
<li><a href="https://blog.freshtracks.io/a-deep-dive-into-kubernetes-metrics-b190cc97f0f6" target="_blank" rel="external nofollow noopener noreferrer">A Deep Dive into Kubernetes Metrics</a></li>
<li><a href="https://stackoverflow.com/questions/49135746/prometheus-grouping-metrics-by-metric-names" target="_blank" rel="external nofollow noopener noreferrer">https://stackoverflow.com/questions/49135746/prometheus-grouping-metrics-by-metric-names</a></li>
</ol>
]]></content>
      <categories>
        <category>Kubernetes</category>
      </categories>
      <tags>
        <tag>Kubernetes</tag>
        <tag>监控</tag>
      </tags>
  </entry>
  <entry>
    <title>LVM 基本概念</title>
    <url>/post/31e91381.html</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th align="center">Date</th>
<th align="center">Log</th>
</tr>
</thead>
<tbody><tr>
<td align="center">2019/05/28</td>
<td align="center">初始版本.</td>
</tr>
<tr>
<td align="center">2019/09/08</td>
<td align="center">添加逻辑卷扩容.</td>
</tr>
</tbody></table><h3 id="原文"><a href="#原文" class="headerlink" title="原文"></a>原文</h3><p><a href="https://www.thegeekdiary.com/redhat-centos-a-beginners-guide-to-lvm-logical-volume-manager/" target="_blank" rel="external nofollow noopener noreferrer">RedHat / CentOS : A beginners guide to LVM</a></p><h3 id="什么是-LVM"><a href="#什么是-LVM" class="headerlink" title="什么是 LVM"></a>什么是 LVM</h3><p>逻辑卷管理（LVM）在物理磁盘和文件系统之间引入了额外的一层从而使得文件系统具有了如下特性：</p><a id="more"></a>


<ul>
<li>方便地在线扩容和移动，不需要系统范围的中断</li>
<li>利用磁盘不连续的空间</li>
<li>有含义的卷名取代通常的晦涩的设备名</li>
<li>跨多个物理磁盘</li>
</ul>
<p>Linux LVM 和 HP-UX LVM 非常相似，但是提供了更多诸如磁盘快照、集群支持（GFS2、OCFS 和  Lustre）等高级功能。</p>
<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>LVM 包含几项概念上的分层：物理卷（PV）、逻辑卷（LV）和文件系统。<br><img src="https://cdn.nlark.com/yuque/0/2019/png/182657/1559006793676-717ab08e-f951-4f4c-b181-9167f797adb9.png#align=left&display=inline&height=316&name=image.png&originHeight=316&originWidth=260&size=21399&status=done&width=260" alt="image.png"><br>这些分层又由较小的单元组成，例如物理卷由一组 PE（Physical Extents）组成、逻辑卷由一组 LE（Logical Extents）组成。Extent 在这里指的是组成卷的最小逻辑单元。Extent 在磁盘管理中指的是一些连续的 block，一个 extent 由起始的 block 加上长度进行定义。 Extent 是 btrfs 管理磁盘空间的最小单位，由 extent tree 管理。 Btrfs 分配 data 或 metadata 都需要查询 extent tree 以便获得空闲空间的信息。<br><img src="https://cdn.nlark.com/yuque/0/2019/png/182657/1559008329932-64cc00c4-b926-40f1-be09-d0ab8e0f90d9.png#align=left&display=inline&height=179&name=image.png&originHeight=179&originWidth=563&size=39153&status=done&width=563" alt="image.png"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2019/png/182657/1559007427978-1c2c017c-ab1a-4b34-a21a-55b313d17ac5.png#align=left&display=inline&height=258&name=image.png&originHeight=258&originWidth=671&size=23025&status=done&width=671" alt="image.png"></p>
<h4 id="物理卷（PV）"><a href="#物理卷（PV）" class="headerlink" title="物理卷（PV）"></a>物理卷（PV）</h4><p>每个物理卷可以是磁盘分区，整个磁盘，元设备或回环文件。 使用命令 pvcreate 初始化存储空间以供 LVM 使用。 将块设备初始化为物理卷会在设备的开头放置标签。</p>
<h4 id="卷组（VG）"><a href="#卷组（VG）" class="headerlink" title="卷组（VG）"></a>卷组（VG）</h4><p>一个卷组将一组逻辑卷和物理卷纳入到一个管理单元。卷组被切分成一组大小固定的 PE。vgcreate 命令使用先前 pvcreate 为 LVM 配置的物理卷路径创建一个卷组。</p>
<ul>
<li>卷组由物理卷构成，物理卷由 PE 构成。不同卷组包含的 PE 大小可以不同，具体是在创建卷组时指定。</li>
<li>PE 的默认大小是 4MB，但是可以在创建 VG 的时候指定不同的值。</li>
<li>一般来讲，PE 大小越大性能越好，逻辑卷的控制粒度也会降低。</li>
</ul>
<h4 id="逻辑卷（LV）"><a href="#逻辑卷（LV）" class="headerlink" title="逻辑卷（LV）"></a>逻辑卷（LV）</h4><p>逻辑卷在概念上和非 LVM 系统中的硬盘分区等价。逻辑卷就是一些在从属于同一卷组的 PE 的基础上创建的块设备。可以使用 lvcreate 命令在某个卷组里创建逻辑卷。</p>
<h4 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h4><p>文件系统构建在逻辑卷之上。使用 mkfs 命令可以在基于逻辑卷创建文件系统。文件系统创建完成后就可以根据需要挂载使用。</p>
<h3 id="实操"><a href="#实操" class="headerlink" title="实操"></a>实操</h3><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p>接下来的操作中我们将会：</p>
<ol>
<li>基于三个物理磁盘（/dev/sdb,/dev/sdc,/dev/sdd）创建三个物理卷。</li>
<li>基于三个物理卷创建一个卷组（/dev/vg01）。</li>
<li>在卷组中创建一个逻辑卷。</li>
<li>在逻辑卷上创建文件系统并且挂载（/data01）。</li>
</ol>
<h4 id="创建物理卷"><a href="#创建物理卷" class="headerlink" title="创建物理卷"></a>创建物理卷</h4><p>使用 pvcreate 命令初始化 LVM 使用的物理卷。在创建物理卷之前需要确保目标磁盘在操作系统中可见。使用 lvmdiskscan 扫描可用于创建物理卷的块设备。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># lvmdiskscan</span></span><br><span class="line">.......</span><br><span class="line">  /dev/sdb   [       2.00 GiB]</span><br><span class="line">  /dev/sdc   [       2.00 GiB]</span><br><span class="line">  /dev/sdd   [       2.00 GiB]</span><br><span class="line">  3 disks</span><br><span class="line">  19 partitions</span><br><span class="line">  0 LVM physical volume whole disks</span><br><span class="line">  0 LVM physical volumes</span><br></pre></td></tr></table></figure>

<p>初始化块设备：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># pvcreate /dev/sdb /dev/sdc /dev/sdd</span></span><br><span class="line">  Physical volume <span class="string">"/dev/sdb"</span> successfully created</span><br><span class="line">  Physical volume <span class="string">"/dev/sdc"</span> successfully created</span><br><span class="line">  Physical volume <span class="string">"/dev/sdd"</span> successfully created</span><br></pre></td></tr></table></figure>

<p>查看物理卷：<br>可以使用 pvdisplay、pvs 和 pvscan 查看刚刚创建的物理卷。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># pvdisplay</span></span><br><span class="line">  <span class="string">"/dev/sdb"</span> is a new physical volume of <span class="string">"2.00 GiB"</span></span><br><span class="line">  --- NEW Physical volume ---</span><br><span class="line">  PV Name               /dev/sdb</span><br><span class="line">  VG Name</span><br><span class="line">  PV Size               2.00 GiB</span><br><span class="line">  Allocatable           NO</span><br><span class="line">  PE Size               0</span><br><span class="line">  Total PE              0</span><br><span class="line">  Free PE               0</span><br><span class="line">  Allocated PE          0</span><br><span class="line">  PV UUID               Mt3F7z-a2AV-28Vn-uXe2-QejE-Z6tP-UMlQGM</span><br><span class="line"></span><br><span class="line">  <span class="string">"/dev/sdc"</span> is a new physical volume of <span class="string">"2.00 GiB"</span></span><br><span class="line">  --- NEW Physical volume ---</span><br><span class="line">  PV Name               /dev/sdc</span><br><span class="line">  VG Name</span><br><span class="line">  PV Size               2.00 GiB</span><br><span class="line">  Allocatable           NO</span><br><span class="line">  PE Size               0</span><br><span class="line">  Total PE              0</span><br><span class="line">  Free PE               0</span><br><span class="line">  Allocated PE          0</span><br><span class="line">  PV UUID               5m1Fuc-yTRn-I2vG-bMfU-6SE7-53EA-s8VQjt</span><br><span class="line"></span><br><span class="line">  <span class="string">"/dev/sdd"</span> is a new physical volume of <span class="string">"2.00 GiB"</span></span><br><span class="line">  --- NEW Physical volume ---</span><br><span class="line">  PV Name               /dev/sdd</span><br><span class="line">  VG Name</span><br><span class="line">  PV Size               2.00 GiB</span><br><span class="line">  Allocatable           NO</span><br><span class="line">  PE Size               0</span><br><span class="line">  Total PE              0</span><br><span class="line">  Free PE               0</span><br><span class="line">  Allocated PE          0</span><br><span class="line">  PV UUID               1x3e2A-C0Lt-DrUA-tPSM-lsMu-sn70-qg1j8p</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># pvscan</span></span><br><span class="line">  PV /dev/sdb                      lvm2 [2.00 GiB]</span><br><span class="line">  PV /dev/sdc                      lvm2 [2.00 GiB]</span><br><span class="line">  PV /dev/sdd                      lvm2 [2.00 GiB]</span><br><span class="line">  Total: 3 [6.00 GiB] / <span class="keyword">in</span> use: 0 [0   ] / <span class="keyword">in</span> no VG: 3 [6.00 GiB]</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># pvs</span></span><br><span class="line">  PV         VG   Fmt  Attr PSize PFree</span><br><span class="line">  /dev/sdb        lvm2 a--  2.00g 2.00g</span><br><span class="line">  /dev/sdc        lvm2 a--  2.00g 2.00g</span><br><span class="line">  /dev/sdd        lvm2 a--  2.00g 2.00g</span><br></pre></td></tr></table></figure>

<h4 id="创建卷组"><a href="#创建卷组" class="headerlink" title="创建卷组"></a>创建卷组</h4><p>使用 vgcreate 命令创建新的卷组 vg01，卷组用到了刚刚创建的三个 PV。使用通过传入 -s 参数指定 PE 的大小、传入 -p 指定 PV 的最大数量、传入 -I 指定 LV 的最大数量。这些参数都是可选项。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># vgcreate vg01 /dev/sdb /dev/sdc /dev/sdd</span></span><br><span class="line">  Volume group <span class="string">"vg01"</span> successfully created</span><br></pre></td></tr></table></figure>

<p>pvcreate 命令可选参数列表如下：</p>
<table>
<thead>
<tr>
<th align="left">Option</th>
<th align="left">Meaning</th>
</tr>
</thead>
<tbody><tr>
<td align="left">-s</td>
<td align="left">Physical extent size</td>
</tr>
<tr>
<td align="left">-p</td>
<td align="left">Max number of PVs</td>
</tr>
<tr>
<td align="left">-l</td>
<td align="left">Max number of LVs</td>
</tr>
<tr>
<td align="left">–alloc</td>
<td align="left">allocation policy (either contiguous, anywhere, or cling)</td>
</tr>
</tbody></table>
<p>使用 vgs 和 vgdisplay 命令可以查看卷组信息：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># vgs vg01</span></span><br><span class="line">  VG   <span class="comment">#PV #LV #SN Attr   VSize VFree</span></span><br><span class="line">  vg01   3   0   0 wz--n- 5.99g 5.99g</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># vgdisplay vg01</span></span><br><span class="line">  --- Volume group ---</span><br><span class="line">  VG Name               vg01</span><br><span class="line">  System ID</span><br><span class="line">  Format                lvm2</span><br><span class="line">  Metadata Areas        3</span><br><span class="line">  Metadata Sequence No  1</span><br><span class="line">  VG Access             <span class="built_in">read</span>/write</span><br><span class="line">  VG Status             resizable</span><br><span class="line">  MAX LV                0</span><br><span class="line">  Cur LV                0</span><br><span class="line">  Open LV               0</span><br><span class="line">  Max PV                0</span><br><span class="line">  Cur PV                3</span><br><span class="line">  Act PV                3</span><br><span class="line">  VG Size               5.99 GiB</span><br><span class="line">  PE Size               4.00 MiB</span><br><span class="line">  Total PE              1533</span><br><span class="line">  Alloc PE / Size       0 / 0</span><br><span class="line">  Free  PE / Size       1533 / 5.99 GiB</span><br><span class="line">  VG UUID               Cw7GGz-NH3o-Sax2-5jPv-buZS-938T-tmNKFa</span><br></pre></td></tr></table></figure>

<p>使用 vgchange 命令可以  activate/deactivate 卷组。<br>激活卷组：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># vgchange -a n vg01</span></span><br><span class="line">  0 logical volume(s) <span class="keyword">in</span> volume group <span class="string">"vg01"</span> now active</span><br></pre></td></tr></table></figure>

<p>停用卷组：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># vgchange -a y vg01</span></span><br><span class="line">  1 logical volume(s) <span class="keyword">in</span> volume group <span class="string">"vg01"</span> now active</span><br></pre></td></tr></table></figure>

<h4 id="创建逻辑卷"><a href="#创建逻辑卷" class="headerlink" title="创建逻辑卷"></a>创建逻辑卷</h4><p>使用 lvcreate 命令在卷组中创建逻辑卷。</p>
<ul>
<li>如果在创建逻辑卷时未指定卷名，默认卷名是 lvol#，#代表逻辑卷序号。</li>
<li>一般来讲，如果在创建逻辑卷时不指定所用物理卷，逻辑卷会在紧邻当前位置的下一个可用 PV 上创建。</li>
</ul>
<p>创建一个 5GB 大小的名称为 lvol01 的逻辑卷：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># lvcreate -L 5G -n lvol01 vg01</span></span><br><span class="line">  Logical volume <span class="string">"lvol01"</span> created</span><br></pre></td></tr></table></figure>

<p>创建一个 stripped 卷，通过以下命令创建一个跨越三个物理卷的 stripped 逻辑卷：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># lvcreate -L 5G -I 4096 -i 3 -n lvol01 vg01</span></span><br><span class="line">  Rounding size (1280 extents) up to stripe boundary size (1281 extents)</span><br><span class="line">  Logical volume <span class="string">"lvol01"</span> created</span><br></pre></td></tr></table></figure>

<p>lvcreate 命令的部分参数说明如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">I - PVs to span <span class="keyword">while</span> creating striped volume</span><br><span class="line">i - stripe unit</span><br></pre></td></tr></table></figure>

<p>创建 mirrored 卷，使用如下命令创建一个跨越三个物理卷的含有三路镜像的卷：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># lvcreate -L 1G -m 2 -n lvol01 vg01</span></span><br><span class="line">  Logical volume <span class="string">"lvol01"</span> created</span><br></pre></td></tr></table></figure>

<p>在创建镜像逻辑卷时可以指定使用哪些物理卷，这里卷组中只有三个物理卷，所以默认逻辑卷默认在这三个物理卷上创建。</p>
<p>查看逻辑卷<br>可以使用  lvdisplay、lvs 和 lvscan 命令查看创建的逻辑卷：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># lvs /dev/vg01/lvol01</span></span><br><span class="line">  LV     VG   Attr      LSize Pool Origin Data%  Move Log         Cpy%Sync Convert</span><br><span class="line">  lvol01 vg01 mwi<span class="_">-a</span>-m-- 1.00g                         lvol01_mlog   100.00</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># lvdisplay /dev/vg01/lvol01</span></span><br><span class="line">  --- Logical volume ---</span><br><span class="line">  LV Path                /dev/vg01/lvol01</span><br><span class="line">  LV Name                lvol01</span><br><span class="line">  VG Name                vg01</span><br><span class="line">  LV UUID                ptlmAV-mO42-fWiJ-e2Ml-r9kj-PFcC-MOexxw</span><br><span class="line">  LV Write Access        <span class="built_in">read</span>/write</span><br><span class="line">  LV Creation host, time localhost.localdomain, 2014-10-22 09:04:25 -0700</span><br><span class="line">  LV Status              available</span><br><span class="line">  <span class="comment"># open                 0</span></span><br><span class="line">  LV Size                1.00 GiB</span><br><span class="line">  Current LE             256</span><br><span class="line">  Mirrored volumes       3</span><br><span class="line">  Segments               1</span><br><span class="line">  Allocation             inherit</span><br><span class="line">  Read ahead sectors     auto</span><br><span class="line">  - currently <span class="built_in">set</span> to     256</span><br><span class="line">  Block device           253:4</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># lvscan</span></span><br><span class="line">  ACTIVE            <span class="string">'/dev/vg01/lvol01'</span> [1.00 GiB] inherit</span><br></pre></td></tr></table></figure>

<h4 id="创建文件系统"><a href="#创建文件系统" class="headerlink" title="创建文件系统"></a>创建文件系统</h4><p>最后一步是在刚刚创建好的逻辑卷上创建文件系统并将其挂载到系统目录从而能够访问它并且存储数据。使用 mkfs 命令在逻辑卷上创建文件系统。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># mkfs.ext4 /dev/vg01/lvol01</span></span><br><span class="line">mke2fs 1.41.12 (17-May-2010)</span><br><span class="line">Filesystem label=</span><br><span class="line">OS <span class="built_in">type</span>: Linux</span><br><span class="line">Block size=4096 (<span class="built_in">log</span>=2)</span><br><span class="line">Fragment size=4096 (<span class="built_in">log</span>=2)</span><br><span class="line">Stride=0 blocks, Stripe width=0 blocks</span><br><span class="line">65536 inodes, 262144 blocks</span><br><span class="line">13107 blocks (5.00%) reserved <span class="keyword">for</span> the super user</span><br><span class="line">First data block=0</span><br><span class="line">Maximum filesystem blocks=268435456</span><br><span class="line">8 block groups</span><br><span class="line">32768 blocks per group, 32768 fragments per group</span><br><span class="line">8192 inodes per group</span><br><span class="line">Superblock backups stored on blocks:</span><br><span class="line">	32768, 98304, 163840, 229376</span><br><span class="line"></span><br><span class="line">Writing inode tables: <span class="keyword">done</span></span><br><span class="line">Creating journal (8192 blocks): <span class="keyword">done</span></span><br><span class="line">Writing superblocks and filesystem accounting information: <span class="keyword">done</span></span><br><span class="line"></span><br><span class="line">This filesystem will be automatically checked every 37 mounts or</span><br><span class="line">180 days, whichever comes first.  Use tune2fs -c or -i to override.</span><br></pre></td></tr></table></figure>

<p>文件系统创建完成后，相应的逻辑卷就可以用来挂载了。请确保在 /etc/fstab 文件中添加相应的条目，然后在系统启动时就可以自动挂载逻辑卷到相应的目录了。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># mkdir /data01</span></span><br><span class="line"><span class="comment"># mount /dev/vg01/lvol01 /data01</span></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># vi /etc/fstab</span></span><br><span class="line">/dev/vg01/lvol01	/data01			ext4	defaults	0 0</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># df -h /data01</span></span><br><span class="line">Filesystem                   Size  Used  Avail  Use%  Mounted on</span><br><span class="line">/dev/mapper/vg01-lvol01     1008M   34M  924M   4%    /data01</span><br></pre></td></tr></table></figure>

<p>使用带 GUI 的工具管理 LVM<br>如果你想使用图形化界面管理 LVM，推荐  system-config-lvm。 使用以下命令进行安装：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># yum install system-config-lvm</span></span><br></pre></td></tr></table></figure>

<p>执行以下命令启动：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">system-config-lvm</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.nlark.com/yuque/0/2019/png/182657/1559628183097-f4e684b1-2ab3-432d-b062-075ed84278f4.png#align=left&display=inline&height=568&name=image.png&originHeight=568&originWidth=970&size=83085&status=done&width=970" alt="image.png"></p>
<ul>
<li>逻辑卷扩容</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 扩容到 12G</span></span><br><span class="line">lvextend -L12G /dev/vg01/lvol01</span><br><span class="line"><span class="comment"># 容量增加 1G</span></span><br><span class="line">lvextend -L+1G /dev/vg01/lvol01</span><br><span class="line"><span class="comment"># 占用 vg 所有剩余空间</span></span><br><span class="line">lvextend -l +100%FREE /dev/vg01/lvol01</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>译文</category>
      </categories>
      <tags>
        <tag>译文</tag>
        <tag>LVM</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 内存管理基础知识</title>
    <url>/post/51188647.html</url>
    <content><![CDATA[<h4 id="buffer-与-cache"><a href="#buffer-与-cache" class="headerlink" title="buffer 与 cache"></a>buffer 与 cache</h4><p>buffer 一般用于数据的批量处理，减少操作次数；cache 一般是缓存一部分文件内容在内存，命中缓存时就不需要从磁盘读取，减少 I/O 读操作。</p>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>内存管理</tag>
      </tags>
  </entry>
  <entry>
    <title>Kubernetes 实践</title>
    <url>/post/9caa466a.html</url>
    <content><![CDATA[<h4 id="kubectl"><a href="#kubectl" class="headerlink" title="kubectl"></a>kubectl</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用原始 URL 获取资源信息</span></span><br><span class="line">kubectl get --raw <span class="string">"/apis/metrics.k8s.io/v1beta1/nodes"</span></span><br><span class="line"><span class="comment"># 定制输出列</span></span><br><span class="line">kubectl get nodes -o=custom-columns=NAME:.metadata.name,TAINTS:.spec.taints</span><br><span class="line"><span class="comment"># 删除所有 evicted pods</span></span><br><span class="line">kubectl get po --all-namespaces --field-selector <span class="string">'status.phase!=Running'</span> -o json | kubectl delete -f -</span><br><span class="line">kubectl get pods --all-namespaces | grep Evicted | awk <span class="string">'&#123;print $2 " --namespace=" $1&#125;'</span> | xargs kubectl delete pod</span><br><span class="line">kubectl get pods --all-namespaces | grep -E <span class="string">'ImagePullBackOff|ErrImagePull|Evicted'</span> | awk <span class="string">'&#123;print $2 " --namespace=" $1&#125;'</span> | xargs kubectl delete pod</span><br><span class="line">kubectl get pods -n rook-ceph | grep -i Evicted | sed <span class="string">'s/\s\s*/ /g'</span> |cut -d<span class="string">" "</span> -f1 | xargs kubectl delete pod -n rook-ceph --force --grace-period=0</span><br><span class="line"><span class="comment"># 列出所有位于指定节点的 pod</span></span><br><span class="line">kubectl get pods --all-namespaces -o wide --field-selector spec.nodeName=10.25.150.64</span><br><span class="line"><span class="comment"># 从 cronjob 手动触发一个 job</span></span><br><span class="line">kubectl create job tmp-daily-report-job-02 --from=cronjob/job-1119051325-app-v1-0  -n data-infra</span><br><span class="line"><span class="comment"># 更新镜像</span></span><br><span class="line">kubectl <span class="built_in">set</span> image deployment/my-deployment mycontainer=myimage:latest</span><br><span class="line"><span class="comment"># 获取某个字段信息</span></span><br><span class="line">kubectl get deployment nginx-deployment -o jsonpath=<span class="string">'&#123;.spec.replicas&#125;'</span></span><br><span class="line"><span class="comment"># 按实际内存使用量排序</span></span><br><span class="line">kubectl top pod --no-headers --all-namespaces | sort --reverse --key 4 --numeric</span><br><span class="line"><span class="comment"># watch pod 变化，并带上时间戳</span></span><br><span class="line">kubectl get pods --watch-only | <span class="keyword">while</span> <span class="built_in">read</span> line ; <span class="keyword">do</span> <span class="built_in">echo</span> -e <span class="string">"<span class="variable">$(date +"%Y-%m-%d %H:%M:%S.%3N")</span>\t pods\t <span class="variable">$line</span>"</span> ; <span class="keyword">done</span></span><br><span class="line"><span class="comment"># 重启容器</span></span><br><span class="line">kubectl rollout restart deployment your_deployment_name</span><br><span class="line"><span class="comment"># 获取</span></span><br><span class="line">kubectl get svc pg-debug -n core -o jsonpath=<span class="string">'&#123;.spec.ports[].nodePort&#125;'</span></span><br><span class="line"><span class="comment"># 使用 annotation 查询对象</span></span><br><span class="line">kubectl get deploy -o=jsonpath=<span class="string">'&#123;.items[?(@.spec.template.metadata.annotations.prometheus\.io/scrape=="true")].metadata.name&#125;'</span></span><br></pre></td></tr></table></figure><a id="more"></a>

<h4 id="判断-deploy-ready"><a href="#判断-deploy-ready" class="headerlink" title="判断 deploy ready"></a>判断 deploy ready</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl rollout status deployment/&lt;deployment-name&gt;</span><br><span class="line"><span class="keyword">if</span> [[ <span class="string">"$?"</span> -ne 0 ]] <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"deployment failed!"</span></span><br><span class="line">    <span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>

<h4 id="列出命名空间下所有资源对象"><a href="#列出命名空间下所有资源对象" class="headerlink" title="列出命名空间下所有资源对象"></a>列出命名空间下所有资源对象</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl api-resources --verbs=list --namespaced -o name | xargs -n 1 kubectl get --show-kind --ignore-not-found -n default</span><br><span class="line"><span class="comment"># 或</span></span><br><span class="line"><span class="keyword">function</span> kubectlgetall &#123;</span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> $(kubectl api-resources --verbs=list --namespaced -o name | grep -v <span class="string">"events.events.k8s.io"</span> | grep -v <span class="string">"events"</span> | sort | uniq); <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"Resource:"</span> <span class="variable">$i</span></span><br><span class="line">    kubectl -n <span class="variable">$&#123;1&#125;</span> get --ignore-not-found <span class="variable">$&#123;i&#125;</span></span><br><span class="line">  <span class="keyword">done</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Patch-更新的三种操作"><a href="#Patch-更新的三种操作" class="headerlink" title="Patch 更新的三种操作"></a>Patch 更新的三种操作</h4><p>如下为 kubectl patch 命令更新资源的基本形式，其中 type 有三种 json/merge/strategic：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl patch xxxx --<span class="built_in">type</span> xxxx --patch xxxx</span><br></pre></td></tr></table></figure>

<p>标准的 json patch，Content-Type: application/json-patch+json：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl patch deployments patch-demo --<span class="built_in">type</span> json --patch <span class="string">'[&#123;"op":"replace", "path":"/spec/replicas", "value":4&#125;]'</span></span><br></pre></td></tr></table></figure>

<p>标准的 json merge patch，Content-Type: application/merge-json-patch+json，执行局部替换：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ cat prometheus-patch.yaml</span><br><span class="line">spec:</span><br><span class="line">  template:</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - image: uhub.service.ucloud.cn/uk8s_public/prometheus:<span class="built_in">test</span></span><br><span class="line">        name: prometheus</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以下命令会将整个 containers 列表替换掉</span></span><br><span class="line">$ kubectl patch deployment prometheus-k8s --<span class="built_in">type</span> merge --patch <span class="string">"<span class="variable">$(cat prometheus-patch.yaml)</span>"</span></span><br><span class="line">kubectl patch configmap/coredns -n kube-system --<span class="built_in">type</span> merge -p <span class="string">'&#123;"data":&#123;"upstreamNameservers":"[\"1.1.1.1\", \"1.0.0.1\"]"&#125;&#125;'</span></span><br></pre></td></tr></table></figure>

<p>JSON strategic merge patch，增量形式更新对象，默认策略是执行替换，实际策略与属性的标签有关：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ cat patch-file-containers.yaml</span><br><span class="line">spec:</span><br><span class="line">  template:</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: patch-demo-ctr-2</span><br><span class="line">        image: redis</span><br><span class="line"></span><br><span class="line">$ kubectl patch deployment patch-demo --patch <span class="string">"<span class="variable">$(cat patch-file-containers.yaml)</span>"</span></span><br><span class="line"><span class="comment"># 可以看到新增了容器，而不是替换了容器列表</span></span><br><span class="line">$ kubectl get deployment patch-demo -o yaml</span><br><span class="line">   containers:</span><br><span class="line">      - image: redis</span><br><span class="line">        imagePullPolicy: Always</span><br><span class="line">        name: patch-demo-ctr-2</span><br><span class="line">        resources: &#123;&#125;</span><br><span class="line">        terminationMessagePath: /dev/termination-log</span><br><span class="line">        terminationMessagePolicy: File</span><br><span class="line">      - image: nginx</span><br><span class="line">        imagePullPolicy: Always</span><br><span class="line">        name: patch-demo-ctr</span><br><span class="line">        resources: &#123;&#125;</span><br><span class="line">        terminationMessagePath: /dev/termination-log</span><br><span class="line">        terminationMessagePolicy: File</span><br><span class="line"></span><br><span class="line"> <span class="comment"># 这是因为在类型定义的标签中定义了 Containers 属性的 patchStrategy 为 merge，因此未执行默认替换策略</span></span><br><span class="line"> <span class="comment"># 而如果 patch 内容中包含 Tolerations 列表，则 Tolerations 会被替换</span></span><br><span class="line"> <span class="built_in">type</span> PodSpec struct &#123;</span><br><span class="line">  ...</span><br><span class="line">  Containers []Container `json:<span class="string">"containers"</span> patchStrategy:<span class="string">"merge"</span> patchMergeKey:<span class="string">"name"</span> ...`</span><br><span class="line">  Tolerations []Toleration `json:<span class="string">"tolerations,omitempty"</span> opt,name=tolerations<span class="string">"`</span></span><br></pre></td></tr></table></figure>

<h4 id="taint"><a href="#taint" class="headerlink" title="taint"></a>taint</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 去除所有节点 mater taint 使之可调度</span></span><br><span class="line">  kubectl taint nodes --all node-role.kubernetes.io/master-</span><br><span class="line"><span class="comment"># 为节点添加 taint</span></span><br><span class="line">kubectl taint nodes node1 node-role.kubernetes.io/master=:NoSchedule</span><br></pre></td></tr></table></figure>

<h4 id="toleration"><a href="#toleration" class="headerlink" title="toleration"></a>toleration</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 容忍所有</span></span><br><span class="line">tolerations:</span><br><span class="line">- operator: <span class="string">"Exists"</span></span><br></pre></td></tr></table></figure>

<h4 id="etcd"><a href="#etcd" class="headerlink" title="etcd"></a>etcd</h4><ul>
<li>命令行读写</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export ETCDCTL_API&#x3D;3</span><br><span class="line">export ETCDCTL_CACERT&#x3D;&#x2F;etc&#x2F;kubernetes&#x2F;pki&#x2F;etcd&#x2F;ca.crt</span><br><span class="line">export ETCDCTL_CERT&#x3D;&#x2F;etc&#x2F;kubernetes&#x2F;pki&#x2F;etcd&#x2F;healthcheck-client.crt</span><br><span class="line">export ETCDCTL_KEY&#x3D;&#x2F;etc&#x2F;kubernetes&#x2F;pki&#x2F;etcd&#x2F;healthcheck-client.key</span><br><span class="line">export ETCDCTL_ENDPOINTS&#x3D;192.168.180.7:2379,192.168.180.8:2379,192.168.180.9:2379</span><br><span class="line">&#x2F;&#x2F; 列出所有键值对</span><br><span class="line">etcdctl get &quot;&quot; --prefix&#x3D;true</span><br><span class="line">etcdctl get &quot;&quot; --from-key</span><br><span class="line">etcdctl get &#x2F; --prefix --keys-only</span><br><span class="line">etcdctl del &#x2F;registry&#x2F;tekton.dev&#x2F;pipelineruns&#x2F;cp-2000001293&#x2F; --prefix</span><br><span class="line">etcdctl get &#x2F;registry&#x2F;pods&#x2F;cp-2000001293&#x2F; --prefix --keys-only | wc -l</span><br></pre></td></tr></table></figure>

<ul>
<li>备份</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">etcdctl --endpoints&#x3D;https:&#x2F;&#x2F;127.0.0.1:2379 --cacert&#x3D;&#x2F;etc&#x2F;kubernetes&#x2F;pki&#x2F;etcd&#x2F;ca.crt --cert&#x3D;&#x2F;etc&#x2F;kubernetes&#x2F;pki&#x2F;etcd&#x2F;healthcheck-client.crt --key&#x3D;&#x2F;etc&#x2F;kubernetes&#x2F;pki&#x2F;etcd&#x2F;healthcheck-client.key snapshot save etcd-snapshot.db</span><br></pre></td></tr></table></figure>

<ul>
<li>磁盘读写速度过慢造成的故障</li>
</ul>
<p>如果 etcd pod 的 log 中会存在大量的类似 “etcdserver: read-only range request “key:…” with result “…” took too long (…) to execute” 的报错，大概率是磁盘损坏造成的读写速度过慢导致的，etcd 的数据存储在 /var/lib/etcd 目录下。</p>
<ul>
<li>删除节点</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">etcdctl member list</span><br><span class="line">etcdctl member remove member_id</span><br></pre></td></tr></table></figure>

<ul>
<li>check cluster health</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">etcdctl endpoint health</span><br></pre></td></tr></table></figure>

<ul>
<li>etcd 故障恢复</li>
</ul>
<p>注意：对于断电或系统意外崩溃的情况可尝试重启 etcd ，如果重启无法解决再使用备份进行恢复。<br>参考：<a href="https://blog.csdn.net/dazuiba008/article/details/94595679" target="_blank" rel="external nofollow noopener noreferrer">https://blog.csdn.net/dazuiba008/article/details/94595679</a></p>
<h4 id="drain-node"><a href="#drain-node" class="headerlink" title="drain node"></a>drain node</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 不加 --ignore-daemonsets 会因为节点上部署有 daemonset 管理的 Pod 而中止</span></span><br><span class="line"><span class="comment"># 不加 --force 会因为节点上有不属于任何控制器的独立 Pod 而中止</span></span><br><span class="line"><span class="comment"># 不加 --delete-local-data 会因为节点上有 Pod 使用了 emptyDir 或 LocalPV 之类的本地存储而中止</span></span><br><span class="line">kubectl drain &lt;nodeName&gt; --ignore-daemonsets --force --delete-local-data</span><br></pre></td></tr></table></figure>

<h4 id="nodeName-nodeSelector-Affinity"><a href="#nodeName-nodeSelector-Affinity" class="headerlink" title="nodeName/nodeSelector/Affinity"></a>nodeName/nodeSelector/Affinity</h4><p>直接指定 nodeName 后 Pod 将被视为已调度而不再经过调度器进行调度；nodeSelector 通过节点标签来指定 Pod 调度到相应节点上去，是较为简单的一种方式；Affinity 支持逻辑表达式实现更复杂的调度逻辑，且可设置不具强制性的软亲和，还可以设置 Pod 之间的亲和与反亲和特性。</p>
<h4 id="逻辑上的隔离"><a href="#逻辑上的隔离" class="headerlink" title="逻辑上的隔离"></a>逻辑上的隔离</h4><p>可通过配置限制 kubelet 在启动时设置节点的某些具有特殊前缀的标签，例如 <code>node-role.kubernetes.io/master, node-restriction.kubernetes.io/</code> 等，这些标签只能在节点加入集群后由具有集群管理员权限的用户添加上去，配合 <code>nodeSelector/Affinity</code> 可以实现 Pod 在逻辑上的一种隔离，将具有不同安全等级要求的 Pod 调度到不同的节点上去。</p>
<h4 id="节点状态和-Taint"><a href="#节点状态和-Taint" class="headerlink" title="节点状态和 Taint"></a>节点状态和 Taint</h4><p>当节点 Condition 中的最后一项即 Type 为 Ready 这一项，其 Status 值为 False 时，controller-manager 中的 node-controller 会自动为节点添加 key 为 node.kubernetes.io/not-ready 的 taint；当其 Status 值为 Unknown 时，自动添加 key 为 node.kubernetes.io/unreachable 的 taint。当 taint effect 为 NoExecute，会驱逐运行在问题节点上的 Pod。参考：<a href="https://kubernetes.io/docs/concepts/scheduling-eviction/taint-and-toleration/" target="_blank" rel="external nofollow noopener noreferrer">https://kubernetes.io/docs/concepts/scheduling-eviction/taint-and-toleration/</a>。</p>
<h4 id="Kubernetes-go-client"><a href="#Kubernetes-go-client" class="headerlink" title="Kubernetes-go-client"></a>Kubernetes-go-client</h4><ul>
<li>更新 api 对象的两种方式</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"k8s.io/apimachinery/pkg/types"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">patch, err := json.Marshal([]common.JsonPatchSpec&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        Op:    <span class="string">"replace"</span>,</span><br><span class="line">        Path:  <span class="string">"/spec/suspend"</span>,</span><br><span class="line">        Value: <span class="literal">true</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">_, err = common.CronClient.CronJobs(config.UMStorInfraNamespace).Patch(in.GetName(), types.JSONPatchType, patch)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者使用 update</span></span><br><span class="line"><span class="comment">// 先按需修改 originDeploy 中的内容，关键是要重建 objectmeta</span></span><br><span class="line">_, err = common.AppsClient.Deployments(config.UMStorInfraNamespace).Update(&amp;k8s_apps_api.Deployment&#123;</span><br><span class="line">    ObjectMeta: k8s_metav1.ObjectMeta&#123;</span><br><span class="line">        Name:            in.Name,</span><br><span class="line">        ResourceVersion: originDeploy.ResourceVersion,</span><br><span class="line">        Labels:          originDeploy.Labels,</span><br><span class="line">    &#125;,</span><br><span class="line">    Spec: originDeploy.Spec,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="证书"><a href="#证书" class="headerlink" title="证书"></a>证书</h4><ul>
<li>为 Ingress Host 生成自签名证书<ul>
<li>简易方法</li>
</ul>
</li>
</ul>
<p>参考：<a href="https://kubernetes.github.io/ingress-nginx/user-guide/tls/" target="_blank" rel="external nofollow noopener noreferrer">https://kubernetes.github.io/ingress-nginx/user-guide/tls/</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">KEY_FILE=dashboard_key</span><br><span class="line">CERT_FILE=dashboard_cert</span><br><span class="line">CERT_NAME=dashboard_tls</span><br><span class="line">HOST=kubernetes-dashboard.test</span><br><span class="line">openssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout <span class="variable">$&#123;KEY_FILE&#125;</span> -out <span class="variable">$&#123;CERT_FILE&#125;</span> -subj <span class="string">"/CN=<span class="variable">$&#123;HOST&#125;</span>/O=<span class="variable">$&#123;HOST&#125;</span>"</span></span><br><span class="line">kubectl create secret tls <span class="variable">$&#123;CERT_NAME&#125;</span> --key <span class="variable">$&#123;KEY_FILE&#125;</span> --cert <span class="variable">$&#123;CERT_FILE&#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>定制</li>
</ul>
<p>参考： <a href="https://mritd.me/2017/03/04/how-to-use-nginx-ingress/" target="_blank" rel="external nofollow noopener noreferrer">https://mritd.me/2017/03/04/how-to-use-nginx-ingress/</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 生成 CA 自签证书 ， 也可以直接使用 /etc/kubernetes/pki/ 下的 CA 证书</span></span><br><span class="line">mkdir cert &amp;&amp; <span class="built_in">cd</span> cert</span><br><span class="line">openssl genrsa -out ca-key.pem 2048</span><br><span class="line">openssl req -x509 -new -nodes -key ca-key.pem -days 10000 -out ca.pem -subj <span class="string">"/CN=kube-ca"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 编辑 openssl 配置</span></span><br><span class="line">cp /etc/pki/tls/openssl.cnf .</span><br><span class="line">vim openssl.cnf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 主要修改如下</span></span><br><span class="line">[req]</span><br><span class="line">req_extensions = v3_req <span class="comment"># 这行默认注释关着的 把注释删掉</span></span><br><span class="line"><span class="comment"># 下面配置是新增的</span></span><br><span class="line">[ v3_req ]</span><br><span class="line">basicConstraints = CA:FALSE</span><br><span class="line">keyUsage = nonRepudiation, digitalSignature, keyEncipherment</span><br><span class="line">subjectAltName = @alt_names</span><br><span class="line">[alt_names]</span><br><span class="line">DNS.1 = harbor.sh.umcloud.network</span><br><span class="line">DNS.2 = gitlab.sh.umcloud.network</span><br><span class="line">DNS.3 = minio.sh.umcloud.network</span><br><span class="line">DNS.4 = registry.sh.umcloud.network</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成证书</span></span><br><span class="line">openssl genrsa -out ingress-key.pem 2048</span><br><span class="line">openssl req -new -key ingress-key.pem -out ingress.csr -subj <span class="string">"/CN=kube-ingress"</span> -config openssl.cnf</span><br><span class="line">openssl x509 -req -<span class="keyword">in</span> ingress.csr -CA ca.pem -CAkey ca-key.pem -CAcreateserial -out ingress.pem -days 365 -extensions v3_req -extfile openssl.cnf</span><br><span class="line">kubectl create secret tls gitlab-ce-gitlab-tls --key ingress-key.pem --cert ingress.pem -n gitlab-ce</span><br></pre></td></tr></table></figure>

<ul>
<li>查看证书内容</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">openssl x509 -in ca.crt -text -noout</span><br><span class="line">openssl s_client -showcerts -connect www.baidu.com:443</span><br></pre></td></tr></table></figure>

<ul>
<li>检查证书过期时间</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubeadm alpha certs check-expiration</span><br></pre></td></tr></table></figure>

<h4 id="Kubeadm"><a href="#Kubeadm" class="headerlink" title="Kubeadm"></a>Kubeadm</h4><ul>
<li>kubeadm join … -v 10</li>
</ul>
<p>kubeadm 添加第二个 master 节点时出现以下错误：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">I0724 10:27:10.396559   31977 token.go:141] [discovery] Requesting info from <span class="string">"https://192.168.2.65:6445"</span> again to validate TLS against the pinned public key</span><br><span class="line">I0724 10:27:10.397359   31977 round_trippers.go:419] curl -k -v -XGET  -H <span class="string">"User-Agent: kubeadm/v1.14.1 (linux/amd64) kubernetes/b739410"</span> -H <span class="string">"Accept: application/json, */*"</span> <span class="string">'https://192.168.2.65:6445/api/v1/namespaces/kube-public/configmaps/cluster-info'</span></span><br><span class="line">I0724 10:27:10.403962   31977 round_trippers.go:438] GET https://192.168.2.65:6445/api/v1/namespaces/kube-public/configmaps/cluster-info  <span class="keyword">in</span> 6 milliseconds</span><br><span class="line">I0724 10:27:10.403989   31977 round_trippers.go:444] Response Headers:</span><br><span class="line">I0724 10:27:10.404036   31977 token.go:147] [discovery] Failed to request cluster info, will try again: [Get https://192.168.2.65:6445/api/v1/namespaces/kube-public/configmaps/cluster-info: x509: certificate has expired or is not yet valid]</span><br></pre></td></tr></table></figure>

<p>错误表明 kubeadm 已经成功从 kube-public 命名空间下的 cluster-info confgimap 中获取到了集群信息，然后在验证集群证书的有效性时出错。<code>x509: certificate has expired or is not yet valid</code> 一般是由于系统时间错误导致，可以先用 date 命令确定本地时间是否正确。如果本地时间错误，可以尝试使用 ntp 同步系统时间。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ntpdate cn.pool.ntp.org</span><br><span class="line">// 如果找不到 ntp 命令，可以使用如下的命令进行安装</span><br><span class="line">yum instal ntp</span><br></pre></td></tr></table></figure>

<ul>
<li>kubeadm 部署时 config 文件</li>
</ul>
<p>参考：<a href="https://godoc.org/k8s.io/kubernetes/cmd/kubeadm/app/apis/kubeadm/v1beta2" target="_blank" rel="external nofollow noopener noreferrer">https://godoc.org/k8s.io/kubernetes/cmd/kubeadm/app/apis/kubeadm/v1beta2</a>，kubelet 自定义配置参考：<a href="https://godoc.org/k8s.io/kubelet/config/v1beta1#KubeletConfiguration" target="_blank" rel="external nofollow noopener noreferrer">https://godoc.org/k8s.io/kubelet/config/v1beta1#KubeletConfiguration</a>。一个需要注意的地方是<br>一个单 master 节点集群配置参考，需要注意的是虽然在下面的配置中已经设置了 failSwapOn 为 false，但是 kubeadm 并不会去检测该配置，仍然会报错，不过该报错可以被忽略，因为这个设置随后确实会被添加到 kubelet 的配置中并生效，因此 init 时执行  <code>sudo kubeadm init --config kubeadm.yml --ignore-preflight-errors=all</code> 即可：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: kubeadm.k8s.io/v1beta2</span><br><span class="line">imageRepository: gcr.azk8s.cn/google-containers</span><br><span class="line">kind: ClusterConfiguration</span><br><span class="line">kubernetesVersion: v1.16.0</span><br><span class="line">networking:</span><br><span class="line">  serviceSubnet: 10.96.0.0/12</span><br><span class="line">  podSubnet: 10.244.0.0/16</span><br><span class="line">apiServer:</span><br><span class="line">  extraArgs:</span><br><span class="line">    <span class="built_in">bind</span>-address: 0.0.0.0</span><br><span class="line">    feature-gates: <span class="string">"EphemeralContainers=true"</span></span><br><span class="line">  extraVolumes:</span><br><span class="line">  - name: <span class="string">"timezone"</span></span><br><span class="line">    hostPath: <span class="string">"/etc/localtime"</span></span><br><span class="line">    mountPath: <span class="string">"/etc/localtime"</span></span><br><span class="line">    readOnly: <span class="literal">true</span></span><br><span class="line">    pathType: File</span><br><span class="line">controllerManager:</span><br><span class="line">  extraArgs:</span><br><span class="line">    <span class="built_in">bind</span>-address: 0.0.0.0</span><br><span class="line">    feature-gates: <span class="string">"EphemeralContainers=true"</span></span><br><span class="line">  extraVolumes:</span><br><span class="line">  - name: <span class="string">"timezone"</span></span><br><span class="line">    hostPath: <span class="string">"/etc/localtime"</span></span><br><span class="line">    mountPath: <span class="string">"/etc/localtime"</span></span><br><span class="line">    readOnly: <span class="literal">true</span></span><br><span class="line">    pathType: File</span><br><span class="line">scheduler:</span><br><span class="line">  extraArgs:</span><br><span class="line">    address: 0.0.0.0</span><br><span class="line">    feature-gates: <span class="string">"EphemeralContainers=true"</span></span><br><span class="line">  extraVolumes:</span><br><span class="line">  - name: <span class="string">"timezone"</span></span><br><span class="line">    hostPath: <span class="string">"/etc/localtime"</span></span><br><span class="line">    mountPath: <span class="string">"/etc/localtime"</span></span><br><span class="line">    readOnly: <span class="literal">true</span></span><br><span class="line">    pathType: File</span><br><span class="line">---</span><br><span class="line">apiVersion: kubeproxy.config.k8s.io/v1alpha1</span><br><span class="line">clusterCIDR: 10.244.0.0/16</span><br><span class="line">iptables:</span><br><span class="line">  masqueradeAll: <span class="literal">false</span></span><br><span class="line">  minSyncPeriod: 0s</span><br><span class="line">  syncPeriod: 30s</span><br><span class="line">ipvs:</span><br><span class="line">  excludeCIDRs: null</span><br><span class="line">  minSyncPeriod: 0s</span><br><span class="line">  scheduler: rr</span><br><span class="line">  syncPeriod: 30s</span><br><span class="line">kind: KubeProxyConfiguration</span><br><span class="line">mode: ipvs</span><br><span class="line">---</span><br><span class="line">apiVersion: kubelet.config.k8s.io/v1beta1</span><br><span class="line">cgroupDriver: systemd</span><br><span class="line">failSwapOn: <span class="literal">false</span></span><br><span class="line">kind: KubeletConfiguration</span><br></pre></td></tr></table></figure>

<ul>
<li>内核配置参考</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[xyc-pc ~]<span class="comment"># cat /etc/modules-load.d/ipvs.conf</span></span><br><span class="line">ip_vs</span><br><span class="line">ip_vs_lc</span><br><span class="line">ip_vs_wlc</span><br><span class="line">ip_vs_rr</span><br><span class="line">ip_vs_wrr</span><br><span class="line">ip_vs_lblc</span><br><span class="line">ip_vs_lblcr</span><br><span class="line">ip_vs_dh</span><br><span class="line">ip_vs_sh</span><br><span class="line">ip_vs_nq</span><br><span class="line">ip_vs_sed</span><br><span class="line">ip_vs_ftp</span><br><span class="line">nf_conntrack</span><br><span class="line">br_netfilter</span><br><span class="line"></span><br><span class="line">//使其临时生效</span><br><span class="line">ipvs_modules=<span class="string">"ip_vs ip_vs_lc ip_vs_wlc ip_vs_rr ip_vs_wrr ip_vs_lblc ip_vs_lblcr ip_vs_dh ip_vs_sh ip_vs_nq ip_vs_sed ip_vs_ftp nf_conntrack br_netfilter"</span>;</span><br><span class="line"><span class="keyword">for</span> kernel_module <span class="keyword">in</span> <span class="variable">$&#123;ipvs_modules&#125;</span>; <span class="keyword">do</span> modprobe <span class="variable">$&#123;kernel_module&#125;</span> &gt; /dev/null 2&gt;&amp;1;<span class="keyword">done</span></span><br><span class="line"></span><br><span class="line">[xyc-pc ~]<span class="comment"># cat /etc/sysctl.conf</span></span><br><span class="line">net.bridge.bridge-nf-call-iptables=1</span><br><span class="line">net.bridge.bridge-nf-call-ip6tables=1</span><br><span class="line">vm.max_map_count=262144</span><br><span class="line">vm.swappiness=0</span><br><span class="line">net.core.somaxconn=32768</span><br><span class="line">net.ipv4.tcp_syncookies=0</span><br><span class="line">net.ipv4.conf.all.rp_filter=1</span><br><span class="line">net.ipv4.ip_forward=1</span><br><span class="line">net.core.default_qdisc=fq_codel</span><br><span class="line">//使其临时生效</span><br><span class="line">sysctl -p /etc/sysctl.conf</span><br></pre></td></tr></table></figure>

<h4 id="Helm"><a href="#Helm" class="headerlink" title="Helm"></a>Helm</h4><ul>
<li>helm init 使用 azure 镜像</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">helm init --stable-repo-url  http:&#x2F;&#x2F;mirror.azure.cn&#x2F;kubernetes&#x2F;charts&#x2F;</span><br><span class="line">helm repo add incubator http:&#x2F;&#x2F;mirror.azure.cn&#x2F;kubernetes&#x2F;charts-incubator&#x2F;</span><br></pre></td></tr></table></figure>

<ul>
<li>从模板生成本地文件</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir yamls</span><br><span class="line">helm fetch --untar --untardir . &#39;stable&#x2F;redis&#39; #makes a directory called redis</span><br><span class="line">helm template --output-dir &#39;.&#x2F;yamls&#39; &#39;.&#x2F;redis&#39; #redis dir (local helm chart), export to yamls dir</span><br></pre></td></tr></table></figure>

<ul>
<li>拉取压缩文件到本地</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">helm fetch ucloud&#x2F;uk8s-etcd-backup</span><br></pre></td></tr></table></figure>

<ul>
<li>制作 chart</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜ tree uk8s-etcd-backup</span><br><span class="line">uk8s-etcd-backup</span><br><span class="line">├── Chart.yaml</span><br><span class="line">├── templates</span><br><span class="line">│   ├── configmap.yaml</span><br><span class="line">│   ├── cronjob.yaml</span><br><span class="line">│   └── secret.yaml</span><br><span class="line">└── values.yaml</span><br><span class="line"></span><br><span class="line">helm package uk8s-etcd-backup</span><br></pre></td></tr></table></figure>

<h4 id="添加自定义-DNS-记录"><a href="#添加自定义-DNS-记录" class="headerlink" title="添加自定义 DNS 记录"></a>添加自定义 DNS 记录</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@10-8-62-148 ~]<span class="comment"># kubectl get cm -n kube-system coredns -oyaml</span></span><br><span class="line">apiVersion: v1</span><br><span class="line">data:</span><br><span class="line">  Corefile: |</span><br><span class="line">    .:53 &#123;</span><br><span class="line">        errors</span><br><span class="line">        health</span><br><span class="line">        rewrite name harbor.sh.umcloud.network harbor.default.svc.cluster.local</span><br><span class="line">        rewrite name docker.sh.umcloud.network docker.default.svc.cluster.local</span><br><span class="line">        kubernetes cluster.local <span class="keyword">in</span>-addr.arpa ip6.arpa &#123;</span><br><span class="line">           pods insecure</span><br><span class="line">           upstream</span><br><span class="line">           fallthrough <span class="keyword">in</span>-addr.arpa ip6.arpa</span><br><span class="line">           ttl 30</span><br><span class="line">        &#125;</span><br><span class="line">        hosts &#123;</span><br><span class="line">          10.250.11.11 test1.test.com</span><br><span class="line">          10.250.12.64 test2.test.com</span><br><span class="line">          fallthrough</span><br><span class="line">        &#125;</span><br><span class="line">        prometheus :9153</span><br><span class="line">        forward . /etc/resolv.conf</span><br><span class="line">        cache 30</span><br><span class="line">        loop</span><br><span class="line">        reload</span><br><span class="line">        loadbalance</span><br><span class="line">    &#125;</span><br><span class="line">kind: ConfigMap</span><br><span class="line">metadata:</span><br><span class="line">  creationTimestamp: <span class="string">"2019-09-05T07:29:37Z"</span></span><br><span class="line">  name: coredns</span><br><span class="line">  namespace: kube-system</span><br><span class="line"></span><br><span class="line">[root@10-8-62-148 ~]<span class="comment"># cat umcloud-svc.yaml</span></span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  name: harbor</span><br><span class="line">spec:</span><br><span class="line">  ports:</span><br><span class="line">    - port: 80</span><br><span class="line">      name: http</span><br><span class="line">    - port: 443</span><br><span class="line">      name: https</span><br><span class="line">---</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Endpoints</span><br><span class="line">metadata:</span><br><span class="line">  name: harbor</span><br><span class="line">subsets:</span><br><span class="line">  - addresses:</span><br><span class="line">      - ip: 10.8.62.148</span><br><span class="line">    ports:</span><br><span class="line">      - port: 80</span><br><span class="line">        name: http</span><br><span class="line">        protocol: TCP</span><br><span class="line">      - port: 443</span><br><span class="line">        name: https</span><br><span class="line">        protocol: TCP</span><br></pre></td></tr></table></figure>

<h4 id="向容器添加-hosts-记录"><a href="#向容器添加-hosts-记录" class="headerlink" title="向容器添加 hosts 记录"></a>向容器添加 hosts 记录</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: hostaliases-pod</span><br><span class="line">spec:</span><br><span class="line">  restartPolicy: Never</span><br><span class="line">  hostAliases:</span><br><span class="line">  - ip: <span class="string">"127.0.0.1"</span></span><br><span class="line">    hostnames:</span><br><span class="line">    - <span class="string">"foo.local"</span></span><br><span class="line">    - <span class="string">"bar.local"</span></span><br><span class="line">  - ip: <span class="string">"10.1.2.3"</span></span><br><span class="line">    hostnames:</span><br><span class="line">    - <span class="string">"foo.remote"</span></span><br><span class="line">    - <span class="string">"bar.remote"</span></span><br><span class="line">  containers:</span><br><span class="line">  - name: cat-hosts</span><br><span class="line">    image: busybox</span><br><span class="line">    <span class="built_in">command</span>:</span><br><span class="line">    - cat</span><br><span class="line">    args:</span><br><span class="line">    - <span class="string">"/etc/hosts"</span></span><br></pre></td></tr></table></figure>

<h4 id="ingress-nginx"><a href="#ingress-nginx" class="headerlink" title="ingress-nginx"></a>ingress-nginx</h4><ul>
<li>为转向上游的请求添加 header：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">apiVersion: extensions/v1beta1</span><br><span class="line">kind: Ingress</span><br><span class="line">metadata:</span><br><span class="line">  annotations:</span><br><span class="line">    ingress.kubernetes.io/configuration-snippet: |-</span><br><span class="line">      <span class="keyword">set</span> $best_http_host "usergate.dev.choicesaas.cn";</span><br><span class="line">      proxy_set_header Host                   $best_http_host;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<ul>
<li>nginx 原样传递编码过的 URL</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">map &#39;&#39; $seed_uri &#123;</span><br><span class="line">    default $request_uri;</span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line">    listen       8001;</span><br><span class="line">    server_name  _;</span><br><span class="line">    root         &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;;</span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">        proxy_set_header Host $http_host;</span><br><span class="line">        proxy_pass http:&#x2F;&#x2F;umstor-rgw-customer.storage-system.svc.cluster.local$seed_uri;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>自定义 timeout</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: extensions/v1beta1</span><br><span class="line">kind: Ingress</span><br><span class="line">metadata:</span><br><span class="line">  annotations:</span><br><span class="line">    nginx.ingress.kubernetes.io/proxy-read-timeout: <span class="string">"1800"</span></span><br><span class="line">    nginx.ingress.kubernetes.io/proxy-send-timeout: <span class="string">"1800"</span></span><br><span class="line">    nginx.ingress.kubernetes.io/rewrite-target: /<span class="variable">$2</span></span><br><span class="line">    nginx.ingress.kubernetes.io/ssl-redirect: <span class="string">"false"</span></span><br></pre></td></tr></table></figure>

<ul>
<li>后端服务需要使用 HTTPS 访问</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nginx.ingress.kubernetes.io/backend-protocol: <span class="string">"HTTPS"</span></span><br></pre></td></tr></table></figure>

<ul>
<li>透传 TLS 握手</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nginx.ingress.kubernetes.io/ssl-passthrough: <span class="string">"true"</span></span><br></pre></td></tr></table></figure>

<ul>
<li>实现泛域名解析</li>
</ul>
<p>借助 lua 脚本实现，参考：<a href="https://www.bookstack.cn/read/kubernetes-practice-guide/best-practice-wildcard-domain-forward.md" target="_blank" rel="external nofollow noopener noreferrer">https://www.bookstack.cn/read/kubernetes-practice-guide/best-practice-wildcard-domain-forward.md</a></p>
<h4 id="CronJob-与-Job"><a href="#CronJob-与-Job" class="headerlink" title="CronJob 与 Job"></a>CronJob 与 Job</h4><p>建议设置  startingDeadlineSeconds 值以防止从最后一次调度到当前时间错过的调度次数超过 100 导致不再进行调度（使用 etcd 备份数据恢复集群时可能出现这种情况），参考：<a href="https://www.jianshu.com/p/3e3b18414e45" target="_blank" rel="external nofollow noopener noreferrer">https://www.jianshu.com/p/3e3b18414e45</a>。<br>job.spec.ttlSecondsAfterFinished 参数有三种选项：不设置，则 Job 不会被自动删除；设置为 0 ，则在 Job 运行完成后立即自动删除；设置为非零值，则在一定时间后自动删除。<br>cronjob 则通过  cronjob.spec.failedJobsHistoryLimit （默认值为 1 ） 和  cronjob.spec.successfulJobsHistoryLimit （默认值为 3 ） 来控制保存的 Job 数量。<br>job.spec.template.spec.restartPolicy 设置的是 Pod 的重启策略，在 Job 这种一次性任务的场景中，应当设置为 OnFailure 或者 Never，在 Deployment 场景中应当保持默认值 Always。<br>job.spec.backoffLimit 设置的次数指的是 Pod 运行失败后，尝试重新创建 Pod 的次数，不包括第一次运行。例如，设置 backoffLimit 为 2 ，则该 job 相关的 Pod 最多会重试三次（通过依次创建 3 个不同的 Pod 实现）。这有别于 job.spec.template.spec.restartPolicy 参数，restartPolicy 是针对同一个 Pod 不停重启重试，而 job.spec.backoffLimit 则是尝试创建新的 Pod。</p>
<h4 id="field-selector-和-labels-selector"><a href="#field-selector-和-labels-selector" class="headerlink" title="field-selector 和 labels-selector"></a>field-selector 和 labels-selector</h4><p>字段选择器：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl get pods --field-selector&#x3D;status.phase!&#x3D;Running,spec.restartPolicy&#x3D;Always</span><br><span class="line">kubectl get statefulsets,services --all-namespaces --field-selector metadata.namespace!&#x3D;default</span><br></pre></td></tr></table></figure>

<p>标签选择器：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl get pods -l environment&#x3D;production,tier&#x3D;frontend</span><br><span class="line">kubectl get pods -l &#39;environment in (production),tier in (frontend)&#39;</span><br><span class="line">kubectl get pods -l &#39;environment in (production, qa)&#39;</span><br><span class="line">kubectl get pods -l &#39;environment,environment notin (frontend)&#39;</span><br><span class="line"># 也可以仅使用标签名选择，而不必指定标签值</span><br><span class="line">kubectl get cm -n monitoring -l prometheus-name</span><br></pre></td></tr></table></figure>

<h4 id="使用-subPath-挂载-Volume"><a href="#使用-subPath-挂载-Volume" class="headerlink" title="使用 subPath 挂载 Volume"></a>使用 subPath 挂载 Volume</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apiVersion: apps&#x2F;v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: mysql</span><br><span class="line">spec:</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: mysql</span><br><span class="line">  strategy:</span><br><span class="line">    type: Recreate</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: mysql</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - image: mysql:5.6</span><br><span class="line">        name: mysql</span><br><span class="line">        env:</span><br><span class="line">          # Use secret in real usage</span><br><span class="line">        - name: MYSQL_ROOT_PASSWORD</span><br><span class="line">          value: password</span><br><span class="line">        ports:</span><br><span class="line">        - containerPort: 3306</span><br><span class="line">          name: mysql</span><br><span class="line">        volumeMounts:</span><br><span class="line">        - name: mysql-configmap-volume</span><br><span class="line">          mountPath: &#x2F;etc&#x2F;mysql&#x2F;conf.d&#x2F;binlog_format.cnf</span><br><span class="line">          subPath: binlog_format.cnf</span><br><span class="line">      volumes:</span><br><span class="line">      - name: mysql-configmap-volume</span><br><span class="line">        configMap:</span><br><span class="line">          name: mysql-configmap</span><br><span class="line">          items:</span><br><span class="line">          - key: mysql_binlog_format.cnf</span><br><span class="line">            path: binlog_format.cnf</span><br></pre></td></tr></table></figure>

<h4 id="创建并使用-imagePullSecrets"><a href="#创建并使用-imagePullSecrets" class="headerlink" title="创建并使用 imagePullSecrets"></a>创建并使用 imagePullSecrets</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 创建 secret</span><br><span class="line">kubectl create secret docker-registry my-registry --docker-server&#x3D;my.private.registry --docker-username&#x3D;test --docker-password&#x3D;test</span><br><span class="line">&#x2F;&#x2F; 在 default service account 中使用</span><br><span class="line">[root@cicd03 ~]# kubectl get serviceaccount default -oyaml</span><br><span class="line">apiVersion: v1</span><br><span class="line">imagePullSecrets:</span><br><span class="line">- name: my-registry</span><br><span class="line">kind: ServiceAccount</span><br><span class="line">metadata:</span><br><span class="line">  name: default</span><br><span class="line">  namespace: default</span><br><span class="line">secrets:</span><br><span class="line">- name: default-token-l9xgs</span><br></pre></td></tr></table></figure>

<h4 id="sealos-部署-Kubernetes"><a href="#sealos-部署-Kubernetes" class="headerlink" title="sealos 部署 Kubernetes"></a>sealos 部署 Kubernetes</h4><p>开发测试可以使用 <a href="https://github.com/fanux/sealos" target="_blank" rel="external nofollow noopener noreferrer">sealos</a> 这个工具，通过离线安装包部署 Kubernetes，省心实用，但是作者在改过的 Kubeadm 代码里夹杂了一些私货令人不喜。</p>
<ul>
<li><p>离线安装包下载链接</p>
<table>
<thead>
<tr>
<th>1.17.0</th>
<th><a href="https://sealyun.oss-cn-beijing.aliyuncs.com/413bd3624b2fb9e466601594b4f72072-1.17.0/kube1.17.0.tar.gz" target="_blank" rel="external nofollow noopener noreferrer">https://sealyun.oss-cn-beijing.aliyuncs.com/413bd3624b2fb9e466601594b4f72072-1.17.0/kube1.17.0.tar.gz</a></th>
</tr>
</thead>
<tbody><tr>
<td>1.17.1</td>
<td><a href="https://sealyun.oss-cn-beijing.aliyuncs.com/9347ea4e446ce514dbba6f686034a363-1.17.1/kube1.17.1.tar.gz" target="_blank" rel="external nofollow noopener noreferrer">https://sealyun.oss-cn-beijing.aliyuncs.com/9347ea4e446ce514dbba6f686034a363-1.17.1/kube1.17.1.tar.gz</a></td>
</tr>
<tr>
<td>1.19.0</td>
<td><a href="https://sealyun.oss-cn-beijing.aliyuncs.com/c937a97b72d16653ef25b0b54bdc7131-1.19.0/kube1.19.0.tar.gz" target="_blank" rel="external nofollow noopener noreferrer">https://sealyun.oss-cn-beijing.aliyuncs.com/c937a97b72d16653ef25b0b54bdc7131-1.19.0/kube1.19.0.tar.gz</a></td>
</tr>
</tbody></table>
</li>
<li><p>添加 master 节点</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 先安装好 docker， 参见：https:&#x2F;&#x2F;docs.docker.com&#x2F;install&#x2F;linux&#x2F;docker-ce&#x2F;centos&#x2F;</span><br><span class="line">systemctl enable --now docker</span><br><span class="line">&#x2F;&#x2F; 从集群内节点拷贝离线安装包并解压缩</span><br><span class="line">scp 192.168.180.8:.&#x2F;kube1.15.0.tar.gz .</span><br><span class="line">tar zxvf kube1.15.0.tar.gz</span><br><span class="line">&#x2F;&#x2F; 执行初始化操作</span><br><span class="line">chmod +x .&#x2F;kube&#x2F;shell&#x2F;init.sh</span><br><span class="line">cd kube&#x2F;shell</span><br><span class="line">.&#x2F;init.sh</span><br><span class="line">&#x2F;&#x2F; 在 hosts 文件中加入 apiserver 解析</span><br><span class="line">echo &#39;192.168.180.7 apiserver.cluster.local&#39; &gt;&gt; &#x2F;etc&#x2F;hosts</span><br><span class="line">&#x2F;&#x2F; 获取 cert-key</span><br><span class="line">kubeadm init phase upload-certs --upload-certs</span><br><span class="line">&#x2F;&#x2F; 获取加入集群的命令</span><br><span class="line">kubeadm token create --print-join-command</span><br><span class="line">&#x2F;&#x2F; 拼出 master 节点加入集群的命令并执行</span><br><span class="line">kubeadm join apiserver.cluster.local:6443 --control-plane --certificate-key $CERT_KEY --token f0d79y.lekvh1338tye45d0 --discovery-token-ca-cert-hash sha256:33d4cbc2207ad24c551cbdd0d5b9c70cf42232795d87d7c30054ddb8773c99f6</span><br><span class="line">&#x2F;&#x2F; 加入成功后替换解析地址为本机 IP</span><br></pre></td></tr></table></figure>

<h4 id="优雅地删除节点"><a href="#优雅地删除节点" class="headerlink" title="优雅地删除节点"></a>优雅地删除节点</h4><p>删除 master 节点时注意可能需要手动修改  kubeadm-config 中的配置，同时手动修改  /etc/kubernetes/manifests/etcd.yaml 文件移除相关 IP。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl get nodes</span><br><span class="line">kubectl drain &lt;node-name&gt;</span><br><span class="line">kubectl drain &lt;node-name&gt; --ignore-daemonsets --delete-local-data</span><br><span class="line">kubectl delete node &lt;node-name&gt;</span><br></pre></td></tr></table></figure>

<h4 id="重启容器而非删除"><a href="#重启容器而非删除" class="headerlink" title="重启容器而非删除"></a>重启容器而非删除</h4><p>删除容器后会重新进行调度，如果希望在同一个宿主机上重新拉起容器可以执行如下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在容器中执行如下命令，会使容器重新创建，但不会重新调度</span></span><br><span class="line"><span class="built_in">kill</span> 1</span><br></pre></td></tr></table></figure>

<p>但需要注意的是，上述命令会造成容器重建，所以在容器中进行的非持久修改均会丢失，若想保留临时修改，可先找到容器所在宿主机，然后登录到宿主机上执行 <code>docker restart</code> 重启会保留临时修改，往往用于调试场景。</p>
<h4 id="ServiceAccountTokenVolumeProjection-生成有时效的-Token"><a href="#ServiceAccountTokenVolumeProjection-生成有时效的-Token" class="headerlink" title="ServiceAccountTokenVolumeProjection 生成有时效的 Token"></a>ServiceAccountTokenVolumeProjection 生成有时效的 Token</h4><p>参考：<a href="https://developer.aliyun.com/article/742572" target="_blank" rel="external nofollow noopener noreferrer">https://developer.aliyun.com/article/742572</a>，<a href="https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#service-account-token-volume-projection" target="_blank" rel="external nofollow noopener noreferrer">https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#service-account-token-volume-projection</a>,<a href="https://www.alibabacloud.com/help/zh/doc-detail/160384.htm" target="_blank" rel="external nofollow noopener noreferrer">https://www.alibabacloud.com/help/zh/doc-detail/160384.htm</a><br>kube-apiserver<br><img src="https://cdn.nlark.com/yuque/0/2020/png/182657/1586427070015-35b14a0a-4cf8-48cf-ae25-db4531f0b8b1.png#crop=0&crop=0&crop=1&crop=1&height=824&id=iJVjL&margin=%5Bobject%20Object%5D&name=image.png&originHeight=824&originWidth=983&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=117967&status=done&style=none&title=&width=983" alt="image.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--service-account-issuer&#x3D;kubernetes.default.svc \</span><br><span class="line">--service-account-signing-key-file&#x3D;&#x2F;etc&#x2F;kubernetes&#x2F;ssl&#x2F;ca-key.pem \</span><br><span class="line">--api-audiences&#x3D;kubernetes.default.svc \</span><br><span class="line">--feature-gates&#x3D;BoundServiceAccountTokenVolume&#x3D;true \</span><br></pre></td></tr></table></figure>

<p>kube-controller-manager<br><img src="https://cdn.nlark.com/yuque/0/2020/png/182657/1586427180951-d8f9d830-5f94-4bb3-bbd6-640dd513b3f2.png#crop=0&crop=0&crop=1&crop=1&height=363&id=FIfGF&margin=%5Bobject%20Object%5D&name=image.png&originHeight=363&originWidth=924&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=65129&status=done&style=none&title=&width=924" alt="image.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--controllers&#x3D;*,bootstrapsigner,tokencleaner,root-ca-cert-publisher \</span><br><span class="line">--feature-gates&#x3D;BoundServiceAccountTokenVolume&#x3D;true \</span><br></pre></td></tr></table></figure>

<p>示例</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">uhub.service.ucloud.cn/wxyz/etcd:3.4.3</span></span><br><span class="line">      <span class="attr">command:</span> <span class="string">["ping"]</span></span><br><span class="line">      <span class="attr">args:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="number">10.13</span><span class="number">.97</span><span class="number">.88</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">etcd</span></span><br><span class="line">      <span class="attr">volumeMounts:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">mountPath:</span> <span class="string">/var/run/secrets/tokens</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">vault-token</span></span><br><span class="line">  <span class="attr">serviceAccountName:</span> <span class="string">build-robot</span></span><br><span class="line">  <span class="attr">volumes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">vault-token</span></span><br><span class="line">      <span class="attr">projected:</span></span><br><span class="line">        <span class="attr">sources:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">serviceAccountToken:</span></span><br><span class="line">              <span class="attr">path:</span> <span class="string">vault-token</span></span><br><span class="line">              <span class="attr">expirationSeconds:</span> <span class="number">600</span></span><br><span class="line">              <span class="attr">audience:</span> <span class="string">vault</span></span><br></pre></td></tr></table></figure>

<h4 id="kube-controller-manager-10252-port-in-use"><a href="#kube-controller-manager-10252-port-in-use" class="headerlink" title="kube-controller-manager 10252 port in use"></a>kube-controller-manager 10252 port in use</h4><p>在一定的概率下启动 kube-controller 会出现所需端口已被 kube-apiserver 占用的情况，这是因为 kube-apiserver 向内核申请一个随机端口用于和 etcd 通信，而恰好该端口是稍后 kube-controller-manger 所需的，由于多次出现这种巧合情况，所以对随机算法仍存疑？临时解决方法是调整随机端口范围，避开 10252 端口：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">net.ipv4.ip_local_port_range="12000</span> <span class="number">65535</span><span class="string">"</span></span><br></pre></td></tr></table></figure>

<h4 id="kubelet-启动时持续报错-node-not-found"><a href="#kubelet-启动时持续报错-node-not-found" class="headerlink" title="kubelet 启动时持续报错 node not found"></a>kubelet 启动时持续报错 node not found</h4><p>一般在经过几次报错后等节点注册成功就会正常，但是有些时候会出现持续报错，此时需要注意的是在 node not found 之前出现的错误，一般解决了这些前置错误就可以了。</p>
<h4 id="编译带-debug-信息的-kubernetes-组件"><a href="#编译带-debug-信息的-kubernetes-组件" class="headerlink" title="编译带 debug 信息的 kubernetes 组件"></a>编译带 debug 信息的 kubernetes 组件</h4><p>修改 <code>hack/lib/golang.sh</code>  文件，将 <code>goldflags=&quot;${GOLDFLAGS:-} -s -w $(kube::version::ldflags)&quot;</code> 修改为 <code>goldflags=&quot;${GOLDFLAGS:-} $(kube::version::ldflags)&quot;</code>。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 执行以下命令编译所需二进制程序：</span><br><span class="line">make hyperkube GOGCFLAGS=<span class="string">"all=-N -l"</span> GOLDFLAGS=<span class="string">""</span></span><br><span class="line">// 执行以下命令开始调试</span><br><span class="line">dlv <span class="built_in">exec</span> ./hyperkube</span><br></pre></td></tr></table></figure>

<h4 id="subpath-挂载-configmap-文件不能自动更新的问题"><a href="#subpath-挂载-configmap-文件不能自动更新的问题" class="headerlink" title="subpath 挂载 configmap 文件不能自动更新的问题"></a>subpath 挂载 configmap 文件不能自动更新的问题</h4><p>参考：<a href="https://github.com/kubernetes/kubernetes/issues/50345#issuecomment-391888999" target="_blank" rel="external nofollow noopener noreferrer">https://github.com/kubernetes/kubernetes/issues/50345#issuecomment-391888999</a>，不使用 subpath，另建一个目录专门挂载 configmap，从而不会覆盖原目录及其文件，在原目录建一个符号链接指向 confgimap 挂载路径，从而能够利用到自动更新机制。</p>
<h4 id="OOM-时-PreStop-钩子无法发挥作用"><a href="#OOM-时-PreStop-钩子无法发挥作用" class="headerlink" title="OOM 时 PreStop 钩子无法发挥作用"></a>OOM 时 PreStop 钩子无法发挥作用</h4><p>当 Pod 内存使用超出 Limit 时，会被内核 oom_killer 杀死，此时由于不是通过 apiserver 发出的删除 pod 调用也不是 Pod 自身的主动终止，所以 PreStop 并不会被触发，为了能够在内存使用超限被杀死前触发 PreStop，一种 walkaround 是通过一个监测内存使用量的程序在内存即将超限（例如 95% ）之前实施自杀，从而能够触发 PreStop ，可参考 ：<a href="https://github.com/16Bitt/kubemem" target="_blank" rel="external nofollow noopener noreferrer">https://github.com/16Bitt/kubemem</a>。</p>
<h4 id="在容器内修改系统参数"><a href="#在容器内修改系统参数" class="headerlink" title="在容器内修改系统参数"></a>在容器内修改系统参数</h4><p>大多数 namespace 级别的系统参数是安全的，可通过以下方式修改：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  labels:</span><br><span class="line">    app: nginx</span><br><span class="line">  name: centos-deployment</span><br><span class="line">  namespace: default</span><br><span class="line">spec:</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: centos</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: centos</span><br><span class="line">    spec:</span><br><span class="line">      securityContext:</span><br><span class="line">        sysctls:</span><br><span class="line">          - name: kernel.shm_rmid_forced</span><br><span class="line">            value: <span class="string">"1"</span></span><br><span class="line">      containers:</span><br><span class="line">      ...</span><br></pre></td></tr></table></figure>

<p>对于非安全的 namespace 级别的参数需在 kubelet 启动参数中启用后才能进一步设置，<code>kubelet --allowed-unsafe-sysctls &#39;kernel.msg*,net.core.somaxconn&#39;</code>。<br>对于非安全的且为非 namespace 级别的内核参数，只能在宿主机上修改或者给容器添加特权后进入容器修改：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  labels:</span><br><span class="line">    app: nginx</span><br><span class="line">  name: centos-deployment</span><br><span class="line">  namespace: default</span><br><span class="line">spec:</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: centos</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: centos</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">        - image: <span class="string">'uhub.service.ucloud.cn/ucloud/centos6-ssh:latest'</span></span><br><span class="line">          imagePullPolicy: Always</span><br><span class="line">          name: centos</span><br><span class="line">          ports:</span><br><span class="line">            - containerPort: 80</span><br><span class="line">              protocol: TCP</span><br><span class="line">          securityContext:</span><br><span class="line">            privileged: <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h4 id="Pod-SecurityContext-和-Container-SecurityContext"><a href="#Pod-SecurityContext-和-Container-SecurityContext" class="headerlink" title="Pod SecurityContext 和 Container SecurityContext"></a>Pod SecurityContext 和 Container SecurityContext</h4><p>参考：<a href="https://medium.com/kubernetes-tutorials/defining-privileges-and-access-control-settings-for-pods-and-containers-in-kubernetes-2cef08fc62b7" target="_blank" rel="external nofollow noopener noreferrer">https://medium.com/kubernetes-tutorials/defining-privileges-and-access-control-settings-for-pods-and-containers-in-kubernetes-2cef08fc62b7</a></p>
<h4 id="DaemonSet-的调度"><a href="#DaemonSet-的调度" class="headerlink" title="DaemonSet 的调度"></a>DaemonSet 的调度</h4><p>DaemonSet 相关的 Pod 并不由 kube-scheduler 进行调度，而是由 kube-controller 中的  DaemonSet controller 进行创建和调度，一般的 Pod 总是创建之后先进入 Pending 状态，而 DaemonSet 相关的 Pod 并没有 Pending 状态，Pod 优先级和抢占由 kube-scheduler 去执行，DaemonSet controller 并不会考虑这些，当然也可以通过一些设置（待补充）让调度工作由 kube-scheduler 去完成。DaemonSet controller 会自动为相关 Pod 添加一系列 toleration（包括对网络分区的容忍，对一些节点不可调度状态的容忍等），会造成 cordon 操作无法对 DaemonSet Pod 生效。参考：<a href="https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/#taints-and-tolerations" target="_blank" rel="external nofollow noopener noreferrer">https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/#taints-and-tolerations</a></p>
<h4 id="Pod-终止信息"><a href="#Pod-终止信息" class="headerlink" title="Pod 终止信息"></a>Pod 终止信息</h4><p>可以在 Pod 意外终止时，向 /dev/termination-log 文件中写入终止原因，方便 Kubernetes 获取信息并填入 Pod 状态字段中。通过以下方式可获取终止原因：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl get pod termination-demo -o go-template&#x3D;&quot;&#123;&#123;range .status.containerStatuses&#125;&#125;&#123;&#123;.lastState.terminated.message&#125;&#125;&#123;&#123;end&#125;&#125;&quot;</span><br></pre></td></tr></table></figure>

<p>另一方面可以通过 Pod.Spec.Containers[0].terminationMessagePath 自定义文件路径（默认是 /dev/termination-log ），也可以将  Pod.Spec.Containers[0].terminationMessagePolicy 设置为  FallbackToLogsOnError 告诉 Kubernetes 在指定文件内容为空且容器错误退出时，从容器日志中获取最后一段日志信息作为终止信息。参考：<a href="https://kubernetes.io/docs/tasks/debug-application-cluster/determine-reason-pod-failure/" target="_blank" rel="external nofollow noopener noreferrer">https://kubernetes.io/docs/tasks/debug-application-cluster/determine-reason-pod-failure/</a></p>
<h4 id="Kubernetes-log-等级"><a href="#Kubernetes-log-等级" class="headerlink" title="Kubernetes log 等级"></a>Kubernetes log 等级</h4><p>一般调试开到 5 级即可，参考：<a href="https://github.com/kubernetes/community/blob/master/contributors/devel/sig-instrumentation/logging.md" target="_blank" rel="external nofollow noopener noreferrer">https://github.com/kubernetes/community/blob/master/contributors/devel/sig-instrumentation/logging.md</a>。可通过 HTTP 接口热更新日志级别：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 调整日志级别到3</span></span><br><span class="line">curl -X PUT http://127.0.0.1:8081/debug/flags/v -d <span class="string">"3"</span></span><br></pre></td></tr></table></figure>

<h4 id="coredns"><a href="#coredns" class="headerlink" title="coredns"></a>coredns</h4><p>coredns 支持多种数据来源插件，对于 Kubernetes 的支持是通过 watch Service/Pod/Endpoints/Namespaces 资源动态增删解析记录实现的。<br>coredns 实现泛域名解析</p>
<h4 id="让-Pod-在节点上均匀分布"><a href="#让-Pod-在节点上均匀分布" class="headerlink" title="让 Pod 在节点上均匀分布"></a>让 Pod 在节点上均匀分布</h4><p>在默认的调度策略下，优先考虑到的是资源使用比例的均衡，所以同一个 Deployment 所属的多个 Pod 副本可能集中分布在个别节点上，为了使 Pod 能够在拓扑结构上均匀分布到各个节点上，有两个策略可以考虑：</p>
<ul>
<li>当 Pod 副本数少于节点数量时，可为 Pod 添加 Pod 之间的反亲和性避免同类 Pod 调度到同一个节点上；</li>
<li>当 Pod 副本数比节点数量多时，反亲和性可能导致节点无处调度，或者仍然出现多个 Pod 调度到同一节点，一种更为通用的做法是使用 1.16 版本开始引入的 PodTopologySpreadConstraints，可以为 Pod 设置如下属性：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  labels:</span><br><span class="line">    k8s-app: uk8s-kubectl</span><br><span class="line">  name: uk8s-kubectl</span><br><span class="line">spec:</span><br><span class="line">  replicas: 18</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      k8s-app: uk8s-kubectl</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        k8s-app: uk8s-kubectl</span><br><span class="line">    spec:</span><br><span class="line">      topologySpreadConstraints:</span><br><span class="line">      - topologyKey: <span class="string">"kubernetes.io/hostname"</span> <span class="comment"># 以节点为粒度，也可以是 region、zone</span></span><br><span class="line">        maxSkew: 1 <span class="comment"># 允许的节点之间 Pod 数量的最大偏差</span></span><br><span class="line">        whenUnsatisfiable: ScheduleAnyway <span class="comment"># 当节点偏差大于设定值时的调度策略</span></span><br><span class="line">        labelSelector:  <span class="comment"># 选中需应用此规则的 Pod</span></span><br><span class="line">          matchLabels:</span><br><span class="line">            k8s-app: uk8s-kubectl</span><br><span class="line">      ...</span><br></pre></td></tr></table></figure>

<h4 id="升级-Kubernetes-组件和-etcd"><a href="#升级-Kubernetes-组件和-etcd" class="headerlink" title="升级 Kubernetes 组件和 etcd"></a>升级 Kubernetes 组件和 etcd</h4><p>参考：<a href="https://platform9.com/blog/kubernetes-upgrade-the-definitive-guide-to-do-it-yourself/" target="_blank" rel="external nofollow noopener noreferrer">https://platform9.com/blog/kubernetes-upgrade-the-definitive-guide-to-do-it-yourself/</a></p>
<h4 id="查看-Kubernetes-每个版本的发布日志"><a href="#查看-Kubernetes-每个版本的发布日志" class="headerlink" title="查看 Kubernetes 每个版本的发布日志"></a>查看 Kubernetes 每个版本的发布日志</h4><p><a href="https://relnotes.k8s.io/" target="_blank" rel="external nofollow noopener noreferrer">https://relnotes.k8s.io/</a></p>
<h4 id="为系统关键组件设置高优先级"><a href="#为系统关键组件设置高优先级" class="headerlink" title="为系统关键组件设置高优先级"></a>为系统关键组件设置高优先级</h4><p>对于部署于集群中的关键组件如 CoreDNS，可通过为 Pod 设置 priorityClassName: system-cluster-critical，来提高优先级，降低集群资源不足时被驱逐后持续 Pending 的概率，system-node-critical 优先级最高，高于 system-cluster-critical。</p>
<h4 id="kube-proxy-的-nftables-实现"><a href="#kube-proxy-的-nftables-实现" class="headerlink" title="kube-proxy 的 nftables 实现"></a>kube-proxy 的 nftables 实现</h4><p><a href="https://github.com/zevenet/nftlb" target="_blank" rel="external nofollow noopener noreferrer">https://github.com/zevenet/nftlb</a>，<a href="https://github.com/sbezverk/nfproxy" target="_blank" rel="external nofollow noopener noreferrer">https://github.com/sbezverk/nfproxy</a>，<a href="https://github.com/zevenet/kube-nftlb" target="_blank" rel="external nofollow noopener noreferrer">https://github.com/zevenet/kube-nftlb</a></p>
<h4 id="Service-Topology"><a href="#Service-Topology" class="headerlink" title="Service Topology"></a>Service Topology</h4><p>用于按照节点物理拓扑分发 ClusterIP 或 NodePort 类型的 Service 流量到不同的 Endpoint 去，例如：可以指定集群内 client 端的请求优先分发到同一宿主机或同一机房的 server 端 Pod 去：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 本例中优先将流量分发至同一宿主机，其次是同一机房，然后是同一地域，最后回退到默认策略</span></span><br><span class="line"><span class="comment"># 若没有最后的 * 号，则会丢弃该请求</span></span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  name: my-service</span><br><span class="line">spec:</span><br><span class="line">  selector:</span><br><span class="line">    app: my-app</span><br><span class="line">  ports:</span><br><span class="line">    - protocol: TCP</span><br><span class="line">      port: 80</span><br><span class="line">      targetPort: 9376</span><br><span class="line">  topologyKeys:</span><br><span class="line">    - <span class="string">"kubernetes.io/hostname"</span></span><br><span class="line">    - <span class="string">"topology.kubernetes.io/zone"</span></span><br><span class="line">    - <span class="string">"topology.kubernetes.io/region"</span></span><br><span class="line">    - <span class="string">"*"</span></span><br></pre></td></tr></table></figure>

<h4 id="Node-Conditions"><a href="#Node-Conditions" class="headerlink" title="Node Conditions"></a>Node Conditions</h4><p>节点 NetworkUnavailable 是否为 True 是通过检查节点上有没有配置好 Pod 网段的路由确定的。节点 Ready Condition 值为 False 说明出现了磁盘、内存或网络等问题， Ready Condition 值为 Unknown 是因为 kubelet 超过 node-monitor-grace-period （默认 40s）没有上报节点状态信息。当 Ready Condition 保持 False 或者 Unknown 超过 pod-eviction-timeout （默认 5 分钟）则 Node controller 将该节点上的 Pod 设置为待删除，若此时节点不可达，API server 无法与 kubelet 通信，则 Pod 将维持 Terminating 或 Unknown 状态直到节点被管理员手动从集群中删除或者节点重新可达。参考：<a href="https://kubernetes.io/docs/concepts/architecture/nodes/#condition" target="_blank" rel="external nofollow noopener noreferrer">https://kubernetes.io/docs/concepts/architecture/nodes/#condition</a>。</p>
<h4 id="多租户的思考"><a href="#多租户的思考" class="headerlink" title="多租户的思考"></a>多租户的思考</h4><p>从 Kubernetes 网络模型的角度来看，Kubernetes 至多实现逻辑上的多租户隔离。多租户的第一步，需要接入用户管理与认证中心，可通过 OpenID 的方式接入；通过 RBAC 控制用户的操作权限，限定用户可以操作的命名空间和资源类型；通过 NetworkPolicy 控制 Pod 之间的网络通信；通过 ResourceQuota 限制 CPU 之类资源的用量和资源对象的数量，从而保证资源使用的公平性；通过 PodSecurityPolicy 限制安全敏感的 Pod 相关字段的设置，如命名空间、系统调用、特权等级；通过 Pod 之间的反亲和性避免不同用户的 Pod 调度到同一节点；通过亲和性或者污点与容忍将特定用户的 Pod 调度到特定节点；引入分层的命名空间实现权限在父子命名空间之间的继承；使用 firecracker 之类的轻量级虚拟机实现 runtime 提升隔离性；进一步可引入 Open Policy Agent 进行应用层的权限验证。</p>
<h4 id="删除命名空间卡在-Terminating"><a href="#删除命名空间卡在-Terminating" class="headerlink" title="删除命名空间卡在 Terminating"></a>删除命名空间卡在 Terminating</h4><p>首先要检查命名空间下所有资源删除成功，接下来有两种处理方式：一种是强制删除命名空间，通过如下命令移除所有 finalizer ：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for ns in $(kubectl get ns --field-selector status.phase&#x3D;Terminating -o jsonpath&#x3D;&#39;&#123;.items[*].metadata.name&#125;&#39;); do  kubectl get ns $ns -ojson | jq &#39;.spec.finalizers &#x3D; []&#39; | kubectl replace --raw &quot;&#x2F;api&#x2F;v1&#x2F;namespaces&#x2F;$ns&#x2F;finalize&quot; -f -; done</span><br></pre></td></tr></table></figure>

<p>另一种是查看命名空间 Status 中的 Conditions 信息，找到导致命名空间删除失败的具体原因，进而解决问题后自动删除。</p>
<h4 id="Containerd-导出镜像"><a href="#Containerd-导出镜像" class="headerlink" title="Containerd 导出镜像"></a>Containerd 导出镜像</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">crictl images | grep -v IMAGE | grep -v ucloud | awk &#39;&#123;print $1,$2&#125;&#39; | while read image tag; do</span><br><span class="line">  name&#x3D;&#96;echo $image | awk -F &quot;&#x2F;&quot; &#39;&#123;print $NF&#125;&#39;&#96;</span><br><span class="line">  new_name&#x3D;&quot;uhub.service.ucloud.cn&#x2F;wxyz&#x2F;&quot;$name&quot;:&quot;$tag</span><br><span class="line">  ctr --namespace k8s.io images tag $image&quot;:&quot;$tag $new_name</span><br><span class="line">  mkdir -p &#x2F;tmp&#x2F;tars</span><br><span class="line">  ctr --namespace k8s.io images export &quot;&#x2F;tmp&#x2F;tars&#x2F;&quot;$name&quot;.&quot;$tag&quot;.tar&quot; $new_name --platform x86_64</span><br><span class="line">  sshpass -p uk8s-r00tme scp -o StrictHostKeyChecking&#x3D;no -r &#x2F;tmp&#x2F;tars 10.8.25.22:&#x2F;root&#x2F;tars</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<h4 id="Pod-创建过程简析"><a href="#Pod-创建过程简析" class="headerlink" title="Pod 创建过程简析"></a>Pod 创建过程简析</h4><p>使用 kubectl apply 命令时，kubectl 首先从服务端拉取完整的 Kubernetes OpenAPI 定义，然后尝试查询待创建的资源是否已存在，未存在则执行 Post 创建，已存在则与本地文件比较是否需要更新，需要更新则执行 Patch 操作；kube-scheduler watch 到 Pod 创建，则执行调度过程将其调度到某一节点上；kubelet watch 到有 Pod 调度过来，则执行创建过程拉起 Pod。</p>
<h4 id="Liveness-Readiness-and-Startup-Probes"><a href="#Liveness-Readiness-and-Startup-Probes" class="headerlink" title="Liveness, Readiness and Startup Probes"></a>Liveness, Readiness and Startup Probes</h4><p>readinessProbe 用来确定服务是否可以接受用户请求，endpoint controller 据此增减 pod ip；livenessProbe 用来确定 Pod 是否存活，kubelet 据此决定是否重启 Pod；readinessProbe 与 livenessProbe 可同时使用，均为持续性检测，可设置检测周期以及失败和成功次数的阈值；startupProbe 用于启动时间较长的 Pod，仅在 Pod 启动时检测，并且启用时 readinessProbe 与 livenessProbe 均被禁用。参考：<a href="https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/" target="_blank" rel="external nofollow noopener noreferrer">https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/</a>。</p>
<h4 id="Pod-的删除流程"><a href="#Pod-的删除流程" class="headerlink" title="Pod 的删除流程"></a>Pod 的删除流程</h4><p>执行 kubectl delete pod , kubectl 向 api server 发起 Delete 请求；api-server 更新 Pod 信息设置 deletionTimestamp 和 deletionGracePeriodSeconds，Phase 可能仍然是 Running ，不发生变化；kubelet watch 到 Pod 变化，然后开始执行 graceful 删除过程；controller manager watch 到 Pod 变化，从 endpoint 中删除 pod，触发 kube-proxy 更新规则；最后，kubelet 触发 api-server 删除 Pod 对象，这样一个同名的 Pod 可以安全地重建。强制删除会导致 api-server 不等待 kubelet 确认删除 Pod 而直接删除对象，此时允许立即新建一个同名的 Pod，对于 StatefulSet 的应用来说是危险的。</p>
<h4 id="Pod-与-Container-状态"><a href="#Pod-与-Container-状态" class="headerlink" title="Pod 与 Container 状态"></a>Pod 与 Container 状态</h4><p>Pod 的 Phase 字段标识 Pod 状态，kubectl get pod 展示的 Status 列并不一定与 Phase 字段一致，而是由 api-server 通过一系列规则计算得到并返回给 kubectl 的，参考代码 <a href="https://github.com/kubernetes/kubernetes/blob/36f571404fcb136011024b89efaa2a0d089acd5f/pkg/printers/internalversion/printers.go#L740" target="_blank" rel="external nofollow noopener noreferrer">printPod</a>，例如当 Pod 的 DeletionTimestamp 字段不为空且节点可达时计算得到的 Status 为 Terminating ；Pod 的 Phase 参考 <a href="https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#pod-phase" target="_blank" rel="external nofollow noopener noreferrer">https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#pod-phase</a>。</p>
<h4 id="日志收集"><a href="#日志收集" class="headerlink" title="日志收集"></a>日志收集</h4><p>日志可大致分为应用日志、K8S 组件日志、Linux 系统日志，另外还有 K8S Events 、APIServer 审计日志也有分析价值，一般可使用 Filebeat 以 DaemonSet 的形式部署到各个节点收集日志，再推送到 Logstash 进行过滤聚合后，推送到 Elasticsearch 进行存储，最后使用 Kibana 查看日志；也可以使用更轻量的 Promtail、Loki、Grafana 的组合。</p>
<h4 id="已用内存的计算"><a href="#已用内存的计算" class="headerlink" title="已用内存的计算"></a>已用内存的计算</h4><p>Kubelet 获取的已用内存的值来自于 cgroup <code>memory.usage_in_bytes - memory.stat.total_inactive_file</code> ，total_inactive_file 被包含在 cache 中，实际上 total_active_file 也是包含在 cache 中，在 Linux 内存管理中，一个文件被读或写两次就会被放入 active_file_list，active_file 也可以被回收从而释放内存。相关的讨论参见：<a href="https://github.com/kubernetes/kubernetes/issues/43916" target="_blank" rel="external nofollow noopener noreferrer">https://github.com/kubernetes/kubernetes/issues/43916</a>，<a href="https://cloud.tencent.com/developer/article/1637682" target="_blank" rel="external nofollow noopener noreferrer">https://cloud.tencent.com/developer/article/1637682</a>，<a href="https://medium.com/@eng.mohamed.m.saeed/memory-working-set-vs-memory-rss-in-kubernetes-which-one-you-should-monitor-8ef77bf0acee" target="_blank" rel="external nofollow noopener noreferrer">Memory_working_set vs Memory_rss in Kubernetes, which one you should monitor?</a>，<a href="https://kubernetes.io/docs/tasks/administer-cluster/out-of-resource/#active-file-memory-is-not-considered-as-available-memory" target="_blank" rel="external nofollow noopener noreferrer">https://kubernetes.io/docs/tasks/administer-cluster/out-of-resource/#active-file-memory-is-not-considered-as-available-memory</a>。</p>
<h4 id="获取-kubelet-profile"><a href="#获取-kubelet-profile" class="headerlink" title="获取 kubelet profile"></a>获取 kubelet profile</h4><p>其它组件的调试信息参考：<a href="https://blog.csdn.net/u012986012/article/details/106065230" target="_blank" rel="external nofollow noopener noreferrer">kubernetes 关键组件 debug</a>。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -k --key /etc/kubernetes/ssl/kubelet.key --cert /etc/kubernetes/ssl/kubelet.crt https://NODE_IP:10250/debug/pprof/heap  &gt;&gt; heap.info</span><br><span class="line">go tool pprof heap.info</span><br><span class="line">或者</span><br><span class="line">kubectl proxy --address=<span class="string">'0.0.0.0'</span> --accept-hosts=<span class="string">'^*$'</span></span><br><span class="line">go tool pprof -seconds=60 -raw -output=kubelet.pprof http://127.0.0.1:8001/api/v1/nodes/<span class="variable">$&#123;NODENAME&#125;</span>/proxy/debug/pprof/profile</span><br></pre></td></tr></table></figure>

<h4 id="Deployment-中使用-PVC"><a href="#Deployment-中使用-PVC" class="headerlink" title="Deployment 中使用 PVC"></a>Deployment 中使用 PVC</h4><p>一般来讲 Deployment 应当用来部署无状态应用，需要挂载 PVC 时最好使用 StatefulSet。如果 Deployment 使用了 ReadWriteOnce 的 PVC （块存储），在滚动更新时会因为需要先拉起新的 Pod 再终止旧 Pod 造成同时挂载该 PVC 的情况，这是不允许，所以会一直卡在这个状态。如果想要这样使用，可以把更新策略改成 Recreate ，这样会先删除旧 Pod 再建新 Pod，这必然导致业务中断。另一种方案是使用 ReadWriteMany 的 PVC（文件或对象存储），可以允许多 Pod 同时挂载。</p>
<h4 id="让-Pod-中的容器按顺序启动"><a href="#让-Pod-中的容器按顺序启动" class="headerlink" title="让 Pod 中的容器按顺序启动"></a>让 Pod 中的容器按顺序启动</h4><p>一种方案是使用 PostStart 脚本去调用 Container 的健康检查接口，直到容器运行正常后终止脚本，其能够工作的前提是：假如容器的  <code>PostStart</code> hook 没有正确的返回，kubelet 便不会去创建下一个容器。这种方式是有些 hack 的，而且也无法保证一直能够使用，这不是 kubernetes 保证不会变更的方式。参考：<a href="https://mp.weixin.qq.com/s/VulB3tiXTRAjYsuWxgU1Zg" target="_blank" rel="external nofollow noopener noreferrer">https://mp.weixin.qq.com/s/VulB3tiXTRAjYsuWxgU1Zg</a>。</p>
<h4 id="通过-patch-修改-service-的-status-字段"><a href="#通过-patch-修改-service-的-status-字段" class="headerlink" title="通过 patch 修改 service 的 status 字段"></a>通过 patch 修改 service 的 status 字段</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># cat /tmp/json</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"status"</span>: &#123;</span><br><span class="line">      <span class="string">"loadBalancer"</span>: &#123;</span><br><span class="line">        <span class="string">"ingress"</span>: [</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="string">"ip"</span>: <span class="string">"10.5.6.79"</span></span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">curl --request PATCH --data <span class="string">"<span class="variable">$(cat /tmp/json)</span>"</span> -H <span class="string">"Content-Type:application/merge-patch+json"</span></span><br><span class="line">http://localhost:8080/api/v1/namespaces/gitlab/services/git-cp/status</span><br></pre></td></tr></table></figure>

<h4 id="kubectl-部署时默认命名空间的设置"><a href="#kubectl-部署时默认命名空间的设置" class="headerlink" title="kubectl 部署时默认命名空间的设置"></a>kubectl 部署时默认命名空间的设置</h4><p>Pod 中执行 kubectl apply 时如果未指定命名空间，并且待部署的资源中也没有明确指定命名空间，则会尝试从几个地方获取命名空间信息，会先尝试从环境变量 <code>POD_NAMESPACE</code> 中读取，读不到则是尝试从当前 context 中获取，如果找不到则继续尝试从 <code>/var/run/secrets/kubernetes.io/serviceaccount/namespace</code> 中获取，参考 <a href="https://kubernetes.io/docs/reference/kubectl/overview/#in-cluster-authentication-and-namespace-overrides" target="_blank" rel="external nofollow noopener noreferrer">https://kubernetes.io/docs/reference/kubectl/overview/#in-cluster-authentication-and-namespace-overrides</a>。<br>可通过以下命令设置 context 中的命名空间。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl config <span class="built_in">set</span>-context --current --namespace=default</span><br></pre></td></tr></table></figure>

<h4 id="在-Pod-中屏蔽-serviceaccount-自动挂载"><a href="#在-Pod-中屏蔽-serviceaccount-自动挂载" class="headerlink" title="在 Pod 中屏蔽 serviceaccount 自动挂载"></a>在 Pod 中屏蔽 serviceaccount 自动挂载</h4><p>一种是设置 Pod 的 automountServiceAccountToken 参数，禁止当前 Pod 自动挂载；一种是设置 ServiceAccount 的 automountServiceAccountToken 参数，默认所有 Pod 不自动挂载；一种是 Pod 挂载后再通过自定义挂载覆盖掉自动挂载的目录 <code>/var/run/secrets/kubernetes.io/serviceaccount</code>。</p>
<h4 id="port-forward-转发-Pod-端口到本地"><a href="#port-forward-转发-Pod-端口到本地" class="headerlink" title="port-forward 转发 Pod 端口到本地"></a>port-forward 转发 Pod 端口到本地</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl port-forward --address 0.0.0.0 pod/mypod 8888:5000</span><br></pre></td></tr></table></figure>

<h4 id="十二因素应用"><a href="#十二因素应用" class="headerlink" title="十二因素应用"></a>十二因素应用</h4><ul>
<li>十二因素的提出早于 Kubernetes 的大规模使用，但是一些因素和基于 Kubernetes 的服务开发部署有着很好的吻合。可参考： <a href="https://skyao.io/learning-cloudnative/factor/" target="_blank" rel="external nofollow noopener noreferrer">https://skyao.io/learning-cloudnative/factor/</a> ，<a href="https://blog.csdn.net/zeb_perfect/article/details/52536411" target="_blank" rel="external nofollow noopener noreferrer">https://blog.csdn.net/zeb_perfect/article/details/52536411</a>， <a href="https://12factor.net/" target="_blank" rel="external nofollow noopener noreferrer">https://12factor.net/</a></li>
<li>关于基准代码的理解：每个应用应该使用单独的代码仓库，如果多个应用有需要共享的基准代码，则应当将这部分共享代码组织为一个单独的代码仓库。<table>
<thead>
<tr>
<th>Factor</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>Codebase</td>
<td></td>
</tr>
<tr>
<td>基准代码</td>
<td>One codebase tracked in revision control, many deploys</td>
</tr>
<tr>
<td>一份基准代码，多份部署</td>
<td></td>
</tr>
<tr>
<td>Dependencies</td>
<td></td>
</tr>
<tr>
<td>依赖</td>
<td>Explicitly declare and isolate dependencies</td>
</tr>
<tr>
<td>显式声明依赖关系</td>
<td></td>
</tr>
<tr>
<td>Config</td>
<td></td>
</tr>
<tr>
<td>配置</td>
<td>Store config in the environment</td>
</tr>
<tr>
<td>在环境中存储配置</td>
<td></td>
</tr>
<tr>
<td>Backing services</td>
<td></td>
</tr>
<tr>
<td>后端服务</td>
<td>Treat backing services as attached resources</td>
</tr>
<tr>
<td>把后端服务当作附加资源</td>
<td></td>
</tr>
<tr>
<td>Build, release, run</td>
<td></td>
</tr>
<tr>
<td>构建，发布，运行</td>
<td>Strictly separate build and run stages</td>
</tr>
<tr>
<td>严格分离构建和运行</td>
<td></td>
</tr>
<tr>
<td>Processes</td>
<td></td>
</tr>
<tr>
<td>进程</td>
<td>Execute the app as one or more stateless processes</td>
</tr>
<tr>
<td>以一个或多个无状态进程运行应用</td>
<td></td>
</tr>
<tr>
<td>Port binding</td>
<td></td>
</tr>
<tr>
<td>端口绑定</td>
<td>Export services via port binding</td>
</tr>
<tr>
<td>通过端口绑定提供服务</td>
<td></td>
</tr>
<tr>
<td>Concurrency</td>
<td></td>
</tr>
<tr>
<td>并发</td>
<td>Scale out via the process model</td>
</tr>
<tr>
<td>通过进程模型进行扩展</td>
<td></td>
</tr>
<tr>
<td>Disposability</td>
<td></td>
</tr>
<tr>
<td>易处理</td>
<td>Maximize robustness with fast startup and graceful shutdown</td>
</tr>
<tr>
<td>快速启动和优雅终止可最大化健壮性</td>
<td></td>
</tr>
<tr>
<td>Dev/prod parity</td>
<td></td>
</tr>
<tr>
<td>开发环境与线上环境等价</td>
<td>Keep development, staging, and production as similar as possible</td>
</tr>
<tr>
<td>尽可能的保持开发，预发布，线上环境相同</td>
<td></td>
</tr>
<tr>
<td>Logs</td>
<td></td>
</tr>
<tr>
<td>日志</td>
<td>Treat logs as event streams</td>
</tr>
<tr>
<td>把日志当作事件流</td>
<td></td>
</tr>
<tr>
<td>Admin processes</td>
<td></td>
</tr>
<tr>
<td>管理进程</td>
<td>Run admin/management tasks as one-off processes</td>
</tr>
<tr>
<td>后台管理任务当作一次性进程运行</td>
<td></td>
</tr>
</tbody></table>
</li>
</ul>
<h4 id="书籍"><a href="#书籍" class="headerlink" title="书籍"></a>书籍</h4><p><a href="https://www.yuque.com/attachments/yuque/0/2020/pdf/182657/1592733448171-9fd3c848-1cef-4910-9722-4655a34dbb87.pdf" target="_blank" rel="external nofollow noopener noreferrer">Kubernetes Patterns Reusable Elements for Designing Cloud-Native Applications.pdf</a></p>
]]></content>
      <categories>
        <category>Kubernetes</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 基础网络知识</title>
    <url>/post/52b545c8.html</url>
    <content><![CDATA[<h4 id="DNS-域名服务器数量"><a href="#DNS-域名服务器数量" class="headerlink" title="DNS 域名服务器数量"></a>DNS 域名服务器数量</h4><p>通常，在 Linux 系统中，可在 /etc/resolv.conf 中配置 DNS 域名服务器，如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># cat /etc/resolv.conf</span></span><br><span class="line">nameserver 10.23.255.1</span><br><span class="line">nameserver 10.23.255.2</span><br><span class="line">nameserver 114.114.114.114</span><br></pre></td></tr></table></figure><a id="more"></a>


<p>排名越靠前的 nameserver 优先级越高，只有从第一个 DNS 服务器获取解析结果超时或失败才会转入下一个。看起来我们可以增加很多 nameserver，实际上这个数量存在一个默认值为 3 的最大数量限制，通过 man 手册可以看到：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  ~ man resolv.conf | awk <span class="string">'/nameserver Name/,/search Search/ &#123;print prev; prev=$0&#125;'</span></span><br><span class="line"></span><br><span class="line">       nameserver Name server IP address</span><br><span class="line">              Internet  address  of a name server that the resolver should query, either an IPv4 address (<span class="keyword">in</span> dot notation), or an IPv6 address <span class="keyword">in</span> colon (and possibly dot) notation as per RFC 2373.  Up to MAXNS (currently 3, see &lt;re‐</span><br><span class="line">              solv.h&gt;) name servers may be listed, one per keyword.  If there are multiple servers, the resolver library queries them <span class="keyword">in</span> the order listed.  If no nameserver entries are present, the default is to use the name  server</span><br><span class="line">              on  the  <span class="built_in">local</span>  machine.   (The algorithm used is to try a name server, and <span class="keyword">if</span> the query <span class="built_in">times</span> out, try the next, until out of name servers, <span class="keyword">then</span> repeat trying all the name servers until a maximum number of retries are</span><br><span class="line">              made.)</span><br></pre></td></tr></table></figure>

<p>进一步这个值实际是在代码头文件中写死的：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在 resolv.h 中引入了 res_state.h</span></span><br><span class="line">[root@pc /] head -n 61 /usr/include/resolv.h | tail -n 10</span><br><span class="line"><span class="comment">#ifndef _RESOLV_H_</span></span><br><span class="line"><span class="comment">#define _RESOLV_H_</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#include &lt;sys/cdefs.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/param.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;netinet/in.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;arpa/nameser.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;bits/types/res_state.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在 res_state.h 中定义了 MAXNS 宏，其值为 3</span></span><br><span class="line">[root@pc /]<span class="comment"># head -n 10 /usr/include/bits/types/res_state.h</span></span><br><span class="line"><span class="comment">#ifndef __res_state_defined</span></span><br><span class="line"><span class="comment">#define __res_state_defined 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#include &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;netinet/in.h&gt;</span></span><br><span class="line"></span><br><span class="line">/* res_state: the global state used by the resolver stub.  */</span><br><span class="line"><span class="comment">#define MAXNS			3	/* max # name servers we'll track */</span></span><br><span class="line"><span class="comment">#define MAXDFLSRCH		3	/* # default domain levels to try */</span></span><br><span class="line"><span class="comment">#define MAXDNSRCH		6	/* max # domains in search path */</span></span><br></pre></td></tr></table></figure>

<p>想要配置更多的 DNS 服务器地址，则可使用第三方软件，例如 dnsmasq ，参考：<a href="https://askubuntu.com/questions/1157265/how-do-i-allow-more-than-3-dns-servers-in-ubuntu-16" target="_blank" rel="external nofollow noopener noreferrer">https://askubuntu.com/questions/1157265/how-do-i-allow-more-than-3-dns-servers-in-ubuntu-16</a>。</p>
<h4 id="NO-CARRIER-网卡故障"><a href="#NO-CARRIER-网卡故障" class="headerlink" title="NO-CARRIER 网卡故障"></a>NO-CARRIER 网卡故障</h4><p>NO-CARRIER 表示网络接口未检测到线路上的信号。通常是因为网络电缆已拔出或断开。在极少数情况下，也可能是硬件故障或驱动程序错误。</p>
<h4 id="WebSocket-和-Socket-的区别"><a href="#WebSocket-和-Socket-的区别" class="headerlink" title="WebSocket 和 Socket 的区别"></a>WebSocket 和 Socket 的区别</h4><p>WebSocket 一般用于浏览器与应用服务器之间的交互，它是类似于 HTTP 的应用层协议，建立在 TCP/IP 之上。它主要应用于浏览器端需要和服务段建立固定连接的场景。而纯粹的 Socket 比 WebSocket 更加强大和通用。Socket 也基于 TCP/IP 但不局限于浏览器应用场景，使用 Socket 可以实现各种各样的通信过程。</p>
<h4 id="WebSocket-通信建立过程"><a href="#WebSocket-通信建立过程" class="headerlink" title="WebSocket 通信建立过程"></a>WebSocket 通信建立过程</h4><p>所有客户端与  WebSocket Server 建立进行通信时，都需要先发送 Http Get 请求完成握手过程，该 Http 请求头中包含  Upgrade: websocket 等必要字段，WebSocket Server 端必须能够处理该 Http 请求并在接受建立 WebSocket 连接时返回一个状态码为 101 的 Http 响应告诉客户端从现在开始把协议切换为 WebSocket。这样设计的一个好处时可以让 WebSocket 服务与已经存在的 Http 服务复用同一个端口，只需要一个后端进程处理两种通信协议。当然，也可以搭建一个纯粹的 WebSocket Server，只是依然需要能够响应握手时客户端发出的用以协议升级的 Http 请求，只不过对于其它的 Http 请求不会响应，亦即纯粹的 WebSocket Server 处理且仅处理用以协议升级 Http Get 的请求，之后的通信过程将全部使用 WebSocket 协议。更多解释参考：<a href="https://stackoverflow.com/questions/47085281/do-websocket-implementations-use-http-protocol-internally" target="_blank" rel="external nofollow noopener noreferrer">https://stackoverflow.com/questions/47085281/do-websocket-implementations-use-http-protocol-internally</a></p>
<h4 id="HTTP-1-0-、1-1-、2-关于-TCP-连接使用的区别"><a href="#HTTP-1-0-、1-1-、2-关于-TCP-连接使用的区别" class="headerlink" title="HTTP 1.0 、1.1 、2 关于 TCP 连接使用的区别"></a>HTTP 1.0 、1.1 、2 关于 TCP 连接使用的区别</h4><p>简单理解，在 HTTP 1.0 中，每个 HTTP 操作对应一个不同的 TCP 连接，即 HTTP 请求与 TCP 连接一一对应；在 1.1 中，浏览器执行多个 HTTP 请求时，仍然可能建立多个 TCP 连接，但是每个连接不再一一对应一个 HTTP 请求，而是多个请求在同一个 TCP 连接上串行方式传递请求-响应数据，实现连接复用；在 2.0 中，一次会话只建立一个 TCP 连接，且多个请求可并行发起并接收响应，实现多路复用。</p>
<h4 id="TCP-连接建立与断开"><a href="#TCP-连接建立与断开" class="headerlink" title="TCP 连接建立与断开"></a>TCP 连接建立与断开</h4><ol>
<li>TCP Server 端初始处于 LISTEN 状态；TCP Client 端新建一个 TCP Socket （端口号由操作系统分配）并主动发起 SYNC 请求，其过程是向 Server 端发送一个标志位为 SYN=1 及 ACK=0 ，序列号为随机生成的 x，数据部分为空的 TCP 报文，其结果是 Client 端进入  SYN_SENT 状态；Server 端接收到 Client 端的报文，根据  SYN=1 及 ACK=0 确定这是发起连接请求的报文并据此进行响应，其过程是向 Client 端发送一个标志位为  SYN=1 及 ACK=1（确认与同步二合一），序列号为随机生成的 y，确认号为 x+1，数据部分为空的 TCP 报文，其结果是服务端进入  SYN_RECV 状态；Client 端接收到 Server 回复的报文，确认可以和服务端建立通信，因此进入  ESTABLISHED 状态，作为对服务端 SYNC 报文的回应，客户端向服务端发送一个标志位为 ACK=1，序列号为 x+1，确认号为 y+1，数据部分为空的 TCP 报文；服务端收到确认报文后才会进入  ESTABLISHED 状态。</li>
<li>TCP 连接建立过程中，最后一次客户端向服务端发送的确认报文除了作为对服务端同步报文的回应，也基于以下原因：在客户端刚开始发起连接时发出的 SYNC 请求报文如果迟迟没有收到服务端的确认报文，客户端会放弃该连接，重新发出 SYNC 请求报文；此时服务端有可能会收到两条 SYNC 报文（超时的报文和新的报文），如果没有最后一次客户端发送的确认报文，服务端直接进入 ESTABLISHED 状态，会建立起两条连接，从而会浪费一条连接开销。</li>
<li>当 TCP 连接建立完成后，两方的角色将变成对称的，任何一端都无法识别自己为客户端还是服务端，因此任何一端都可以先发送 FIN 报文用以关闭连接。由于一旦 FIN 报文从某一端发出，则该端将无法向对端发送数据（接收不受影响），因此往往是由先确知自己无需再发送数据的一端首先发起关闭连接的请求，而对端无需在收到 FIN 报文后立即开始 FIN 过程，可以继续向发起端发送数据直到数据发送完毕后再开始 FIN 过程，因此 TCP 的关闭过程也被称为是半关闭过程，所谓的四次挥手也源于此。</li>
<li>FIN 开始之前两方都处于  ESTABLISHED 状态，直到有一方的应用层确认数据发送完毕，主动发起了关闭连接的过程，此时会向另一方（后称为被动方）发送 FIN 请求，其过程是发送一个标志位 FIN=1，序列号为 u ，数据部分为空（也可能不为空，稍后讨论）的 TCP 报文，其结果是主动方进入了  FIN_WAIT 状态；被动方接收到主动方发出的报文，会返回一个标志位为  ACK=1，序列号为 v，确认号为 u+1 ，数据部分为空的报文，结果是被动方进入  CLOSE_WAIT 状态；此后被动方可以继续发送数据直到数据发送完成；被动方完成数据发送，向主动方发送标志位为 FIN=1 及 ACK=1 ，序列号为 w ，确认号依然为 u+1 的，数据部分为空（也可能不为空，稍后讨论）的 TCP 报文，之后被动方进入  LAST_ACK 状态；主动方收到被动方的 FIN 报文后，返回一个标志位为 ACK=1 ，序列号为 u+1 ，确认号为 w+1，数据部分为空的报文，此后主动方进入  TIME_WAIT 状态进行超时等待；被动方收到主动方的确认报文后进入 CLOSED 状态，此时被动方已经先完成了关闭连接的过程。</li>
<li>FIN 主动方进入  TIME_WAIT 状态后，会等待 2 倍的最大报文生存时间即  2MSL，等待的原因主要有两个： ① 为了保证主动方发送的最后一个 ACK 报文段能够到达被动方。即如果最后这个确认报文丢失，被动方会超时重传 FIN 报文，然后主动方再一次确认，同时启动 2MSL 计时器，如此下去。如果主动方没有等待时间，发送完确认报文就立即释放连接的话，即使被动方重传了 FIN 报文，也会因主动方已关闭而使被动方无法收到确认报文，被动方就无法正常进入 CLOSE 状态。 ② 防止已失效的连接请求报文出现在新的连接中。经过 2MSL，和该连接的相关的报文要么已经到达目的地，要么会被丢弃掉，不会滞留在网络中。这样的话，在下一个连接中就不会出现上一个连接遗留下来的请求报文了。</li>
<li>RFC 793 中规定 MSL（Maximum Segment Lifetime）为 2 分钟，实际应用中常用的是 30 秒，1 分钟和 2 分钟等。Linux 系统下可通过以下命令查看：<code>cat /proc/sys/net/ipv4/tcp_fin_timeout</code> ，在我的 Deepin 和 Manjaro 系统中分别是 40s 和 60s。</li>
</ol>
<p>补充：这段描述可能有误，tcp_fin_timeout 时间应该指的是 FIN_WAIT_2 状态的连接，超时强制关闭的时间。</p>
<ol start="7">
<li>FIN 报文中是可以携带数据的，携带数据时的连接关闭过程与不携带数据时并无本质区别，只不过与 FIN 报文对应的 ACK 报文中的确认号值需要加上 FIN 报文发来的数据长度 d ，如果 FIN 报文不携带数据时对应的 ACK 报文的确认号为 u+1，则 FIN 携带数据时确认号还要加上 d 用以表示被动方收到了长度为 d 的数据内容，此时确认号为 u+1+d 。 FIN 包携带数据往往是为了提高通信效率，因为这样做相当于将最后一个数据报文和 FIN 报文合二为一，节省了一个报文的发送过程。</li>
<li>FIN 谁先关闭的问题可以通过一个简单的抓包实验进行观察：通过启动一个 <code>python3 -mhttp.server</code> Http 服务器，使用 WireShark 进行抓包，执行  <code>curl 127.0.0.1:8000</code> 后观察抓取的数据包，可以发现服务端在发送 Http 响应的同时主动发起了关闭连接的过程，即最后一个数据报文和 FIN 报文合二为一。</li>
<li>通过抓包观察，在数据传输过程中某一方应答报文的确认号为总是等于另一方发送的报文的序列号和报文数据长度之和，而这个和值也会变成发送方下一次发送报文时的序列号。序列号和确认号的初始值来源于建立连接时客户端和服务端分别获取的随机序列号值 x， y，在连接建立后，第一个数据报文的序列号和确认号分别是 x+1,y+1（客户端发送第一份数据）或者 y+1, x+1（服务端发送第一份数据）。</li>
<li>TCP 连接参考文档：<a href="https://blog.csdn.net/guyuealian/article/details/52535294" target="_blank" rel="external nofollow noopener noreferrer">https://blog.csdn.net/guyuealian/article/details/52535294</a> ，<a href="https://stackoverflow.com/questions/289194/what-is-maximum-segment-lifetime/35000966" target="_blank" rel="external nofollow noopener noreferrer">https://stackoverflow.com/questions/289194/what-is-maximum-segment-lifetime/35000966</a>， <a href="https://www.wikiwand.com/en/Transmission_Control_Protocol" target="_blank" rel="external nofollow noopener noreferrer">https://www.wikiwand.com/en/Transmission_Control_Protocol</a>，<a href="https://stackoverflow.com/questions/4677925/who-first-sets-tcp-fin-flag-in-client-server-connection" target="_blank" rel="external nofollow noopener noreferrer">https://stackoverflow.com/questions/4677925/who-first-sets-tcp-fin-flag-in-client-server-connection</a></li>
<li>一张助于理解的图：</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2019/png/182657/1571478423292-36b18cb8-3312-42ed-940e-40b15315d38d.png#align=left&display=inline&height=793&margin=%5Bobject%20Object%5D&name=image.png&originHeight=793&originWidth=796&size=62072&status=done&style=none&width=796" alt="image.png"></p>
<h4 id="Linux-内核网络相关函数调用关系图"><a href="#Linux-内核网络相关函数调用关系图" class="headerlink" title="Linux 内核网络相关函数调用关系图"></a>Linux 内核网络相关函数调用关系图</h4><p><img src="https://cdn.nlark.com/yuque/0/2019/jpeg/182657/1571896927566-028e0063-6be9-4472-a446-66ac67ca17f5.jpeg#align=left&display=inline&height=1952&margin=%5Bobject%20Object%5D&name=linux-net.jpeg&originHeight=1952&originWidth=3489&size=1016557&status=done&style=none&width=3489" alt="linux-net.jpeg"></p>
<h4 id="简略数据收发流图"><a href="#简略数据收发流图" class="headerlink" title="简略数据收发流图"></a>简略数据收发流图</h4><p><img src="https://cdn.nlark.com/yuque/0/2020/png/182657/1597494298490-a685c988-d4f4-4d89-8edb-af96e7b55d0a.png#align=left&display=inline&height=547&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1093&originWidth=1545&size=268899&status=done&style=none&width=772.5" alt="image.png"></p>
<h4 id="Qdisc-在-Linux-网络栈中的位置"><a href="#Qdisc-在-Linux-网络栈中的位置" class="headerlink" title="Qdisc 在 Linux 网络栈中的位置"></a>Qdisc 在 Linux 网络栈中的位置</h4><p><img src="https://cdn.nlark.com/yuque/0/2019/png/182657/1571898730049-ed53082d-e336-42cd-aa59-7233ebb6d57c.png#align=left&display=inline&height=913&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1475&originWidth=1205&size=325485&status=done&style=none&width=746" alt="image.png"></p>
<h4 id="网络路由过程"><a href="#网络路由过程" class="headerlink" title="网络路由过程"></a>网络路由过程</h4><ul>
<li>路由器与 NAT：</li>
</ul>
<p>纯粹的路由过程并不会修改 IP 地址，路由过程会修改 MAC 地址，而家用路由器往往并不是纯粹的路由器，而是包含了 NAT 单元，所以家用路由器会修改 IP 从而实现一个局域网内的多个计算机同时连接外网。</p>
<ul>
<li>一个关于路由过程的说明：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">The source and destination MAC address will change as the frame traverses the</span><br><span class="line">network to that of the next hop device and sending device port MAC, respectively.</span><br><span class="line"></span><br><span class="line">EXAMPLE:</span><br><span class="line"></span><br><span class="line">Three routers, A, B, C. They are connected in line (A connects to B, B connects to</span><br><span class="line">A and C and C only connects to B like this: A — B — C ) with Host 1 on router A and</span><br><span class="line">Host 2 on Router C.</span><br><span class="line"></span><br><span class="line">( 1 — A — B — C — 2 )</span><br><span class="line"></span><br><span class="line">Host connected to router A wants to talk to host connected to router C. Host A</span><br><span class="line">determines the IP address of the host and does an ARP lookup to see if it is local.</span><br><span class="line">The host on A determines that it is not local so it looks for a default gateway IP</span><br><span class="line">address. Once found, the IP of the default gateway is checked for an ARP entry and,</span><br><span class="line">if not, broadcasts and ARP to determine the MAC address. Now that all this has been</span><br><span class="line">done, Host 1 on Router A will forward the packet with the Source IP and MAC of its</span><br><span class="line">machine, Host 1. The Destination IP will be that of Host 2 on Router C and the</span><br><span class="line">Destination MAC will be the MAC address of the default gateway, which in this case,</span><br><span class="line">if the network is setup properly, will be the interface on Router A connecting to</span><br><span class="line">the local LAN segment where Host 1 resides. Once Router A receives the frame,</span><br><span class="line">it will check the destination IP address to see if the IP Address is connected to</span><br><span class="line">a local LAN segment or not. In this case, we need to go through Router C to get</span><br><span class="line">to Host 2, the router determines that the destination IP is NOT local and looks</span><br><span class="line">at the routing table for the next steps. This step will check for the BEST route</span><br><span class="line">available to the Destination IP address. If no route is found, it will check for</span><br><span class="line">a quad route (0.0.0.0 a.k.a. Default Route). Once the interface is determined based</span><br><span class="line">on the route selection process, it will check for an ARP entry for the IP address</span><br><span class="line">of the next hop, in this case, Router B interface facing Router A. Router A will</span><br><span class="line">send the frame up to the CPU and have the source and dest MAC addresses updated to</span><br><span class="line">reflect the following. Router A egress interface will be the new Source MAC and</span><br><span class="line">Router B interface facing toward router A will be the Destination MAC address.</span><br><span class="line">Once Router B gets the frame, it will do the same thing and forward the frame out</span><br><span class="line">toward router C with the Source MAC being the Router B interface facing Router C</span><br><span class="line">and the Destination MAC address being the interface of Router C. All the while,</span><br><span class="line">the Source and Destination IP addresses are the same. Since Host 2 would most</span><br><span class="line">likely be sent to a switch that connects all the users up, Router C will check</span><br><span class="line">its route table and see that the Destination IP address is locally connected via</span><br><span class="line">one of its interfaces. At that point,a final ARP check is done to find the MAC</span><br><span class="line">address of Host 2. The switch will respond with this information and report it</span><br><span class="line">back to Router C. Router C then replaces the Destination MAC to that of Host 2</span><br><span class="line">(learned via ARP) and replaces the Source MAC as the interface of Router C</span><br><span class="line">connected to the LAN Segment&#x2F;Switch. The switch, assuming it’s layer 2 only,</span><br><span class="line">will see the Destination MAC as that of Host 2 and forward the packet out the port</span><br><span class="line">that Host 2 is connected. Host 2 then receives the frame and the initial journey</span><br><span class="line">is completed. All the while, these ARP entries are being cached and stored for the</span><br><span class="line">return path as well.</span><br><span class="line"></span><br><span class="line">In summary, ARP is used to map the IP to MAC addresses in a network for non-local</span><br><span class="line">forwarding. This is done to prevent broadcasts from flooding the network. Imagine</span><br><span class="line">if you will, the Internet being one big flat network. All of the hosts on the</span><br><span class="line">Internet would be ARP-ing for the MAC address of the device it wants to talk to and,</span><br><span class="line">we would never be able to load http:&#x2F;&#x2F;Quora.com as the Internet would be flooded</span><br><span class="line">with Broadcasts. The purpose of a router is just that, break up the broadcast</span><br><span class="line">domains to prevent this from occuring. Back in the day, we had to design networks</span><br><span class="line">with this in mind as switching hadn’t been fully realized yet.</span><br><span class="line"></span><br><span class="line">Last thing to note that is important. All communication happens at Layer 2,</span><br><span class="line">Layer 3 is just a way for us humans to organize the network in a way that makes</span><br><span class="line">logical sense using IP addressing.</span><br></pre></td></tr></table></figure>

<ul>
<li>一个路由选择的例子：</li>
</ul>
<p><a href="https://community.cisco.com/t5/networking-blogs/what-happens-when-router-receives-packet/ba-p/3105996" target="_blank" rel="external nofollow noopener noreferrer">https://community.cisco.com/t5/networking-blogs/what-happens-when-router-receives-packet/ba-p/3105996</a></p>
<h4 id="端口与套接字的区别与联系"><a href="#端口与套接字的区别与联系" class="headerlink" title="端口与套接字的区别与联系"></a>端口与套接字的区别与联系</h4><p>原文地址：<a href="https://stackoverflow.com/questions/152457/what-is-the-difference-between-a-port-and-a-socket?page=1&tab=votes#tab-top" target="_blank" rel="external nofollow noopener noreferrer">https://stackoverflow.com/questions/152457/what-is-the-difference-between-a-port-and-a-socket?page=1&amp;tab=votes#tab-top</a><br><strong>总结</strong><br>一个 TCP 套接字是一个端点（endpoint）实例：由特定 TCP 连接或处于监听状态的 TCP server 的上下文环境中的一个 IP 地址和一个端口定义。<br>一个端口是一个虚拟的 ID 定义了一个服务端点（有别于服务实例端点又称 session ID）。<br>TCP 套接字不是连接，而是特定连接的一个端点。<br>同一个服务端点可以存在多个并发连接，因为一个连接是由本地和远端端点共同标识的，所以能够允许不同连接的流量根据该连接的信息被路由到不同的服务实例去处理。<br>对于给定的一个地址与端口组合，只能有一个处于监听状态的套接字（ Linux 从 3.9 版本的开始引入了 SO_REUSEPORT 选项，允许多进程多个套接字监听在同一个端口，内核负责把建立新连接的请求负载均衡到不同的进程去处理，提高 accept 性能，就我个人的理解，在云原生场景下不应该使用该选项，更好的一种方式是以容器的形式在不同的宿主机上启动多个进程，通过四层或七层负载均衡的方式提升 HTTP Server 的性能 ）。<br><strong>说明</strong><br>这是一个有趣的问题，迫使我重新审视许多我以为自己彻底了解的事情。你可能认为像 “socket” 这样的名字是不言自明的：它的选择显然是为了让人联想起插入网络电缆的端点，因为它们具有很强的功能相似性。然而，在网络编程术语中来说，“插座” 这个词背负着太多的包袱，因此有必要对它进行仔细的重新检查。<br>在广泛的意义上来理解，一个端口就是一个进口或出口点。尽管 porte 这个法语单词没有被用在网络术语中，但它的字面意思门或门户进一步强调了这样一个事实：无论你是运输数据还是大型钢制集装箱，端口都是运输的端点。<br>基于本次讨论的需要，这里仅仅考虑 TCP-IP 网络的情况。OSI 模型是一个非常好的网络模型，但它从来没有被完整实现过，在高流量高压力的网络环境中也很少有部署实施。<br>IP 地址和端口的组合严格地来讲被称为端点，有时也称为套接字。这种用法起源于 RFC793，它是最初的 TCP 规范文档。<br>一个 TCP  连接由两个端点 (又称为套接字) 定义。<br>一个端点 (套接字) 由网络地址和端口 ID 组合定义。需要注意的是，地址与端口的组合并不能确切标识一个套接字 (稍后将详细介绍)。<br>端口的作用是区分给定网络地址上的多个服务端点。也可以说一个端口是一个虚拟的端点。 这种虚拟化使单个网络接口上的多个并发连接成为可能。</p>
<blockquote>
<p>套接字对 (由客户端 IP 地址、客户端端口号、服务器 IP 地址和服务器端口号组成的 4 元组) 描述的两个端点唯一标识了一个网络中的每个 TCP 连接。 (<em>TCP-IP Illustrated Volume 1</em>, W. Richard Stevens)</p>
</blockquote>
<p>在大多数派生自 C 的编程语言中，TCP 连接的建立和操作都是通过调用 Socket 类的实例的一系列方法完成的。虽然常见的是在更高的抽象层次上去操作连接，例如通过  NetworkStream 类的实例，但这些高层次类一般也是通过暴露底层套接字对象的引用来实现的。对于编程人员来说，这个套接字对象似乎代表连接，因为连接是使用套接字对象的方法创建和操作的。<br>在 C# 中，建立一个 TCP 连接（与已经存在的一个监听服务）的第一步是创建一个 TcpClient 对象。如果你没有为 TcpClient 构造函数指定端点，它将使用默认值：某种方法定义的本地端点。然后在已创建的实例上调用 Connect 方法，Connect 方法需要对方端点信息作为参数。<br>所有这些都有点令人困惑，让你相信套接字是一种连接，这是不正确的。 我一直在这种误解之下苦苦思索，直到到  Richard Dorman  问了这个问题。<br>经过大量的阅读和思考，我现在确信，拥有一个带有两个参数 LocalEndpoint 和 RemoteEndpoint 的构造函数的类 TcpConnection 更有具体意义。 当本地端点可以接受缺省值时，可以支持传入单个参数 RemoteEndpoint。 在具有多个网络接口的计算机上使用默认的本地端点会产生不确定性，但是可以使用路由表来选择能够到达远程端点的最短路径的接口来消除这种不确定性。<br>在其它方面的一些明确性也能有提升。套接字不能被 IP 地址和端口的组合确切地标识：</p>
<blockquote>
<p>[…]TCP 会用到组成本地和外部地址的所有四个值对传入的多路数据段进行解析：目的 IP 地址、目的端口、源 IP 地址和源端口。 TCP 无法仅通过目的端口来确定将到达的数据段传递给哪个进程。 此外，[给定端口号] 上的 [多个] 端点中唯有处于监听状态的端点才会收到建立连接的请求。 (p255, <em>TCP-IP Illustrated Volume 1</em>, W. Richard Stevens)</p>
</blockquote>
<p>如你所见，对于一个网络服务来说，在同一地址 / 端口上存在多个套接字不仅是可能的，而且这种可能性还很大，只不过在一个特定的地址 / 端口组合上只能有一个处于监听状态的套接字。 典型的库实现提供一个套接字类，开发人员使用这个类的实例创建和管理连接。这是极其不幸的，因为它造成了混淆，并导致了对套接字和连接两个概念大范围的混用。<br>Hagrawal 不相信我的观点（见评论），因此在此给出一个示例。我通过浏览器访问了  <a href="http://dilbert.com" target="_blank" rel="external nofollow noopener noreferrer">http://dilbert.com</a>  然后执行了  <code>netstat -an -p tcp</code>  命令。命令输出内容的最后六行包含了两个例子可以说明仅靠地址和端口是不足以唯一标识一个套接字的事实。可以看到在 192.168.1.3 (我的本地工作站) 和 54.252.94.236:80 (远端 HTTP 服务器) 之间有两个不同的 TCP 连接。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">TCP    192.168.1.3:63240      54.252.94.236:80       SYN_SENT</span><br><span class="line">TCP    192.168.1.3:63241      54.252.94.236:80       SYN_SENT</span><br><span class="line">TCP    192.168.1.3:63242      207.38.110.62:80       SYN_SENT</span><br><span class="line">TCP    192.168.1.3:63243      207.38.110.62:80       SYN_SENT</span><br><span class="line">TCP    192.168.1.3:64161      65.54.225.168:443      ESTABLISHED</span><br></pre></td></tr></table></figure>

<p>由于套接字是一个连接的一个端点，所以地址／端口组合  <code>207.38.110.62:80</code>  和<code>54.252.94.236:80</code>  分别都有两个套接字。<br>我想  Hagrawal 的误解来自于我对 “identifies” 一词的极其谨慎地使用。  我提到  “identifies” 一词指的是  “完全、明确和唯一地识别”。 在上面的示例中，地址 / 端口组合 54.252.94.236:80 有两个端点。 如果只有地址和端口信息，则无法区分这些套接字，即没有足够的信息来标识一个套接字。<br>RFC793 文档 2.7 章节第二段说到：</p>
<blockquote>
<p>一个连接由通信两端的一对套接字完整描述。一个本地套接字可以参与到与多个外部套接字建立的多个连接中。</p>
</blockquote>
<p>从编程的角度来讲这个关于套接字的说法毫无意义，因为它和作为特定连接端点的套接字对象并不相同。对于一个编程人员来说（这个问题的大多数受众应该是程序员），这是非常关键的实用性的区别。<br>端口是用在 TCP/IP 协议栈中指代通信端点。而套接字是在各种协议栈的实现中通用的对通信端点的软件抽象（socket API）。例如不同于 TCP/IP 的另一种协议实现是  XTI/TLI API。</p>
<h4 id="Linux-bridge"><a href="#Linux-bridge" class="headerlink" title="Linux bridge"></a>Linux bridge</h4><p>网桥可以是指物理设备也可以指虚拟设备，两者功能一致。这里只讨论 Linux 系统中虚拟网桥的工作过程。Linux bridge 是一个虚拟的二层设备，它本身不能收发任何数据，除非将一个或多个网卡设备和它绑定，即将网络接口加入网桥。Linux bridge 完成工作依赖四个组件：</p>
<ul>
<li>一组网络接口：用于在上游交换机（路由器）和其它主机之间转发流量。这些接口可以是物理接口也可以是虚拟接口。一般来讲，要想能够访问广域网则必须有物理接口，而如果是在同一宿主机的不同虚拟机之间通信则使用虚拟接口即可。</li>
<li>控制平面：用于运行 STP （生成树协议），避免产生环路造成网络崩溃。</li>
<li>转发平面：用于处理从各个网络接口进入的数据帧，根据 MAC 地址表中的记录决定将数据帧转发到哪个网络接口。</li>
<li>MAC 地址表：用于记录局域网中每个宿主机的位置（通过 MAC 地址与接口的对应关系确定位置）。</li>
</ul>
<p>网桥通过构造一张 MAC 地址表将 MAC 地址和 MAC 地址连接的网络端口关联起来。当一个数据帧到达网桥的一个接口，网桥会更新 MAC 地址表记录下数据帧中的源 MAC 地址和该网络接口的对应关系。每个接口可以关联多个 MAC 地址，但是每个 MAC 地址只能对应一个网络接口。<br>数据帧从某个接口到达网桥后，网桥在记录源 MAC 地址与接口的对应关系的同时，也会查找表中关于目的 MAC 地址的记录。如果目的 MAC 地址在表中，则数据帧会被转发到对应的接口。如果目的 MAC 地址不在表中，或者目的 MAC 地址是一个广播或多播地址，则该数据帧将会被转发给除了进入网桥时的端口之外的所有端口。这样会造成环路和流量洪泛，而 STP 就是用来解决这个问题的，STP 会保留所有可以到达根路由器的路径中最短的路径，而切断其它的路径，从而形成树形结构。<br>实验细节参考：<a href="https://hechao.li/2017/12/13/linux-bridge-part1/" target="_blank" rel="external nofollow noopener noreferrer">https://hechao.li/2017/12/13/linux-bridge-part1/</a></p>
<h4 id="TUN-TAP"><a href="#TUN-TAP" class="headerlink" title="TUN/TAP"></a>TUN/TAP</h4><p>根据 Linux 内核文档: TUN/TAP 为用户空间程序提供分组接收和传输功能。它可以被看作是一个简单的点对点或以太网设备，它不是从物理媒体接收数据包，而是从用户空间程序接收数据包，并且不是通过物理媒体发送数据包，而是将数据包写入用户空间程序。<br>也就是说，TUN/TAP  接口是虚拟接口，没有相关的物理设备。用户空间程序可以连接到 TUN/TAP 接口，并处理发送到接口的流量。<br>TUN 接口是虚拟 IP 点对点接口，而 TAP 接口是虚拟以太网接口。 这意味着用户程序只能从 / 向 TUN 接口读 / 写 IP 数据包，从 / 向 TAP 接口读 / 写以太网帧。<br>TUN 接口的典型用例是 IP 隧道。 例如，OpenVPN 从 tun0 等 TUN 接口接收数据包，并在将其发送到真正的以太网接口 eth0 之前对其进行加密。 然后，对端网络上的 OpenVPN 客户端接收来自 eth0 的数据包，并在将其发送到 tun0 之前对其进行解密。 换句话说，OpenVPN 作为 tun0 和 eth0 之间的代理工作，并在两个主机之间通过互联网创建加密的 UDP 连接。<br><img src="https://cdn.nlark.com/yuque/0/2019/png/182657/1576386544299-80e5dc93-9f94-475c-9c4e-ba06248e534e.png#align=left&display=inline&height=474&margin=%5Bobject%20Object%5D&name=image.png&originHeight=559&originWidth=879&size=160518&status=done&style=none&width=746" alt="image.png"><br>TAP 接口的典型用例是虚拟网络。 例如，在 Linux Bridge Part 1 中，我们已经看到，当我们使用桥接网络在 KVM 中创建一个 VM 时，它会创建一个类似 vnet0 的 TAP 接口，并将其添加到 Linux 桥。 在这种情况下，KVM 是用于读取和写入 TAP 接口的 usersapce 程序。 当 VM0 向它的 eth0 发送一个数据包时，KVM 将其发送到 TAP 接口 vnet0，以便桥接器将其转发到 vnet1。 然后 KVM 接收它并将其发送给 VM1 的 eth0。<br><img src="https://cdn.nlark.com/yuque/0/2019/png/182657/1576386832999-494d3049-2e09-4f79-a962-d68a84ff1820.png#align=left&display=inline&height=341&margin=%5Bobject%20Object%5D&name=image.png&originHeight=341&originWidth=521&size=21678&status=done&style=none&width=521" alt="image.png"><br><code>ip tuntap</code>  命令可用于管理  TUN/TAP 接口。例如:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ip tuntap <span class="built_in">help</span></span><br><span class="line">Usage: ip tuntap &#123; add | del | show | list | lst | <span class="built_in">help</span> &#125; [ dev PHYS_DEV ]</span><br><span class="line">          [ mode &#123; tun | tap &#125; ] [ user USER ] [ group GROUP ]</span><br><span class="line">          [ one_queue ] [ pi ] [ vnet_hdr ] [ multi_queue ]</span><br><span class="line"></span><br><span class="line">Where: USER  := &#123; STRING | NUMBER &#125;</span><br><span class="line">       GROUP := &#123; STRING | NUMBER &#125;</span><br></pre></td></tr></table></figure>

<p>参考：<a href="https://hechao.li/2018/05/21/Tun-Tap-Interface/" target="_blank" rel="external nofollow noopener noreferrer">https://hechao.li/2018/05/21/Tun-Tap-Interface/</a></p>
<h4 id="iproute2-用法"><a href="#iproute2-用法" class="headerlink" title="iproute2 用法"></a>iproute2 用法</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 列出所有 veth 设备</span></span><br><span class="line">ip -c link show <span class="built_in">type</span> veth</span><br><span class="line"><span class="comment"># 列出所有 tunnel 设备</span></span><br><span class="line">ip tunnel show</span><br></pre></td></tr></table></figure>

<h4 id="TCP-连接的意外情况"><a href="#TCP-连接的意外情况" class="headerlink" title="TCP 连接的意外情况"></a>TCP 连接的意外情况</h4><ul>
<li>服务端连接处于建立状态，但收到 SYN 包</li>
</ul>
<p>当 TCP 连接建立后，如果客户端意外断电（没有主动关闭 TCP 连接的过程），此时服务端连接状态仍为  established，客户端重启后如果恰好使用了之前一样的端口重新发起建立 TCP 连接的请求，服务端会收到 SYN 包，并将其作为一个合法的包，返回 ACK ；客户端此时处于  SYN_SENT 状态，却收到了一个不带 SYN 标志的 ACK 包，由此客户端可以确定这是来自于遗留连接的包，因此会发出 RST 包。服务端收到 RST 包则会清理掉遗留连接的信息。客户端在稍后可以重新尝试建立连接。<br>导致建立状态的服务端收到 SYN 包情况有多种，可参考：<a href="https://serverfault.com/a/733727" target="_blank" rel="external nofollow noopener noreferrer">https://serverfault.com/a/733727</a></p>
<ul>
<li>服务端进程终止</li>
</ul>
<p>如果服务端进程通过 kill 终止，操作系统在结束进程时会关闭该进程打开的所有连接，此时会向客户端发送 FIN 包，客户端回复 ACK 包，若客户端继续向服务端发送数据，则虽然 TCP 连接还是半关闭状态，理论上讲可以继续接收数据，但由于进程已经被终止，所以服务端会回复 RST 包，客户端读取操作将会接收到  ECONNRESET 错误。</p>
<ul>
<li>服务端意外崩溃从网络中消失</li>
</ul>
<p>此时，客户端没有任何感知，仍然继续发送包，一般来讲，会进入重传直至超时的过程，最后发送操作会返回 ETIMEDOUT 错误；但如果中间路由器已经判定服务端主机不可达，则会返回  EHOSTUNREACH 或  ENETUNREACH 错误。</p>
<ul>
<li>服务端崩溃后重启回到网络中</li>
</ul>
<p>此时，客户端发送给服务端的数据包会得到 RST 响应。</p>
<ul>
<li>服务端正常关机或重启</li>
</ul>
<p>此时，服务端会先终止进程再关机，终止进程时 TCP 连接会被正常关闭，客户端能够及时获取到服务端状态从而做出响应。<br>参考：<a href="https://www.cnblogs.com/549294286/p/5208357.html" target="_blank" rel="external nofollow noopener noreferrer">https://www.cnblogs.com/549294286/p/5208357.html</a></p>
<h4 id="TCP-连接能存活多久"><a href="#TCP-连接能存活多久" class="headerlink" title="TCP 连接能存活多久"></a>TCP 连接能存活多久</h4><p>理论上讲，一旦连接建立，将永远存活下去，哪怕一直没有数据传输，即使是其中一端故障，另一端仍保持连接建立状态。如果开启了 keepalive 特性（Linux 中在 setsockopt 时传入 SO_KEEPALIVE 参数)，则操作系统（ Linux 内核协议栈）会自动在空闲一段时间后发送探测包，帮助一直保持连接状态或者在故障时及时发现并关闭连接。但实际上会有各种规则或意外会使连接无法持续维持：一种情况是通过 DHCP 获取的 IP 地址到期，IP 地址可能发生变化；还有一些需要经过 NAT 的连接则可能由于存储空间不足丢弃老的 TCP 连接状态；Linux conntrack 表的大小也是有限的，如果连接数太多到超过表的存储上限，老的不活跃的 TCP 连接状态也会被丢弃；还有的防火墙能够识别出 keepalive 探测包和数据包，会根据用户配置的规则在连接空闲一段时间后强制关闭连接。参考：<a href="https://stackoverflow.com/a/419491" target="_blank" rel="external nofollow noopener noreferrer">https://stackoverflow.com/a/419491</a>，<a href="https://networkengineering.stackexchange.com/a/30961" target="_blank" rel="external nofollow noopener noreferrer">https://networkengineering.stackexchange.com/a/30961</a>，<a href="https://notes.shichao.io/unp/ch7/" target="_blank" rel="external nofollow noopener noreferrer">https://notes.shichao.io/unp/ch7/</a>。</p>
<h4 id="发送数据时超时时间设置"><a href="#发送数据时超时时间设置" class="headerlink" title="发送数据时超时时间设置"></a>发送数据时超时时间设置</h4><p>keepalive 对于空闲的连接可以及时发现问题并关闭 broken 连接，对于处于繁忙状态的 TCP 连接，数据包发送失败且重试也失败直至关闭连接会经历两个过程：tcp_retries1，默认进行 3 次重传；tcp_retries1  后，网络层将被告知传输故障；tcp_retries2，默认进行 15 次重传；tcp_retries2 连接关闭。我们可以通过设置这两个参数来改变每个阶段的重传次数从而间接影响超时时间，但是由于无法直接设置时间限制，这种更改不具有太大实用价值。实际上，在 Linux 编程中有另外一个 socket 参数  TCP_USER_TIMEOUT 可能更加有效，它可以确保重试过程在指定时间内终结并强制关闭连接。但更多的编程方式推荐在应用层去设置超时时间，从而更灵活的实现逻辑而不是去更改和依赖底层配置，例如 HTTP 1.1 中的 Keepalive header 可以指定该连接的存活时间，一旦超过指定时间仍没有数据传输，则关闭连接。在服务端 HTTP 编程中我们也经常设置发送和接收的超时时间。<br>参考：<a href="https://blog.cloudflare.com/when-tcp-sockets-refuse-to-die/" target="_blank" rel="external nofollow noopener noreferrer">https://blog.cloudflare.com/when-tcp-sockets-refuse-to-die/</a>，<a href="https://man7.org/linux/man-pages/man7/tcp.7.html" target="_blank" rel="external nofollow noopener noreferrer">https://man7.org/linux/man-pages/man7/tcp.7.html</a>，<a href="https://stackoverflow.com/a/5907951" target="_blank" rel="external nofollow noopener noreferrer">https://stackoverflow.com/a/5907951</a>，<a href="https://pracucci.com/linux-tcp-rto-min-max-and-tcp-retries2.html" target="_blank" rel="external nofollow noopener noreferrer">https://pracucci.com/linux-tcp-rto-min-max-and-tcp-retries2.html</a>。</p>
<h4 id="关于-TCP-KEEPALIVE-的阅读资料"><a href="#关于-TCP-KEEPALIVE-的阅读资料" class="headerlink" title="关于  TCP_KEEPALIVE 的阅读资料"></a>关于  TCP_KEEPALIVE 的阅读资料</h4><p><a href="https://codearcana.com/posts/2015/08/28/tcp-keepalive-is-a-lie.html" target="_blank" rel="external nofollow noopener noreferrer">https://codearcana.com/posts/2015/08/28/tcp-keepalive-is-a-lie.html</a>，<a href="https://blog.csdn.net/chrisnotfound/article/details/80111559" target="_blank" rel="external nofollow noopener noreferrer">https://blog.csdn.net/chrisnotfound/article/details/80111559</a>，</p>
<h4 id="查看网络统计信息的几种工具"><a href="#查看网络统计信息的几种工具" class="headerlink" title="查看网络统计信息的几种工具"></a>查看网络统计信息的几种工具</h4><p>参考：<a href="https://www.cyberciti.biz/faq/network-statistics-tools-rhel-centos-debian-linux/" target="_blank" rel="external nofollow noopener noreferrer">https://www.cyberciti.biz/faq/network-statistics-tools-rhel-centos-debian-linux/</a>，<a href="https://prefetch.net/blog/2011/07/11/using-netstat-and-dropwatch-to-observe-packet-loss-on-linux-servers/" target="_blank" rel="external nofollow noopener noreferrer">https://prefetch.net/blog/2011/07/11/using-netstat-and-dropwatch-to-observe-packet-loss-on-linux-servers/</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 查看每个网卡的统计信息，以下三种命令结果类似,主要包括发送和接收的包量和比特数，MTU，发送和接收的出错数量</span><br><span class="line">netstat -i</span><br><span class="line">ifconfig</span><br><span class="line">ip -s link</span><br><span class="line"># 查看所有协议栈信息的汇总</span><br><span class="line">netstat -s</span><br><span class="line"># 查看发送接收速率</span><br><span class="line">sar -n DEV 1 3</span><br><span class="line">sar -n DEV</span><br><span class="line"># 使用 dropwatch（Kernel dropped packet monitor） 可以监测内核丢包信息 ，执行以下命令，然后输入 start</span><br><span class="line">dropwatch -l kas</span><br></pre></td></tr></table></figure>

<h4 id="网络性能测试"><a href="#网络性能测试" class="headerlink" title="网络性能测试"></a>网络性能测试</h4><p>使用 iperf3 进行性能测试， centos 可直接执行 <code>yum install iperf3</code> 进行安装：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 启动服务端 -s 意思是服务端</span></span><br><span class="line">iperf3 -s</span><br><span class="line"><span class="comment"># 后台进程方式启动服务端，-D 意思是 Daemon 进程启动</span></span><br><span class="line">iperf3 -s -D</span><br><span class="line"><span class="comment"># 在客户端执行 TCP 测试， -c 指的是客户端，-b 目标带宽（一般与网卡带宽相匹配），-n 发送字节数</span></span><br><span class="line">iperf3 -c 10.10.140.95 -b 10000M -n 10G</span><br><span class="line"><span class="comment"># 执行 UDP 测试，-u 使用 UDP 协议，-l 指定数据包大小，这里指定的是 TCP 或 UDP 数据部分的大小为 1400</span></span><br><span class="line"><span class="comment"># 实际发送时的 MAC 帧长会是 1454 ，包括：</span></span><br><span class="line"><span class="comment"># 26 个字节的 MAC 帧头：7 个字节的前导码，1 个字节的帧起始符，6 字节目的 MAC ，6 字节源 MAC ，2 字节帧长度，以及位于帧末尾的 4 字节 CRC 校验和</span></span><br><span class="line"><span class="comment"># 20 字节的 IP 头部</span></span><br><span class="line"><span class="comment"># 8 字节 UDP 头部</span></span><br><span class="line">iperf3 -u -c 10.10.140.95 -b 10000M -n 10G -l1400</span><br><span class="line"><span class="comment"># 由于 iperf3 只显示带宽，可以借助 sar 查看包量</span></span><br><span class="line"><span class="comment"># sar 工具包含在 sysstat 中</span></span><br></pre></td></tr></table></figure>

<h4 id="网络性能调优"><a href="#网络性能调优" class="headerlink" title="网络性能调优"></a>网络性能调优</h4><p>网卡收发数据处理速度成为瓶颈时，可通过手动设置 CPU 亲和性（ irqbalance 的自动负载均衡很多时候不好用） 将中断处理分发到不同的 CPU 上，避免集中在一个 CPU 上。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 执行以下命令可以找到虚拟机上 eth0 对应的底层设备</span></span><br><span class="line">readlink -e /sys/class/net/eth0/</span><br><span class="line">/sys/devices/pci0000:00/0000:00:04.0/virtio1/net/eth0</span><br><span class="line"><span class="comment"># 从 proc 目录下可以找到设备驱动相关的中断</span></span><br><span class="line">[root@10-10-175-184 ~]<span class="comment"># cat /proc/interrupts</span></span><br><span class="line">           CPU0       CPU1       CPU2       CPU3</span><br><span class="line">  0:         32          0          0          0   IO-APIC   2-edge      timer</span><br><span class="line">  1:          9          0          0          0   IO-APIC   1-edge      i8042</span><br><span class="line">  4:          0          0        728          0   IO-APIC   4-edge      ttyS0</span><br><span class="line">  6:          0          0          0          3   IO-APIC   6-edge      floppy</span><br><span class="line">  8:          0          0          0          0   IO-APIC   8-edge      rtc0</span><br><span class="line">  9:          0          0          0          0   IO-APIC   9-fasteoi   acpi</span><br><span class="line"> 10:          0          0          0          0   IO-APIC  10-fasteoi   virtio0</span><br><span class="line"> 11:          0          0         32          0   IO-APIC  11-fasteoi   uhci_hcd:usb1</span><br><span class="line"> 12:          0          0          0         15   IO-APIC  12-edge      i8042</span><br><span class="line"> 14:          0          0          0          0   IO-APIC  14-edge      ata_piix</span><br><span class="line"> 15:          0          0          0          0   IO-APIC  15-edge      ata_piix</span><br><span class="line"> 24:          0          0          0          0   PCI-MSI 81920-edge      virtio2-config</span><br><span class="line"> 25:          0          0       8954          0   PCI-MSI 81921-edge      virtio2-req.0</span><br><span class="line"> 26:          0          0          0          0   PCI-MSI 65536-edge      virtio1-config</span><br><span class="line"> 27:          0          0          0     152606   PCI-MSI 65537-edge      virtio1-input.0</span><br><span class="line"> 28:      15864          0          0          0   PCI-MSI 65538-edge      virtio1-output.0</span><br><span class="line"> <span class="comment"># 目前有四个 CPU 核，通过如下方式可以设置 irq CPU 亲和性，设置的是十六进制值，1 表示 0001 第一个 CPU 核，即将 27 号中断调度到 CPU0 上处理；</span></span><br><span class="line"> <span class="comment"># 8 表示 1000 ，将 28 号中断调度到 CPU3 上处理；f 表示 1111 ，表明可以将中断调度到四个核中任一个上处理</span></span><br><span class="line"> <span class="built_in">echo</span> 1 &gt; /proc/irq/27/smp_affinity</span><br><span class="line"> <span class="built_in">echo</span> 8 &gt; /proc/irq/28/smp_affinity</span><br></pre></td></tr></table></figure>

<p>上述方式能够有效的前提是网卡收发数据过程中确实存在多种中断请求，而一般情况下，一张网卡对应一个发送队列，一个发送队列对应一种中断请求，此时就无法通过 CPU 负载均衡来提升网络性能。有的网卡是硬件实现多队列，在虚拟化场景下，配置网卡多队列也可以通过软件实现。<br>对于多队列网卡，可通过设置 <code>/sys/class/net/eth0/queues/rx-0/rps_cpus</code> 来指定使用哪些 CPU 处理接收操作，参考： <a href="https://xixiliguo.github.io/post/multi-queue/" target="_blank" rel="external nofollow noopener noreferrer">https://xixiliguo.github.io/post/multi-queue/</a>，<a href="https://www.eflycloud.com/blog/blogDetail?id=377" target="_blank" rel="external nofollow noopener noreferrer">https://www.eflycloud.com/blog/blogDetail?id=377</a>。<br>当缓冲区大小成为瓶颈时，可调整内核参数进行优化：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 该参数决定了，网络设备接收数据包的速率比内核处理这些包的速率快时，允许送到队列的数据包的最大数目。</span></span><br><span class="line">net.core.netdev_max_backlog = 400000</span><br><span class="line"><span class="comment"># 该参数指定了每个套接字所允许的最大缓冲区的大小</span></span><br><span class="line">net.core.optmem_max = 10000000</span><br><span class="line"><span class="comment"># 指定了接收套接字缓冲区大小的缺省值（以字节为单位）</span></span><br><span class="line">net.core.rmem_default = 16777216</span><br><span class="line"><span class="comment"># 指定了接收套接字缓冲区大小的最大值（以字节为单位）</span></span><br><span class="line">net.core.rmem_max = 16777216</span><br><span class="line"><span class="comment"># 表示socket监听的backlog(监听队列)上限</span></span><br><span class="line">net.core.somaxconn = 100000</span><br><span class="line"><span class="comment"># 定义默认的发送窗口大小</span></span><br><span class="line">net.core.wmem_default = 16777216</span><br><span class="line"><span class="comment"># 定义发送窗口的最大大小</span></span><br><span class="line">net.core.wmem_max = 16777216</span><br><span class="line"><span class="comment"># 确定 TCP 栈应该如何反映内存使用；每个值的单位都是内存页（通常是 4KB）。</span></span><br><span class="line"><span class="comment"># 第一个值是内存使用的下限。</span></span><br><span class="line"><span class="comment"># 第二个值是内存压力模式开始对缓冲区使用应用压力的上限。</span></span><br><span class="line"><span class="comment"># 第三个值是内存上限。在这个层次上可以将报文丢弃，从而减少对内存的使用。</span></span><br><span class="line">net.ipv4.tcp_mem=91650	122203	183300</span><br><span class="line"><span class="comment"># 为自动调优定义每个 socket 使用的内存。</span></span><br><span class="line"><span class="comment"># 第一个值是为 socket 的发送缓冲区分配的最少字节数。</span></span><br><span class="line"><span class="comment"># 第二个值是默认值（该值会被 wmem_default 覆盖），缓冲区在系统负载不重的情况下可以增长到这个值。</span></span><br><span class="line"><span class="comment"># 第三个值是发送缓冲区空间的最大字节数（该值会被 wmem_max 覆盖）。</span></span><br><span class="line">net.ipv4.tcp_wmem=4096 16384 16777216</span><br><span class="line">net.ipv4.tcp_rmem=4096 131072 16777216</span><br></pre></td></tr></table></figure>

<p>对于 tap 设备，建议设置以下参数，参考 <a href="https://access.redhat.com/documentation/en-us/red_hat_openstack_platform/13/html/ovs-dpdk_end_to_end_troubleshooting_guide/high_packet_loss_in_the_tx_queue_of_the_instance_s_tap_interface" target="_blank" rel="external nofollow noopener noreferrer">high_packet_loss_in_the_tx_queue_of_the_instance_s_tap_interface</a>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 注意以下设置仅临时有效</span></span><br><span class="line">ifconfig eth0 txqueuelen 8000</span><br><span class="line"><span class="comment"># 或</span></span><br><span class="line">ip link <span class="built_in">set</span> tap&lt;uuid&gt; txqueuelen &lt;new queue length&gt;</span><br><span class="line"><span class="comment"># 持久设置</span></span><br><span class="line">cat &lt;&lt;<span class="string">'EOF'</span>&gt;/etc/udev/rules.d/71-net-txqueuelen.rules</span><br><span class="line">SUBSYSTEM==<span class="string">"net"</span>, ACTION==<span class="string">"add"</span>, KERNEL==<span class="string">"tap*"</span>, ATTR&#123;tx_queue_len&#125;=<span class="string">"10000"</span></span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>

<h4 id="OSI-开放互联模型"><a href="#OSI-开放互联模型" class="headerlink" title="OSI 开放互联模型"></a>OSI 开放互联模型</h4><p><img src="https://cdn.nlark.com/yuque/0/2020/png/182657/1593480135479-c91d4d48-b51e-4746-931c-5c1533e624b6.png#align=left&display=inline&height=794&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1587&originWidth=1120&size=505862&status=done&style=none&width=560" alt="image.png"></p>
<h4 id="tcp-tw-reuse-和-SO-REUSEADDR"><a href="#tcp-tw-reuse-和-SO-REUSEADDR" class="headerlink" title="tcp_tw_reuse 和 SO_REUSEADDR"></a>tcp_tw_reuse 和 SO_REUSEADDR</h4><p>tcp_tw_reuse 和 SO_REUSEADDR 都会改变内核处理 TIME_WAIT 状态的 TCP 连接的方式。只有先发起关闭连接的一方才会进入 TIME_WAIT 状态。<br>开启 tcp_tw_reuse 可以重复利用处于 TIME_WAIT 状态的连接。tcp_tw_reuse 设置的是内核变量 sysctl_tcp_tw_reuse ，而这个变量仅在 tcp_twsk_unique 函数中使用。而这个函数的调用路径有且仅有一个：tcp_v4_connect-&gt;inet_hash_connect-&gt;__inet_check_established-&gt;twsk_unique-&gt;twsk_unique。也就是说 tcp_tw_reuse 仅在 TCP 套接字作为客户端，调用 connect 时起作用。绝大部分的 TCP 服务器不会有大量主动连接的动作（或许会连接 DB 等，但一般也是长连接）。因此这个选项对于 TCP 服务端来说，基本上是无用的，完全是没必要打开。在 K8S 环境中，节点一般既是服务端也是客户端，发起大量短连接的可能性是存在的，所以开启也是有作用的。<br>SO_REUSEADDR 可以缓解 TIME_WAIT 状态的连接的端口占用问题，允许将未彻底释放的端口 bind 到新的 socket 进行监听，server 端启动监听时应默认设置该参数，这样可以在 server 端服务重启时不至出现 “Address already in use” 的 bind 错误，加快重启过程。</p>
<h4 id="SO-REUSEADDR-与-SO-REUSEPORT"><a href="#SO-REUSEADDR-与-SO-REUSEPORT" class="headerlink" title="SO_REUSEADDR 与 SO_REUSEPORT"></a>SO_REUSEADDR 与 SO_REUSEPORT</h4><p>SO_REUSEADDR 两个主要效果：改变了通配绑定时处理源地址冲突的处理方式；允许将处于 TIME_WAIT 状态的 TCP 连接对应的 socket 所占用的端口号拿出来给新的 socket 去 bind 使用。<br>SO_REUSEPORT 主要是允许多个 socket 绑定到同一个端口上进行监听，为了防止端口劫持，限制所有使用相同 ip 和 port 的 socket 都必须拥有相同的有效用户 id，其主要效果是由内核进行负载均衡提高了 accept 的效率。</p>
<h4 id="多线程（进程）网络编程与-SO-REUSEPORT"><a href="#多线程（进程）网络编程与-SO-REUSEPORT" class="headerlink" title="多线程（进程）网络编程与 SO_REUSEPORT"></a>多线程（进程）网络编程与 SO_REUSEPORT</h4><p>在 SO_REUSEPORT 没有出现之前，多线程编程一般有两种方式处理客户端请求：① 指派一条线程专门进行 accept ，获取 socket 后分派给 worker 线程。这种方法使得进行 accept 的线程成为了单点，容易成为性能的瓶颈。② 多个线程同时进行 accept ，这种方法的问题是协议栈/调度器中的一些机制导致每个线程 accept 成功的概率不均匀，可能出现几个 CPU 撑死几个 CPU 饿死的情况，导致负载不均衡。且多个线程监听同一个 socket 会出现惊群现象，造成 CPU 资源的浪费，而为了解决惊群现象引入了共享锁机制，又会带来处理性能的下降。<br>而引入 SO_REUSEPORT 之后，每个 worker 线程均拥有自己的 socket，内核负责把用户请求通过 hash 映射均匀地分发给各个 worker 线程，避免了共享锁的竞争带来的消耗和性能下降。各个线程中 accept socket 不一样，有新连接建立时，内核只会唤醒一个线程来 accept ，不会出现惊群现象并且保证唤醒的均衡性。<br>多个 socket 的一个问题是其中一个 worker 线程阻塞时会造成所有分发到该线程的请求均被阻塞，参见：<a href="https://blog.csdn.net/dog250/article/details/107227145" target="_blank" rel="external nofollow noopener noreferrer">从 SO_REUSEPORT 服务器的一个弊端看多队列服务模型</a>。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/182657/1596547632756-09311bd2-899c-45f8-83e7-165af8e2a16f.png#align=left&display=inline&height=393&margin=%5Bobject%20Object%5D&name=image.png&originHeight=785&originWidth=850&size=90942&status=done&style=none&width=425" alt="image.png">    <img src="https://cdn.nlark.com/yuque/0/2020/png/182657/1596547640520-425396fc-a06a-4590-ac4f-a4351a70bc83.png#align=left&display=inline&height=390&margin=%5Bobject%20Object%5D&name=image.png&originHeight=780&originWidth=850&size=94147&status=done&style=none&width=425" alt="image.png"></p>
<h4 id="QUIC"><a href="#QUIC" class="headerlink" title="QUIC"></a>QUIC</h4><p>快速 UDP 网路连接协议（QUIC）最初由 Google 公司推出，用于支持下一代 HTTPS 协议。IETF 基于此推出了更通用的 QUIC 协议，可以支持 HTTP 以外的诸如 SSH、SMTP、DNS、NTP 等应用层协议。QUIC 的主要特性有：</p>
<ul>
<li>QUIC 将握手和密钥协商（TLS）过程整合在一起，即发起请求的同时传递密钥协商报文，相对于 TCP 场景下 TCP 连接的建立和 TLS 握手是独立的过程，QUIC 减少了初始化时所需的请求和响应包，节省了开销；</li>
<li>QUIC 的数据重传实现在 QUIC 级别而不是协议栈级别，因此一个 QUIC 连接中的多个流可以相互独立而不会因丢包重传发生阻塞，QUIC 在修复一个流时不会影响到其它流的工作，相较之下基于 TCP 实现的 HTTP/2 协议虽然也实现了连接的多路复用，但只要其中一个流发生丢包就会引发协议栈级别的重传，从而可能阻塞所有流的工作过程，直到丢包得以恢复；</li>
<li>QUIC 能够提高网络切换期间的性能，这是相较于 TCP 而言，用户使用移动设备时经常发生网络切换，由于 IP 地址的变化会导致原有 TCP 连接失效，因而需要重新握手建立连接，而 QUIC 通过一个连接标识符而不是地址与端口的组合来唯一标识一个连接，当用户 IP 发生变化时，连接 ID 依然有效从而无需重新建立连接；</li>
<li>QUIC 在应用程序中实现而不是在内核代码中实现，这使其具有更大的灵活性，可以快速更新引入特性而无需依赖内核升级，QUIC 能够实现以上特性的一个原因也正是因为其减少了对内核协议栈的依赖，具有更大的自主性和灵活性，而想要对 TCP 这种存在极其悠久的网络协议模块进行改良无疑是困难的甚至是不可能的。</li>
</ul>
<h4 id="tcp-syncookies"><a href="#tcp-syncookies" class="headerlink" title="tcp_syncookies"></a>tcp_syncookies</h4><p>其基本思想是通过生成特殊的序列号保存信息而不是在服务端分配资源保存半连接，避免消耗服务端过多资源，从而防范 sync flood 攻击，参考：<a href="https://segmentfault.com/a/1190000019292140" target="_blank" rel="external nofollow noopener noreferrer">https://segmentfault.com/a/1190000019292140</a>。</p>
<h4 id="获取网络栈监控信息"><a href="#获取网络栈监控信息" class="headerlink" title="获取网络栈监控信息"></a>获取网络栈监控信息</h4><p>参考：<a href="https://arthurchiao.art/blog/monitoring-network-stack/" target="_blank" rel="external nofollow noopener noreferrer">Monitoring Network Stack</a></p>
<h4 id="XDP"><a href="#XDP" class="headerlink" title="XDP"></a>XDP</h4><p>XDP 是从 Linux 4.8 版本内核引入的基于 eBPF 的快速数据路径，其基本原理是在数据接收路径上添加了一个更早的 hook 点（早于 Netfilter 的 PREROUTING hook 点），可以根据用户提供的 eBPF 程序确定对数据包的处理（丢弃、向上传递或者转发）。该 hook 点位于网卡驱动程序中，紧随中断处理，在数据包进入内核协议栈进行内存分配（开销巨大）之前，因此具有极高性能。对于不支持 offload 的网卡，eBPF 代码仍在内核中执行，流量较大时 CPU 负载会较高；而对于支持 offload 的网卡，可以将用户提供的 eBPF 程序注入到网卡中，由网卡硬件负责执行，大大降低了 CPU 的负担，且性能更好。XDP 的一种应用场景是应对 DDoS 的攻击，因为其可以高效地拦截数据包。</p>
<h4 id="unix-socket"><a href="#unix-socket" class="headerlink" title="unix socket"></a>unix socket</h4><p>使用 <code>lsof -U</code> 可以列出所有 Unix 套接字对应的文件，有些文件名以 <code>@</code> 符号开头，它们是使用了 Linux 抽象命名空间的特性，其好处是不需要在文件系统上创建一个文件，从而不需要小心维护文件的存在且在套接字关闭之后删除文件，<code>@</code> 开头的文件在套接字关闭后自动删除，仅存在于内存。</p>
<h4 id="阅读资料"><a href="#阅读资料" class="headerlink" title="阅读资料"></a>阅读资料</h4><ul>
<li><a href="https://notes.shichao.io/unp/ch7/" target="_blank" rel="external nofollow noopener noreferrer">Socket Options</a></li>
<li><a href="https://www.wikiwand.com/zh-hans/%E5%BF%AB%E9%80%9FUDP%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5" target="_blank" rel="external nofollow noopener noreferrer">快速 UDP 网络连接</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/32553477" target="_blank" rel="external nofollow noopener noreferrer">科普：QUIC 协议原理分析</a></li>
<li><a href="https://cloud.tencent.com/developer/article/1412003" target="_blank" rel="external nofollow noopener noreferrer">以讹传讹的“tcp_tw_reuse”</a></li>
<li><a href="https://www.nginx.com/blog/socket-sharding-nginx-release-1-9-1/" target="_blank" rel="external nofollow noopener noreferrer">Socket Sharding in NGINX Release 1.9.1</a></li>
<li><a href="https://www.zhihu.com/question/51618274/answer/126729306" target="_blank" rel="external nofollow noopener noreferrer">最近在 nginx1.9.1 中支持了 reuse_port 这个功能 是准许多个 socket 监听同一个端口？ - 凡柯的回答 - 知乎</a></li>
<li><a href="https://www.zhihu.com/question/22062795/answer/20197329" target="_blank" rel="external nofollow noopener noreferrer">Nginx 多进程模型是如何实现高并发的？ - linuor 的回答 - 知乎</a></li>
<li><a href="https://www.cnblogs.com/Anker/p/7075141.html" target="_blank" rel="external nofollow noopener noreferrer">Linux 网络编程客户\服务器设计范式</a>，<a href="https://www.cnblogs.com/Anker/p/7076537.html" target="_blank" rel="external nofollow noopener noreferrer">Linux 最新 SO_REUSEPORT 特性</a></li>
<li><a href="https://www.cnblogs.com/sunsky303/p/9094822.html" target="_blank" rel="external nofollow noopener noreferrer">简单对比 Libevent、libev、libuv</a></li>
<li><a href="https://blog.csdn.net/dog250/article/details/51287078" target="_blank" rel="external nofollow noopener noreferrer">TCP 拥塞控制图解</a></li>
<li><a href="https://blog.csdn.net/dog250/article/details/107243696" target="_blank" rel="external nofollow noopener noreferrer">Linux 网络数据转发平面的变迁-从内核协议栈到 DPDK/XDP</a></li>
<li><a href="https://blog.csdn.net/dog250/article/details/5593508" target="_blank" rel="external nofollow noopener noreferrer">虚拟网卡和 loopback 的思想</a></li>
<li><a href="https://blog.csdn.net/dog250/article/details/5561083" target="_blank" rel="external nofollow noopener noreferrer">cache 老化时间的思考–以 nat 为例</a></li>
<li><a href="https://blog.csdn.net/dog250/article/details/77993218" target="_blank" rel="external nofollow noopener noreferrer">使用 XDP(eXpress Data Path)防御 DDoS 攻击</a></li>
<li><a href="https://www.wikiwand.com/en/Express_Data_Path" target="_blank" rel="external nofollow noopener noreferrer">Express Data Path</a></li>
<li><a href="https://www.ibm.com/developerworks/cn/linux/l-lo-eBPF-history/index.html" target="_blank" rel="external nofollow noopener noreferrer">eBPF 简史</a></li>
<li><a href="https://www.cnblogs.com/aquester/p/9891484.html" target="_blank" rel="external nofollow noopener noreferrer">https://www.cnblogs.com/aquester/p/9891484.html</a></li>
</ul>
<p><a href="https://www.yuque.com/attachments/yuque/0/2019/pdf/182657/1576388605079-fe7121cc-ed8c-4401-ad04-3e503fbc7e82.pdf" target="_blank" rel="external nofollow noopener noreferrer">The Journey of a Packet Through the Linux Network Stack.pdf</a></p>
<p><a href="https://www.yuque.com/attachments/yuque/0/2019/pdf/182657/1576388462144-fcd84c73-35de-40f6-aa91-4cc5e6121c57.pdf" target="_blank" rel="external nofollow noopener noreferrer">Linux Kernel Networking.pdf</a></p>
<p><a href="https://www.yuque.com/attachments/yuque/0/2019/pdf/182657/1576388512234-3f978f9b-43af-4140-906d-8fa7f05ab6be.pdf" target="_blank" rel="external nofollow noopener noreferrer">Understanding Linux Network Internals.pdf</a></p>
]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 常用系统调用</title>
    <url>/post/fa6b61f1.html</url>
    <content><![CDATA[<h4 id="fcntl"><a href="#fcntl" class="headerlink" title="fcntl"></a>fcntl</h4><p>用于操作文件描述符，可以改变已打开文件的性质，fcntl 针对描述符提供控制，参数 fd 是被参数 cmd 操作的描述符，根据 cmd 的类型，fcntl 能够接受第三个参数 int arg :</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 设置 fd 为非阻塞</span><br><span class="line">fcntl(fd, F_SETFL, flags | O_NONBLOCK);</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>系统调用</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 实用命令集合</title>
    <url>/post/b489449e.html</url>
    <content><![CDATA[<h4 id="CentOS"><a href="#CentOS" class="headerlink" title="CentOS"></a>CentOS</h4><ul>
<li>升级系统内核</li>
</ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rpm --import https://www.elrepo.org/RPM-GPG-KEY-elrepo.org</span><br><span class="line">rpm -Uvh http://www.elrepo.org/elrepo-release-7.0-2.el7.elrepo.noarch.rpm</span><br><span class="line">yum --enablerepo=elrepo-kernel install kernel-ml</span><br><span class="line">awk -F\<span class="string">' '</span><span class="variable">$1</span>==<span class="string">"menuentry "</span> &#123;<span class="built_in">print</span> i++ <span class="string">" : "</span> <span class="variable">$2</span>&#125;<span class="string">' /etc/grub2.cfg</span></span><br><span class="line"><span class="string">grub2-set-default 0</span></span><br><span class="line"><span class="string">grub2-mkconfig -o /boot/grub2/grub.cfg</span></span><br><span class="line"><span class="string">reboot</span></span><br></pre></td></tr></table></figure><a id="more"></a>


<ul>
<li>安装 fish</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /etc/yum.repos.d/</span><br><span class="line">wget https://download.opensuse.org/repositories/shells:fish:release:2/CentOS_7/shells:fish:release:2.repo</span><br><span class="line">yum install fish -y</span><br></pre></td></tr></table></figure>

<ul>
<li>创建网桥</li>
</ul>
<p>可以直接在配置文件修改，如下创建网桥 br0：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># cat /etc/sysconfig/network-scripts/ifcfg-br0</span></span><br><span class="line">TYPE=Bridge</span><br><span class="line">BOOTPROTO=static</span><br><span class="line">DEFROUTE=yes</span><br><span class="line">NAME=br0</span><br><span class="line">DEVICE=br0</span><br><span class="line">ONBOOT=yes</span><br><span class="line">IPADDR=192.168.180.136</span><br><span class="line">NETMASK=255.255.255.0</span><br><span class="line">GATEWAY=192.168.180.254</span><br><span class="line">DNS1=114.114.114.114</span><br></pre></td></tr></table></figure>

<p>加入物理网卡 em1 到网桥</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># cat /etc/sysconfig/network-scripts/ifcfg-em1</span></span><br><span class="line">TYPE=Ethernet</span><br><span class="line">BOOTPROTO=static</span><br><span class="line">DEFROUTE=no</span><br><span class="line">NAME=em1</span><br><span class="line">DEVICE=em1</span><br><span class="line">ONBOOT=yes</span><br><span class="line">BRIDGE=br0</span><br></pre></td></tr></table></figure>

<ul>
<li>创建 veth 并持久化</li>
</ul>
<p>创建两对 veth 并加入到网桥，脚本如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># cat /root/config_veth.sh</span></span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">ip link add dev veth0 <span class="built_in">type</span> veth peer name veth1</span><br><span class="line">ip link add dev veth2 <span class="built_in">type</span> veth peer name veth3</span><br><span class="line">ip link <span class="built_in">set</span> dev veth0 up</span><br><span class="line">ip link <span class="built_in">set</span> dev veth1 up</span><br><span class="line">ip link <span class="built_in">set</span> dev veth2 up</span><br><span class="line">ip link <span class="built_in">set</span> dev veth3 up</span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span> 0</span><br></pre></td></tr></table></figure>

<p>执行上述脚本，只是临时创建虚拟网卡，系统重启后又会消失，目前没找到持久化方法，所以只能退而求其次，将上述脚本做成一个服务，在每次系统启动时自动执行以上操作：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># cat /usr/lib/systemd/system/veth.service</span></span><br><span class="line">[Unit]</span><br><span class="line">Description=Create veths</span><br><span class="line">After=network-pre.target dbus.service</span><br><span class="line">Before=network.target network.service</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">ExecStart=/root/config_veth.sh</span><br><span class="line">Restart=on-failure</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure>

<p>创建完上述文件，不要忘了执行 systemctl enable –now veth 启用服务；而对于虚拟网卡设备的配置仍然放在网络配置文件目录下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># cat /etc/sysconfig/network-scripts/ifcfg-veth0</span></span><br><span class="line">DEVICE=veth0</span><br><span class="line">DEVICETYPE=veth</span><br><span class="line">VETH_PEER=veth1</span><br><span class="line">BRIDGE=br0</span><br><span class="line">ONBOOT=yes</span><br><span class="line"></span><br><span class="line"><span class="comment"># cat /etc/sysconfig/network-scripts/ifcfg-veth1</span></span><br><span class="line">DEVICE=veth1</span><br><span class="line">DEVICETYPE=veth</span><br><span class="line">VETH_PEER=veth0</span><br><span class="line">ONBOOT=yes</span><br><span class="line">BOOTPROTO=static</span><br><span class="line">IPADDR=192.168.180.211</span><br><span class="line">MTU=1500</span><br><span class="line">NETMASK=255.255.255.0</span><br><span class="line"></span><br><span class="line"><span class="comment"># cat /etc/sysconfig/network-scripts/ifcfg-veth2</span></span><br><span class="line">DEVICE=veth2</span><br><span class="line">DEVICETYPE=veth</span><br><span class="line">VETH_PEER=veth3</span><br><span class="line">BRIDGE=br0</span><br><span class="line">ONBOOT=yes</span><br><span class="line"></span><br><span class="line"><span class="comment"># cat /etc/sysconfig/network-scripts/ifcfg-veth3</span></span><br><span class="line">DEVICE=veth3</span><br><span class="line">DEVICETYPE=veth</span><br><span class="line">VETH_PEER=veth2</span><br><span class="line">ONBOOT=yes</span><br></pre></td></tr></table></figure>

<p>现在，就算重启系统虚拟网卡也会被自动重建了。</p>
<ul>
<li>自动加载内核模块</li>
</ul>
<p>以下示例加载 ipvs 内核模块:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ cat /etc/modules-load.d/ipvs.conf</span><br><span class="line">ip_vs</span><br><span class="line">ip_vs_lc</span><br><span class="line">ip_vs_wlc</span><br><span class="line">ip_vs_rr</span><br><span class="line">ip_vs_wrr</span><br><span class="line">ip_vs_lblc</span><br><span class="line">ip_vs_lblcr</span><br><span class="line">ip_vs_dh</span><br><span class="line">ip_vs_sh</span><br><span class="line">ip_vs_nq</span><br><span class="line">ip_vs_sed</span><br><span class="line">ip_vs_ftp</span><br><span class="line">nf_conntrack</span><br></pre></td></tr></table></figure>

<p>以下示例启用 ipv4 转发功能：</p>
<ul>
<li>自动设置内核参数</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ cat /etc/sysctl.conf</span><br><span class="line">net.bridge.bridge-nf-call-iptables=1</span><br><span class="line">net.bridge.bridge-nf-call-ip6tables=1</span><br><span class="line">vm.max_map_count=262144</span><br><span class="line">vm.swappiness=0</span><br><span class="line">net.core.somaxconn=32768</span><br><span class="line">net.ipv4.tcp_syncookies=0</span><br><span class="line">net.ipv4.conf.all.rp_filter=1</span><br><span class="line">net.ipv4.ip_forward=1</span><br></pre></td></tr></table></figure>

<ul>
<li>磁盘性能测试</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install epel-release</span><br><span class="line">yum install fio</span><br><span class="line">fio --randrepeat=1 --ioengine=libaio --direct=1 --gtod_reduce=1 --name=<span class="built_in">test</span> --filename=<span class="built_in">test</span> --bs=4k --iodepth=64 --size=4G --readwrite=randrw --rwmixread=75</span><br><span class="line"></span><br><span class="line">//latnecy</span><br><span class="line">yum install epel-release</span><br><span class="line">yum install ioping</span><br><span class="line">ioping -c 10 .</span><br></pre></td></tr></table></figure>

<ul>
<li>安装 MariaDB</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 添加 MariaDB 仓库</span></span><br><span class="line">cat /etc/yum.repos.d/MariaDB.repo</span><br><span class="line">[mariadb]</span><br><span class="line">name = MariaDB</span><br><span class="line">baseurl = http://yum.mariadb.org/10.4/centos7-amd64</span><br><span class="line">gpgkey=https://yum.mariadb.org/RPM-GPG-KEY-MariaDB</span><br><span class="line">gpgcheck=1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行安装</span></span><br><span class="line">yum -y install MariaDB-server MariaDB-client</span><br><span class="line">systemctl <span class="built_in">enable</span> --now mariadb</span><br></pre></td></tr></table></figure>

<ul>
<li>在 grub 引导界面临时编辑内核启动参数</li>
</ul>
<p>首先，选中要编辑的内核项，按 <strong>e</strong> 进入编辑页面，编辑完成后按  <strong>Ctrl + x</strong>  启动系统。下图为编辑内核参数直接进入救援模式。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2019/png/182657/1570848156874-4feb1fc6-38d3-4dc2-a3f9-ff076f94291e.png#height=230&id=KOcUY&margin=%5Bobject%20Object%5D&name=image.png&originHeight=230&originWidth=716&originalType=binary%E2%88%B6=1&size=13999&status=done&style=none&width=716" alt="image.png"></p>
<ul>
<li>在操作系统中编辑内核启动参数并重新生成 grub 引导</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 修改 /etc/default/grub 中的参数设置</span><br><span class="line">[root@umstor03 ~]<span class="comment"># cat /etc/default/grub</span></span><br><span class="line">GRUB_TIMEOUT=5</span><br><span class="line">GRUB_DISTRIBUTOR=<span class="string">"<span class="variable">$(sed 's, release .*$,,g' /etc/system-release)</span>"</span></span><br><span class="line">GRUB_DEFAULT=saved</span><br><span class="line">GRUB_DISABLE_SUBMENU=<span class="literal">true</span></span><br><span class="line">GRUB_TERMINAL_OUTPUT=<span class="string">"console"</span></span><br><span class="line">GRUB_CMDLINE_LINUX=<span class="string">"crashkernel=auto rd.lvm.lv=centos_umstor03/root video=640x480 nomodeset"</span></span><br><span class="line">GRUB_DISABLE_RECOVERY=<span class="string">"true"</span></span><br><span class="line"></span><br><span class="line">// 执行以下命令生成新的 grub 引导文件</span><br><span class="line">grub2-mkconfig -o /boot/grub2/grub.cfg</span><br><span class="line">// 重启系统时参数生效</span><br></pre></td></tr></table></figure>

<ul>
<li>netinstall  centos 1804 可用如下镜像源</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 不要遗漏最后的反斜线</span><br><span class="line">https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;centos-vault&#x2F;7.5.1804&#x2F;os&#x2F;x86_64&#x2F;</span><br></pre></td></tr></table></figure>

<ul>
<li>包版本降级</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum downgrade httpd-2.2.3-22.el5</span><br></pre></td></tr></table></figure>

<ul>
<li>查看包安装信息</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查询已安装的软件包</span></span><br><span class="line">rpm -qa | grep sysstat</span><br><span class="line"><span class="comment"># 查询软件包信息</span></span><br><span class="line">rpm -qi sysstat-10.1.5-19.el7.x86_64</span><br><span class="line"><span class="comment"># 查询软件包含的文件信息</span></span><br><span class="line">rpm -ql sysstat-10.1.5-19.el7.x86_64</span><br><span class="line"><span class="comment"># 通过绝对路径查询文件属于哪个软件包</span></span><br><span class="line">rpm -qf /usr/bin/pidstat</span><br><span class="line"><span class="comment"># 查看安装包中的版本信息</span></span><br><span class="line">rpm -qip foo.rpm</span><br><span class="line"><span class="comment"># 只下载不安装</span></span><br><span class="line">yum install -y --downloadonly --downloaddir=. docker-ce</span><br><span class="line"><span class="comment"># 列出依赖包</span></span><br><span class="line">yum deplist containerd</span><br></pre></td></tr></table></figure>

<ul>
<li>安装指定版本</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum --showduplicate list kubeadm</span><br><span class="line">yum install kubeadm-1.17.4-0</span><br></pre></td></tr></table></figure>

<h4 id="Debian"><a href="#Debian" class="headerlink" title="Debian"></a>Debian</h4><ul>
<li>按关键字检索安装包</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apt update</span><br><span class="line">apt-cache search linux-image</span><br><span class="line">apt-cache madison iptables</span><br></pre></td></tr></table></figure>

<ul>
<li>查看已安装软件包</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dpkg -l | grep linux</span><br></pre></td></tr></table></figure>

<ul>
<li>下载包不安装</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apt-get download docker-ce</span><br></pre></td></tr></table></figure>

<h4 id="Raspberry"><a href="#Raspberry" class="headerlink" title="Raspberry"></a>Raspberry</h4><ul>
<li>清理桌面环境</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get purge desktop-base lightdm lxappearance lxde-common lxde-icon-theme lxinput lxpanel lxpolkit lxrandr lxsession-edit lxshortcut lxtask lxterminal obconf openbox raspberrypi-artwork xarchiver xinit xserver-xorg xserver-xorg-video-fbdev</span><br><span class="line">sudo apt-get autoremove --purge</span><br></pre></td></tr></table></figure>

<h4 id="vim"><a href="#vim" class="headerlink" title="vim"></a>vim</h4><ul>
<li>替换空格为换行</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2019/png/182657/1559296752599-dea00714-5a9b-40e4-9f26-b2aff1323c3c.png#height=25&id=vqX5r&margin=%5Bobject%20Object%5D&name=image.png&originHeight=25&originWidth=160&originalType=binary%E2%88%B6=1&size=2640&status=done&style=none&width=160" alt="image.png"></p>
<ul>
<li>替换 tab 为空格</li>
</ul>
<p><code>:%s/\t/ /g</code></p>
<ul>
<li>复制</li>
</ul>
<p><code>v</code> 进入按字符复制模式， <code>Shift + v</code>进入按行复制模式，<code>Ctrl + Shift + v</code> 进入按块复制模式</p>
<h4 id="Ansible"><a href="#Ansible" class="headerlink" title="Ansible"></a>Ansible</h4><ul>
<li>打印 Ansible 所有的变量</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- name: Print some debug information</span><br><span class="line">  vars:</span><br><span class="line">    msg: |</span><br><span class="line">        Module Variables (&quot;vars&quot;):</span><br><span class="line">        --------------------------------</span><br><span class="line">        &#123;&#123; vars | to_nice_json &#125;&#125;</span><br><span class="line"> </span><br><span class="line">        Environment Variables (&quot;environment&quot;):</span><br><span class="line">        --------------------------------</span><br><span class="line">        &#123;&#123; environment | to_nice_json &#125;&#125;</span><br><span class="line"> </span><br><span class="line">        GROUP NAMES Variables (&quot;group_names&quot;):</span><br><span class="line">        --------------------------------</span><br><span class="line">        &#123;&#123; group_names | to_nice_json &#125;&#125;</span><br><span class="line"> </span><br><span class="line">        GROUPS Variables (&quot;groups&quot;):</span><br><span class="line">        --------------------------------</span><br><span class="line">        &#123;&#123; groups | to_nice_json &#125;&#125;</span><br><span class="line"> </span><br><span class="line">        HOST Variables (&quot;hostvars&quot;):</span><br><span class="line">        --------------------------------</span><br><span class="line">        &#123;&#123; hostvars | to_nice_json &#125;&#125;</span><br><span class="line"> </span><br><span class="line">  debug:</span><br><span class="line">    msg: &quot;&#123;&#123; msg.split(&#39;\n&#39;) &#125;&#125;&quot;      </span><br><span class="line">  tags: debug_info</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- name: Display all variables&#x2F;facts known for a host</span><br><span class="line">  debug:</span><br><span class="line">    var: hostvars[inventory_hostname]</span><br><span class="line">  tags: debug_info</span><br></pre></td></tr></table></figure>

<ul>
<li>执行命令</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ansible -i hosts master -m shell -a &quot;ls &#x2F;root&quot;</span><br></pre></td></tr></table></figure>

<ul>
<li>从远端拉取文件</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ansible -i hosts master -m fetch -a &quot;src&#x3D;&#x2F;root&#x2F;test.json dest&#x3D;&#x2F;root&#x2F;test.json&quot;</span><br></pre></td></tr></table></figure>

<ul>
<li>上传文件</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ansible -i hosts master -m copy -a &quot;src&#x3D;&#x2F;root&#x2F;uk8s-apiresources dest&#x3D;&#x2F;root&#x2F;uk8s-apiresources mode&#x3D;0777&quot;</span><br></pre></td></tr></table></figure>

<h4 id="man"><a href="#man" class="headerlink" title="man"></a>man</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 查看 man 命令使用说明</span><br><span class="line">man man</span><br><span class="line">&#x2F;&#x2F; 查看 exit bash 命令使用说明</span><br><span class="line">man exit</span><br><span class="line">&#x2F;&#x2F; 查看 exit 系统调用使用说明，指定 section 为 2（系统调用手册所在区）</span><br><span class="line">man 2 exit</span><br><span class="line">&#x2F;&#x2F; 默认情况 man 会找到最佳匹配结果并显示，若需要显示所有匹配结果可使用 -a 参数</span><br><span class="line">man -a socket</span><br><span class="line">&#x2F;&#x2F; 如果提示 No entry in section 2 ，可尝试安装 man-pages</span><br><span class="line">yay -S man-pages</span><br></pre></td></tr></table></figure>

<h4 id="tcpdump"><a href="#tcpdump" class="headerlink" title="tcpdump"></a>tcpdump</h4><p>捕获 http 包，更多参考：<a href="https://hackertarget.com/tcpdump-examples/" target="_blank" rel="external nofollow noopener noreferrer">https://hackertarget.com/tcpdump-examples/</a>，<a href="https://danielmiessler.com/study/tcpdump/" target="_blank" rel="external nofollow noopener noreferrer">https://danielmiessler.com/study/tcpdump/</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tcpdump -s 0 -A <span class="string">'tcp[((tcp[12:1] &amp; 0xf0) &gt;&gt; 2):4] = 0x47455420'</span></span><br><span class="line">tcpdump -ni ens5f0 -A -s 10240 <span class="string">'tcp port 8056 and (((ip[2:2] - ((ip[0]&amp;0xf)&lt;&lt;2)) - ((tcp[12]&amp;0xf0)&gt;&gt;2)) != 0)'</span> | egrep --line-buffered <span class="string">"^........(GET |HTTP\/|POST |HEAD )|^[A-Za-z0-9-]+: "</span> | sed -r <span class="string">'s/^........(GET |HTTP\/|POST |HEAD )/\n\1/g'</span></span><br></pre></td></tr></table></figure>

<h4 id="mount-查看目录或分区挂载情况"><a href="#mount-查看目录或分区挂载情况" class="headerlink" title="mount 查看目录或分区挂载情况"></a>mount 查看目录或分区挂载情况</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat /proc/mounts</span><br><span class="line">// or</span><br><span class="line">cat /proc/self/mountinfo</span><br><span class="line">// or</span><br><span class="line">mount -l</span><br><span class="line">// or</span><br><span class="line">findmnt</span><br><span class="line">// or</span><br><span class="line">df -aTh</span><br></pre></td></tr></table></figure>

<h4 id="pgrep-进程检索与杀死"><a href="#pgrep-进程检索与杀死" class="headerlink" title="pgrep 进程检索与杀死"></a>pgrep 进程检索与杀死</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 按名称列出进程 ID</span><br><span class="line">pgrep chrome</span><br><span class="line">// 按名称杀死进程</span><br><span class="line">pkill -9 fish</span><br><span class="line">killall -9 fish</span><br><span class="line">// 杀死指定 ID 的进程</span><br><span class="line"><span class="built_in">kill</span> -9 3049</span><br><span class="line">// 列出进程树</span><br><span class="line">pstree -p</span><br></pre></td></tr></table></figure>

<h4 id="pstree"><a href="#pstree" class="headerlink" title="pstree"></a>pstree</h4><p>进程树中，名称使用大括号包裹的为线程，其它为进程。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ pstree -pg | grep node</span><br><span class="line">             |-node(26200,26200)-+-node(26211,26200)-+-&#123;node&#125;(26212,26200)</span><br><span class="line">             |                   |                   |-&#123;node&#125;(26213,26200)</span><br><span class="line">             |                   |                   |-&#123;node&#125;(26214,26200)</span><br><span class="line">             |                   |                   |-&#123;node&#125;(26215,26200)</span><br><span class="line">             |                   |                   |-&#123;node&#125;(26216,26200)</span><br><span class="line">             |                   |                   |-&#123;node&#125;(26217,26200)</span><br><span class="line">             |                   |                   |-&#123;node&#125;(26218,26200)</span><br><span class="line">             |                   |                   |-&#123;node&#125;(26219,26200)</span><br><span class="line">             |                   |                   |-&#123;node&#125;(26220,26200)</span><br><span class="line">             |                   |                   `-&#123;node&#125;(26221,26200)</span><br><span class="line">             |                   |-&#123;node&#125;(26201,26200)</span><br><span class="line">             |                   |-&#123;node&#125;(26202,26200)</span><br><span class="line">             |                   |-&#123;node&#125;(26203,26200)</span><br><span class="line">             |                   |-&#123;node&#125;(26204,26200)</span><br><span class="line">             |                   |-&#123;node&#125;(26205,26200)</span><br><span class="line">             |                   |-&#123;node&#125;(26206,26200)</span><br><span class="line">             |                   |-&#123;node&#125;(26207,26200)</span><br><span class="line">             |                   |-&#123;node&#125;(26208,26200)</span><br><span class="line">             |                   |-&#123;node&#125;(26209,26200)</span><br><span class="line">             |                   `-&#123;node&#125;(26210,26200)</span><br></pre></td></tr></table></figure>

<p>可通过 top 命令进一步验证：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 列出一个进程中所有线程的信息</span></span><br><span class="line">top -H -p 26200</span><br></pre></td></tr></table></figure>

<p>另一个分辨方式是线程共享地址空间，一个进程中的所有线程具有相同的 VIRT，RES 和 SHR ，如下图：<br><img src="https://cdn.nlark.com/yuque/0/2020/png/182657/1592743812467-47c3df1f-4677-4969-a005-3bff19a08a40.png#height=771&id=ddR0q&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1542&originWidth=2700&originalType=binary%E2%88%B6=1&size=902573&status=done&style=none&width=1350" alt="image.png"></p>
<h4 id="fuser-找到正在使用某个文件的进程"><a href="#fuser-找到正在使用某个文件的进程" class="headerlink" title="fuser 找到正在使用某个文件的进程"></a>fuser 找到正在使用某个文件的进程</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// fuser 是 file user 的缩写</span><br><span class="line">fuser -uv &lt;filename&gt;</span><br><span class="line">fuser -uvm /folder</span><br><span class="line">// 查看哪个程序在占用 8000 端口</span><br><span class="line">fuser -v -n tcp 8000</span><br></pre></td></tr></table></figure>

<h4 id="lsof-列出所有打开的文件"><a href="#lsof-列出所有打开的文件" class="headerlink" title="lsof 列出所有打开的文件"></a>lsof 列出所有打开的文件</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// lsof 是 list open files 的缩写</span><br><span class="line">// -i 代表列出正在打开的 IPV4[6] 文件； -n 表示不进行 DNS 反解； -P 表示不进行端口反解</span><br><span class="line">lsof -i -n -P</span><br><span class="line">// 查看当前目录下打开的文件</span><br><span class="line">lsof .</span><br><span class="line"><span class="comment"># 获取指定进程打开的文件</span></span><br><span class="line">lsof -p pid</span><br></pre></td></tr></table></figure>

<h4 id="strace"><a href="#strace" class="headerlink" title="strace"></a>strace</h4><p>strace 用法参考： <a href="https://www.howtoforge.com/linux-strace-command/" target="_blank" rel="external nofollow noopener noreferrer">https://www.howtoforge.com/linux-strace-command/</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">strace -i ls</span><br></pre></td></tr></table></figure>

<h4 id="getent-获取系统用户信息"><a href="#getent-获取系统用户信息" class="headerlink" title="getent 获取系统用户信息"></a>getent 获取系统用户信息</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">getent passwd</span><br></pre></td></tr></table></figure>

<h4 id="sed"><a href="#sed" class="headerlink" title="sed"></a>sed</h4><ul>
<li>删除所有以 # 开头的行</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sed <span class="string">'/^#/ d'</span></span><br></pre></td></tr></table></figure>

<p>更多使用方法参考：<a href="https://www.folkstalk.com/2013/03/sed-remove-lines-file-unix-examples.html" target="_blank" rel="external nofollow noopener noreferrer">https://www.folkstalk.com/2013/03/sed-remove-lines-file-unix-examples.html</a></p>
<ul>
<li>替换一个匹配字符串的其中一部分</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sed <span class="string">'s/\(前一部分\)要替换的部分\(后一部分\)/\1替换后的字符串\2/'</span></span><br></pre></td></tr></table></figure>

<ul>
<li>使用环境变量</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">eval</span> sed <span class="string">'s/$a/$b/'</span> filename</span><br><span class="line">sed <span class="string">"s/<span class="variable">$a</span>/<span class="variable">$b</span>/"</span> filename</span><br><span class="line">sed <span class="string">'s/'</span><span class="variable">$a</span><span class="string">'/'</span><span class="variable">$b</span><span class="string">'/'</span> filename</span><br><span class="line">sed s/<span class="variable">$a</span>/<span class="variable">$b</span>/ filename</span><br></pre></td></tr></table></figure>

<ul>
<li>替换多个空格为一个</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sed <span class="string">'s/\s\+/ /g'</span></span><br></pre></td></tr></table></figure>

<ul>
<li>打印指定行</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -n 不打印输入内容; -e 多项操作或; p 表示打印</span></span><br><span class="line">sed -n 8p file  <span class="comment">#print line 8</span></span><br><span class="line">sed -n -e 1p -e 8p file   <span class="comment">#print line 1 and line 8</span></span><br><span class="line">sed -n 1,8p file    <span class="comment">#print line 1 to line 8</span></span><br><span class="line">sed -n -e 1,8p -e 20p file   <span class="comment">#print line 1-8 and line 20</span></span><br></pre></td></tr></table></figure>

<ul>
<li>删除指定行</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sed -i <span class="string">'2d'</span> filename                <span class="comment"># 删除第二行</span></span><br><span class="line">sed -i <span class="string">'2,5d'</span> filename					    <span class="comment"># 删除第 2 至第 5 行</span></span><br><span class="line">var1=7</span><br><span class="line">var2=9</span><br><span class="line">sed -i <span class="string">"<span class="variable">$&#123;var1&#125;</span>,<span class="variable">$&#123;var2&#125;</span>d"</span> filename	<span class="comment"># 这里引号必须为双引号，删除第 7 到第 9 行</span></span><br><span class="line">sed -i <span class="string">'$d'</span> filename                <span class="comment"># 删除最后一行</span></span><br><span class="line">sed -i <span class="string">'/xxx/d'</span> filename            <span class="comment"># 删除包含 xxx 的行</span></span><br></pre></td></tr></table></figure>

<ul>
<li>替换一组文件中的字符</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sed -i <span class="string">'s/CURRENT_HOST_ZONE_ID/test/g'</span> /tmp/&#123;test1,test2&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>插入多个空格只需要在第一个空格前加反斜线</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sed -i -e <span class="string">'/network-plugin/i\                --container-runtime=remote \\'</span> /etc/kubernetes/kubelet</span><br></pre></td></tr></table></figure>

<ul>
<li>在指定模式串前面或后面添加内容</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 后面</span></span><br><span class="line">sed -i <span class="string">'/\[Service\]/a EnvironmentFile\=\-\/etc\/kubernetes\/ucloud'</span> /usr/lib/systemd/system/containerd.service</span><br><span class="line"><span class="comment"># 前面只需将 a 换成 i</span></span><br></pre></td></tr></table></figure>

<ul>
<li>对目录下所有文件执行替换</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 最后的 \; 必不可少</span></span><br><span class="line">find ./ -<span class="built_in">type</span> f -<span class="built_in">exec</span> sed -i -e <span class="string">"s/K8S_NODE_NAME/<span class="variable">$K8S_NODE_NAME</span>/g"</span> -e <span class="string">"s/WORK_Dir/<span class="variable">$WORK_Dir</span>/g"</span> -e <span class="string">"s/STATUS_CM/<span class="variable">$STATUS_CM</span>/g"</span> &#123;&#125; \;</span><br></pre></td></tr></table></figure>

<ul>
<li>报错</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">如下报错一般是因为匹配字符串中包含了多余的 &#x2F;</span><br><span class="line">sed: -e expression #1, char 34: unknown option to &#96;s&#39;</span><br></pre></td></tr></table></figure>

<h4 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -i 不区分大小写; -n 显示文件行号; -e 多项查询条件，或操作</span></span><br><span class="line">grep -<span class="keyword">in</span> -e <span class="string">'AddNode'</span> -e <span class="string">'checkpara'</span> -r .</span><br><span class="line">grep -E <span class="string">"10.9.150.110|10.9.68.13"</span></span><br><span class="line"><span class="comment"># -v 匹配不符合指定条件的内容</span></span><br><span class="line">grep -<span class="keyword">in</span> -v <span class="string">'AddUK8SClusterNode'</span> -r .</span><br><span class="line">grep -v -E <span class="string">"10.9.150.110|10.9.68.13"</span></span><br><span class="line"><span class="comment"># -I 忽略检索二进制文件，等同于 --binary-files=without-match</span></span><br><span class="line">grep -I -i <span class="string">'ifup-post'</span> -r .</span><br></pre></td></tr></table></figure>

<h4 id="awk"><a href="#awk" class="headerlink" title="awk"></a>awk</h4><p>修改 fstab ，添加 mount option，参见： <a href="https://stackoverflow.com/a/9119317" target="_blank" rel="external nofollow noopener noreferrer">https://stackoverflow.com/a/9119317</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 为 /home 挂载添加 acl 配置</span></span><br><span class="line">awk <span class="string">'$2~"^/home$"&#123;$4="acl,"$4&#125;1'</span> OFS=<span class="string">"\t"</span> /etc/fstab</span><br></pre></td></tr></table></figure>

<p>打印指定列，参考：<a href="https://www.cnblogs.com/liuyihua1992/p/9689308.html" target="_blank" rel="external nofollow noopener noreferrer">https://www.cnblogs.com/liuyihua1992/p/9689308.html</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># $0 表示所有列; -F 指定解析时使用的分隔符; $(NF) 表示最后一列，$(NF-1) 表示倒数第二列，以此类推</span></span><br><span class="line">awk <span class="string">'&#123;print $0&#125;'</span> file    <span class="comment">#打印所有列</span></span><br><span class="line">awk <span class="string">'&#123;print $1&#125;'</span> file  <span class="comment">#打印第一列</span></span><br><span class="line">awk <span class="string">'&#123;print $1, $3&#125;'</span> file   <span class="comment">#打印第一和第三列</span></span><br><span class="line">cat file | awk <span class="string">'&#123;print $3, $1&#125;'</span>   <span class="comment">#打印第三列和第一列，注意先后顺序。</span></span><br><span class="line">cat file | awk <span class="string">'&#123;print $3, $NF&#125;'</span> <span class="comment">#打印第三列和最后一列</span></span><br><span class="line">awk -F <span class="string">":"</span> <span class="string">'&#123;print $1, $3&#125;'</span>  <span class="comment">#以“:”为分隔符分割列，然后打印第一列和第三列</span></span><br><span class="line"><span class="comment"># 一种打印N列之后的所有列的方法：把前N列都赋值为空，然后打印所有列</span></span><br><span class="line">awk <span class="string">'&#123;for(i=1;i&lt;=N;i++)&#123;$i=""&#125;; print $0&#125;'</span> file</span><br><span class="line"><span class="comment"># 打印时带上分隔符</span></span><br><span class="line">awk -v OFS=<span class="string">','</span> <span class="string">'&#123;print $1,$2&#125;'</span></span><br><span class="line"><span class="comment"># 处理多个返回值</span></span><br><span class="line">crictl images | grep -v IMAGE | awk <span class="string">'&#123;print $1,$2&#125;'</span> | <span class="keyword">while</span> <span class="built_in">read</span> var1 var2; <span class="keyword">do</span> <span class="built_in">echo</span> <span class="variable">$var1</span><span class="string">":"</span><span class="variable">$var2</span>; <span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<h4 id="tee"><a href="#tee" class="headerlink" title="tee"></a>tee</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 同时输出到标准输出和追加至文件</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"test"</span>| tee -a outfile</span><br></pre></td></tr></table></figure>

<h4 id="split"><a href="#split" class="headerlink" title="split"></a>split</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 按行数分割文件</span></span><br><span class="line">split -l 300 log.txt newfile</span><br><span class="line"><span class="comment"># 按大小分割文件</span></span><br><span class="line">split -b 500m log.txt newfile</span><br></pre></td></tr></table></figure>

<h4 id="date"><a href="#date" class="headerlink" title="date"></a>date</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 获取当前时间时间戳，ms 为单位</span></span><br><span class="line"><span class="built_in">echo</span> `expr \`date +%s%N\` / 1000000`</span><br></pre></td></tr></table></figure>

<h4 id="od"><a href="#od" class="headerlink" title="od"></a>od</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 按指定进制读取文件的二进制数据 -d 十进制  -o 八进制  -x 十六进制 -t 可用以指定显示时每项的字节宽度</span><br><span class="line">od -t u1 prometheus-new.yaml</span><br></pre></td></tr></table></figure>

<h4 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 按指定列排序</span></span><br><span class="line">sort -k 2 file.txt</span><br></pre></td></tr></table></figure>

<h4 id="crond"><a href="#crond" class="headerlink" title="crond"></a>crond</h4><p>/etc/cron.d 目录下添加文件设置定时任务时必须要在文件结尾加换行才能生效。</p>
<h4 id="iproute2"><a href="#iproute2" class="headerlink" title="iproute2"></a>iproute2</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 获取指定目标地址匹配的路由</span><br><span class="line">ip route get 106.75.220.2</span><br></pre></td></tr></table></figure>

<h4 id="nc"><a href="#nc" class="headerlink" title="nc"></a>nc</h4><p>检查端口是否开启</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> ! nc -z &lt;ip&gt; &lt;port&gt;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    sleep 1</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<h4 id="正则匹配"><a href="#正则匹配" class="headerlink" title="正则匹配"></a>正则匹配</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 匹配除空格以外的字符</span></span><br><span class="line">\S+ 或 [^\s]+</span><br></pre></td></tr></table></figure>

<h4 id="生成-Linux-用户密码的哈希值"><a href="#生成-Linux-用户密码的哈希值" class="headerlink" title="生成 Linux 用户密码的哈希值"></a>生成 Linux 用户密码的哈希值</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python -c &quot;import crypt, getpass, pwd; print(crypt.crypt(&#39;password&#39;, &#39;\$6\$saltsalt\$&#39;))&quot;</span><br><span class="line">&#x2F;&#x2F; 或者使用 go</span><br><span class="line">package main</span><br><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;github.com&#x2F;tredoe&#x2F;osutil&#x2F;user&#x2F;crypt&#x2F;sha512_crypt&quot;</span><br><span class="line">)</span><br><span class="line">func main() &#123;</span><br><span class="line">    c :&#x3D; sha512_crypt.New()</span><br><span class="line">    hash, err :&#x3D; c.Generate([]byte(&quot;rasmuslerdorf&quot;), []byte(&quot;$6$usesomesillystringforsalt&quot;))</span><br><span class="line">    if err !&#x3D; nil &#123;</span><br><span class="line">        panic(err)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(hash)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="允许使用-root-用户-ssh-登录"><a href="#允许使用-root-用户-ssh-登录" class="headerlink" title="允许使用 root 用户 ssh 登录"></a>允许使用 root 用户 ssh 登录</h4><p>先删除 <code>/root/.ssh/authorized_keys</code> 中的多余限制信息，之后在 <code>/etc/ssh/sshd_config</code> 中添加 <code>PermitRootLogin yes</code> 后重启 sshd 服务。</p>
<h4 id="解决”rtnetlink-answers-file-exists”"><a href="#解决”rtnetlink-answers-file-exists”" class="headerlink" title="解决”rtnetlink answers file exists”"></a>解决”rtnetlink answers file exists”</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ip a flush dev eth0</span><br></pre></td></tr></table></figure>

<h4 id="查看登录记录"><a href="#查看登录记录" class="headerlink" title="查看登录记录"></a>查看登录记录</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看当前登录用户</span></span><br><span class="line">who</span><br><span class="line"><span class="comment"># 查看最近登录记录</span></span><br><span class="line">last -F</span><br><span class="line"><span class="comment"># 查看最近90天所有用户的最后登录时间</span></span><br><span class="line">lastlog --time 90</span><br></pre></td></tr></table></figure>

<h4 id="rsync-同步时需要-root-权限"><a href="#rsync-同步时需要-root-权限" class="headerlink" title="rsync 同步时需要 root 权限"></a>rsync 同步时需要 root 权限</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rsync -aru -e <span class="string">"ssh"</span> --rsync-path=<span class="string">"sudo rsync"</span> 172.16.110.215:~/ ~/  --progress --exclude=.cache</span><br></pre></td></tr></table></figure>

<h4 id="rclone-将-http-file-server-的内容同步到本地"><a href="#rclone-将-http-file-server-的内容同步到本地" class="headerlink" title="rclone  将 http file server 的内容同步到本地"></a>rclone  将 http file server 的内容同步到本地</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rclone sync --http-url http://my.file.server :http:centos/<span class="built_in">test</span> /repo/<span class="built_in">test</span> --progress</span><br></pre></td></tr></table></figure>

<h4 id="expr-比较字符串大小"><a href="#expr-比较字符串大小" class="headerlink" title="expr 比较字符串大小"></a>expr 比较字符串大小</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">str3=<span class="string">'v1.13'</span></span><br><span class="line">str2=<span class="string">'v1.14'</span></span><br><span class="line"><span class="keyword">if</span> [ $(expr <span class="variable">$&#123;str3&#125;</span> \&lt;= <span class="variable">$&#123;str2&#125;</span>) -eq 1 ]; <span class="keyword">then</span>    <span class="built_in">echo</span> <span class="string">"[<span class="variable">$&#123;str3&#125;</span>] &lt;= [<span class="variable">$&#123;str2&#125;</span>]"</span>; <span class="keyword">else</span>    <span class="built_in">echo</span> <span class="string">"[<span class="variable">$&#123;str3&#125;</span>] &gt; [<span class="variable">$&#123;str2&#125;</span>]"</span>; <span class="keyword">fi</span></span><br></pre></td></tr></table></figure>

<h4 id="tr-移除所有空格"><a href="#tr-移除所有空格" class="headerlink" title="tr 移除所有空格"></a>tr 移除所有空格</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 获取 kubernetes 版本</span><br><span class="line">kubectl version --short | tail -1 | cut -d<span class="string">':'</span> -f2 | tr -d <span class="string">'[:space:]'</span></span><br></pre></td></tr></table></figure>

<h4 id="vegeta-对-HTTP-服务进行性能测试"><a href="#vegeta-对-HTTP-服务进行性能测试" class="headerlink" title="vegeta 对 HTTP 服务进行性能测试"></a>vegeta 对 HTTP 服务进行性能测试</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">echo <span class="string">"GET http://localhost:8080/cephcsi"</span> | vegeta attack -rate=<span class="number">20000</span> -duration=<span class="number">60</span>s &gt; result.bin</span><br><span class="line">vegeta report result.bin</span><br></pre></td></tr></table></figure>

<p>更多内容参考：<a href="https://www.scaleway.com/en/docs/vegeta-load-testing/" target="_blank" rel="external nofollow noopener noreferrer">https://www.scaleway.com/en/docs/vegeta-load-testing/</a></p>
<h4 id="zip-压缩文件不带顶级目录"><a href="#zip-压缩文件不带顶级目录" class="headerlink" title="zip 压缩文件不带顶级目录"></a>zip 压缩文件不带顶级目录</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pushd &#x2F;Users&#x2F;me&#x2F;development&#x2F;something</span><br><span class="line">cd path&#x2F;to&#x2F;parent&#x2F;dir&#x2F;;</span><br><span class="line">zip -r complete&#x2F;path&#x2F;to&#x2F;name.zip .&#x2F;*</span><br><span class="line">popd</span><br></pre></td></tr></table></figure>

<h4 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h4><ul>
<li>执行单行命令</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql --user&#x3D;&quot;$user&quot; --password&#x3D;&quot;$password&quot; --database&#x3D;&quot;$database&quot; --execute&#x3D;&quot;DROP DATABASE $user; CREATE DATABASE $database;&quot;</span><br></pre></td></tr></table></figure>

<ul>
<li>导出数据库</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 导出</span><br><span class="line">mysqldump -P 3306 -u root --password&#x3D;password -h 172.30.100.43  keycloak &gt; keycloak-3.sql</span><br><span class="line">&#x2F;&#x2F; 导入</span><br><span class="line">mysql -P 3306 -u root --password&#x3D;password -h 172.30.100.43  keycloak &lt; keycloak.sql</span><br></pre></td></tr></table></figure>

<h4 id="ss-列出所有处于监听状态的-socket"><a href="#ss-列出所有处于监听状态的-socket" class="headerlink" title="ss 列出所有处于监听状态的 socket"></a>ss 列出所有处于监听状态的 socket</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">ss -lntu</span><br><span class="line">-l = only services which are listening on some port</span><br><span class="line">-n = show port number, don<span class="string">'t try to resolve the service name</span></span><br><span class="line"><span class="string">-t = tcp ports</span></span><br><span class="line"><span class="string">-u = udp ports</span></span><br><span class="line"><span class="string">-p = name of the program</span></span><br></pre></td></tr></table></figure>

<h4 id="查看网段中已使用-IP"><a href="#查看网段中已使用-IP" class="headerlink" title="查看网段中已使用 IP"></a>查看网段中已使用 IP</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">arp-scan -I eth0 192.168.180.0/24</span><br><span class="line">//或</span><br><span class="line">nmap -sP -PR 192.168.180.*</span><br></pre></td></tr></table></figure>

<h4 id="Wireshark-过滤表达式"><a href="#Wireshark-过滤表达式" class="headerlink" title="Wireshark 过滤表达式"></a>Wireshark 过滤表达式</h4><p>参考：<a href="https://www.wireshark.org/docs/wsug_html_chunked/ChWorkBuildDisplayFilterSection.html" target="_blank" rel="external nofollow noopener noreferrer">https://www.wireshark.org/docs/wsug_html_chunked/ChWorkBuildDisplayFilterSection.html</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ip.scr&#x3D;&#x3D;10.0.0.5 or ip.dst&#x3D;&#x3D;192.1.1.1</span><br></pre></td></tr></table></figure>

<h4 id="alpine-修改镜像源"><a href="#alpine-修改镜像源" class="headerlink" title="alpine 修改镜像源"></a>alpine 修改镜像源</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sed -i &#39;s&#x2F;dl-cdn.alpinelinux.org&#x2F;mirrors.aliyun.com&#x2F;g&#39; &#x2F;etc&#x2F;apk&#x2F;repositories</span><br></pre></td></tr></table></figure>

<h4 id="tinc-配置-VPN"><a href="#tinc-配置-VPN" class="headerlink" title="tinc 配置 VPN"></a>tinc 配置 VPN</h4><p>首先要有一个有公网 IP 的服务器作为交换节点。该节点进行如下配置：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install -y tinc</span><br><span class="line">mkdir -p /etc/tinc/vpn/hosts</span><br><span class="line">vim /etc/tinc/vpn/tinc.conf</span><br><span class="line">  Name = vpn</span><br><span class="line">  Interface = tinc</span><br><span class="line">  Mode = switch</span><br><span class="line">tincd -n vpn -K</span><br><span class="line"> // 启动服务</span><br><span class="line">tincd -n vpn -D</span><br><span class="line">ip link <span class="built_in">set</span> tinc up</span><br><span class="line">ip a add 192.168.120.1/24 dev tinc</span><br></pre></td></tr></table></figure>

<p>客户端配置：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir -p /etc/tinc/`hostname`/hosts</span><br><span class="line">vim /etc/tinc/`hostname`/tinc.conf</span><br><span class="line">  Name = hostname</span><br><span class="line">  Interface = tinc</span><br><span class="line">  Mode = switch</span><br><span class="line">  ConnectTo = vpn</span><br><span class="line">tincd -n `hostname` -K</span><br><span class="line">scp vpn-public-ip:/etc/tinc/vpn/hosts/vpn /etc/tinc/`hostname`/hosts</span><br><span class="line">vim /etc/tinc/`hostname`/hosts/vpn <span class="comment"># 第一行加上 Address = vpn-public-ip</span></span><br><span class="line">scp /etc/tinc/vpn/hosts/`hostname` vpn-public-ip:/etc/tinc/vpn/hosts/</span><br><span class="line"> // 启动服务</span><br><span class="line">tincd -n `hostname` -D</span><br><span class="line">ip link <span class="built_in">set</span> tinc up</span><br><span class="line">ip a add 192.168.120.2/24 dev tinc</span><br><span class="line">ip r add 10.10.0.0/16 dev tinc</span><br></pre></td></tr></table></figure>

<h4 id="删文件报错-Structure-needs-cleaning"><a href="#删文件报错-Structure-needs-cleaning" class="headerlink" title="删文件报错  Structure needs cleaning"></a>删文件报错  Structure needs cleaning</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo rm -fR hourly.5/</span><br><span class="line"></span><br><span class="line">rm: cannot remove <span class="string">'hourly.5/snapshot_root/mnt/Vancouver/temp/temp - old/temp - 09 (Dec 07, 2014 - Sep 02, 2015)/a_OLD-gmail/victoria.a.stuart@gmail.com/[Gmail]/LINUX/rsync, rsnapshot; Other backups/19.bak'</span>: Structure needs cleaning</span><br></pre></td></tr></table></figure>

<p>原因可能是文件系统损坏，xfs 文件系统可以使用 Live 系统登陆后使用以下命令尝试修复：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">umount /dev/sda1</span><br><span class="line">xfs_repair /dev/sda1</span><br></pre></td></tr></table></figure>

<h4 id="coredumpctl"><a href="#coredumpctl" class="headerlink" title="coredumpctl"></a>coredumpctl</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">coredumpctl list</span><br><span class="line">coredumpctl dump pid</span><br><span class="line">coredumpctl dump chrome</span><br><span class="line">coredumpctl -o core.dump dump chrome</span><br><span class="line">coredumpctl gdb pid</span><br></pre></td></tr></table></figure>

<h4 id="gdb-生成-coredump"><a href="#gdb-生成-coredump" class="headerlink" title="gdb 生成 coredump"></a>gdb 生成 coredump</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ gdb --pid=26426</span><br><span class="line">(gdb) gcore</span><br><span class="line">Saved corefile core.26426</span><br><span class="line">(gdb) detach</span><br><span class="line">// 或者</span><br><span class="line">gcore $(pidof processname)</span><br></pre></td></tr></table></figure>

<h4 id="终端设置全局代理，对-ssh-和-http-均有效"><a href="#终端设置全局代理，对-ssh-和-http-均有效" class="headerlink" title="终端设置全局代理，对 ssh 和 http 均有效"></a>终端设置全局代理，对 ssh 和 http 均有效</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> ALL_PROXY=socks5://127.0.0.1:1080</span><br></pre></td></tr></table></figure>

<h4 id="fpm-制作-deb-rpm-安装包"><a href="#fpm-制作-deb-rpm-安装包" class="headerlink" title="fpm 制作 deb/rpm 安装包"></a>fpm 制作 deb/rpm 安装包</h4><p>参考：<a href="https://askubuntu.com/a/1121733" target="_blank" rel="external nofollow noopener noreferrer">https://askubuntu.com/a/1121733</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fpm -f -s dir -t deb -n iptables -v 1.6.2 -C &#96;pwd&#96; --prefix &#x2F; --deb-no-default-config-files usr</span><br></pre></td></tr></table></figure>

<h4 id="生成随机值"><a href="#生成随机值" class="headerlink" title="生成随机值"></a>生成随机值</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(awk -v n&#x3D;1 -v seed&#x3D;&quot;$RANDOM&quot; &#39;BEGIN &#123; srand(seed); for (i&#x3D;0; i&lt;n; ++i) printf(&quot;%.4f\n&quot;, rand()*10) &#125;&#39;)</span><br></pre></td></tr></table></figure>

<h4 id="NetworkManager-nmcli"><a href="#NetworkManager-nmcli" class="headerlink" title="NetworkManager (nmcli)"></a>NetworkManager (nmcli)</h4><ul>
<li>设置静态地址</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nmcli connection</span><br><span class="line">nmcli con mod eth1 ipv4.addresses 192.168.5.1/24</span><br><span class="line">nmcli con mod eth1 ipv4.method manual</span><br><span class="line">nmcli con up eth1</span><br></pre></td></tr></table></figure>

<h4 id="base64-编码"><a href="#base64-编码" class="headerlink" title="base64 编码"></a>base64 编码</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># echo 不打印换行</span><br><span class="line">echo -n &#39;test&#39; | base64</span><br><span class="line"># base64 输出不打印换行</span><br><span class="line">echo -n &quot;apfjxkic-omyuobwd339805ak:60a06cd2ddfad610b9490d359d605407&quot; | base64 -w 0</span><br></pre></td></tr></table></figure>

<h4 id="wget"><a href="#wget" class="headerlink" title="wget"></a>wget</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 下载文件到指定目录</span></span><br><span class="line"><span class="string">wget</span> <span class="string">-P</span> <span class="string">/tmp</span> <span class="string">http://cluster-api.cn-bj.ufileos.com/cluster-api-uk8s-init.tar.gz</span></span><br><span class="line"><span class="comment"># 下载指定目录下所有文件到本地当前目录：-nd 不创建目录；-r 递归下载；-l1 只下载当前目录下的文件；–no-parent 不下载父目录中的文件</span></span><br><span class="line"><span class="comment"># -nd 递归下载时不创建一层一层的目录，把所有的文件下载到当前目录</span></span><br><span class="line"><span class="comment"># -np 递归下载时不搜索上层目录，如wget -c -r www.xianren.org/pub/path/</span></span><br><span class="line"><span class="string">wget</span> <span class="string">-nd</span> <span class="string">-r</span> <span class="string">-l1</span> <span class="string">--no-parent</span> <span class="string">--reject</span> <span class="string">"index.html*"</span> <span class="string">http://demo.abc.com/path/to/file/</span></span><br></pre></td></tr></table></figure>

<h4 id="tar-解压到指定目录"><a href="#tar-解压到指定目录" class="headerlink" title="tar 解压到指定目录"></a>tar 解压到指定目录</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">tar</span> <span class="string">-zxvf</span> <span class="string">/tmp/cluster-api-uk8s-init.tar.gz</span> <span class="string">-C</span> <span class="string">/usr/local/bin</span></span><br></pre></td></tr></table></figure>

<h4 id="判断-Linux-发行版"><a href="#判断-Linux-发行版" class="headerlink" title="判断 Linux 发行版"></a>判断 Linux 发行版</h4><p>通过 <code>/etc/os-release</code></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">ssh</span> <span class="string">$ip</span> <span class="string">"sed -n 's/^ID= *//p' /etc/os-release | xargs"</span></span><br><span class="line"><span class="string">if</span> <span class="string">[</span> <span class="string">"$result"</span> <span class="string">=</span> <span class="string">"centos"</span> <span class="string">];</span> <span class="string">then</span></span><br><span class="line">  <span class="string">echo</span> <span class="string">"=========current linux distribution is centos========"</span></span><br><span class="line">  <span class="comment"># do something</span></span><br><span class="line"><span class="string">elif</span> <span class="string">[</span> <span class="string">"$result"</span> <span class="string">=</span> <span class="string">"debian"</span> <span class="string">];</span> <span class="string">then</span></span><br><span class="line">  <span class="string">echo</span> <span class="string">"=========current linux distribution is debian========"</span></span><br><span class="line">  <span class="string">ssh</span> <span class="string">$ip</span> <span class="string">"cat /etc/debian_version"</span></span><br><span class="line">  <span class="string">if</span> <span class="string">[</span> <span class="string">"$result"</span> <span class="string">=</span> <span class="string">"8.2"</span> <span class="string">];</span> <span class="string">then</span></span><br><span class="line">    <span class="comment"># do something</span></span><br><span class="line">  <span class="string">fi</span></span><br><span class="line"><span class="string">else</span></span><br><span class="line">  <span class="string">echo</span> <span class="string">"=========current linux distribution not support========"</span></span><br><span class="line">  <span class="string">exit</span> <span class="number">1</span></span><br><span class="line"><span class="string">fi</span></span><br></pre></td></tr></table></figure>

<p>通过文件，参考：<a href="https://stackoverflow.com/a/3792848" target="_blank" rel="external nofollow noopener noreferrer">https://stackoverflow.com/a/3792848</a></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">if</span> <span class="string">[</span> <span class="string">-f</span> <span class="string">/etc/centos-release</span> <span class="string">];</span> <span class="string">then</span></span><br><span class="line">  <span class="comment"># do something</span></span><br><span class="line"><span class="string">elif</span> <span class="string">[</span> <span class="string">-f</span> <span class="string">/etc/debian_version</span> <span class="string">];</span> <span class="string">then</span></span><br><span class="line">  <span class="string">VERSION=$(cat</span> <span class="string">/etc/debian_version)</span></span><br><span class="line">  <span class="string">if</span> <span class="string">[</span> <span class="string">"$&#123;VERSION&#125;"</span> <span class="string">=</span> <span class="string">"8.2"</span> <span class="string">];</span> <span class="string">then</span></span><br><span class="line">    <span class="string">echo</span> <span class="string">"debian 8.2"</span></span><br><span class="line">  <span class="string">fi</span></span><br><span class="line"><span class="string">fi</span></span><br></pre></td></tr></table></figure>

<p>使用 lsb_release</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># centos 需要安装支持软件</span></span><br><span class="line"><span class="string">yum</span> <span class="string">install</span> <span class="string">redhat-lsb-core</span></span><br><span class="line"><span class="comment"># debian 可以直接使用</span></span><br><span class="line"><span class="string">lsb_release</span> <span class="string">-is</span></span><br></pre></td></tr></table></figure>

<h4 id="sshpass-跳过-hostkey-检查"><a href="#sshpass-跳过-hostkey-检查" class="headerlink" title="sshpass 跳过 hostkey 检查"></a>sshpass 跳过 hostkey 检查</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sshpass -p password scp -o StrictHostKeyChecking=no -r <span class="built_in">test</span>/ root@10.8.53.47:/tmp/<span class="built_in">test</span></span><br></pre></td></tr></table></figure>

<h4 id="查看-NVIDIA-GPU-工作情况"><a href="#查看-NVIDIA-GPU-工作情况" class="headerlink" title="查看 NVIDIA GPU 工作情况"></a>查看 NVIDIA GPU 工作情况</h4><p>下载 P40 驱动：<a href="http://us.download.nvidia.com/tesla/440.64.00/NVIDIA-Linux-x86_64-440.64.00.run" target="_blank" rel="external nofollow noopener noreferrer">http://us.download.nvidia.com/tesla/440.64.00/NVIDIA-Linux-x86_64-440.64.00.run</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lspci | grep -i nvidia</span><br><span class="line">nvidia-smi</span><br></pre></td></tr></table></figure>

<h4 id="fio"><a href="#fio" class="headerlink" title="fio"></a>fio</h4><p>可指定 fio 测试输出结果格式为 json ，然后使用 jq 按需解析，参考：<a href="https://boke.wsfnk.com/archives/293.html" target="_blank" rel="external nofollow noopener noreferrer">https://boke.wsfnk.com/archives/293.html</a></p>
<h4 id="jq"><a href="#jq" class="headerlink" title="jq"></a>jq</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 统计 curl 结果中 Info 数组的长度</span><br><span class="line">curl <span class="string">'http://…'</span> | jq <span class="string">'.Infos'</span> | jq length</span><br></pre></td></tr></table></figure>

<h4 id="rar-解压"><a href="#rar-解压" class="headerlink" title="rar 解压"></a>rar 解压</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt install unrar</span><br><span class="line">sudo dnf install unrar</span><br><span class="line">yay unrar</span><br><span class="line">unrar e tecmint.rar</span><br><span class="line">unrar e tecmint.rar /home/</span><br></pre></td></tr></table></figure>

<h4 id="Python-amp-pip"><a href="#Python-amp-pip" class="headerlink" title="Python &amp; pip"></a>Python &amp; pip</h4><p>出现安装错误：<br><code>Cannot uninstall &#39;ipython&#39;. It is a distutils installed project and thus we cannot accurately determine which files belong to it which would lead to only a partial uninstall.</code><br>可尝试通过以下命令解决：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install --ignore-installed -U ipython</span><br></pre></td></tr></table></figure>

<h4 id="head-tail-dd-截取文件中部分内容"><a href="#head-tail-dd-截取文件中部分内容" class="headerlink" title="head/tail/dd 截取文件中部分内容"></a>head/tail/dd 截取文件中部分内容</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">head -n 100 file   <span class="comment"># 前 100 行</span></span><br><span class="line">head -c 100 file   <span class="comment"># 前 100 字符</span></span><br><span class="line">tail -n 100 file   <span class="comment"># 后 100 行</span></span><br><span class="line">tail -c 100 file   <span class="comment"># 后 100 字符</span></span><br><span class="line">head -n 10 /var/<span class="built_in">log</span>/pacman.log | tail -n 1                    <span class="comment"># 第 10 行</span></span><br><span class="line">dd count=5 bs=1 <span class="keyword">if</span>=/var/<span class="built_in">log</span>/pacman.log 2&gt;/dev/null            <span class="comment"># 前 5 个字符</span></span><br><span class="line">head -n 10 /var/<span class="built_in">log</span>/pacman.log | tail -n 1 | cut -c 10-15     <span class="comment"># 第 10 行的第 10 到 15 个字符</span></span><br></pre></td></tr></table></figure>

<h4 id="快速生成大文件用于占位空间"><a href="#快速生成大文件用于占位空间" class="headerlink" title="快速生成大文件用于占位空间"></a>快速生成大文件用于占位空间</h4><p>参见：<a href="https://askubuntu.com/questions/506910/creating-a-large-size-file-in-less-time" target="_blank" rel="external nofollow noopener noreferrer">https://askubuntu.com/questions/506910/creating-a-large-size-file-in-less-time</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 仅对支持该操作的文件系统有效，仅为一次系统调用，无 IO 读写，预分配空间，速度快，使用 du 查看确实占用了 5G 空间</span></span><br><span class="line">fallocate -l 5G example_file</span><br><span class="line"><span class="comment"># 仅对支持该操作的文件系统有效，仅在文件末尾写入一个字节，使用 du 查看未见占用 10G 空间，有效性存疑</span></span><br><span class="line">dd <span class="keyword">if</span>=/dev/zero of=zeros.img count=1 bs=1 seek=$((10 * 1024 * 1024 * 1024 - 1))</span><br><span class="line"><span class="comment"># 常规的做法</span></span><br><span class="line">dd <span class="keyword">if</span>=/dev/urandom of=test1 bs=1M count=10240   <span class="comment"># 用随机数填充文件</span></span><br><span class="line">dd <span class="keyword">if</span>=/dev/zero of=zero.img count=1024 bs=10M <span class="comment"># 用 0 填充文件</span></span><br></pre></td></tr></table></figure>

<h4 id="dev-null、-dev-zero、-dev-random-和-dev-urandom"><a href="#dev-null、-dev-zero、-dev-random-和-dev-urandom" class="headerlink" title="/dev/null、/dev/zero、/dev/random 和/dev/urandom"></a>/dev/null、/dev/zero、/dev/random 和/dev/urandom</h4><p>参考：<a href="https://blog.csdn.net/sinat_26058371/article/details/86754683" target="_blank" rel="external nofollow noopener noreferrer">https://blog.csdn.net/sinat_26058371/article/details/86754683</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># /dev/null “空”设备，又称黑洞。任何输入到这个“设备”的数据都将被直接丢弃。最常用的用法是把不需要的输出重定向到这个文件。</span></span><br><span class="line">run.sh 1&gt;/dev/null 2&gt;&amp;1  <span class="comment">#将标准输出和错误输出重定向到/dev/null，运行这个脚本不会输出任何信息到终端</span></span><br><span class="line"><span class="comment"># /dev/zero “零”设备，可以无限的提供空字符（0x00，ASCII代码NUL）。常用来生成一个特定大小的文件。</span></span><br><span class="line">dd <span class="keyword">if</span>=/dev/zero of=./output.txt bs=1024 count=1 <span class="comment">#产生一个1k大小的文件output.txt</span></span><br><span class="line"><span class="comment"># /dev/random 和 /dev/urandom 是随机数设备，提供不间断的随机字节流。</span></span><br><span class="line"><span class="comment"># /dev/random 产生随机数据依赖系统中断，当系统中断不足时，/dev/random 设备会“挂起”，因而产生数据速度较慢，但随机性好；</span></span><br><span class="line"><span class="comment"># /dev/urandom 不依赖系统中断，数据产生速度快，但随机性较低。</span></span><br><span class="line">str=$(cat /dev/urandom | od -x | tr -d <span class="string">' '</span> | head -n 1) <span class="comment"># 利用 /dev/urandom 设备产生一个 128 位的随机字符串</span></span><br></pre></td></tr></table></figure>

<h4 id="iptables"><a href="#iptables" class="headerlink" title="iptables"></a>iptables</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 备份 filter 表</span><br><span class="line">iptables-save -t filter &gt; iptables.bak</span><br><span class="line">// 从备份恢复</span><br><span class="line">iptables-restor &lt; iptables.bak</span><br></pre></td></tr></table></figure>

<h4 id="findmnt"><a href="#findmnt" class="headerlink" title="findmnt"></a>findmnt</h4><p>参见： <a href="https://www.tecmint.com/find-mounted-file-systems-in-linux/" target="_blank" rel="external nofollow noopener noreferrer">https://www.tecmint.com/find-mounted-file-systems-in-linux/</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 列出所有 ext4 文件系统</span></span><br><span class="line">findmnt -t ext4</span><br><span class="line"><span class="comment"># 查找 /data 挂载点</span></span><br><span class="line">findmnt -T /data</span><br><span class="line"><span class="comment"># 在 /etc/fstab 中查找挂载点</span></span><br><span class="line">findmnt -s</span><br><span class="line"><span class="comment"># 隐藏打印的信息列头</span></span><br><span class="line">findmnt -n</span><br><span class="line"><span class="comment"># 指定输出的列</span></span><br><span class="line">findmnt -o FSTYPE</span><br></pre></td></tr></table></figure>

<h4 id="systemctl"><a href="#systemctl" class="headerlink" title="systemctl"></a>systemctl</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 判断服务是否存活</span></span><br><span class="line">systemctl is-active --quiet service</span><br><span class="line"><span class="comment"># 获取服务文件地址</span></span><br><span class="line">systemctl show -p FragmentPath containerd | awk -F <span class="string">"="</span> <span class="string">'&#123;print $2&#125;'</span></span><br></pre></td></tr></table></figure>

<h4 id="conntrack"><a href="#conntrack" class="headerlink" title="conntrack"></a>conntrack</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 显示时间戳</span></span><br><span class="line">conntrack -E -o timestamp</span><br></pre></td></tr></table></figure>

<h4 id="ssh"><a href="#ssh" class="headerlink" title="ssh"></a>ssh</h4><ul>
<li>ssh debug 带时间戳</li>
</ul>
<p>参考：<a href="https://www.depesz.com/2010/12/13/a-tale-of-slow-ssh-connections/" target="_blank" rel="external nofollow noopener noreferrer">https://www.depesz.com/2010/12/13/a-tale-of-slow-ssh-connections/</a>, <a href="https://blog.csdn.net/sinat_38723234/article/details/103216464" target="_blank" rel="external nofollow noopener noreferrer">https://blog.csdn.net/sinat_38723234/article/details/103216464</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">time ssh -v 192.168.255.128 id 2&gt;&amp;1  | perl -pe <span class="string">'use Time::HiRes qw( time ); $_ = sprintf("%.6f %s", time(), $_)'</span></span><br></pre></td></tr></table></figure>

<ul>
<li>ssh 保持连接存活</li>
</ul>
<p>可以在客户端设置  ServerAliveInterval 或者在服务端设置  ServerAliveInterval，其效果是一样的，即在一段时间没有收到对方的数据后，发送探活消息，确保连接存活。分别配合 ServerAliveCountMax（默认为 3 ） 和 ClientAliveCountMax （默认为 3 ）使用，超过三次探活包没有得到回应则关闭会话。与  TCPKeepAlive 的一个不同是，ssh 的探活消息是加密传输的。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"ClientAliveInterval 60"</span> | sudo tee -a /etc/ssh/sshd_config</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"	ServerAliveInterval 30"</span> &gt;&gt; /etc/ssh/ssh_config</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"ServerAliveInterval 60"</span> &gt;&gt; ~/.ssh/config</span><br></pre></td></tr></table></figure>

<ul>
<li>ssh 取消 StrictHostKeyChecking 并从环境变量读取 ssh key 到本地</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"Host *"</span> &gt; /etc/ssh/ssh_config</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"  StrictHostKeyChecking=no"</span> &gt;&gt; /etc/ssh/ssh_config</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"  UserKnownHostsFile=/dev/null"</span> &gt;&gt; /etc/ssh/ssh_config</span><br><span class="line">mkdir -p ~/.ssh</span><br><span class="line">chmod 700 ~/.ssh</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"<span class="variable">$SSH_PRIVATE_KEY</span>"</span> | tr -d <span class="string">'\r'</span> &gt; ~/.ssh/id_rsa</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"<span class="variable">$SSH_PUBLIC_KEY</span>"</span> &gt; ~/.ssh/id_rsa.pub</span><br><span class="line">chmod 600 ~/.ssh/id_rsa</span><br><span class="line">chmod 644 ~/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure>

<h4 id="pssh"><a href="#pssh" class="headerlink" title="pssh"></a>pssh</h4><p>轻量的 ssh 批量操作工具</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 安装</span><br><span class="line">yum install pssh</span><br><span class="line">#pssh 远程批量执行命令</span><br><span class="line">pssh -h ip.txt -P &quot;uptime&quot;</span><br><span class="line">#-h  后面接主机ip文件,文件数据格式[user@]host[:port]</span><br><span class="line">#-P  显示输出内容</span><br><span class="line">#如果没办法密钥认证.可以采用下面方法,但不是很安全</span><br><span class="line">sshpass -p 123456 pssh -A -h ip.txt -i &quot;uptime&quot;</span><br></pre></td></tr></table></figure>

<h4 id="按行读取文件并处理"><a href="#按行读取文件并处理" class="headerlink" title="按行读取文件并处理"></a>按行读取文件并处理</h4><p>参考：<a href="https://stackoverflow.com/questions/10929453/read-a-file-line-by-line-assigning-the-value-to-a-variable" target="_blank" rel="external nofollow noopener noreferrer">https://stackoverflow.com/questions/10929453/read-a-file-line-by-line-assigning-the-value-to-a-variable</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># IFS= (or IFS='') 不去除行头和行尾的空格，一般可不加</span></span><br><span class="line"><span class="comment"># -r 不进行反斜线转义，原样输出</span></span><br><span class="line"><span class="keyword">while</span> IFS= <span class="built_in">read</span> -r line; <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"Text read from file: <span class="variable">$line</span>"</span></span><br><span class="line"><span class="keyword">done</span> &lt; my_filename.txt</span><br></pre></td></tr></table></figure>

<h4 id="浮点数运算"><a href="#浮点数运算" class="headerlink" title="浮点数运算"></a>浮点数运算</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">'scale=2; 3/2'</span> | bc -l</span><br></pre></td></tr></table></figure>

<h4 id="部署-STUN-服务"><a href="#部署-STUN-服务" class="headerlink" title="部署 STUN 服务"></a>部署 STUN 服务</h4><p>参考：<a href="https://github.com/coturn/coturn" target="_blank" rel="external nofollow noopener noreferrer">https://github.com/coturn/coturn</a>，<a href="http://www.stunprotocol.org/" target="_blank" rel="external nofollow noopener noreferrer">http://www.stunprotocol.org/</a>，<a href="https://webrtc.github.io/samples/src/content/peerconnection/trickle-ice/" target="_blank" rel="external nofollow noopener noreferrer">https://webrtc.github.io/samples/src/content/peerconnection/trickle-ice/</a></p>
<h4 id="安装-ruby"><a href="#安装-ruby" class="headerlink" title="安装 ruby"></a>安装 ruby</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gpg2 --keyserver hkp://pool.sks-keyservers.net --recv-keys 409B6B1796C275462A1703113804BB82D39DC0E3 7D2BAF1CF37B13E2069D6956105BD0E739499BDB</span><br><span class="line">curl -sSL get.rvm.io | bash -s stable</span><br><span class="line"><span class="built_in">source</span> /etc/profile.d/rvm.sh</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"ruby_url=https://cache.ruby-china.com/pub/ruby"</span> &gt; /usr/<span class="built_in">local</span>/rvm/user/db</span><br><span class="line">rvm list known</span><br><span class="line">rvm install 2.3.1</span><br><span class="line">rvm use 2.3.1 --default</span><br><span class="line">gem sources --add https://mirrors.tuna.tsinghua.edu.cn/rubygems/ --remove https://rubygems.org/</span><br><span class="line">gem sources -l</span><br><span class="line">gem install --no-document fpm</span><br></pre></td></tr></table></figure>

<h4 id="find"><a href="#find" class="headerlink" title="find"></a>find</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 按扩展名排除文件</span></span><br><span class="line">find . -not -name <span class="string">"*.exe"</span> -not -name <span class="string">"*.dll"</span> -not -<span class="built_in">type</span> d</span><br></pre></td></tr></table></figure>

<h4 id="find-print0-与-xargs-0"><a href="#find-print0-与-xargs-0" class="headerlink" title="find -print0 与  xargs -0"></a>find -print0 与  xargs -0</h4><p>一般会有下列用法：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">find . -name <span class="string">"*.txt"</span> | xargs rm</span><br></pre></td></tr></table></figure>

<p>上述用法在大多数时候是有效的，而当文件名称中包含空格或换行符时则会出错，这是因为 xargs 默认将空格或换行符作为切分字符串的标识。一种有效的改进方法是使用 NULL 作为分隔符，如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">find . -name <span class="string">"*.txt"</span> -print0 | xargs -0 rm</span><br></pre></td></tr></table></figure>

<p>其中，-print0 用于告诉 find 在每个查询到的结果后加一个 NULL 字符而不是默认的加一个换行符，-0 告诉 xargs 使用 NULL 来分切字符串而不是默认的空格或换行符。参考：<a href="https://www.cnblogs.com/liuyihua1992/p/9689314.html" target="_blank" rel="external nofollow noopener noreferrer">https://www.cnblogs.com/liuyihua1992/p/9689314.html</a><br>另一种简单可行的方法是：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">find . -name <span class="string">"*.txt"</span> | xargs -i rm &#123;&#125;</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">find . -name <span class="string">"*.txt"</span> | xargs -I &#123;&#125; rm &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>其中 -i 默认使用 {} 作为替换符号， -I 可以自行指定其他的替换符号，其能够生效的原因是该选项使得 xargs 以换行符为结尾的每一项直接去替换 {} ，而不再使用换行符或空格去解析字符内容。</p>
<h4 id="nginx-指定子进程运行时使用的用户"><a href="#nginx-指定子进程运行时使用的用户" class="headerlink" title="nginx 指定子进程运行时使用的用户"></a>nginx 指定子进程运行时使用的用户</h4><p>更改 <code>/etc/nginx/nginx.conf</code> 配置<code>user nginx;</code>。参考：<a href="https://stackoverflow.com/a/42329561" target="_blank" rel="external nofollow noopener noreferrer">https://stackoverflow.com/a/42329561</a></p>
<h4 id="禁用-selinux"><a href="#禁用-selinux" class="headerlink" title="禁用 selinux"></a>禁用 selinux</h4><p>参考：<a href="https://linuxconfig.org/how-to-disable-enable-selinux-on-ubuntu-20-04-focal-fossa-linux" target="_blank" rel="external nofollow noopener noreferrer">https://linuxconfig.org/how-to-disable-enable-selinux-on-ubuntu-20-04-focal-fossa-linux</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">'SELINUX=disabled'</span> &gt; /etc/selinux/config</span><br></pre></td></tr></table></figure>

<h4 id="检查最近是否出现-OOM"><a href="#检查最近是否出现-OOM" class="headerlink" title="检查最近是否出现 OOM"></a>检查最近是否出现 OOM</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dmesg | egrep -i &quot;killed process&quot;</span><br><span class="line">#CentOS</span><br><span class="line">grep -i &quot;out of memory&quot; &#x2F;var&#x2F;log&#x2F;messages</span><br><span class="line">#Debian &#x2F; Ubuntu</span><br><span class="line">grep -i &quot;out of memory&quot; &#x2F;var&#x2F;log&#x2F;kern.log</span><br></pre></td></tr></table></figure>

<h4 id="判断-cloud-init-结束"><a href="#判断-cloud-init-结束" class="headerlink" title="判断 cloud-init 结束"></a>判断 cloud-init 结束</h4><p>cloud-init 执行结束后会创建文件 <code>/var/lib/cloud/instance/boot-finished</code></p>
<h4 id="手动添加-ARP-表项"><a href="#手动添加-ARP-表项" class="headerlink" title="手动添加 ARP 表项"></a>手动添加 ARP 表项</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 该命令仅临时有效，重启消失</span><br><span class="line">arp -s 10.0.0.2 00:0c:29:c0:94:bf</span><br><span class="line"># 可将相关命令放入开机启动脚本每次开机自动添加</span><br><span class="line">arp -i eth0 -s 192.168.0.4 00:50:cc:44:55:55</span><br></pre></td></tr></table></figure>

<h4 id="添加开机启动脚本"><a href="#添加开机启动脚本" class="headerlink" title="添加开机启动脚本"></a>添加开机启动脚本</h4><p>常规的做法是在 <code>/etc/rc.local</code> 中添加相关脚本，但现在并不推荐这样做，centos <code>rc.local</code> 中有这样一段提示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> cat &#x2F;etc&#x2F;rc.local</span><br><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line"># THIS FILE IS ADDED FOR COMPATIBILITY PURPOSES</span><br><span class="line">#</span><br><span class="line"># It is highly advisable to create own systemd services or udev rules</span><br><span class="line"># to run scripts during boot instead of using this file.</span><br><span class="line">#</span><br><span class="line"># In contrast to previous versions due to parallel execution during boot</span><br><span class="line"># this script will NOT be run after all other services.</span><br><span class="line">#</span><br><span class="line"># Please note that you must run &#39;chmod +x &#x2F;etc&#x2F;rc.d&#x2F;rc.local&#39; to ensure</span><br><span class="line"># that this script will be executed during boot.</span><br><span class="line"></span><br><span class="line">touch &#x2F;var&#x2F;lock&#x2F;subsys&#x2F;local</span><br></pre></td></tr></table></figure>

<p>对于网络相关的配置，也可以创建 <code>/sbin/ifup-pre-local</code> 或者 <code>/sbin/ifup-local</code> 脚本，它们分别在 <code>ifup</code> 和 <code>ifup-post</code> 中被调用。<br>所以更好的一种方式是创建由 systemd 管理的一次性服务，服务中可设置 Type=oneshot 或 Type=simple 。</p>
<h4 id="systemd"><a href="#systemd" class="headerlink" title="systemd"></a>systemd</h4><p>参考：<a href="http://www.jinbuguo.com/systemd/systemd.service.html" target="_blank" rel="external nofollow noopener noreferrer">http://www.jinbuguo.com/systemd/systemd.service.html</a>，<a href="http://www.jinbuguo.com/" target="_blank" rel="external nofollow noopener noreferrer">http://www.jinbuguo.com/</a>，<a href="https://www.ruanyifeng.com/blog/2016/03/systemd-tutorial-part-two.html" target="_blank" rel="external nofollow noopener noreferrer">https://www.ruanyifeng.com/blog/2016/03/systemd-tutorial-part-two.html</a>，<a href="https://stackoverflow.com/a/39050387" target="_blank" rel="external nofollow noopener noreferrer">https://stackoverflow.com/a/39050387</a></p>
<h4 id="systemd-modules-load-service"><a href="#systemd-modules-load-service" class="headerlink" title="systemd-modules-load.service"></a>systemd-modules-load.service</h4><p>systemd-modules-load.service 在系统启动时自动读取 /etc/modules-load.d 等目录下的配置文件加载指定的内核模块。</p>
<h4 id="拉高-CPU-使用率"><a href="#拉高-CPU-使用率" class="headerlink" title="拉高 CPU 使用率"></a>拉高 CPU 使用率</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat /dev/zero&gt;/dev/null</span><br></pre></td></tr></table></figure>

<h4 id="配置-6to4-隧道"><a href="#配置-6to4-隧道" class="headerlink" title="配置 6to4 隧道"></a>配置 6to4 隧道</h4><p>参考：<a href="https://www.deepspace6.net/docs/iproute2tunnel-en.html" target="_blank" rel="external nofollow noopener noreferrer">https://www.deepspace6.net/docs/iproute2tunnel-en.html</a>，<a href="https://www.tldp.org/HOWTO/Linux+IPv6-HOWTO/ch09s04.html" target="_blank" rel="external nofollow noopener noreferrer">https://www.tldp.org/HOWTO/Linux+IPv6-HOWTO/ch09s04.html</a></p>
<h4 id="常见工具的-IPV6-模式"><a href="#常见工具的-IPV6-模式" class="headerlink" title="常见工具的 IPV6 模式"></a>常见工具的 IPV6 模式</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">scp -6 hyperkube root@[2003:da8:2004:1000:0a09:6ec4:0006:ed49]:/tmp</span><br><span class="line">ping6 2003:da8:2004:1000:0a2a:1e5e:0122:d75b</span><br><span class="line">curl -g <span class="string">'http://[2003:ac12:fed0:1:0:ff:aad:aef]:8080'</span></span><br></pre></td></tr></table></figure>

<h4 id="linux-排故常用命令"><a href="#linux-排故常用命令" class="headerlink" title="linux 排故常用命令"></a>linux 排故常用命令</h4><p><a href="https://arthurchiao.art/blog/linux-trouble-shooting-cheat-sheet/" target="_blank" rel="external nofollow noopener noreferrer">https://arthurchiao.art/blog/linux-trouble-shooting-cheat-sheet/</a></p>
<h4 id="journalctl"><a href="#journalctl" class="headerlink" title="journalctl"></a>journalctl</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 获取指定时间段的日志</span></span><br><span class="line">journalctl -u kube-apiserver.service --since <span class="string">"2020-07-27 17:10:00"</span> --until <span class="string">"2020-07-27 17:15:00"</span></span><br><span class="line"><span class="comment"># 获取磁盘用量</span></span><br><span class="line">journalctl --disk-usage</span><br><span class="line"><span class="comment"># 仅保留两天内日志</span></span><br><span class="line">journalctl --vacuum-time=2d</span><br><span class="line"><span class="comment"># 仅保留 500M 日志</span></span><br><span class="line">journalctl --vacuum-size=500M</span><br><span class="line"><span class="comment"># 两者可结合使用，表明两个条件需同时满足</span></span><br><span class="line">journalctl --vacuum-time=2d --vacuum-size=500M</span><br></pre></td></tr></table></figure>

<h4 id="手动断开一个-TCP-连接"><a href="#手动断开一个-TCP-连接" class="headerlink" title="手动断开一个 TCP 连接"></a>手动断开一个 TCP 连接</h4><p>在 server 端手动断开一个连接，可以有以下几种方式：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ss -K dst 192.168.1.214 dport = 49029</span><br><span class="line">iptables -A FORWARD -p TCP  -s 192.168.1.146 --sport 36522 -j REJECT --reject-with tcp-reset</span><br><span class="line">conntrack -D -p tcp --src 192.168.1.146 --sport 33486</span><br></pre></td></tr></table></figure>

<h4 id="NR-与-nr"><a href="#NR-与-nr" class="headerlink" title="NR 与 _nr"></a>NR 与 _nr</h4><p>在 awk 语义环境中， NR 和 NF 是内置的变量，NR 表示当前记录的行号，NF 则表示当前记录可以按照指定分隔符划分成几个部分。在 Linux 环境中，经常看到 nr 结尾的统计数据，此时 nr 代表的是 number 的缩写。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 打印一行内容并随后打印当前行的 NF 值</span><br><span class="line">awk &#39;&#123;print ; print NF&#125;&#39; infile</span><br><span class="line"># 打印每行的 NR 值</span><br><span class="line">awk &#39;&#123;print NR&#125;&#39; infile</span><br><span class="line"># sar 打印系统使用的 file 和 inode 数量</span><br><span class="line">sar -v 1 2</span><br><span class="line">09:38:17 AM dentunusd   file-nr  inode-nr    pty-nr</span><br><span class="line">09:38:18 AM     33059      2048     32077         1</span><br><span class="line">09:38:19 AM     33059      2048     32077         1</span><br><span class="line">Average:        33059      2048     32077         1</span><br></pre></td></tr></table></figure>

<h4 id="Linux-系统启动过程"><a href="#Linux-系统启动过程" class="headerlink" title="Linux 系统启动过程"></a>Linux 系统启动过程</h4><p>上电 -&gt; 从固件读取 BIOS -&gt; 从磁盘固定位置（或者网络、CD 等）读取 BootLoader（通常是 GRUB2）-&gt; BootLoader 加载内核和初始根文件系统 -&gt; 加载文件系统 -&gt; 初始化工作完成后启动 1 号用户进程 init。参考：<a href="https://segmentfault.com/a/1190000006872609" target="_blank" rel="external nofollow noopener noreferrer">简述 Linux 的启动过程</a></p>
<h4 id="如何找到环境变量是在哪里被设置的"><a href="#如何找到环境变量是在哪里被设置的" class="headerlink" title="如何找到环境变量是在哪里被设置的"></a>如何找到环境变量是在哪里被设置的</h4><p>参考：<a href="https://unix.stackexchange.com/a/154971" target="_blank" rel="external nofollow noopener noreferrer">https://unix.stackexchange.com/a/154971</a>，<a href="https://unix.stackexchange.com/a/249922" target="_blank" rel="external nofollow noopener noreferrer">https://unix.stackexchange.com/a/249922</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">PS4=<span class="string">'+$BASH_SOURCE&gt; '</span> BASH_XTRACEFD=7 bash -xl 7&gt;&amp;2</span><br></pre></td></tr></table></figure>

<h4 id="查看自己的公网出口-IP"><a href="#查看自己的公网出口-IP" class="headerlink" title="查看自己的公网出口 IP"></a>查看自己的公网出口 IP</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -s ifcfg.cn/<span class="built_in">echo</span> | python -m json.tool</span><br></pre></td></tr></table></figure>

<h4 id="实用工具"><a href="#实用工具" class="headerlink" title="实用工具"></a>实用工具</h4><ul>
<li>一个在线渲染代码为图片的网站：<a href="https://carbon.now.sh/" target="_blank" rel="external nofollow noopener noreferrer">https://carbon.now.sh/</a> ， 可以通过设置修改边框等信息。</li>
<li>pandoc 可以借助第三方引擎实现各种文档格式之间的转换：<a href="https://pandoc.org/" target="_blank" rel="external nofollow noopener noreferrer">https://pandoc.org/</a>。</li>
<li>MOBI 转 PDF 的在线网站：<a href="https://ebook2pdf.com/" target="_blank" rel="external nofollow noopener noreferrer">https://ebook2pdf.com/</a></li>
<li>Github dispatch 使用示例：<a href="https://alejandroandr.eu/posts/manual-trigger-github-workflows/" target="_blank" rel="external nofollow noopener noreferrer">https://alejandroandr.eu/posts/manual-trigger-github-workflows/</a></li>
<li>deepin-wine 安装微软雅黑字体 : <a href="https://github.com/wszqkzqk/deepin-wine-ubuntu/issues/136#issuecomment-514585722" target="_blank" rel="external nofollow noopener noreferrer">https://github.com/wszqkzqk/deepin-wine-ubuntu/issues/136#issuecomment-514585722</a></li>
<li>配置 Linux 为一个简单的路由器：<a href="https://www.ascinc.com/blog/linux/how-to-build-a-simple-router-with-ubuntu-server-18-04-1-lts-bionic-beaver/" target="_blank" rel="external nofollow noopener noreferrer">https://www.ascinc.com/blog/linux/how-to-build-a-simple-router-with-ubuntu-server-18-04-1-lts-bionic-beaver/</a></li>
<li>安装 cuda 参考：<a href="https://linuxconfig.org/how-to-install-nvidia-cuda-toolkit-on-centos-7-linux" target="_blank" rel="external nofollow noopener noreferrer">https://linuxconfig.org/how-to-install-nvidia-cuda-toolkit-on-centos-7-linux</a></li>
<li>下载 vscode 使用国内镜像: <a href="https://zhuanlan.zhihu.com/p/112215618" target="_blank" rel="external nofollow noopener noreferrer">https://zhuanlan.zhihu.com/p/112215618</a></li>
<li>查看系统的各种统计信息：<a href="https://www.cnblogs.com/lovesKey/p/10900501.html" target="_blank" rel="external nofollow noopener noreferrer">https://www.cnblogs.com/lovesKey/p/10900501.html</a></li>
</ul>
<h4 id="疑难杂症"><a href="#疑难杂症" class="headerlink" title="疑难杂症"></a>疑难杂症</h4><ul>
<li>ssh 设置 <code>UseDNS no</code> 后仍然登录慢，依然有可能是 DNS 解析的问题，更改 /etc/resolv.conf 中配置的 nameserver 之后好了，更多可能参考：<a href="https://jrs-s.net/2017/07/01/slow-ssh-logins/#:~:text=It' target=" _blank" rel="external nofollow noopener noreferrer" s%20usually%20dns.,restart%20ssh%2c%20etc%20as%20appropriate." target="_blank">https://jrs-s.net/2017/07/01/slow-ssh-logins/#:~:text=It’s%20usually%20DNS.,restart%20ssh%2C%20etc%20as%20appropriate.</a>。</li>
<li>centos yum 命令执行到 <code>Loaded plugins: fastestmirror</code> 时很慢，也可能是 DNS 解析的问题。</li>
<li>在 while 循环中使用 ssh 命令时，发现 while 循环提前结束了，其原因是 ssh 命令会从标准输入中读取内容，因此后续脚本被 ssh 读入了，所以无法继续执行，解决办法就是重定向 ssh 命令的标准输入为 /dev/null，参考：<a href="https://stackoverflow.com/a/9393147" target="_blank" rel="external nofollow noopener noreferrer">https://stackoverflow.com/a/9393147</a>。</li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag> 云计算</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 故障排查方法与工具</title>
    <url>/post/c2292029.html</url>
    <content><![CDATA[<h3 id="负载模拟与分析"><a href="#负载模拟与分析" class="headerlink" title="负载模拟与分析"></a>负载模拟与分析</h3><h4 id="CPU-密集型"><a href="#CPU-密集型" class="headerlink" title="CPU 密集型"></a>CPU 密集型</h4><ol>
<li><code>stress-ng --cpu 2 --timeout 600 模拟 CPU</code> 负载；</li>
<li>通过 <code>uptime</code> 可以观察到，系统平均负载很高，通过 <code>mpstat -P ALL 1 5</code> 或 <code>top</code> 观察到 2 个 CPU 使用率很高，平均负载也很高，而 iowait 为 0 ，说明进程是 CPU 密集型的，一般是由进程使用 CPU 密集导致系统平均负载变高;</li>
<li>通过 <code>pidstat -u 1</code> 查看是哪个进程导致 CPU 使用率较高。</li>
</ol><a id="more"></a>
<h4 id="I-O-密集型"><a href="#I-O-密集型" class="headerlink" title="I/O 密集型"></a>I/O 密集型</h4><ol>
<li><code>stress-ng -i 4 --hdd 1 --timeout 600</code> 模拟磁盘 IO；</li>
<li>可以通过 <code>uptime</code> 观察到，系统平均负载很高，通过 <code>mpstat -P ALL 1 5</code> 或 <code>top</code> 观察到 CPU 使用率很低，iowait 很高，一直在等待 IO 处理，说明是 IO 密集型的场景；</li>
<li>通过 <code>pidstat -d 1</code> 可以查看哪个进程磁盘读写速度高，也可以通过 <code>iotop</code> 查看 IO 高的进程。</li>
</ol>
<h4 id="大量进程争抢-CPU"><a href="#大量进程争抢-CPU" class="headerlink" title="大量进程争抢 CPU"></a>大量进程争抢 CPU</h4><ol>
<li><code>stress-ng -c 16 --timeout 600</code> 模拟大量进程；</li>
<li>通过 <code>uptime</code> 观察到系统平均负载很高，通过通过 <code>mpstat -P ALL 1 5</code> 或 <code>top</code> 观察到 CPU 使用率也很高，iowait 为 0，说明此进程是 CPU 密集型的，或者在进行 CPU 的争用；</li>
<li>通过 <code>pidstat -u 1</code> 观察到 wait 指标很高，则说明进程间存在 CPU 争用的情况，可以判断系统中存在大量的进程在等待使用 CPU；大量的进程，超出了 CPU 的计算能力，导致的系统的平均负载很高;</li>
<li>通过 <code>pidstat -w 1</code> 也可以看到存在大量的非自愿进程上下文切换。</li>
</ol>
<h4 id="单进程多线程争抢-CPU"><a href="#单进程多线程争抢-CPU" class="headerlink" title="单进程多线程争抢 CPU"></a>单进程多线程争抢 CPU</h4><ol>
<li><code>sysbench --threads=10 --time=300 threads run</code> 模拟多线程；</li>
<li>观察步骤类似大量进程争抢，不同的是 <code>pidstat -w 1 10</code> 看到 sysbench 无上下文切换，因为默认显示的是进程间的上下文切换；而使用 <code>pidstat -w -t</code> 可以看到存在大量 sysbench 相关的非自愿上下文切换。</li>
</ol>
<h4 id="网络包注入"><a href="#网络包注入" class="headerlink" title="网络包注入"></a>网络包注入</h4><p>使用 Python 包 scapy 可以模拟网络包注入，参考：<a href="https://www.cnblogs.com/darkpig/p/7629854.html" target="_blank" rel="external nofollow noopener noreferrer">用 Python 模拟 TCP 三次握手连接及发送数据</a>，<a href="https://www.cnblogs.com/lsdb/p/10496171.html" target="_blank" rel="external nofollow noopener noreferrer">Python3 + Scapy 安装使用教程</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> scapy.all <span class="keyword">import</span> *</span><br><span class="line">ans = sr1(IP(src=<span class="string">'107.55.66.38'</span>,dst=<span class="string">'106.75.175.95'</span>)/TCP(dport=<span class="number">80</span>, sport=<span class="number">56789</span>,seq=<span class="number">123</span>, flags=<span class="string">'S'</span>), verbose=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>

<h3 id="常用工具"><a href="#常用工具" class="headerlink" title="常用工具"></a>常用工具</h3><h4 id="vmstat"><a href="#vmstat" class="headerlink" title="vmstat"></a>vmstat</h4><p>vmstat 可查看系统 CPU 、内存、IO 的基本使用状态信息。vmstat 展示的是整体 CPU 的使用情况，而不是单个 CPU。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root@10-9-23-85 ~# vmstat 1 10</span><br><span class="line">procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----</span><br><span class="line"> r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st</span><br><span class="line"> 1  0      0 262052      0 1843248    0    0     1    55    0    7  3  2 94  0  0</span><br><span class="line"> 0  0      0 262232      0 1843260    0    0     0    57 1656 2956  3  2 95  0  0</span><br><span class="line"> 0  0      0 261744      0 1843308    0    0     0    56 2038 3790  3  2 95  0  0</span><br><span class="line"> 0  0      0 261712      0 1843312    0    0     0   146 2043 3590  2  2 96  1  0</span><br><span class="line"> 0  0      0 261776      0 1843312    0    0     0    50 1771 3263  2  2 96  1  0</span><br><span class="line"> 0  0      0 261680      0 1843316    0    0     0    48 1461 2896  1  1 98  0  0</span><br><span class="line"> 0  0      0 260360      0 1843276    0    0    16    36 1971 3538  3  2 95  0  0</span><br><span class="line"> 0  0      0 260168      0 1843256    0    0     0   129 1542 2906  2  2 96  1  0</span><br><span class="line"> 1  0      0 259572      0 1843256    0    0     0    82 2417 4036  6  3 91  1  0</span><br><span class="line"> 0  0      0 259604      0 1843260    0    0     0   128 1707 3228  2  2 96  1  0</span><br></pre></td></tr></table></figure>

<p>其中各项数据的含义如下：</p>
<table>
<thead>
<tr>
<th align="center">procs</th>
<th align="center">r</th>
<th>等待运行的进程数。如果等待运行的进程数越多，意味着 CPU 非常繁忙。另外，如果该参数长期大于 cpu 核心数 3 倍，说明 CPU 资源可能存在较大的瓶颈。</th>
</tr>
</thead>
<tbody><tr>
<td align="center"></td>
<td align="center">b</td>
<td>处在不可中断睡眠状态的进程数。一般是等待 IO 的进程。</td>
</tr>
<tr>
<td align="center">memory</td>
<td align="center">swpd</td>
<td>已使用的虚拟内存大小。如果虚拟内存使用较多，可能系统的物理内存比较吃紧，需要采取合适的方式来减少物理内存的使用。swapd 不为 0 ，并不意味物理内存吃紧，如果 swapd 没变化，si、so 的值长期为 0 ，也表明系统没有问题。</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">free</td>
<td>空闲的物理内存的大小。</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">buff</td>
<td>用来做 buffer（缓存，主要用于块设备缓存）的内存数，单位：KB。</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">cache</td>
<td>用作缓存的内存大小，如果 cache 的值大的时候，说明 cache 处的文件数多，如果频繁访问到的文件都能被 cache 处，那么磁盘的读 IO bi 会非常小，单位：KB 。</td>
</tr>
<tr>
<td align="center">swap</td>
<td align="center">si</td>
<td>从磁盘写入到 swap 虚拟内存的交换页数量，单位：KB/秒。如果这个值大于 0，表示物理内存不够用或者内存泄露了。</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">so</td>
<td>从 swap 虚拟内读出的数据。即从 swap 中的数据写入到磁盘的交换页数量，单位：KB/秒，如果这个值大于 0 ，表示物理内存不够用或者内存泄露了。</td>
</tr>
</tbody></table>
<p>内存够用的时候，这两个值都是 0，如果这两个值长期大于 0 时，系统性能会受到影响，磁盘 IO 和 CPU 资源都会被消耗。<br>当看到空闲内存（free）很少的或接近于 0 时，就认为内存不够用了，这个是不正确的。不能光看这一点，还要结合 si 和 so 。如果 free 很少，但是 si 和 so 是 0，那么不用担心，系统性能这时不会受到影响的。 |<br>| io | bi | 每秒从块设备接收到的块数，单位：块/秒 也就是读块设备。bi 通常是读磁盘的数据。 |<br>| | bo | 每秒发送到块设备的块数，单位：块/秒 也就是写块设备。bo 通常是写磁盘的数据。 |<br>| system | in | 每秒的中断数，包括时钟中断。 |<br>| | cs | 每秒的环境（上下文）切换次数。比如我们调用系统函数，就要进行上下文切换，而过多的上下文切换会浪费较多的 CPU 资源，这个数值应该越小越好。 |<br>| cpu | us | 用户态使用 CPU 的时间（非内核进程占用时间）（单位为百分比）。 us 的值比较高时，说明用户进程消耗的 CPU 时间多。 |<br>| | sy | 系统使用的 CPU 时间（单位为百分比）。sy 的值高时，说明系统内核消耗的 CPU 资源多，这并不是良性表现，我们应该检查原因。 |<br>| | id | 空闲的 CPU 的时间（百分比）。 |<br>| | wa | 等待 IO 的 CPU 时间。这个指标意味着 CPU 在等待硬盘读写操作的时间，用百分比表示。wa 越大则机器 IO 性能就越差。说明 IO 等待比较严重，这可能由于对磁盘大量随机访问造成，也有可能磁盘出现瓶颈（块操作）。 |<br>| | st | 虚拟机占用 cpu 时间的百分比。如果 CentOS 系统上运行了 KVM 虚拟机监视器，而 KVM 上运行了几个虚拟机，那么这个值将显示这个几个正在运行的虚拟机从物理机中窃取 CPU 运行时间的百分比。 |</p>
<h4 id="stress-ng"><a href="#stress-ng" class="headerlink" title="stress-ng"></a>stress-ng</h4><p>stress-ng 是 stress 的增强版本，兼容 stress 命令的同时提供了更丰富的压力模拟场景。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install stress-ng</span><br><span class="line"># 两个 worker 计算圆周率测试，top 命令可以看到 cpu 时间均被消耗在用户空间</span><br><span class="line">stress-ng -c 2 --cpu-method pi</span><br><span class="line"># 两个 worker 遍历所有压力测试算法</span><br><span class="line">stress-ng -c 2 --cpu-method all</span><br><span class="line"># 一个 worker 产生 socket 相关的操作，top 命令可以看到 cpu 时间主要被内核以及软中断占用</span><br><span class="line"># --taskset 选项将任务绑定到指定 cpu 处理</span><br><span class="line">stress-ng --sock 1 --taskset 1</span><br><span class="line"># 不断执行 sync 操作</span><br><span class="line">stress-ng --io 2 --timeout 60s --metrics-brief</span><br><span class="line"># 执行 mmap 申请内存并写入内容</span><br><span class="line">stress-ng --vm 2 --vm-bytes 1G --timeout 60s</span><br></pre></td></tr></table></figure>

<h4 id="mpstat"><a href="#mpstat" class="headerlink" title="mpstat"></a>mpstat</h4><p>mpstat 是 Multiprocessor Statistics 的缩写，可用于获取 CPU 实时统计指标信息，其数据来源于 /proc/stat 文件。mpstat 区别于 vmstat 的一点是：可以查看多核 CPU 中每个计算核心的统计数据。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 显示整体状态</span><br><span class="line">mpstat</span><br><span class="line"># 显示指定 CPU 状态</span><br><span class="line">mpstat -P 0</span><br><span class="line"># 每隔 2 秒显示所有 CPU 的使用信息，共打印 5 次</span><br><span class="line">mpstat -P ALL 2 5</span><br><span class="line"># 显示所有 CPU 上的各种中断每秒总次数</span><br><span class="line">mpstat -I SUM -P ALL</span><br><span class="line"># 显示指定 CPU 的中断总次数</span><br><span class="line">mpstat -I SUM -P 0</span><br><span class="line"># 查看各个 CPU 上各种中断次数</span><br><span class="line">mpstat -I CPU</span><br><span class="line"># 查看各个 CPU 上各种软中断次数</span><br><span class="line">mpstat -I SCPU</span><br></pre></td></tr></table></figure>

<h4 id="iostat"><a href="#iostat" class="headerlink" title="iostat"></a>iostat</h4><p>参考：<a href="https://www.linuxtechi.com/monitor-linux-systems-performance-iostat-command/" target="_blank" rel="external nofollow noopener noreferrer">How to Monitor Linux Systems Performance with iostat command</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">iostat -d -x -m 1 6</span><br></pre></td></tr></table></figure>

<h4 id="sar"><a href="#sar" class="headerlink" title="sar"></a>sar</h4><p>sar 可用于获取进程和网络等各种系统活动统计信息，参考：<a href="https://www.computerhope.com/unix/usar.htm#:~:text=The%20sar%20command%20extracts%20and,data%20of%20that%20days%20ago." target="_blank" rel="external nofollow noopener noreferrer">Linux sar command</a>，<a href="https://www.cnblogs.com/xhyan/p/6531098.html" target="_blank" rel="external nofollow noopener noreferrer">Linux Sar 命令详解</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 获取 CPU 利用率信息</span></span><br><span class="line">sar -u 2 5</span><br><span class="line"><span class="comment"># 获取 127 号中断向量统计信息</span></span><br><span class="line">sar -I 127 1 10</span><br><span class="line"><span class="comment"># 获取内存统计信息</span></span><br><span class="line">sar -r 1 2</span><br><span class="line"><span class="comment"># 获取网卡统计信息</span></span><br><span class="line">sar -n DEV 1 2</span><br><span class="line"><span class="comment"># 获取所有系统统计信息</span></span><br><span class="line">sar -A 1 2</span><br><span class="line"><span class="comment"># 从文件中获取历史统计信息，DD 指的是当天在本月是第几天</span></span><br><span class="line">sar -r -f /var/<span class="built_in">log</span>/sa/saDD</span><br><span class="line"><span class="comment"># 查看换页情况，其中 pgsteal/s 表示每秒钟从 cache 中被清除来满足内存需要的页个数，数值较大说明确实内存严重不足</span></span><br><span class="line">sar -B 10 3</span><br><span class="line"><span class="comment"># 获取块设备统计信息</span></span><br><span class="line">sar -d 1 2</span><br><span class="line"><span class="comment"># 上下文切换信息</span></span><br><span class="line">sar -w 1 5</span><br><span class="line"><span class="comment"># socket 信息</span></span><br><span class="line">sar -n SOCK 5 5</span><br><span class="line"><span class="comment"># TCP 信息</span></span><br><span class="line">sar -n TCP 1 5</span><br><span class="line"><span class="comment"># 文件系统统计信息</span></span><br><span class="line">sar -F 2 4</span><br></pre></td></tr></table></figure>

<h4 id="pidstat"><a href="#pidstat" class="headerlink" title="pidstat"></a>pidstat</h4><p>用于显示进程相关统计信息。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 以下命令均可添加 -p PID 只显示指定进程信息，加上数字指定刷新间隔，另外可追加 -t 参数显示线程相关信息，默认只显示进程信息</span></span><br><span class="line"><span class="comment"># 显示 CPU 信息</span></span><br><span class="line">pidstat -u</span><br><span class="line"><span class="comment"># 显示内存信息，其中 Cswch/s 表示主动上下文切换，Nvcswch/s 表示被动上下文切换</span></span><br><span class="line">pidstat -r</span><br><span class="line"><span class="comment"># 显示磁盘 IO 信息</span></span><br><span class="line">pidstat -d</span><br><span class="line"><span class="comment"># 显示上下文切换</span></span><br><span class="line">pidstat -w</span><br><span class="line"><span class="comment"># 显示线程相关信息</span></span><br><span class="line">pidstat -t -p 9252</span><br><span class="line"><span class="comment"># 显示独立 TASK 即进程信息，默认显示 CPU 使用信息，可通过追加 -r / -d / -w 等指定显示的信息</span></span><br><span class="line">pidstat -T TASK</span><br><span class="line"><span class="comment"># 显示进程下所有线程信息，默认显示 CPU 使用信息，可通过追加 -r / -d / -w 等指定显示的信息</span></span><br><span class="line">pidstat -T CHILD</span><br><span class="line"><span class="comment"># 以下命令在新版本 sysstat 中才有</span></span><br><span class="line"><span class="comment"># 列出启动命令中包含指定字符串的进程</span></span><br><span class="line">pidstat -G kube</span><br><span class="line"><span class="comment"># -t 包括线程</span></span><br><span class="line">pidstat -t -G kube</span><br><span class="line"><span class="comment"># 显示调度相关信息</span></span><br><span class="line">pidstat -R</span><br></pre></td></tr></table></figure>

<h4 id="top"><a href="#top" class="headerlink" title="top"></a>top</h4><p>P - 按照 CPU 使用率排序；M - 按照内存使用量排序；T - 按照进程启动后占用的 CPU 时间总和排序</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -u 指定用户 -d 指定刷新间隔</span></span><br><span class="line">top -u ceph -d 0.5</span><br></pre></td></tr></table></figure>

<h4 id="iotop"><a href="#iotop" class="headerlink" title="iotop"></a>iotop</h4><p><code>iotop</code>  进程或线程的当前 I/O 使用情况，显示每个进程/线程读写 I/O 带宽以及等待换入和等待 I/O 的线程/进程花费的时间的百分比。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 仅显示正在进行 IO 操作的进程或线程信息</span><br><span class="line">iotop -o</span><br><span class="line"># 只显示进程（线程读写也算到所属进程）</span><br><span class="line">iotop -P -o</span><br></pre></td></tr></table></figure>

<h4 id="nethogs"><a href="#nethogs" class="headerlink" title="nethogs"></a>nethogs</h4><p>查看进程网络流量</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install nethogs</span><br></pre></td></tr></table></figure>

<h4 id="arp"><a href="#arp" class="headerlink" title="arp"></a>arp</h4><p>查看 arp 缓存</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">arp -e</span><br></pre></td></tr></table></figure>

<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul>
<li><a href="https://blog.csdn.net/weixin_41843699/article/details/97614157" target="_blank" rel="external nofollow noopener noreferrer">CPU-IO-网络-内核参数调优</a></li>
<li><a href="https://coolshell.cn/articles/7490.html" target="_blank" rel="external nofollow noopener noreferrer">性能调优攻略</a></li>
<li><a href="https://www.cyberciti.biz/faq/stress-test-linux-unix-server-with-stress-ng/" target="_blank" rel="external nofollow noopener noreferrer">Stress Test CPU and Memory (VM) On a Linux / Unix With Stress-ng</a></li>
<li><a href="https://www.cnblogs.com/xudong-bupt/p/8643094.html" target="_blank" rel="external nofollow noopener noreferrer">linux top 命令看到的实存(RES)与虚存(VIRT)分析</a></li>
<li><a href="https://www.jellythink.com/archives/438" target="_blank" rel="external nofollow noopener noreferrer">Linux iostat 命令详解</a></li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>故障排查</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 文件系统基础知识</title>
    <url>/post/c957e495.html</url>
    <content><![CDATA[<h4 id="superblock-inode-dentry-file"><a href="#superblock-inode-dentry-file" class="headerlink" title="superblock, inode, dentry, file"></a>superblock, inode, dentry, file</h4><p>理解这几个概念，首先需要搞清楚元数据（metadata ）的概念，借用维基百科的定义，元数据是关于数据的数据，即元数据包含了某段数据的一些信息。就好像你买了一辆车，而这辆车的型号、品牌及产地等信息即为该车的元数据。这些信息并不是车本身的一部分而是关于车的描述，因此称为车的元数据。在 Linux 文件系统中，元数据本身又分为了多个层级。<br>superblock 超级块是文件系统的元数据，定义了文件系统的大小、类型状态以及一些其它元数据结构的信息（因此可称超级块是元数据的元数据）。超级块是处于较高层级的文件系统的元数据结构，是文件系统非常关键的信息，一旦损坏则会导致所有的数据不可用，所以一般文件系统中超级块的内容会保存多份，必要时可使用工具找到备份的超级块信息恢复损坏的文件系统。<br>inode 定义了文件的元数据信息。在 Linux 系统中，为了简洁和统一，文件、目录、设备等都被视为 file。inode 包含的元数据中，不包含文件名信息，主要包含：文件的归属关系、读写权限、文件类型以及 inode 描述的 file 在磁盘存储的数据块地址等信息。问题来了，如果 inode 不包含文件名信息，而文件名信息又必然保存在磁盘上（因为将磁盘在不同的计算机上挂载都能够看到文件名，所以文件名信息不可能是保存在某一特定计算机上），而 Linux 文件系统中保存在磁盘上的除了 inode、superblock 等元数据，也就只有数据区了，所以文件名信息必然保存在数据区，那具体是怎么保存呢？刚才提到 inode 指向的也有可能是一个目录，所以猜想这个目录对象的数据区中即保存了相关文件的文件名。<br>dentry 是仅存在与内核中的对象，用于将内核中的 file 对象与 inode 对象联系起来。dentry 中保存了文件的文件名信息，该文件名也是根据 inode number 信息从磁盘数据中获取的。dentry 是 Linux 内核用来跟踪目录中文件层次结构的工具。 每个 dentry 将一个 inode 号映射到一个文件名。dentry 在文件访问加速和目录遍历等操作中发挥作用。<br>file 则是最接近用户的文件的定义，对于编程人员来说，操作文件时内核都会创建一个  file 对象，该对象包含文件存储位置和使用该文件的进程的信息和读写文件时的游标信息以及指向的 dentry（在 5.8-rc6 内核源码中看起来是直接指向的 inode ） 信息。 文件对象 (但不包括文件数据本身) 在关闭文件时被丢弃。<br>以上几种元数据中，superblock 和 inode 都会保存在磁盘上，在操作系统操作文件系统时被读入内核空间，所以在内核空间也会有相关的数据结构和相应的对象，而 dentry 和 file 则是根据内核操作文件的需要动态地进行创建和销毁，是临时存在的对象，不会持久化到磁盘上进行存储。<br>dentry 是仅存在于内存的目录项缓存，为了提高查找性能而设计，基于文件系统中存储目录信息的 inode 的数据构建，形成一个树状结构，用于从文件名到 inode 号的对应查找，从而能够快速将用户操作的 file 与底层 inode 关联起来。<br>进程每打开一个文件，就会有一个 file 结构与之对应。同一个进程可以多次打开同一个文件而得到多个不同的 file 结构，file 结构描述被打开文件的属性，如文件的当前偏移量等信息。<br>两个不同的 file 结构可以对应同一个 dentry 结构。进程多次打开同一个文件时，对应的只有一个 dentry 结构。dentry 结构存储目录项和对应文件（inode）的信息。<br>在存储介质中，每个文件对应唯一的 inode 结点，但是每个文件又可以有多个文件名。即可以通过不同的文件名访问同一个文件。这里多个文件名对应一个文件的关系在数据结构中表示就是 dentry 和 inode 的关系。<br>Inode 中不存储文件的名字，它只存储节点号；而 dentry 则保存有名字和与其对应的节点号，所以就可以通过不同的 dentry 访问同一个 inode。<br>指向同一个 inode 的不同的 dentry 则是通过文件链接（ln 命令）来实现的。<br><img src="https://cdn.nlark.com/yuque/0/2019/png/182657/1576301246896-71a41644-8a76-4077-82dc-e758fc49f277.png#align=left&display=inline&height=150&margin=%5Bobject%20Object%5D&name=image.png&originHeight=299&originWidth=441&size=14934&status=done&style=none&width=220.5" alt="image.png"><br>参考： <a href="https://www.wikiwand.com/en/Inode" target="_blank" rel="external nofollow noopener noreferrer">https://www.wikiwand.com/en/Inode</a>，<a href="https://unix.stackexchange.com/a/4403" target="_blank" rel="external nofollow noopener noreferrer">https://unix.stackexchange.com/a/4403</a>，<a href="https://marcoguerri.github.io/linux/2016/09/19/on-vfs-dentry-inodes.html" target="_blank" rel="external nofollow noopener noreferrer">https://marcoguerri.github.io/linux/2016/09/19/on-vfs-dentry-inodes.html</a></p><a id="more"></a>
<h4 id="软链接和硬链接的区别"><a href="#软链接和硬链接的区别" class="headerlink" title="软链接和硬链接的区别"></a>软链接和硬链接的区别</h4><p><img src="https://cdn.nlark.com/yuque/0/2019/png/182657/1573195363300-6e1b32b6-8636-48a9-a84c-def0811985fb.png#align=left&display=inline&height=255&margin=%5Bobject%20Object%5D&name=image.png&originHeight=255&originWidth=514&size=34517&status=done&style=none&width=514" alt="image.png"></p>
<ul>
<li>参考：<a href="https://stackoverflow.com/questions/185899/what-is-the-difference-between-a-symbolic-link-and-a-hard-link" target="_blank" rel="external nofollow noopener noreferrer">https://stackoverflow.com/questions/185899/what-is-the-difference-between-a-symbolic-link-and-a-hard-link</a></li>
<li>硬链接是对 inode 的引用，只有所有引用都删除后 inode 才会被删除，删除源文件，通过硬链接创建的文件仍然能够访问之前保存的数据；软链接指向源文件，源文件被删除后，访问软链接会提示文件不存在， inode 一般在源文件删除后即被删除（除非有硬链接指向该 inode）。</li>
<li>创建硬链接时源文件必须存在；而软链接可以指向不存在的对象以及不同文件系统（如 nfs）的对象（目录或文件）。</li>
<li>创建硬链接增加了针对指定 inode 的引用项，创建软链接增加了一条包含指定路径名称的记录项，由此在内核中构建的 dentry 记录也会有所差别。</li>
<li>关于为什么不允许对目录创建硬链接的个人理解：硬链接创建的是和源文件同样类型的文件系统对象，在硬链接创建完成后，文件系统已经无法区分新建出来的文件系统对象是否是通过硬链接创建出来的，因此在执行目录遍历时便会将其作为普通的文件对象对待，因此一旦允许硬链接指向目录，则在出现环路时会永不停止的遍历下去，造成文件系统无法正常工作；而对目录创建软链接可以工作是因为，软链接创建出来的文件系统对象和普通的文件系统对象类型是不一样的，因此文件系统可以区分出软链接创建出来的文件系统对象并在进行目录遍历时获取到软链接指向的最短路径（readlink -f soft-link）后就终止对其进行遍历，从而能够正常工作；其关键在于是否可识别，如果能够识别就可以区别对待。</li>
</ul>
<h4 id="chroot"><a href="#chroot" class="headerlink" title="chroot"></a>chroot</h4><p>chroot 改变了进程及其子进程能够访问的文件系统的入口点，使得该应用只能访问新的根目录下的文件内容而无法访问根目录以外的文件，将应用置于沙盒中从而限制其能够访问的文件和设备等资源，实现对应用的安全隔离。</p>
<h4 id="软链接和-bind-mount-的比较"><a href="#软链接和-bind-mount-的比较" class="headerlink" title="软链接和 bind mount 的比较"></a>软链接和 bind mount 的比较</h4><ul>
<li>其相同之处是都可以实现对源目录进行跨文件系统的定位和访问。</li>
<li>其主要的不同点在于它们的控制主体和表现形式，软链接由文件系统负责管理，是文件系统中的对象；bind mount 由内核直接控制，是内核中的实体，比文件系统层级更低（因此 bind mount 需要 root 权限，创建软链接并不需要 root 权限），它可以更改文件系统的底层拓扑结构而使得文件系统毫无察觉（因此 bind mount 过程不会持久化保存，系统重启时必须重新进行 bind mount，一般将其写入到 /etc/fstab）。</li>
<li>软链接的创建可以使用相对路径或绝对路径，表示对象中保存的源路径与输入路径完全一致，因此有可能使得软链接在某些情况无法访问（例如，在由软链接建立的循环路径中相对路径可能失效）；bind mount 在使用相对路径作为源路径时会将其解析为绝对路径后保存并挂载。</li>
<li>在使用 chroot 的情况下，软链接的范围仅限于当前新的根目录下（源目录与目的目录均在当前 chroot 下），而 bind mount 可以将 chroot 外的文件挂载到当前 chroot 中使用（过程是怎样的？）</li>
<li>容器文件系统的挂载过程借助了 bind mount。</li>
<li>bind mount 是将内核中的数据结构从源端拷贝到目的端。</li>
<li>改变目录树视图的文件系统可被称为 overlay 文件系统，bindfs/overlay2/aufs 均可称为 overlay 文件系统。</li>
<li>参考：<a href="https://www.quora.com/What-are-the-differences-between-bind-mounts-and-symlink-on-Unix" target="_blank" rel="external nofollow noopener noreferrer">https://www.quora.com/What-are-the-differences-between-bind-mounts-and-symlink-on-Unix</a></li>
<li>参考：<a href="https://unix.stackexchange.com/questions/198590/what-is-a-bind-mount" target="_blank" rel="external nofollow noopener noreferrer">https://unix.stackexchange.com/questions/198590/what-is-a-bind-mount</a></li>
</ul>
<h4 id="mount-namespace"><a href="#mount-namespace" class="headerlink" title="mount namespace"></a>mount namespace</h4><ul>
<li><a href="https://lwn.net/Articles/689856/" target="_blank" rel="external nofollow noopener noreferrer">https://lwn.net/Articles/689856/</a></li>
<li>新的 mount namespace 会继承原 mount namespace 的挂载点（因为是 clone），之后挂载点会各自变化。</li>
<li>Creating a mount namespace is similar to a recursive bind mount of / followed by chroot into the bind mount. Chroot creating is simular to creating a mount namespace followed by pivot_root.</li>
<li><a href="https://unix.stackexchange.com/questions/456620/how-to-perform-chroot-with-linux-namespaces" target="_blank" rel="external nofollow noopener noreferrer">https://unix.stackexchange.com/questions/456620/how-to-perform-chroot-with-linux-namespaces</a></li>
</ul>
<h4 id="bind-mount-写入-fstab"><a href="#bind-mount-写入-fstab" class="headerlink" title="bind mount 写入 fstab"></a>bind mount 写入 fstab</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;cephfs&#x2F;storage &#x2F;storage none defaults,bind 0 0</span><br></pre></td></tr></table></figure>

<h4 id="文件的-atime-mtime-ctime"><a href="#文件的-atime-mtime-ctime" class="headerlink" title="文件的 atime/mtime/ctime"></a>文件的 atime/mtime/ctime</h4><p>atime 是文件最后被访问的时间，mtime 是文件最后更新的时间，ctime 是文件权限/所有者等元数据发生变化的时间，<code>ls -l</code> 默认显示文件的 mtime，<code>touch</code> 命令用于更新文件的 atime/mtime/ctime 为当前时间。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用 stat 命令可以查看文件的三种时间戳</span></span><br><span class="line"><span class="built_in">stat</span> Dockerfile</span><br><span class="line"><span class="comment"># 输出如下</span></span><br><span class="line">  File: Dockerfile</span><br><span class="line">  Size: 714       	Blocks: 8          IO Block: 4096   regular file</span><br><span class="line">Device: 801h/2049d	Inode: 1730866260  Links: 1</span><br><span class="line">Access: (0644/-rw-r--r--)  Uid: ( 1000/     xyc)   Gid: (  985/   users)</span><br><span class="line">Access: 2020-07-20 18:30:18.011746992 +0800</span><br><span class="line">Modify: 2020-07-20 18:28:45.569930146 +0800</span><br><span class="line">Change: 2020-07-20 18:28:45.569930146 +0800</span><br><span class="line"> Birth: 2020-07-20 18:28:45.569930146 +0800</span><br></pre></td></tr></table></figure>

<h4 id="系统启动时加载-initrd-initramfs"><a href="#系统启动时加载-initrd-initramfs" class="headerlink" title="系统启动时加载 initrd (initramfs)"></a>系统启动时加载 initrd (initramfs)</h4><p>grub 在加载内核的同时，还需要加载 initrd (initramfs)，并交给内核进行挂载。grub 完成自己的任务后会把系统启动的工作移交给内核继续进行，initrd 提供了内核执行启动工作所必须的最小资源集，包括网卡驱动、磁盘驱动、各种文件系统驱动和扩展内核模块等，可视为一个临时的根文件系统，当内核从中获取必要的驱动与模块从而有能力操作各种外设后，将会挂载最终的根文件系统来替换掉该临时的文件系统。<br>initrd (initial ram disk) 和 initramfs (initial ram file system) 所承载的内容是一样的，区别在于其工作模式。<br>顾名思义，initrd 是内存盘的镜像，内核在读取其内容时将其作为块设备处理，且这个块设备完整存在于内存中，占用了内存空间，再加上内核从块设备读取数据时会将数据拷贝到 page cache（对于文件数据）和 dentry cache（(对于目录项），相当于同样的数据在内存中存在了两份从而造成浪费。initrd 的另一个特点是，既然它是一个块设备，则在其之上必然存在一种系统（一般是 ext2 ）才能承载可供内核读取的数据，同时内核在编译时也必须加入此种文件系统的驱动。块设备大小固定，所以可能存在内存空间浪费或所需空间不足的情况。<br>显然，initramfs 是一份文件系统的数据镜像，其所使用的文件系统名为 tmpfs，是一种 dummy 文件系统，它提供给 VFS （虚拟文件系统）的接口仅包含了能够保证正常工作的最少功能集。基于 tmpfs 的文件读写均是对内核中同一份数据的操作，且不需要块设备驱动的介入。另外，tmpfs 基于 Linux cache 系统构建，仅增加少量代码，是内核原生支持的文件系统格式，而无需加入额外的驱动支持。<br>参考：<a href="https://stackoverflow.com/a/10604667" target="_blank" rel="external nofollow noopener noreferrer">https://stackoverflow.com/a/10604667</a>，<a href="https://blog.csdn.net/findstr/article/details/6990807" target="_blank" rel="external nofollow noopener noreferrer">https://blog.csdn.net/findstr/article/details/6990807</a></p>
<h4 id="xfs-文件系统"><a href="#xfs-文件系统" class="headerlink" title="xfs 文件系统"></a>xfs 文件系统</h4><p>参考：<a href="http://landoflinux.com/linux_xfs_filesystem_introduction.html" target="_blank" rel="external nofollow noopener noreferrer">http://landoflinux.com/linux_xfs_filesystem_introduction.html</a>，<a href="https://www.wikiwand.com/en/XFS" target="_blank" rel="external nofollow noopener noreferrer">https://www.wikiwand.com/en/XFS</a>，<a href="https://righteousit.wordpress.com/2018/05/21/xfs-part-1-superblock/" target="_blank" rel="external nofollow noopener noreferrer">https://righteousit.wordpress.com/2018/05/21/xfs-part-1-superblock/</a></p>
<h4 id="tmpfs"><a href="#tmpfs" class="headerlink" title="tmpfs"></a>tmpfs</h4><p>tmpfs 是基于内存的文件系统，它使用虚拟内存空间，可被交换至 swap 分区，初始挂载时使用很小的空间，其占用的内存空间大小随实际文件的大小变化，当文件被删除时内存空间会被释放。挂载时可指定可用空间大小，若未指定，则默认为内存空间大小的一半。tmpfs 基于 ramfs 和 page cache 构建，不同于 ramfs 的是 tmpfs 中的内容可被交换至 swap 分区，tmpfs 所用内存大小和 inode 数量可被限制，防止内存被耗尽。ramfs 基于物理内存，所以无法使用 swap 分区；tmpfs 基于虚拟内存，可使用物理内存和 swap 空间。<br>tmpfs 通常被用在 /tmp, /var/lock, /var/run 挂载点，也被挂载在 /dev/shm 用于 POSIX 共享内存，挂载至 /dev/shm 由 systemd 自动完成。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 手动挂载，size=0 意味不限制大小，nr_inodes=0 意味不限制 inode 数量</span><br><span class="line">mount -t tmpfs -o size=20m tmpfs /mnt/tmp</span><br><span class="line">// 写入 fstab</span><br><span class="line">tmpfs /tmp tmpfs size=2m 0 0</span><br></pre></td></tr></table></figure>

<h4 id="ls-列出的文件信息"><a href="#ls-列出的文件信息" class="headerlink" title="ls 列出的文件信息"></a>ls 列出的文件信息</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ls -ltrh</span><br><span class="line">total 19M</span><br><span class="line">drwxr-xr-x  4 root root   35 Jul  1 18:07 uk8s-demo</span><br><span class="line">-rw-r--r--  1 root root  21K Jul  3 12:52 prometheus.yaml</span><br><span class="line">-rw-r--r--  1 root root  998 Jul  3 15:02 prometheus-instance.yaml</span><br><span class="line">-rw-r--r--  1 root root 1.5K Jul  3 15:05 prometheus-operator-old.yaml</span><br><span class="line">-rw-r--r--  1 root root 1.4K Jul  3 16:19 etcd-sm.yaml</span><br><span class="line">-rw-r--r--  1 root root  202 Jul  8 15:35 delete-cm.bash</span><br><span class="line">-rw-r--r--  1 root root  32K Jul  8 16:45 prometheus-new.yaml</span><br><span class="line">-rw-r--r--  1 root root  325 Jul  8 18:12 prometheus-svc.yaml</span><br><span class="line">-rw-r--r--  1 root root 2.4K Jul 21 10:33 prometheus-sts.yaml</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>第一列</th>
<th>第二列</th>
<th>第三列</th>
<th>第四列</th>
<th>第五列</th>
<th>第六列</th>
<th>第七列</th>
</tr>
</thead>
<tbody><tr>
<td>drwxr-xr-x</td>
<td>4</td>
<td>root</td>
<td>root</td>
<td>35</td>
<td>Jul  1 18:07</td>
<td>uk8s-demo</td>
</tr>
</tbody></table>
<p>| 文件的类型和文件权限<br>第一个字符表示文件类型：d 目录 , - 文件 , l 链接 , s: socket , p: named pipe , b: block device , c: character device。<br>文件权限中 x 位为 s 时，表示在文件执行时把进程的属主或组 ID 置为该文件的文件属主。 | 文件链接个数 | 文件的所有者 | 文件的属组 | 文件大小 | 文件内容被修改的最后时间 | 文件名称 |</p>
<h4 id="dev-ptmx"><a href="#dev-ptmx" class="headerlink" title="/dev/ptmx"></a>/dev/ptmx</h4><p>伪终端 (pseudoterminal) : ptmx, pts (伪终端 master 和伪终端 slave )。/dev/ptmx 用于创建伪终端主从设备对。当我们用 open 打开 /dev/ptmx 设备后, 返回主设备的文件描述符，并且在 /dev/pts/ 目录下创建一个伪终端从设备。在成功打开 /dev/ptmx 后, 可以通过函数 ptsname() 来获取从设备的 path 。想要打开 open 伪终端从设备,必须先使用主设备的文件描述符调用 grantpt() , unlockpt() 。当主设备和从设备都打开后, 在主设备写入的数据可以在从设备上读取, 在从设备上写入的数据可以在主设备读取。</p>
<h4 id="阅读材料"><a href="#阅读材料" class="headerlink" title="阅读材料"></a>阅读材料</h4><ul>
<li><a href="https://helpdeskgeek.com/linux-tips/what-are-inodes-in-linux-and-how-are-they-used/" target="_blank" rel="external nofollow noopener noreferrer">What Are Inodes in Linux and How Are They Used</a></li>
<li><a href="https://www.wikiwand.com/en/Inode" target="_blank" rel="external nofollow noopener noreferrer">https://www.wikiwand.com/en/Inode</a></li>
<li><a href="https://www.thegeekdiary.com/unix-file-basics-inode-soft-vs-hard-link-device-files/" target="_blank" rel="external nofollow noopener noreferrer">https://www.thegeekdiary.com/unix-file-basics-inode-soft-vs-hard-link-device-files/</a></li>
<li><a href="https://www.kernel.org/doc/html/latest/filesystems/tmpfs.html" target="_blank" rel="external nofollow noopener noreferrer">Tmpfs</a>，<a href="https://wiki.archlinux.org/index.php/Tmpfs" target="_blank" rel="external nofollow noopener noreferrer">archwiki-Tmpfs</a></li>
<li><a href="https://www.cnblogs.com/sparkdev/p/9651622.html" target="_blank" rel="external nofollow noopener noreferrer">Linux 特殊权限 SUID,SGID,SBIT</a></li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>MeshCentral - 管理远程设备的利器</title>
    <url>/post/f5428d95.html</url>
    <content><![CDATA[<h4 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h4><p>仓库地址：<a href="https://github.com/Ylianst/MeshCentral" target="_blank" rel="external nofollow noopener noreferrer">https://github.com/Ylianst/MeshCentral</a><br>官方首页：<a href="https://www.meshcommander.com/meshcentral2" target="_blank" rel="external nofollow noopener noreferrer">https://www.meshcommander.com/meshcentral2</a><br>开发语言：MeshCentral 中心服务器采用 NodeJS 开发（UI 是 JavaScript），另外需要在每个远程设备上安装  MeshAgent 用于控制设备，该组件使用 C 语言开发。<br>工作原理：MeshCentral 作为中心服务器应当部署在具有公网 IP 的节点上，这样方便随时随地管理远程设备；如果你只需要在本地局域网内管理其它设备，也可以部署在本地节点；如果你的家用宽带有自己固定的公网 IP ，部署在家里的电脑上也是可以的；总之，你需要部署一个具有广泛可达的通信地址的中心服务器，这里推荐使用公有云厂商的羊毛版服务器。MeshAgent 安装在你的远程节点上，远程节点的操作系统可以是 macOS 、Windows 或者 Linux。MeshAgent 向中心服务器注册自己的基本信息并通过 WebSocket 协议与中心服务器保持通信，如果开启了 WebRTC 模式，还会使用  STUN 协议获取节点的公网通信地址并上报给中心服务器。当你在笔记本电脑上通过浏览器打开控制界面尝试去连接远程节点时，若未开启 WebRTC，所有的通信流量都要经过中心服务器中转，这样不仅会增加中心服务器的负担，通信速率也将受到中心服务器带宽能力的限制，而在 WebRTC 模式下，你的笔记本可以和远程节点直连，这无疑是一种更高效地工作模式，在运气好的情况下（两端上行带宽都比较高）可以获得极佳的远程桌面清晰度和流畅度。<br>官方文档：该项目的另一大优点是文档较为详细，安装指南：<a href="http://info.meshcentral.com/downloads/MeshCentral2/MeshCentral2InstallGuide-0.0.9.pdf" target="_blank" rel="external nofollow noopener noreferrer">MeshCentral2InstallGuide-0.0.9.pdf</a>；用户手册：<a href="http://info.meshcentral.com/downloads/MeshCentral2/MeshCentral2UserGuide-0.2.9.pdf" target="_blank" rel="external nofollow noopener noreferrer">MeshCentral2UserGuide-0.2.9.pdf</a>。</p><a id="more"></a>
<h4 id="安装部署"><a href="#安装部署" class="headerlink" title="安装部署"></a>安装部署</h4><p>MeshCentral 的功能较为丰富，这里我仅结合自己的使用需求实施较为简单的部署。MeshCentral 部署在我之前购买的阿里云虚拟机上，其基本信息如下，目前已稳定运行了两年，我的博客也部署在同一台虚拟机上：<br><img src="https://cdn.nlark.com/yuque/0/2020/png/182657/1592718150625-fce9a72d-93b0-4421-a548-2bae46f3ccbc.png#align=left&display=inline&height=268&margin=%5Bobject%20Object%5D&name=image.png&originHeight=536&originWidth=2676&size=133276&status=done&style=none&width=1338" alt="image.png"><br>使用 nvm 安装 NodeJS ：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.35.3/install.sh | bash</span><br><span class="line">cat&gt;&gt;~/.bashrc&lt;&lt;EOF</span><br><span class="line"><span class="built_in">export</span> NVM_DIR=<span class="string">"<span class="variable">$HOME</span>/.nvm"</span></span><br><span class="line">[ -s <span class="string">"<span class="variable">$NVM_DIR</span>/nvm.sh"</span> ] &amp;&amp; \. <span class="string">"<span class="variable">$NVM_DIR</span>/nvm.sh"</span>  <span class="comment"># This loads nvm</span></span><br><span class="line">[ -s <span class="string">"<span class="variable">$NVM_DIR</span>/bash_completion"</span> ] &amp;&amp; \. <span class="string">"<span class="variable">$NVM_DIR</span>/bash_completion"</span>  <span class="comment"># This loads nvm bash_completion</span></span><br><span class="line">EOF</span><br><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br><span class="line">nvm install 12</span><br><span class="line">nvm <span class="built_in">alias</span> default 12</span><br></pre></td></tr></table></figure>

<p>使用 node 安装 meshcentral :</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install -g nrm</span><br><span class="line">nrm use taobao</span><br><span class="line">mkdir /root/meshcentral</span><br><span class="line"><span class="built_in">cd</span> /root/meshcentral</span><br><span class="line">npm install meshcentral</span><br></pre></td></tr></table></figure>

<p>创建 systemd 服务描述文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat&gt;/etc/systemd/system/meshcentral.service&lt;&lt;EOF</span><br><span class="line">[Unit]</span><br><span class="line">Description=MeshCentral Server</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=simple</span><br><span class="line">LimitNOFILE=1000000</span><br><span class="line">ExecStart=`<span class="built_in">which</span> node` /root/meshcentral/node_modules/meshcentral</span><br><span class="line">WorkingDirectory=/root/meshcentral</span><br><span class="line">Environment=NODE_ENV=production</span><br><span class="line">User=root</span><br><span class="line">Group=root</span><br><span class="line">Restart=always</span><br><span class="line"><span class="comment"># Restart service after 10 seconds if node service crashes</span></span><br><span class="line">RestartSec=10</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>

<p>启动服务：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 启动服务</span></span><br><span class="line">systemctl <span class="built_in">enable</span> --now meshcentral</span><br><span class="line"><span class="comment"># 检查服务状态，若无异常则服务已经启动</span></span><br><span class="line">systemctl status meshcentral</span><br></pre></td></tr></table></figure>

<p>meshcentral 默认监听在 8080 和 8443 端口，8080 端口可使用 http 访问，8443 端口需使用 https 访问，默认情况下，http 访问 8080 端口会重定向至 8443 https 访问。由于我们使用的私有证书，浏览器会提示非安全链接，忽略即可。初次登录时由于无用户，所以会提示创建用户，并授予该用户管理员权限。<br>登录后需要先创建设备组，填好设备组名称，设备组类型使用默认的 “Manage using a software agent” 即可， 如下：<br><img src="https://cdn.nlark.com/yuque/0/2020/png/182657/1592724691670-56251d09-9d0d-4e45-841a-1d84cdbd5ddf.png#align=left&display=inline&height=413&margin=%5Bobject%20Object%5D&name=image.png&originHeight=826&originWidth=2364&size=278961&status=done&style=none&width=1182" alt="image.png"><br>然后向设备组中添加设备，根据操作系统选择部署 MeshAgent 的方式，若远程节点操作系统为 Linux ，则会生成一个脚本，到远程节点上去执行该脚本即可，Windows 和 macOS 则是下载一个安装包到节点上部署。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/182657/1592725026046-9d018b1f-9b75-423f-8915-7421a188e5f9.png#align=left&display=inline&height=399&margin=%5Bobject%20Object%5D&name=image.png&originHeight=798&originWidth=2270&size=190398&status=done&style=none&width=1135" alt="image.png"></p>
<h4 id="开启-WebRTC"><a href="#开启-WebRTC" class="headerlink" title="开启 WebRTC"></a>开启 WebRTC</h4><h4 id="操作使用体验"><a href="#操作使用体验" class="headerlink" title="操作使用体验"></a>操作使用体验</h4><p>远程桌面<br><img src="https://cdn.nlark.com/yuque/0/2020/png/182657/1592725895076-877202e7-75d8-4421-9563-43a098870059.png#align=left&display=inline&height=796&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1592&originWidth=2612&size=3526151&status=done&style=none&width=1306" alt="image.png"><br>终端<br><img src="https://cdn.nlark.com/yuque/0/2020/png/182657/1592725982695-c2d7c4e7-39b3-492a-b4cd-30609eecbbff.png#align=left&display=inline&height=409&margin=%5Bobject%20Object%5D&name=image.png&originHeight=818&originWidth=1810&size=235964&status=done&style=none&width=905" alt="image.png"><br>文件传输<br><img src="https://cdn.nlark.com/yuque/0/2020/png/182657/1592726016995-65c4a6eb-da88-4d68-be49-564918406ee1.png#align=left&display=inline&height=545&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1090&originWidth=1566&size=131995&status=done&style=none&width=783" alt="image.png"></p>
<h4 id="WebRTC-阅读材料"><a href="#WebRTC-阅读材料" class="headerlink" title="WebRTC 阅读材料"></a>WebRTC 阅读材料</h4><p>参考：<a href="https://zhuanlan.zhihu.com/p/86759357" target="_blank" rel="external nofollow noopener noreferrer">https://zhuanlan.zhihu.com/p/86759357</a></p>
]]></content>
      <categories>
        <category>开发工具</category>
      </categories>
      <tags>
        <tag>开发工具</tag>
        <tag>MeshCentral</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 进程管理基础知识</title>
    <url>/post/ee7438a7.html</url>
    <content><![CDATA[<h4 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h4><p>对于 Linux 来讲，所有的线程都当作进程来实现，因为没有单独为线程定义特定的调度算法，也没有单独为线程定义特定的数据结构（所有的线程或进程的核心数据结构都是 task_struct）。<br>对于一个进程，相当于是它含有一个线程，就是它自身。对于多线程来说，原本的进程称为主线程，它们在一起组成一个线程组。<br>进程拥有自己的地址空间，所以每个进程都有自己的页表。而线程却没有，只能和其它线程共享某一个地址空间和同一份页表。这个区别的根本原因是，在进程 / 线程创建时，因是否拷贝当前进程的地址空间还是共享当前进程的地址空间，而使得指定的参数不同而导致的。<br>进程和线程的创建都可以通过 clone 系统调用完成。clone 系统调用会执行 do_fork 内核函数，而它则又会调用 copy_process 内核函数来完成。主要包括如下操作：在调用 copy_process 的过程中，会创建并拷贝当前进程的 task_stuct，同时还会创建属于子进程的 thread_info 结构以及内核栈。此后，会为创建好的 task_stuct 指定一个新的 pid（在 task_struct 结构体中）。然后根据传递给 clone 的参数标志，来选择拷贝还是共享打开的文件，文件系统信息，信号处理函数，进程地址空间等。这就是进程和线程不一样地方的本质所在。</p><a id="more"></a>
<h4 id="用户态和内核态"><a href="#用户态和内核态" class="headerlink" title="用户态和内核态"></a>用户态和内核态</h4><p>内核态和用户态是操作系统的两种运行级别，用于区分不同程序的不同权利。内核态就是拥有资源多的状态，或者说访问资源多的状态，也称为特权态。相对来说，用户态就是非特权态，访问的而资源将受到限制。如果一个程序运行在特权态，该程序就可以访问计算机的任何资源，它的资源访问权限不受限制。如果一个程序运行在用户态，其资源需求将受到各种限制。如：要访问操作系统的内核数据结构，如进程表，则需要在特权态下才能办到。如果要访问用户程序里的数据，在用户态即可。<br>用户态切换到内核态的 3 种方式：系统调用、异常、外围设备的中断。其中系统调用可以认为是用户进程主动发起的，异常和外围设备中断则是被动的。从触发方式上看，可以认为存在前述 3 种不同的类型，但是从最终实际完成由用户态到内核态的切换操作上来说，涉及的关键步骤是完全一致的，没有任何区别，都相当于执行了一个中断响应的过程，因为系统调用实际上最终是中断机制实现的，而异常和中断的处理机制基本上也是一致的。</p>
<h4 id="用户栈和内核栈"><a href="#用户栈和内核栈" class="headerlink" title="用户栈和内核栈"></a>用户栈和内核栈</h4><p>内核在创建进程的时候，在创建 task_struct 的同时，会为进程创建相应的堆栈。每一个进程都有两个栈，一个用户栈，存在于用户空间；一个内核栈，存在于内核空间。当进程在用户空间运行时，CPU 堆栈指针寄存器里面的内容是用户栈地址，使用用户栈；当进程在内核空间时，CPU 堆栈指针寄存器里面的内容是内核栈空间地址，使用内核栈。<br>当进程因为中断或者系统调用陷入到内核态时，进程所使用的堆栈也要从用户栈转到内核栈。进程陷入到内核态后，先把用户态堆栈的地址保存在内核栈之中，然后设置堆栈指针寄存器的内容为内核栈的地址，这样就完成了用户栈向内核栈的转换；当进程从内核态恢复到用户态时，在内核态运行的最后将保存在内核栈里面的用户栈的地址恢复到堆栈指针寄存器即可。这样就实现了用户栈和内核栈的互转。<br>我们知道从内核态转到用户态时，用户栈的地址是在陷入内核的时候保存在内核栈里面的，但是在陷入内核的时候，如何知道内核栈的地址？其关键点在于进程从用户态转到内核态的时候，进程的内核栈总是空的。这是因为当进程在用户态运行时，使用的用户栈，当进程陷入到内核态时，内核保存进程在内核态运行的相关信息，但是一旦进程返回到用户态后，内核栈中保存的信息已全部弹出，因此每次进程从用户态陷入内核的时候得到的内核栈都是空的。所以在进程陷入内核的时候，直接把内核栈的栈顶地址给堆栈指针寄存器就可以了。</p>
<h4 id="fork-clone"><a href="#fork-clone" class="headerlink" title="fork, clone"></a>fork, clone</h4><p>vfork() 是一个过时的优化。在进行良好的内存管理之前，fork() 完整复制了父进程的内存，因此成本很高。 因此在许多情况下，fork() 后面跟着 exec() ，它丢弃复制的内存并创建一个新的内存空间。 现在，fork() 不复制内存；它只是简单地设置为 copy on write ，所以 fork() + exec() 的效率与 vfork() + exec() 一样。<br>clone()  根据传入参数的不同可用于创建进程和线程。 它们之间的区别仅仅在于哪些数据结构 (内存空间、处理器状态、堆栈、 PID、打开的文件等) 是共享的。<br>glibc fork() 内部实现调用了 clone()。应用编程一般都调用 clone()，fork() 的存在只是为了兼容老的程序。<br>execve() 替换当前的进程的可执行镜像为另一个可执行文件。<br>posix_spawn() 所做的操作和  fork()/execve() 一致，所以推荐使用  posix_spawn() 而不是  fork()/execve()。pthread_create() 创建一个线程，内部也是调用了 clone()。</p>
<h4 id="内核常驻内存"><a href="#内核常驻内存" class="headerlink" title="内核常驻内存"></a>内核常驻内存</h4><p>当内核函数申请内存时，内核总是立即满足（因为内核完全信任它们，所以优先级最高）。在分配适当内存空间后，将其映射到内核地址空间中（3-4GB 中的某部分空间），然后将地址映射写入页表。内核地址空间（3-4GB）中的页面所映射的页框始终在物理内存中存在，不会被换出。即使是 vmalloc 动态申请的页面也会一直在物理内存中，直至通过相关内核函数释放掉。其原因在于，一方面内核文件不是太大，完全可以一次性装入物理内存；另一方面在于即使是动态申请内存空间，也能立即得到满足。因此，处于内核态的普通进程或内核线程（后面会提到）不会因为页面没有在内存中而产生缺页异常（不过处于内核态的普通进程会因为页表项没有同步的原因而产生缺页异常）。<br>每一个普通进程都拥有 4GB 的虚拟地址空间（对于 32 位的 CPU 来说，即 2 B）。主要分为两部分，一部分是用户空间（0-3GB），一部分是内核空间（3-4GB）。每个普通进程都有自己的用户空间，但是内核空间被所有普通进程所共享。</p>
<h4 id="普通线程的用户堆栈与寄存器"><a href="#普通线程的用户堆栈与寄存器" class="headerlink" title="普通线程的用户堆栈与寄存器"></a>普通线程的用户堆栈与寄存器</h4><p>对于多线程环境，虽然所有线程都共享同一片虚拟地址空间，但是每个线程都有自己的用户栈空间和寄存器，而用户堆仍然是所有线程共享的。<br>栈空间的使用是有明确限制的，栈中相邻的任意两条数据在地址上都是连续的。试想，假设多个普通线程函数都在执行递归操作。如果多个线程共有用户栈空间，由于线程是异步执行的，那么某个线程从栈中取出数据时，这条数据就很有可能是其它线程之前压入的，这就导致了冲突。所以，每个线程都应该有自己的用户栈空间。<br>寄存器也是如此，如果共用寄存器，很可能出现使用混乱的现象。<br>而堆空间的使用则并没有这样明确的限制，某个线程在申请堆空间时，内核只要从堆空间中分配一块大小合适的空间给线程就行了。所以，多个线程同时执行时不会出现向栈那样产生冲突的情况，因而线程组中的所有线程共享用户堆。<br>那么在创建线程时，内核是怎样为每个线程分配栈空间的呢？<br>进程 / 线程的创建主要是由 clone 系统调用完成的。而 clone 系统调用的参数中有一个 void *child_stack，它就是用来指向所创建的进程 / 线程的堆栈指针。而在该进程 / 线程在用户态下是通过调用 pthread_create 库函数而陷入内核的。对于 pthread_create 函数，它则会调用一个名为 pthread_allocate_stack 的函数，专门用来为所创建的线程分配的栈空间（通过 mmap 系统调用）。然后再将这个栈空间的地址传递给 clone 系统调用。这也是为什么线程组中的每个线程都有自己的栈空间。<br>每个进程或线程都有三个数据结构，分别是 struct thread_info, struct task_struct 和 内核栈，它们都在内核空间中，如下：<br><img src="https://cdn.nlark.com/yuque/0/2019/png/182657/1576311106924-9fb6ef15-10d8-487f-8989-90af8c06ef5a.png#align=left&display=inline&height=418&margin=%5Bobject%20Object%5D&name=image.png&originHeight=836&originWidth=1242&size=92406&status=done&style=none&width=621" alt="image.png"></p>
<h4 id="内核线程"><a href="#内核线程" class="headerlink" title="内核线程"></a>内核线程</h4><p>内核线程是一种只运行在内核地址空间的线程。所有的内核线程共享内核地址空间（对于 32 位系统来说，就是 3-4GB 的虚拟地址空间），所以也共享同一份内核页表。这也是为什么叫内核线程，而不叫内核进程的原因。<br>普通进程与内核线程有如下区别：内核线程只运行在内核态，而普通进程既可以运行在内核态，也可以运行在用户态；内核线程只使用 3-4GB (假设为 32 位系统) 的内核地址空间（共享的），但普通进程由于既可以运行在用户态，又可以运行在内核态，因此可以使用 4GB 的虚拟地址空间。<br>系统中有很多内核守护线程，可以通过：<code>ps -efj</code> 进行查看，其中带有 [] 号的就属于内核守护线程。它们的祖先都是这个 kthreadd 内核线程。</p>
<h4 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h4><p>linux 内核中设置了一组用于实现系统功能的子程序，称为系统调用。系统调用和普通库函数调用非常相似，只是系统调用由操作系统核心提供，运行于内核态，而普通的函数调用由函数库或用户自己提供，运行于用户态。一般的，进程是不能访问内核的。它不能访问内核所占内存空间也不能调用内核函数。为了和用户空间上运行的进程进行交互，内核提供了一组接口。透过该接口，应用程序可以访问硬件设备和其他操作系统资源。这组接口在应用程序和内核之间扮演了使者的角色，应用程序发送各种请求，而内核负责满足这些请求 (或者让应用程序暂时搁置)。实际上提供这组接口主要是为了保证系统稳定可靠，避免应用程序肆意妄行，惹出大麻烦。系统调用在用户空间进程和硬件设备之间添加了一个中间层。该层主要作用有三个：</p>
<ul>
<li>它为用户空间提供了一种统一的硬件的抽象接口。比如当需要读些文件的时候，应用程序就可以不去管磁盘类型和介质，甚至不用去管文件所在的文件系统到底是哪种类型。</li>
<li>系统调用保证了系统的稳定和安全。作为硬件设备和应用程序之间的中间人，内核可以基于权限和其他一些规则对需要进行的访问进行裁决。举例来说，这样可以避免应用程序不正确地使用硬件设备，窃取其他进程的资源，或做出其他什么危害系统的事情。</li>
<li>每个进程都运行在虚拟系统中，而在用户空间和系统的其余部分提供这样一层公共接口，也是出于这种考虑。如果应用程序可以随意访问硬件而内核又对此一无所知的话，几乎就没法实现多任务和虚拟内存，当然也不可能实现良好的稳定性和安全性。在 Linux 中，系统调用是用户空间访问内核的惟一手段；除异常和中断外，它们是内核惟一的合法入口。</li>
</ul>
<p>Linux 系统调用的 API 是以 POSIX 标准为基础实现的。传统的系统调用是通过 int 0x80 软中断实现的，但是现代的 CPU 中也提供了如 syscall/sysexit 指令级的支持以加快系统调用执行速度。<br>系统调用总体上可分为六个类别：</p>
<ul>
<li>进程控制：创建和终止进程，获取或设置进程属性，等待设定时间，等待事件，信号操作，分配和释放内存；</li>
<li>文件管理：创建、删除、打开、关闭和读写文件，设置文件属性；</li>
<li>设备管理：请求设备，释放设备，读写设备，设置设备属性， attach 或 detach 设备；</li>
<li>信息维护：获取或设置系统时间和日期，获取或设置系统数据；</li>
<li>通信：创建通信连接，发送接收消息，传输状态信息，attach 或 detach 远程设备；</li>
<li>保护：获取或者文件权限。</li>
</ul>
<h4 id="信号处理机制"><a href="#信号处理机制" class="headerlink" title="信号处理机制"></a>信号处理机制</h4><p>如果想要进程捕获某个信号，然后作出相应的处理，就需要注册信号处理函数。同中断类似，内核也为每个进程准备了一个信号向量表，信号向量表中记录着每个信号所对应的处理机制，默认情况下是调用默认处理机制。当进程为某个信号注册了信号处理程序后，发生该信号时，内核就会调用注册的函数。<br>信号是异步的，一个进程不可能等待信号的到来，也不知道信号会到来，那么，进程是如何发现和接受信号呢？实际上，信号的接收不是由用户进程来完成的，而是由内核代理。当一个进程 P2 向另一个进程 P1 发送信号后，内核接收到信号，并将其放在 P1 的信号队列当中。当 P1 再次陷入内核态时，会检查信号队列，并根据相应的信号调取相应的信号处理函数。</p>
<h4 id="Linux-中的常见信号"><a href="#Linux-中的常见信号" class="headerlink" title="Linux 中的常见信号"></a>Linux 中的常见信号</h4><p>Linux 支持标准的 POSIX 信号定义，使用 <code>man 7 signal</code> 可以查看信号的详细信息。每种信号都有预定义的默认行为。常见的几种：当用户退出 shell 时，由该 shell 启动的所有进程将收到 SIGHUP 信号，默认动作为终止进程，SIGHUP 也常用于重启进程，若需要进程忽略该信号，可通过 nohup 启动程序；SIGINT 信号由用户发送 INTR 字符( Ctrl+C )触发；SIGKILL 信号无条件结束程序（不能被捕获、阻塞或忽略），可通过 <code>kill -9 pid</code> 向进程发出信号，强制杀死进程；SIGTERM 信号默认动作也是终止进程，但该信号可以被捕获也可以被忽略，可用于优雅关闭进程，让进程有足够的时间去清理资源，在 Kubernetes 中删除 Pod 时，首先容器中 1 号进程会接收到 SIGTERM 信号开始优雅关闭，超过设定的优雅关闭限时后，进程会收到 SIGKILL 信号强制关闭。</p>
<h4 id="进程调度和进程切换"><a href="#进程调度和进程切换" class="headerlink" title="进程调度和进程切换"></a>进程调度和进程切换</h4><p>Linux 既支持普通的分时进程，也支持实时进程。Linux 中的调度是多种混合调度策略和调度算法的混合。Linux 中的调度是基于分时和优先级，且优先级是动态的，会根据进程的行为周期性调整。<br>Linux 通过 schedule() 函数实现进程调度。schedule () 是内核函数，也不是一个系统调用，所以在用户态时是无法直接调用 schedule () 的，只能间接地调用，通过中断。<br>进程调度的时机：中断处理过程（时钟中断、I/O 中断、系统调用、异常）中直接调用 schedule ()，或者返回用户态时根据 need_resched（）标记调用 schedule ()。<br>用户态进程只能被动调度，内核线程可以直接调用 schedule () 进行进程切换，也可以在中断处理过程中进行调度，也就是说内核线程作为一类的特殊的进程可以主动调度，也可以被动调度；用户态进程无法实现主动调度，仅能通过陷入内核态后的某个时机点进行调度，即在中断处理过程中进行调度。</p>
<h4 id="进程切换与模式切换"><a href="#进程切换与模式切换" class="headerlink" title="进程切换与模式切换"></a>进程切换与模式切换</h4><p>当一个进程在执行时，CPU 的所有寄存器中的值、进程的状态以及堆栈中的内容被称为该进程的上下文。当内核需要切换到另一个进程时，它需要保存当前进程的所有状态，即保存当前进程的上下文，以便在再次执行该进程时，能够根据切换前的状态执行下去。在 Linux 中，当前进程上下文均保存在进程的任务数据结构中。系统调用进行的是模式切换 (mode switch)。模式切换与进程切换比较起来，容易很多，而且节省时间，因为模式切换最主要的任务只是进行进程寄存器上下文的切换。在发生中断时，内核就在被中断进程的上下文中，在内核态下执行中断服务例程。但同时会保留所有需要用到的资源，以便中继服务结束时能恢复被中断进程的执行。中断的执行过程类似于系统调用，它复用了当前进程的内核栈，但不代表当前进程运行，而一般是代表硬件运行。</p>
<h4 id="进程-OOM"><a href="#进程-OOM" class="headerlink" title="进程 OOM"></a>进程 OOM</h4><p>一般来讲，进程意外终止有两种常见情况：程序本身的 Bug，出现访问非法地址的情况，接收到  SIGSEGV 信号而终止；另一种情况是系统磁盘空间不足或内存空间不足，而内存空间不足又更为常见。内存空间不足时，操作系统为了保护系统本身不致崩溃，会通过 oom killer 选择一些进程将其终止，被选中的进程会接收到 SIGKILL 信号。选择进程时的一个考虑是尽量牺牲最少的进程释放足够的空间，所以一些拥有较多子进程且内存消耗极大的进程（例如  PostgreSQL / Apache / MySQL ）会有更大的可能性被选中终止，而系统关键进程（例如具有 CAP_SYS_ADMIN 权限）则基本不会被选中。oom killer 本身并不是常驻的内核线程，而是只有在内存不足时才会触发调用的一组内核函数。<br>另外需要注意的是，如果使用了 cgroup 对一组进程可用的内存总量进行控制，oom 会在 cgroup 限制的内存被耗尽时针对该组进程触发。</p>
<h4 id="进程间通信机制"><a href="#进程间通信机制" class="headerlink" title="进程间通信机制"></a>进程间通信机制</h4><p>匿名管道：只能用于具有亲缘关系的进行通信，使用面相对较窄，实际开发中较少使用；<br>命名管道：可以用于任意进程间的通信，对于大块数据的传输效率较高，可应用于单进程大量数据传递，和多个进程向一个进程传递数据；<br>信号：无法传递数据，而且信号的种类有限，只适用于完成一些简单的事件通知任务，如配置跟新信号通知，一个服务通过信号告知另一个服务自身状态；<br>文件锁：不能用来传递数据，用来对操作进行协调，利用文件锁实现多个进程对于某个资源的排队请求，或者多个进程对系统某个全局资源进行读写操作，可以通过文件锁实现进程间读写锁的功能；<br>共享文件：文件的存在与否来当锁，文件内容来交互数据；<br>共享内存：最为高效的进程间通信方式，进程可以直接读写内存，不需要任何数据拷贝，适用于多个进程共享数据，或进程间频繁的进行大量的数据交互，建议使用 mmap 方式；<br>消息队列：进程间传递简单的命令和控制消息，如配置更新通知，多进程对多进程的通信等，可以简化代码逻辑，建议使用全双工管道替代；<br>信号量：某种资源数为 N，多个进程都在使用该资源，为了进行进程间的互斥，可以使用初始值为 N 的信号量，–建议使用记录锁替代；<br>Unix 套接字：某个服务与多个服务同时通信，此时需要维护多个通信通道，使用 Unix 套接字，可以使用 Linux IO 多路复用功能，建议优先考虑网络套接字；<br>网络套接字：如果系统需要支持分布式部署，服务可能在同一设备或者不同设备，此时使用网络套接字比较合适，提高了扩展性。</p>
<h4 id="进程间锁"><a href="#进程间锁" class="headerlink" title="进程间锁"></a>进程间锁</h4><p>进程较线程来说相对独立，进程间同步的粒度一般较大，且多借助分布式消息队列、分布式内存等中间件实现分布式节点之间的同步。单机上多进程间同步相对少见，一种典型的场景是 Nginx 多进程模型中的 woker 进程通过对 accept 加锁实现多 worker 进程之间的协调。进程间锁借助进程间通信机制实现，是进程间通信机制的一种应用实例。进程间锁可借助共享内存、共享文件、信号量等方式实现。借助共享内存实现进程间锁的基本原理是：开辟一块共享内存，使得相关进程均可访问同一块区域，再将互斥锁定义在该区域（即共享内存）上，使得相关进程可以使用该锁。为解决多进程对同一文件的读写冲突，在 linux 系统中，提供了 flock 这一系统调用，用来实现对文件的读写保护，即文件锁的功能。文件锁保护文件的功能，与 fork 多进程及 pthread 库中多线程使用读写锁来保护内存资源的方式是类似的。</p>
<h4 id="线程同步机制"><a href="#线程同步机制" class="headerlink" title="线程同步机制"></a>线程同步机制</h4><p>线程间因为共享资源易产生资源竞争所以需要进行同步。常用的线程同步机制有：互斥锁、读写锁、条件变量等。</p>
<h4 id="nice-值"><a href="#nice-值" class="headerlink" title="nice 值"></a>nice 值</h4><p>在 Linux 中，nice 值表示进程的优先级，一般地 nice 值的范围从 -20 到 +19（不同系统的值范围是不一样的），正值表示低优先级，负值表示高优先级，值为零则表示不会调整该进程的优先级。具有最高优先级的程序，其 nice 值最低，所以在 Linux 系统中，值 -20 使得一项任务变得非常重要；与之相反，如果任务的 nice 为 +19 ，则表示它是一个高尚的、无私的任务，允许所有其他任务比自己享有宝贵的 CPU 时间的更大使用份额，这也就是 nice 的名称的来意。默认优先级是 0 。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 运行程序时可指定 nice 值</span><br><span class="line">nice -n -5 vim a.txt</span><br><span class="line"># 使用 renice 修改正在运行进程的优先级</span><br><span class="line">renice -n 6 23305</span><br></pre></td></tr></table></figure>

<h4 id="CPU-亲和性"><a href="#CPU-亲和性" class="headerlink" title="CPU 亲和性"></a>CPU 亲和性</h4><p>在多核的情况下，可以使用 taskset 命令指定一个进程在哪颗 CPU 上执行程序，减少进程在不同 CPU 之间切换的开销。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 使用 top 命令，按下数字 1，可以看到 CPU 各个核心的情况</span><br><span class="line"># 假设 CPU 有四个核心，则其编号一般是 0,1,2,3</span><br><span class="line"># 以下命令指定程序运行在第三个核心上</span><br><span class="line">taskset -c 0,2 vim a.txt</span><br><span class="line"># 以下命令可以查看指定进程的 CPU 亲和列表，若未指定 CPU 亲和性，则结果中默认会列出所有的 CPU 核心</span><br><span class="line">taskset -cp 1316</span><br></pre></td></tr></table></figure>

<h4 id="Nginx-使用多进程而不是多线程"><a href="#Nginx-使用多进程而不是多线程" class="headerlink" title="Nginx 使用多进程而不是多线程"></a>Nginx 使用多进程而不是多线程</h4><p>Nginx 要保证它的高可用高可靠性，若使用多线程，由于线程之间是共享同一个地址空间的，当某一个第三方模块引发了一个地址空间的段错误时（例如：地址越界），会导致整个 Nginx 全部挂掉；当采用多进程来实现时，往往不会出现这个问题。</p>
<h4 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h4><p><img src="https://cdn.nlark.com/yuque/0/2020/png/182657/1598691917078-859b6014-e14a-40f5-b73b-e7a290079d48.png#align=left&display=inline&height=670&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1339&originWidth=1562&size=646894&status=done&style=none&width=781" alt="image.png"></p>
<h4 id="subreaper-进程"><a href="#subreaper-进程" class="headerlink" title="subreaper 进程"></a>subreaper 进程</h4><p>当用户态通过 prctl(PR_SET_CHILD_SUBREAPER,1) 的时候就是让当前进程像 init 进程一样来收养孤儿进程，称为 subreaper 进程。</p>
<h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ul>
<li><a href="http://abcdxyzk.github.io/blog/2018/01/10/kernel-task-thread/" target="_blank" rel="external nofollow noopener noreferrer">http://abcdxyzk.github.io/blog/2018/01/10/kernel-task-thread/</a></li>
<li><a href="https://blog.csdn.net/gatieme/article/details/50779184" target="_blank" rel="external nofollow noopener noreferrer">https://blog.csdn.net/gatieme/article/details/50779184</a></li>
<li><a href="https://learn-linux.readthedocs.io/zh_CN/latest/system-programming/syscall/principle.html" target="_blank" rel="external nofollow noopener noreferrer">https://learn-linux.readthedocs.io/zh_CN/latest/system-programming/syscall/principle.html</a></li>
<li><a href="https://xnerv.wang/linux-process-kernel-and-file-system-summary/" target="_blank" rel="external nofollow noopener noreferrer">https://xnerv.wang/linux-process-kernel-and-file-system-summary/</a></li>
<li>内核态与用户态：<a href="https://www.cnblogs.com/viviwind/archive/2012/09/22/2698450.html" target="_blank" rel="external nofollow noopener noreferrer">https://www.cnblogs.com/viviwind/archive/2012/09/22/2698450.html</a></li>
<li><a href="https://www.wikiwand.com/en/System_call" target="_blank" rel="external nofollow noopener noreferrer">https://www.wikiwand.com/en/System_call</a></li>
<li>进程切换：<a href="https://www.jianshu.com/p/c68de44edb98" target="_blank" rel="external nofollow noopener noreferrer">https://www.jianshu.com/p/c68de44edb98</a></li>
<li>进程切换：<a href="https://blog.csdn.net/Hatsune_Miku_/article/details/77851218" target="_blank" rel="external nofollow noopener noreferrer">https://blog.csdn.net/Hatsune<em>Miku</em>/article/details/77851218</a></li>
<li><a href="https://www.cnblogs.com/Anker/p/3269106.html" target="_blank" rel="external nofollow noopener noreferrer">https://www.cnblogs.com/Anker/p/3269106.html</a></li>
<li><a href="https://docs.memset.com/other/linux-s-oom-process-killer#:~:text=The%20%22OOM%20Killer%22%20or%20%22,is%20critically%20low%20on%20memory.&text=This%20maximises%20the%20use%20of,processes%20is%20being%20actively%20used." target="_blank" rel="external nofollow noopener noreferrer">Linux’s OOM Process Killer</a>  描述了进程查看是否有进程 OOM 和如何优化</li>
<li><a href="https://linux-mm.org/OOM_Killer" target="_blank" rel="external nofollow noopener noreferrer">LinuxMM: OOM_Killer</a>  中描述了 oom killer 相关函数的一些细节</li>
<li>内核文档关于 OOM 的说明：<a href="https://www.kernel.org/doc/gorman/html/understand/understand016.html" target="_blank" rel="external nofollow noopener noreferrer">https://www.kernel.org/doc/gorman/html/understand/understand016.html</a></li>
<li>改变进程 OOM 的分数：<a href="https://www.oracle.com/technical-resources/articles/it-infrastructure/dev-oom-killer.html" target="_blank" rel="external nofollow noopener noreferrer">https://www.oracle.com/technical-resources/articles/it-infrastructure/dev-oom-killer.html</a></li>
<li>oom_score 的计算：<a href="https://unix.stackexchange.com/a/153586" target="_blank" rel="external nofollow noopener noreferrer">https://unix.stackexchange.com/a/153586</a></li>
<li><a href="https://blog.csdn.net/weixin_44344462/article/details/97180648" target="_blank" rel="external nofollow noopener noreferrer">Linux 进程间互斥锁 （共享内存实现）</a>，<a href="https://blog.csdn.net/u012385733/article/details/80057461" target="_blank" rel="external nofollow noopener noreferrer">进程间同步之 mutex 锁</a>，<a href="https://blog.csdn.net/jinguangliu/article/details/71773784" target="_blank" rel="external nofollow noopener noreferrer">使用文件锁实现进程间同步</a>，<a href="https://www.zybuluo.com/lishuhuakai/note/562247" target="_blank" rel="external nofollow noopener noreferrer">多进程之间的文件锁</a>，<a href="https://zhuanlan.zhihu.com/p/25134841" target="_blank" rel="external nofollow noopener noreferrer">被遗忘的桃源——flock 文件锁</a>，<a href="https://blog.csdn.net/u011244446/article/details/47313963" target="_blank" rel="external nofollow noopener noreferrer">Linux 进程间互斥锁</a></li>
<li><a href="https://gravitational.com/blog/golang-ssh-bastion-graceful-restarts" target="_blank" rel="external nofollow noopener noreferrer">golang-ssh-bastion-graceful-restarts</a></li>
<li><a href="https://www.cnblogs.com/sxhlinux/p/6767484.html" target="_blank" rel="external nofollow noopener noreferrer">https://www.cnblogs.com/sxhlinux/p/6767484.html</a></li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>MongoDB 使用</title>
    <url>/post/f07e554d.html</url>
    <content><![CDATA[<h4 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 选择数据库</span><br><span class="line">use testdb;</span><br><span class="line">&#x2F;&#x2F; 打印所有文档</span><br><span class="line">db.clusters.find().pretty();</span><br><span class="line">&#x2F;&#x2F; 删除文档</span><br><span class="line">db.clusters.remove(&#123;&quot;name&quot;: &quot;test&quot;&#125;);</span><br><span class="line">db.workspaces.remove(&#123;&quot;createTime&quot;: &#123; $gte : new ISODate(&quot;2021-07-01T20:15:31Z&quot;) &#125;&#125;)</span><br><span class="line">&#x2F;&#x2F; 更新文档</span><br><span class="line">db.clusters.update(&#123;&#39;name&#39;:&#39;test100&#39;&#125;,&#123;$set:&#123;&#39;kubeConfig&#39;:&#39;111&#39;&#125;&#125;)</span><br><span class="line">db.workspaces.updateMany(&#123;&quot;createTime&quot;: &#123; $gte : new ISODate(&quot;2021-07-05T06:43:18.456Z&quot;) , $lte : new ISODate(&quot;2021-07-05T06:53:18.456Z&quot;) &#125;&#125;,&#123;$set:&#123;&#39;creator.acctID&#39;: new NumberLong(&quot;2100000924&quot;)&#125;&#125;)</span><br><span class="line">&#x2F;&#x2F; 插入文档</span><br><span class="line">db.records.insertOne(&#123;&quot;RunID&quot;:&quot;606d866135cece2969a106c9&quot;&#125;)</span><br><span class="line">&#x2F;&#x2F; 创建索引</span><br><span class="line">db.pipelines.createIndex(&#123;&quot;triggerTime&quot;: -1, &quot;createTime&quot;: -1&#125;)</span><br><span class="line">&#x2F;&#x2F; 查看索引</span><br><span class="line">db.pipelines.getIndexes()</span><br><span class="line">&#x2F;&#x2F; 删除索引</span><br><span class="line">db.col.dropIndexes()</span><br><span class="line">db.pipelines.dropIndex(&quot;索引名称&quot;)</span><br><span class="line">&#x2F;&#x2F; 复制文档</span><br><span class="line">var newOne &#x3D; db.clusters.findOne(&#123;name: &#39;devbox&#39;&#125;)</span><br><span class="line">newOne._id &#x3D; ObjectId(&#39;60702cf406aa28fd97c11011&#39;)</span><br><span class="line">db.clusters.insertOne(newOne)</span><br><span class="line">&#x2F;&#x2F; 备份数据库</span><br><span class="line">mongodump -d cp -o mongo-cp</span><br><span class="line">&#x2F;&#x2F; 恢复数据库</span><br><span class="line">mongorestore -d cp cp</span><br><span class="line">&#x2F;&#x2F; 从 json 导入数据</span><br><span class="line">mongoimport --db test --collection docs --file example2.json</span><br></pre></td></tr></table></figure><a id="more"></a>

<h4 id="K8S-中部署-MongoDB-副本集"><a href="#K8S-中部署-MongoDB-副本集" class="headerlink" title="K8S 中部署 MongoDB 副本集"></a>K8S 中部署 MongoDB 副本集</h4><p>参考：<a href="https://kubernetes.io/blog/2017/01/running-mongodb-on-kubernetes-with-statefulsets/" target="_blank" rel="external nofollow noopener noreferrer">https://kubernetes.io/blog/2017/01/running-mongodb-on-kubernetes-with-statefulsets/</a></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">mongo</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">mongo</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">mongo</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">27017</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">27017</span></span><br><span class="line">  <span class="attr">clusterIP:</span> <span class="string">None</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">mongo</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">StatefulSet</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">mongo</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">mongo</span></span><br><span class="line">  <span class="attr">serviceName:</span> <span class="string">"mongo"</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">3</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">mongo</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">serviceAccountName:</span> <span class="string">mongo</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">mongo</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">mongo:latest</span></span><br><span class="line">        <span class="attr">command:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">mongod</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">"--bind_ip_all"</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">"--replSet"</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">rs0</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">27017</span></span><br><span class="line">        <span class="attr">volumeMounts:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">mongo-data</span></span><br><span class="line">          <span class="attr">mountPath:</span> <span class="string">/data/db</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">mongo-sidecar</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">cvallance/mongo-k8s-sidecar</span></span><br><span class="line">        <span class="attr">env:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">MONGO_SIDECAR_POD_LABELS</span></span><br><span class="line">          <span class="attr">value:</span> <span class="string">"app=mongo"</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">KUBE_NAMESPACE</span></span><br><span class="line">          <span class="attr">valueFrom:</span></span><br><span class="line">            <span class="attr">fieldRef:</span></span><br><span class="line">              <span class="attr">fieldPath:</span> <span class="string">metadata.namespace</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">KUBERNETES_MONGO_SERVICE_NAME</span></span><br><span class="line">          <span class="attr">value:</span> <span class="string">"mongo"</span></span><br><span class="line">      <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">mongo-data</span></span><br><span class="line">        <span class="attr">emptyDir:</span> <span class="string">&#123;&#125;</span></span><br><span class="line"> <span class="string">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ServiceAccount</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">mongo</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">mongo</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">mongo</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Role</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">mongo</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">mongo</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">mongo</span></span><br><span class="line"><span class="attr">rules:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">apiGroups:</span> <span class="string">[</span> <span class="string">""</span> <span class="string">]</span></span><br><span class="line">    <span class="attr">resources:</span> <span class="string">[</span> <span class="string">"pods"</span> <span class="string">]</span></span><br><span class="line">    <span class="attr">verbs:</span> <span class="string">[</span> <span class="string">"list"</span> <span class="string">]</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">RoleBinding</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">mongo</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">mongo</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">mongo</span></span><br><span class="line"><span class="attr">roleRef:</span></span><br><span class="line">  <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br><span class="line">  <span class="attr">kind:</span> <span class="string">Role</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">mongo</span></span><br><span class="line"><span class="attr">subjects:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">ServiceAccount</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">mongo</span></span><br></pre></td></tr></table></figure>

<p>部署完成进行初始化（如果以上 yaml 中的 sidecar 工作正常就不需要手动初始化）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kd-cp <span class="built_in">exec</span> -it -n mongo mongo-0 -- bash</span><br><span class="line">// 进入 mongo 交互窗口</span><br><span class="line">cfg = &#123; _id:<span class="string">"rs0"</span> , members: [&#123; _id: 0, host: <span class="string">"mongo-0.mongo.mongo"</span>&#125;,&#123; _id: 1, host: <span class="string">"mongo-1.mongo.mongo"</span>&#125;,&#123; _id: 2, host: <span class="string">"mongo-2.mongo.mongo"</span>&#125;] &#125;;</span><br><span class="line">rs.initiate(cfg)</span><br><span class="line">rs.status()</span><br></pre></td></tr></table></figure>

<p>连接数据库使用如下 URL：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mongodb://mongo-0.mongo.mongo,mongo-1.mongo.mongo,mongo-2.mongo.mongo/?replicaSet=rs0</span><br></pre></td></tr></table></figure>

<p>如此部署的 MongoDB 只能在 K8S 集群中使用。</p>
<h4 id="watch-字段变化"><a href="#watch-字段变化" class="headerlink" title="watch 字段变化"></a>watch 字段变化</h4><p>参考：<a href="https://www.cnblogs.com/flipped/p/mongo-watch-specified-fields.html" target="_blank" rel="external nofollow noopener noreferrer">https://www.cnblogs.com/flipped/p/mongo-watch-specified-fields.html</a><br>可以 watch 的事件类型： <a href="https://docs.mongodb.com/manual/reference/change-events/" target="_blank" rel="external nofollow noopener noreferrer">https://docs.mongodb.com/manual/reference/change-events/</a></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">func</span> <span class="string">watch(coll</span> <span class="string">*mongo.Collection)</span> <span class="string">&#123;</span></span><br><span class="line"><span class="string">match</span> <span class="string">:=</span> <span class="string">bson.D&#123;&#123;"operationType",</span> <span class="string">"update"</span><span class="string">&#125;,</span></span><br><span class="line"><span class="string">&#123;"updateDescription.updatedFields.name",</span> <span class="string">bson.D&#123;&#123;"$exists",</span> <span class="literal">true</span><span class="string">&#125;&#125;&#125;&#125;</span></span><br><span class="line"><span class="string">coll.Watch(context.Background(),</span> <span class="string">mongo.Pipeline&#123;&#123;&#123;"$match",</span> <span class="string">match&#125;&#125;&#125;,</span></span><br><span class="line"><span class="string">options.ChangeStream().SetFullDocument(options.UpdateLookup))</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="bson-反序列化到结构体"><a href="#bson-反序列化到结构体" class="headerlink" title="bson 反序列化到结构体"></a>bson 反序列化到结构体</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">cluster = ⊧.Cluster&#123;&#125;</span><br><span class="line"><span class="keyword">if</span> fullDocument, ok := fullDocument.(bson.M); ok &#123;</span><br><span class="line">    data, _ := bson.Marshal(fullDocument)</span><br><span class="line">    <span class="comment">// 使用 bson.Unmarshal 应该也可以</span></span><br><span class="line">    _ = bson.UnmarshalWithRegistry(bson.DefaultRegistry, data, cluster)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="性能调优"><a href="#性能调优" class="headerlink" title="性能调优"></a>性能调优</h4><h4 id="更新多层数组结构嵌套的数据"><a href="#更新多层数组结构嵌套的数据" class="headerlink" title="更新多层数组结构嵌套的数据"></a>更新多层数组结构嵌套的数据</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Post.findOneAndUpdate(</span><br><span class="line">   &#123; <span class="string">'posts.replies._id'</span>: _id &#125;,</span><br><span class="line">   &#123; <span class="variable">$set</span>: &#123; <span class="string">'posts.$[post].replies.$[reply].text'</span>: <span class="string">"something1"</span> &#125; &#125;,</span><br><span class="line">   &#123; arrayFilters: [&#123; <span class="string">'post._id'</span>: postId &#125;, &#123; <span class="string">'reply._id'</span>: _id &#125;]&#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者先查出目标的索引然后使用索引来更新</span></span><br><span class="line">Post.findOneAndUpdate(</span><br><span class="line">   &#123; <span class="string">'posts.replies._id'</span>: _id &#125;,</span><br><span class="line">   &#123; <span class="variable">$set</span>: &#123; <span class="string">'posts.0.replies.2.text'</span>: <span class="string">"something1"</span> &#125; &#125;,</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>PostgreSQL 使用</title>
    <url>/post/8d587d49.html</url>
    <content><![CDATA[<h4 id="修改用户密码"><a href="#修改用户密码" class="headerlink" title="修改用户密码"></a>修改用户密码</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo -u postgres psql</span><br><span class="line">ALTER USER postgres WITH PASSWORD <span class="string">'postgres'</span>;</span><br></pre></td></tr></table></figure><h4 id="备份和恢复数据库"><a href="#备份和恢复数据库" class="headerlink" title="备份和恢复数据库"></a>备份和恢复数据库</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 备份</span><br><span class="line">pg_dump mydatabase &gt; data.backup</span><br><span class="line">// 恢复</span><br><span class="line">psql</span><br><span class="line">create database mydatabase;</span><br><span class="line">psql -f data.backup mydatabase</span><br></pre></td></tr></table></figure><a id="more"></a>



<h4 id="通用的可操作多种数据库的命令行工具"><a href="#通用的可操作多种数据库的命令行工具" class="headerlink" title="通用的可操作多种数据库的命令行工具"></a>通用的可操作多种数据库的命令行工具</h4><p><a href="https://github.com/xo/usql" target="_blank" rel="external nofollow noopener noreferrer">https://github.com/xo/usql</a></p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>Proxmox 使用拾遗</title>
    <url>/post/399a617a.html</url>
    <content><![CDATA[<h4 id="zfs-destroy-提示-dataset-is-busy"><a href="#zfs-destroy-提示-dataset-is-busy" class="headerlink" title="zfs destroy 提示 dataset is busy"></a>zfs destroy 提示 dataset is busy</h4><p>报错如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@umstor22:~<span class="comment"># zfs destroy -r umstor22-zfs</span></span><br><span class="line">cannot destroy <span class="string">'umstor22-zfs/vm-109-disk-0'</span>: dataset is busy</span><br><span class="line">cannot destroy <span class="string">'umstor22-zfs/vm-109-disk-2'</span>: dataset is busy</span><br><span class="line">cannot destroy <span class="string">'umstor22-zfs/vm-109-disk-1'</span>: dataset is busy</span><br></pre></td></tr></table></figure><a id="more"></a>


<p>首先使用 fuser 查看挂载了相关虚拟设备的进程：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@umstor22:~<span class="comment"># fuser -am /dev/umstor22-zfs/vm-109-disk-0</span></span><br><span class="line">/dev/zd0:            2133532</span><br><span class="line">root@umstor22:~<span class="comment"># fuser -am /dev/umstor22-zfs/vm-109-disk-1</span></span><br><span class="line">/dev/zd16:           2133532</span><br><span class="line">root@umstor22:~<span class="comment"># fuser -am /dev/umstor22-zfs/vm-109-disk-2</span></span><br><span class="line">/dev/zd32:           2133532</span><br></pre></td></tr></table></figure>

<p>然后查看进程号为  2133532 的进程信息：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@umstor22:~<span class="comment"># ps aux | grep 2133532</span></span><br><span class="line">root     1832619  0.0  0.0   6072   892 pts/0    S+   11:41   0:00 grep 2133532</span><br><span class="line">root     2133532  3.2  0.1 9705992 105132 ?      Sl   Sep02  42:19 /usr/bin/kvm -id 109 -name yf01 -chardev socket,id=qmp,path=/var/run/qemu-server/109.qmp,server,nowait -mon chardev=qmp,mode=control -chardev socket,id=qmp-event,path=/var/run/qmeventd.sock,reconnect=5 -mon chardev=qmp-event,mode=control -pidfile /var/run/qemu-server/109.pid -daemonize -smbios <span class="built_in">type</span>=1,uuid=3969d5bf-1597-4834-ac82-bc89de18495a -smp 8,sockets=2,cores=4,maxcpus=8 -nodefaults -boot menu=on,strict=on,reboot-timeout=1000,splash=/usr/share/qemu-server/bootsplash.jpg -vnc unix:/var/run/qemu-server/109.vnc,password -cpu kvm64,+lahf_lm,+sep,+kvm_pv_unhalt,+kvm_pv_eoi,enforce -m 8192 -device pci-bridge,id=pci.1,chassis_nr=1,bus=pci.0,addr=0x1e -device pci-bridge,id=pci.2,chassis_nr=2,bus=pci.0,addr=0x1f -device vmgenid,guid=b917480a-d4f1-4d4d-869e-632b6a9d7769 -device piix3-usb-uhci,id=uhci,bus=pci.0,addr=0x1.0x2 -device usb-tablet,id=tablet,bus=uhci.0,port=1 -device VGA,id=vga,bus=pci.0,addr=0x2 -chardev socket,path=/var/run/qemu-server/109.qga,server,nowait,id=qga0 -device virtio-serial,id=qga0,bus=pci.0,addr=0x8 -device virtserialport,chardev=qga0,name=org.qemu.guest_agent.0 -device virtio-balloon-pci,id=balloon0,bus=pci.0,addr=0x3 -iscsi initiator-name=iqn.1993-08.org.debian:01:c024a4d1a487 -drive file=rbd:cloud-disk/vm-109-cloudinit:conf=/etc/pve/ceph.conf:id=admin:keyring=/etc/pve/priv/ceph/ceph.keyring,<span class="keyword">if</span>=none,id=drive-ide0,media=cdrom,aio=threads -device ide-cd,bus=ide.0,unit=0,drive=drive-ide0,id=ide0,bootindex=200 -device virtio-scsi-pci,id=scsihw0,bus=pci.0,addr=0x5 -drive file=/dev/zvol/umstor22-zfs/vm-109-disk-0,<span class="keyword">if</span>=none,id=drive-scsi0,format=raw,cache=none,aio=native,detect-zeroes=on -device scsi-hd,bus=scsihw0.0,channel=0,scsi-id=0,lun=0,drive=drive-scsi0,id=scsi0,bootindex=100 -drive file=/dev/zvol/umstor22-zfs/vm-109-disk-1,<span class="keyword">if</span>=none,id=drive-scsi1,format=raw,cache=none,aio=native,detect-zeroes=on -device scsi-hd,bus=scsihw0.0,channel=0,scsi-id=0,lun=1,drive=drive-scsi1,id=scsi1 -drive file=/dev/zvol/umstor22-zfs/vm-109-disk-2,<span class="keyword">if</span>=none,id=drive-scsi2,format=raw,cache=none,aio=native,detect-zeroes=on -device scsi-hd,bus=scsihw0.0,channel=0,scsi-id=0,lun=2,drive=drive-scsi2,id=scsi2 -drive file=rbd:cloud-disk/vm-109-disk-0:conf=/etc/pve/ceph.conf:id=admin:keyring=/etc/pve/priv/ceph/ceph.keyring,<span class="keyword">if</span>=none,id=drive-scsi3,format=raw,cache=none,aio=native,detect-zeroes=on -device scsi-hd,bus=scsihw0.0,channel=0,scsi-id=0,lun=3,drive=drive-scsi3,id=scsi3 -drive file=rbd:cloud-disk/vm-109-disk-2:conf=/etc/pve/ceph.conf:id=admin:keyring=/etc/pve/priv/ceph/ceph.keyring,<span class="keyword">if</span>=none,id=drive-scsi4,format=raw,cache=none,aio=native,detect-zeroes=on -device scsi-hd,bus=scsihw0.0,channel=0,scsi-id=0,lun=4,drive=drive-scsi4,id=scsi4 -drive file=rbd:cloud-disk/vm-109-disk-5:conf=/etc/pve/ceph.conf:id=admin:keyring=/etc/pve/priv/ceph/ceph.keyring,<span class="keyword">if</span>=none,id=drive-scsi5,format=raw,cache=none,aio=native,detect-zeroes=on -device scsi-hd,bus=scsihw0.0,channel=0,scsi-id=0,lun=5,drive=drive-scsi5,id=scsi5 -netdev <span class="built_in">type</span>=tap,id=net0,ifname=tap109i0,script=/var/lib/qemu-server/pve-bridge,downscript=/var/lib/qemu-server/pve-bridgedown,vhost=on -device virtio-net-pci,mac=1A:D3:33:5C:92:DF,netdev=net0,bus=pci.0,addr=0x12,id=net0,bootindex=300 -machine <span class="built_in">type</span>=pc-i440fx-4.0 -incoming unix:/run/qemu-server/109.migrate -S</span><br></pre></td></tr></table></figure>

<p>可知，该进程为一个 kvm 虚拟机的进程，杀掉进程后重新执行 destroy 即可：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">kill</span> -9 2133532</span><br><span class="line">zfs destroy -r umstor22-zfs</span><br><span class="line">zpool destroy umstor22-zfs</span><br></pre></td></tr></table></figure>

<ul>
<li>vm is locked</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">qm unlock 101</span><br></pre></td></tr></table></figure>

<h4 id="zfs-基本用法"><a href="#zfs-基本用法" class="headerlink" title="zfs 基本用法"></a>zfs 基本用法</h4><p>参考：<a href="https://www.thegeekdiary.com/zfs-tutorials-creating-zfs-pools-and-file-systems/" target="_blank" rel="external nofollow noopener noreferrer">https://www.thegeekdiary.com/zfs-tutorials-creating-zfs-pools-and-file-systems/</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 创建完 pool 就直接在 /poolname 下自动挂载了</span><br><span class="line">zpool create poolname /dev/sdc /dev/sdd</span><br><span class="line">zpool status</span><br><span class="line">zfs create poolname/fs1</span><br><span class="line">zfs list</span><br><span class="line">NAME           USED  AVAIL  REFER  MOUNTPOINT</span><br><span class="line">poolname       131K   976M    31K  /poolname</span><br><span class="line">poolname/fs1    31K   976M    31K  /poolname/fs1</span><br></pre></td></tr></table></figure>

<h4 id="添加-CE-版-Proxmox-Debian-源"><a href="#添加-CE-版-Proxmox-Debian-源" class="headerlink" title="添加 CE 版   Proxmox Debian 源"></a>添加 CE 版   Proxmox Debian 源</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">deb http://download.proxmox.com/debian/pve buster pve-no-subscription</span><br></pre></td></tr></table></figure>

<h4 id="在-Proxmox-集群之间迁移虚拟机"><a href="#在-Proxmox-集群之间迁移虚拟机" class="headerlink" title="在 Proxmox 集群之间迁移虚拟机"></a>在 Proxmox 集群之间迁移虚拟机</h4><p>参考：<a href="https://cyberpersons.com/2016/09/13/backup-transfer-proxmox-vm-another-proxmox-node/" target="_blank" rel="external nofollow noopener noreferrer">https://cyberpersons.com/2016/09/13/backup-transfer-proxmox-vm-another-proxmox-node/</a></p>
<ol>
<li>创建虚拟机备份</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Change directory where backups are stored</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> /var/lib/vz/dump</span><br><span class="line"></span><br><span class="line"><span class="comment"># create backup</span></span><br><span class="line"></span><br><span class="line">vzdump 100</span><br><span class="line"></span><br><span class="line"><span class="comment"># this will create backup for vm id 100</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>拷贝到新集群宿主机</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># change directory</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> /var/lib/vz/dump</span><br><span class="line"></span><br><span class="line">scp vzdump-qemu-122-2016_09_13-14_12_32.vma root@192.168.1.1:/var/lib/vz/dump/vzdump-qemu-122-2016_09_13-14_12_32.vma</span><br><span class="line"></span><br><span class="line"><span class="comment"># this is one single command</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>恢复虚拟机</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /var/lib/vz/dump</span><br><span class="line"></span><br><span class="line">qmrestore vzdump-qemu-122-2016_09_13-14_12_32.vma 500</span><br></pre></td></tr></table></figure>

<h4 id="从集群中删除节点"><a href="#从集群中删除节点" class="headerlink" title="从集群中删除节点"></a>从集群中删除节点</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pvecm nodes</span><br><span class="line">pvecm delnode node1</span><br></pre></td></tr></table></figure>

<h4 id="国内镜像"><a href="#国内镜像" class="headerlink" title="国内镜像"></a>国内镜像</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;proxmox&#x2F;</span><br><span class="line">http:&#x2F;&#x2F;download.proxmox.wiki&#x2F;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Proxmox</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Proxmox</tag>
      </tags>
  </entry>
  <entry>
    <title>Netfilter 框架及其周边组件</title>
    <url>/post/d617cc74.html</url>
    <content><![CDATA[<h3 id="Netfilter"><a href="#Netfilter" class="headerlink" title="Netfilter"></a>Netfilter</h3><p>Netfilter 是  Linux 2.4.x 及后续版本内核引入的包过滤框架。Netfilter 包含了一组内核钩子 API ，周边内核组件可以使用这些钩子在网络栈中注册回调函数。每一个在网络栈中流通的包到达相应的钩子时，就会触发相应的回调函数，从而能够完成包过滤、网络地址（端口）转换和网络包协议头修改等各种操作。<br>Netfilter 提供了五种钩子（参考<a href="https://medium.com/@GoldenOak/linux-kernel-communication-part-1-netfilter-hooks-15c07a5a5c4e" target="_blank" rel="external nofollow noopener noreferrer">Linux Kernel Communication — Netfilter Hooks</a>），如下：<br><img src="https://cdn.nlark.com/yuque/0/2019/png/182657/1576396676777-643a7090-d522-4f7b-a4a8-e1d20742681a.png#align=left&display=inline&height=237&margin=%5Bobject%20Object%5D&name=image.png&originHeight=474&originWidth=1330&size=35302&status=done&style=none&width=665" alt="image.png"></p><a id="more"></a>
<ol>
<li>NF_IP_PER_ROUNTING — 当数据包到达计算机立即触发。</li>
<li>NF_IP_LOCAL_IN — 当数据包的目的地就是当前计算机时触发。</li>
<li>NF_IP_FORWARD — 当数据包目的地址是其它的网络接口时触发。</li>
<li>NF_IP_POST_ROUTING — 当数据包即将从计算机发出时触发。</li>
<li>NF_IP_LOCAL_OUT — 当数据包由本地生成并发向外部时触发。</li>
</ol>
<p>基于 Netfilter 钩子 API 实现的内核模块主要有 ebtables、arptables、ip(6)tables、nf_tables、NAT、connection tracking 等。如下是维基百科上关于 Netfilter 相关组件的一张示意图：<br><img src="https://cdn.nlark.com/yuque/0/2019/png/182657/1576376326201-8e54e0c3-4710-47c7-ae4d-07f66be4452f.png#align=left&display=inline&height=421&margin=%5Bobject%20Object%5D&name=image.png&originHeight=451&originWidth=800&size=58313&status=done&style=none&width=746" alt="image.png"><br>下图是数据包在 Netfilter 框架中的流动过程：<br><img src="https://cdn.nlark.com/yuque/0/2019/png/182657/1576390222986-8e61ba27-7ac7-4695-a7e0-0ad91e7ee581.png#align=left&display=inline&height=215&margin=%5Bobject%20Object%5D&name=image.png&originHeight=475&originWidth=1650&size=186592&status=done&style=none&width=746" alt="image.png"></p>
<h3 id="ebtables"><a href="#ebtables" class="headerlink" title="ebtables"></a>ebtables</h3><p>ebtables  是以太网桥防火墙，以太网桥工作在数据链路层，ebtables 主要用来过滤链路层数据包。使用 ebtables 可以实现 filtering 、NAT 和 brouting。过滤根据 MAC 头包括 VLAN ID 等信息确定是否丢弃该帧。MAC NAT 可以修改 MAC 源和目的地址。Brouting 意为 bridge or route，根据规则确定应该将数据帧路由给上层（iptables）还是通过网桥转给其它的接口。<br>ebtables 和我们熟悉的 iptables 很像，也有规则（rules）、链（chains）和表（tables）的概念。ebtables 使用规则确定应当对数据帧执行什么动作。规则按照不同的链分组，不同的表中包含不同的链。在 ebtables 中有三张表：filter、nat 和 broute，分别对应其三大功能模块。<br>需要注意的是如果一个以太网接口 eth1，它并没有桥接到网桥上，此时，从 eth1 进来的数据包不会走到 ebtables 中。在 bridge check 点，会检查数据包进入的接口是否属于某个桥，如果是则走 ebtables，否则直接走 iptables。也就是说，ebtables 只对桥接网络生效。</p>
<h4 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h4><ul>
<li>INPUT 链：当数据帧的目的 MAC 地址是网桥的 MAC 地址时，这条链上的过滤规则会被应用。</li>
<li>FORWARD 链：当数据帧将要被网桥转发给其它接口时，这条链上的过滤规则会被应用。</li>
<li>OUTPUT 链：当数据帧由本地产生或者已经完成路由时。</li>
</ul>
<h4 id="nat"><a href="#nat" class="headerlink" title="nat"></a>nat</h4><ul>
<li>PREROUTING 链：当数据帧到达时会立即执行该链上的规则。</li>
<li>OUTPUT 链：对于本地生成的或者已经完成路由的数据帧，在被桥接之前进行修改。</li>
<li>POSTROUTING 链：在数据帧被发送之前进行修改。</li>
</ul>
<h4 id="broute"><a href="#broute" class="headerlink" title="broute"></a>broute</h4><ul>
<li>BROUTING 链：应用规则决定对数据帧进行 bridge or route。</li>
</ul>
<p>下图是一个 iptables 与 ebtables 工作流图：<br><img src="https://cdn.nlark.com/yuque/0/2019/png/182657/1576390449967-dd24ea02-2232-41fd-bd07-33aea0a350de.png#align=left&display=inline&height=352&margin=%5Bobject%20Object%5D&name=image.png&originHeight=703&originWidth=1696&size=126471&status=done&style=none&width=848" alt="image.png"></p>
<h3 id="arptables"><a href="#arptables" class="headerlink" title="arptables"></a>arptables</h3><p>arptables 和 ebtables 相似，区别在于 arptables 不局限于桥接网络且是专门用来配置和处理 ARP 消息相关的规则。</p>
<h3 id="iptables"><a href="#iptables" class="headerlink" title="iptables"></a>iptables</h3><p>正是基于 Netfilter 钩子 API 的共同点，iptables 和 ebtables 的工作机制相似，区别是 iptables 工作在 OSI 网络模型的三层和四层。<br>iptables 提供的功能主要有：</p>
<ul>
<li>无状态数据包过滤。</li>
<li>有状态数据包过滤：iptables 可以识别到如 ftp 数据包的连接状态，从而基于连接状态能够提供更多的过滤功能。</li>
<li>网络地址（端口）转换：iptables 可以修改数据包的协议头信息包括 IP 地址和 TCP/UDP 端口。</li>
</ul>
<p>一般的说法是 iptables 包含四张表：filter、nat、mangle 和 raw ，但是通过 man 查看 iptables 的使用手册可以看到最新的 iptables 还有 security 表，但是 security 的应用确实也不是很常见，所以这里仍然沿用四张表的说法。filter 表顾名思义主要是根据规则对数据包进行过滤，nat 表则是根据规则进行地址转换，mangle 表用于一些专门的修改操作，例如修改包头中的 TOS（服务类型）字段，raw 表则是在数据包进入 connection tracking 之前应用一些规则进行修改操作。<br>NAT 又有 SNAT、DNAT 、NAPT 和 MASQUERADE 各种术语。SNAT 意味着更改数据包的源 IP 地址。DNAT 则是更改数据包的目的 IP 地址。NAPT 则是进行端口转发，即修改数据包的 TCP/UDP 端口。MASQUERADE 是 SNAT 的特例，可称为动态 SNAT ，它是用发送数据的网卡上的 IP 来替换源 IP，因此，对于那些 IP 不固定的场合，比如拨号网络或者通过 DHCP 分配 IP 的情况下，需要用 MASQUERADE。以下是一些示例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// SNAT 必须指定目标 IP</span><br><span class="line">// 更改数据包的源 IP 地址为 1.2.3.4</span><br><span class="line">iptables -t nat -A POSTROUTING -o eth0 -j SNAT --to 1.2.3.4</span><br><span class="line">// 把所有 10.8.0.0 网段的数据包 SNAT 成 192.168.5.3/192.168.5.4/192.168.5.5 几个 IP 然后发出去</span><br><span class="line">iptables -t nat -A POSTROUTING -s 10.8.0.0/255.255.255.0 -o eth0 -j SNAT --to-source 192.168.5.3-192.168.5.5</span><br><span class="line">// 更改数据包的目的 IP 地址为 1.2.3.4</span><br><span class="line">iptables -t nat -A PREROUTING -i eth0 -j DNAT --to 1.2.3.4</span><br><span class="line">// 将从 eth0 进入的目标端口为 80 的数据包转发到 192.168.1.200 的 8080 端口</span><br><span class="line">iptables -t nat -A PREROUTING -i etho --dport 80 -j DNAT --to-destination 192.168.1.200:8080</span><br><span class="line">// MASQUERADE 不用指定 SNAT 的目标 IP ，不管现在 eth0 的出口获得了怎样的动态 IP</span><br><span class="line">// MASQUERADE 会自动读取 eth0 现在的 IP 地址然后做 SNAT 出去</span><br><span class="line">// 这样就实现了很好的动态 SNAT 地址转换</span><br><span class="line">iptables -t nat -A POSTROUTING -s 10.8.0.0/255.255.255.0 -o eth0 -j MASQUERADE</span><br></pre></td></tr></table></figure>

<p>一张可供参考的 iptables 工作流图，需要注意的是只有对发起新连接（包括和已经存在的连接有 related 关系的请求）的请求才会去重新匹配 nat 表中的规则，而其它表中的规则对每一个到来的数据包都会匹配一遍，这得益于基于 Netfilter 的另一个组件 connection tracking 系统，它记录了每一个连接的信息，从而使得同一个连接上的数据包不必经过重新匹配 nat 规则就可获知应当如何传递。<br><img src="https://cdn.nlark.com/yuque/0/2019/png/182657/1576394377796-20f9f09a-67df-418a-96a0-96c9201f59c5.png#align=left&display=inline&height=851&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1133&originWidth=730&size=78757&status=done&style=none&width=548" alt="image.png"></p>
<h3 id="conntrack"><a href="#conntrack" class="headerlink" title="conntrack"></a>conntrack</h3><p>在 Netfilter 体系中，状态跟踪机制（conntrack）是重要的一部分。它是基于 Linux 系统的 stateful 防火墙和 NAT 的基础。conntrack 将信息存在内存结构中，包括 IP，端口，协议类型，状态以及超时时间。conntrack 不仅可以对 TCP 这种有状态的会话进行状态跟踪，还可以对 UDP/ICMP 进行状态跟踪。conntrack 本身并不会对包进行过滤，而是提供一种基于状态和关系的过滤依据。<br>conntrack 定义了 5 种连接状态，分别如下：<br><strong>NEW</strong> 匹配连接的第一个包。意思就是，iptables 从连接跟踪表中查到此包是某连接的第一个包。判断此包是某连接的第一个包是依据 conntrack 当前”只看到一个方向数据包”( [UNREPLIED] )，不关联特定协议，因此 NEW 并不单指 tcp 连接的 SYN 包。<br><strong>ESTABLISHED</strong> 匹配连接的响应包及后续的包。意思是，iptables 从连接跟踪表中查到此包是属于一个已经收到响应的连接(即没有 [UNREPLIED] 字段)。因此在 iptables 状态中，只要发送并接到响应，连接就认为是 ESTABLISHED 的了。这个特点使 iptables 可以控制由谁发起的连接才可以通过，比如 A 与 B 通信， A 发给 B 数据包属于 NEW 状态， B 回复给 A 的数据包就变为 ESTABLISHED 状态。 ICMP 的错误和重定向等信息包也被看作是 ESTABLISHED ，只要它们是我们所发出的信息的应答。<br><strong>RELATED</strong> 状态有点复杂，当一个连接与另一个已经是 ESTABLISHED 的连接有关时，这个连接就被认为是 RELATED 。这意味着，一个连接要想成为 RELATED ，必须首先有一个已经是 ESTABLISHED 的连接存在。这个 ESTABLISHED 连接再产生一个主连接之外的新连接，这个新连接就是 RELATED 状态了，当然首先 conntrack 模块要能”读懂”它是 RELATED 。拿 ftp 来说， FTP 数据传输连接就是 RELATED 与先前已创建的 FTP 控制连接，还有通过 IRC 的 DCC 连接。有了 RELATED 这个状态， ICMP 错误消息、 FTP 传输、 DCC 等才能穿过防火墙正常工作。有些依赖此机制的 TCP 协议和 UDP 协议非常复杂，他们的连接被封装在其它的 TCP 或 UDP 包的数据部分(可以了解下 overlay/vxlan/gre)，这使得 conntrack 需要借助其它辅助模块才能正确”读懂”这些复杂数据包，比如 nf_conntrack_ftp 这个辅助模块。<br><strong>INVALID</strong> 匹配那些无法识别或没有任何状态的数据包。这可能是由于系统内存不足或收到不属于任何已知连接的 ICMP 错误消息。一般情况下我们应该 DROP 此类状态的包。<br><strong>UNTRACKED</strong> 状态比较简单，它匹配那些带有 NOTRACK 标签的数据包。需要注意的一点是，如果你在 raw 表中对某些数据包设置有 NOTRACK 标签，那上面的 4 种状态将无法匹配这样的数据包，因此你需要单独考虑 NOTRACK 包的放行规则。</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul>
<li><a href="https://www.digitalocean.com/community/tutorials/a-deep-dive-into-iptables-and-netfilter-architecture" target="_blank" rel="external nofollow noopener noreferrer">https://www.digitalocean.com/community/tutorials/a-deep-dive-into-iptables-and-netfilter-architecture</a></li>
<li><a href="https://guanjunjian.github.io/2017/12/05/study-15-docker-single-host-network-analysis/" target="_blank" rel="external nofollow noopener noreferrer">https://guanjunjian.github.io/2017/12/05/study-15-docker-single-host-network-analysis/</a></li>
<li><a href="https://blog.csdn.net/dog250/article/details/5561082" target="_blank" rel="external nofollow noopener noreferrer">https://blog.csdn.net/dog250/article/details/5561082</a></li>
<li><a href="https://blog.spoock.com/2020/01/18/conntrack/" target="_blank" rel="external nofollow noopener noreferrer">https://blog.spoock.com/2020/01/18/conntrack/</a></li>
<li><a href="https://my.oschina.net/u/232595/blog/1919450" target="_blank" rel="external nofollow noopener noreferrer">https://my.oschina.net/u/232595/blog/1919450</a></li>
<li><a href="https://www.cnblogs.com/huenchao/p/6225770.html" target="_blank" rel="external nofollow noopener noreferrer">https://www.cnblogs.com/huenchao/p/6225770.html</a></li>
<li><a href="https://www.projectcalico.org/when-linux-conntrack-is-no-longer-your-friend/#:~:text=Connection%20tracking%20(%E2%80%9Cconntrack%E2%80%9D),the%20Linux%20kernel' target=" _blank" rel="external nofollow noopener noreferrer" s%20networking%20stack.&text="This%20allows%20you%20to%20write,explicitly%20allow%20the%20response%20traffic." " target="_blank">When Linux conntrack is no longer your friend</a></li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Qt 常见编译问题汇总</title>
    <url>/post/da23d674.html</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th align="center">Date</th>
<th align="center">Log</th>
</tr>
</thead>
<tbody><tr>
<td align="center">04/07/2017</td>
<td align="center">Initial version: add “constant string to char *“ and “comparison between signed and unsigned integer “.</td>
</tr>
<tr>
<td align="center">04/15/2017</td>
<td align="center">add “undefined reference to `inet_addr@4’ “</td>
</tr>
</tbody></table><a id="more"></a>
<p>本文汇总了在 Qt  5.8 中使用 C++进行开发时遇到的编译错误和警告及其解决方法，基于 C++11 标准。</p>
<h3 id="constant-string-to-char"><a href="#constant-string-to-char" class="headerlink" title="constant string to char *"></a>constant string to char *</h3><p>初始代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">char *p &#x3D; &quot;Hello&quot;;</span><br></pre></td></tr></table></figure>

<p>编译输出：</p>
<blockquote>
<p>ISO C++ forbids conversion from constant string to char *.</p>
</blockquote>
<p>修改代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">char const *p &#x3D; &quot;Hello&quot;;</span><br></pre></td></tr></table></figure>

<p>参考资料：</p>
<ol>
<li><a href="http://stackoverflow.com/questions/20944784/why-is-conversion-from-string-constant-to-char-valid-in-c-but-invalid-in-c" target="_blank" rel="external nofollow noopener noreferrer">Why is conversion from string constant to ‘char*‘ valid in C but invalid in C++</a></li>
</ol>
<h3 id="comparison-between-signed-and-unsigned"><a href="#comparison-between-signed-and-unsigned" class="headerlink" title="comparison between signed and unsigned"></a>comparison between signed and unsigned</h3><p>初始代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for (int i &#x3D; 0, max &#x3D; vec.size(); i !&#x3D; max; ++i)</span><br></pre></td></tr></table></figure>

<p>编译输出：</p>
<blockquote>
<p>warning: comparison between signed and unsigned integer expressions [-Wsign-compare]</p>
</blockquote>
<p>修改代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for (std::size_t i &#x3D; 0, max &#x3D; vec.size(); i !&#x3D; max; ++i)</span><br></pre></td></tr></table></figure>

<p>附加注释：</p>
<blockquote>
<p>一般情况下，直接使用 size_t 即可。</p>
</blockquote>
<p>参考资料：</p>
<ol>
<li><a href="http://stackoverflow.com/questions/7984955/what-is-wrong-with-my-for-loops-i-get-warnings-comparison-between-signed-and-u" target="_blank" rel="external nofollow noopener noreferrer">What is wrong with my For loops? i get warnings: comparison between signed and unsigned integer expressions [-Wsign-compare]</a></li>
<li><a href="http://stackoverflow.com/questions/3660901/a-warning-comparison-between-signed-and-unsigned-integer-expressions" target="_blank" rel="external nofollow noopener noreferrer">A warning - comparison between signed and unsigned integer expressions</a></li>
</ol>
<h3 id="undefined-reference-to-inet-addr-4’"><a href="#undefined-reference-to-inet-addr-4’" class="headerlink" title="undefined reference to `inet_addr@4’"></a>undefined reference to `inet_addr@4’</h3><p>编译输出：</p>
<blockquote>
<p>undefined reference to `inet_addr@4’</p>
</blockquote>
<p>问题分析：</p>
<blockquote>
<p>这种情况是因为没有把 ws2_32.lib 或 libws2_32.a 加入到编译依赖项中。</p>
</blockquote>
<p>一般情况下，出现类似的 undefined reference to ‘…@…’都是因为只在源代码中引入了头文件，而没有在编译依赖中加入库文件。这种错误多出现在同时具有头文件，静态库，动态库的外部库的引用过程中。</p>
]]></content>
      <categories>
        <category>Qt</category>
      </categories>
      <tags>
        <tag>Qt</tag>
        <tag>编译</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Qt 5.8 中的实用功能配置</title>
    <url>/post/65827044.html</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th align="center">Date</th>
<th align="center">Log</th>
</tr>
</thead>
<tbody><tr>
<td align="center">03/27/2017</td>
<td align="center">初始版本，增加”使用 SVN 进行版本控制”和”使用第三方代码格式化工具”两个章节。</td>
</tr>
</tbody></table><p>Qt 中已经集成了强大的扩展功能，根据需要进行简单的配置就可以更方便的进行开发。以下配置均基于 Windows 平台。</p><h2 id="使用-SVN-进行版本控制"><a href="#使用-SVN-进行版本控制" class="headerlink" title="使用 SVN 进行版本控制"></a>使用 SVN 进行版本控制</h2><p>前提是你的项目中已经有 SVN 服务器，没有的话可以自行搭建，参考[TBD]。</p><a id="more"></a>


<h3 id="下载并安装-SVN-命令行客户端"><a href="#下载并安装-SVN-命令行客户端" class="headerlink" title="下载并安装 SVN 命令行客户端"></a>下载并安装 SVN 命令行客户端</h3><p>推荐使用<a href="https://sliksvn.com/download/" target="_blank" rel="external nofollow noopener noreferrer">SlikSVN</a>。下载后按照提示正常安装即可。</p>
<h3 id="打开-Qt-进行设置"><a href="#打开-Qt-进行设置" class="headerlink" title="打开 Qt 进行设置"></a>打开 Qt 进行设置</h3><ol>
<li>打开 Qt，点击菜单栏”Tools”下的”Options”选项，弹出如下图所示的设置窗口。</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2019/png/182657/1575440239388-be68ae19-ccea-4767-a0aa-66d7d99af9da.png#align=left&display=inline&height=677&name=image.png&originHeight=677&originWidth=1178&size=105310&status=done&style=none&width=1178" alt="image.png"></p>
<ol start="2">
<li>在窗口左侧导航栏中，选择”Version Control”,然后点击”Subversion”选项卡，设置”Subversion command”路径-上一步中安装的 SlikSvn 路径，”Username”和”Password”,然后保存并退出。</li>
</ol>
<h3 id="通过-Qt-导入-SVN-中的工程"><a href="#通过-Qt-导入-SVN-中的工程" class="headerlink" title="通过 Qt 导入 SVN 中的工程"></a>通过 Qt 导入 SVN 中的工程</h3><ol>
<li>点击菜单栏”File”，选择”New File or Project”，弹出如下窗口。</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2019/png/182657/1575440346832-96128373-e3af-42e9-877c-0341b124c797.png#align=left&display=inline&height=629&name=image.png&originHeight=629&originWidth=962&size=85193&status=done&style=none&width=962" alt="image.png"></p>
<ol start="2">
<li>依次选择”Import Project”，”Subversion Checkout”，然后点击”Choose”选项，弹出如下窗口。</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2019/png/182657/1575440378311-0ced6759-7122-4060-92cb-a21d594e9f44.png#align=left&display=inline&height=573&name=image.png&originHeight=573&originWidth=882&size=80786&status=done&style=none&width=882" alt="image.png"></p>
<ol start="3">
<li>在窗体中分别设置”Repository”-要导入的已经保存在 SVN 中的工程的路径，”Path”-本地保存路径，”Directory”-本地工程目录名（建议使用默认），然后点击”Next”开始自动 Checkout，等 Checkout 完成，打开当前工程，即可开始开发工作。</li>
</ol>
<h3 id="在-Qt-中进行-SVN-常用操作"><a href="#在-Qt-中进行-SVN-常用操作" class="headerlink" title="在 Qt 中进行 SVN 常用操作"></a>在 Qt 中进行 SVN 常用操作</h3><p>对工程代码文件修改后，可在菜单栏”Tools”下找到 SVN 常用的”Add”,”Commit”等指令，如下图。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2019/png/182657/1575440398604-6260a817-8f50-416b-ac37-d3bb7f06f34c.png#align=left&display=inline&height=781&name=image.png&originHeight=781&originWidth=977&size=210113&status=done&style=none&width=977" alt="image.png"></p>
<h2 id="使用第三方代码格式化工具"><a href="#使用第三方代码格式化工具" class="headerlink" title="使用第三方代码格式化工具"></a>使用第三方代码格式化工具</h2><p>Qt 中内置了代码格式化工具，其默认快捷键是 Ctrl + i，使用很方便，但是无法对赋值操作”=”两侧自动添加空格，这很不爽，我尝试修改配置文件，却仍然毫无效果，于是决定使用第三方格式化工具。</p>
<p>这个配置过程主要参考的是 Qt Creator 的<a href="http://doc.qt.io/qtcreator/creator-beautifier.html" target="_blank" rel="external nofollow noopener noreferrer">官方手册</a>，这里只是稍作翻译。</p>
<h3 id="打开-Beautifier-功能"><a href="#打开-Beautifier-功能" class="headerlink" title="打开 Beautifier 功能"></a>打开 Beautifier 功能</h3><p>选择 Help &gt; About Plugins &gt; C++ &gt; Beautifier 来打开 Beautifier 功能，之后重启 Qt Creator 以使 Beautifier 生效。</p>
<h3 id="下载安装第三方代码格式化工具"><a href="#下载安装第三方代码格式化工具" class="headerlink" title="下载安装第三方代码格式化工具"></a>下载安装第三方代码格式化工具</h3><p>Beautifier 支持 Artistic Style, ClangFormat, Uncrustify 三种工具，我都进行了尝试，Artistic Style 没有配置成功，Uncrustify 自带的代码格式化风格没有合适的，最后使用了 ClangFormat，这本是我最不想用的，因为获取其安装包的两种方式都很不爽，一种是自行编译-相当麻烦，一种是下载官方编译好的安装包 LLVM-包含了很多其它工具，非常臃肿。</p>
<p>其实 LLVM 是一款很强大的工具，只是在这里只用到了其中的 ClangFormat 功能，打开<a href="http://releases.llvm.org/download.html" target="_blank" rel="external nofollow noopener noreferrer">LLVM</a>页面，选择</p>
<p>Clang for Windows 32 位或 64 位下载官方编译好的安装包，正常安装即可。</p>
<h3 id="在-Qt-中配置-ClangFormat"><a href="#在-Qt-中配置-ClangFormat" class="headerlink" title="在 Qt 中配置 ClangFormat"></a>在 Qt 中配置 ClangFormat</h3><ol>
<li>打开 Qt，点击菜单栏”Tools”下的”Options”选项，弹出如下图所示的设置窗口。</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2019/png/182657/1575440424321-012b41a0-fc18-4ffe-8e55-920b51fd416b.png#align=left&display=inline&height=677&name=image.png&originHeight=677&originWidth=1178&size=95656&status=done&style=none&width=1178" alt="image.png"></p>
<ol start="2">
<li>在窗口左侧导航栏中，选择”Beautifier”,然后在”General”选项卡下勾选”Enable auto format on file save”使得文件在保存时自动格式化，并选择”Tool”为 ClangFormat。</li>
<li>选择”Clang Format”选项卡，设置”Clang Format command”为 ClangFormat 安装路径，选择”Use predefined style”为你需要的代码风格，如下图，之后保存并退出。</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2019/png/182657/1575440448145-ed66c2da-2ece-4773-b1f3-0bedc3286748.png#align=left&display=inline&height=677&name=image.png&originHeight=677&originWidth=1178&size=108392&status=done&style=none&width=1178" alt="image.png"></p>
<h3 id="设置格式化快捷键"><a href="#设置格式化快捷键" class="headerlink" title="设置格式化快捷键"></a>设置格式化快捷键</h3><p>已经习惯了使用 Ctrl + i 作为格式化快捷键，因此需要重新设置一下。</p>
<p>选择 Tools &gt; Options &gt; Environment &gt; Keyboard，首先去掉默认的 AutoIndentSelection 的快捷键 Ctrl + i，再为 ClangFormat 的 FormatSelectedText 添加快捷键 Ctrl + i，保存并关闭又可以愉快地使用 Ctrl + i 了，如下图所示。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2019/png/182657/1575440471310-0ee910d2-b3e5-4747-adc6-a710d582a4b5.png#align=left&display=inline&height=677&name=image.png&originHeight=677&originWidth=1178&size=113437&status=done&style=none&width=1178" alt="image.png"></p>
]]></content>
      <categories>
        <category>Qt</category>
      </categories>
      <tags>
        <tag>Qt</tag>
        <tag>SVN</tag>
        <tag>代码格式化</tag>
      </tags>
  </entry>
  <entry>
    <title>Rust 基础知识</title>
    <url>/post/bedbca3d.html</url>
    <content><![CDATA[<h4 id="rustup"><a href="#rustup" class="headerlink" title="rustup"></a>rustup</h4><p>rustup 是一个 rust 开发环境管理工具，可用于在不同的 rust 版本切换，指定目标平台等。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 安装</span><br><span class="line">curl --proto &#39;&#x3D;https&#39; --tlsv1.2 -sSf https:&#x2F;&#x2F;sh.rustup.rs | sh</span><br><span class="line">rustup show</span><br><span class="line">rustup man cargo</span><br></pre></td></tr></table></figure><a id="more"></a>


<p>打包为无需依赖 libc 的 fully static binaries：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rustup target add x86_64-unknown-linux-musl</span><br><span class="line">cargo build --target x86_64-unknown-linux-musl --release</span><br></pre></td></tr></table></figure>

<h4 id="打印结构体"><a href="#打印结构体" class="headerlink" title="打印结构体"></a>打印结构体</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#[derive(Debug)]</span><br><span class="line">struct User &#123;</span><br><span class="line">  username: String,</span><br><span class="line">  email: String,</span><br><span class="line">  sign_in_count: u64,</span><br><span class="line">  active: bool,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">  let user1 &#x3D; User &#123;</span><br><span class="line">    email: String::from(&quot;someone@example.com&quot;),</span><br><span class="line">    username: String::from(&quot;someusername123&quot;),</span><br><span class="line">    active: true,</span><br><span class="line">    sign_in_count: 1,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  let user2 &#x3D; User &#123;</span><br><span class="line">    email: user1.email.clone(),</span><br><span class="line">    username: String::from(&quot;anotherusername567&quot;),</span><br><span class="line">    active: user1.active,</span><br><span class="line">    sign_in_count: user1.sign_in_count,</span><br><span class="line">  &#125;;</span><br><span class="line">  println!(&quot;&#123;:?&#125;&quot;, user1);</span><br><span class="line">  println!(&quot;&#123;:?&#125;&quot;, user2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>S3 使用</title>
    <url>/post/28376d03.html</url>
    <content><![CDATA[<h4 id="流式上传文件"><a href="#流式上传文件" class="headerlink" title="流式上传文件"></a>流式上传文件</h4><p>使用 S3 标准接口上传文件时需要提供一个 ReadSeeker ，这样就不方便把一个流式数据源的内容转存到对象存储（本地文件可以支持 ReadSeeker），可以使用 s3manager 提供的 API 进行流式上传：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="string">"io"</span></span><br><span class="line">    <span class="string">"github.com/aws/aws-sdk-go/service/s3/s3manager"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> reader <span class="keyword">struct</span> &#123;</span><br><span class="line">    r io.Reader</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *reader)</span> <span class="title">Read</span><span class="params">(p []<span class="keyword">byte</span>)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> r.r.Read(p)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// ... parse flags</span></span><br><span class="line"></span><br><span class="line">    sess := session.Must(session.NewSession())</span><br><span class="line">    uploader := s3manager.NewUploader(sess, <span class="function"><span class="keyword">func</span><span class="params">(u *s3manager.Uploader)</span></span> &#123;</span><br><span class="line">        u.PartSize = <span class="number">20</span> &lt;&lt; <span class="number">20</span> <span class="comment">// 20MB</span></span><br><span class="line">        <span class="comment">// ... more configuration</span></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... context stuff</span></span><br><span class="line"></span><br><span class="line">    _, err := uploader.UploadWithContext(ctx, &amp;s3manager.UploadInput&#123;</span><br><span class="line">        Bucket: aws.String(bucket),</span><br><span class="line">        Key:    aws.String(key),</span><br><span class="line">        Body:   &amp;reader&#123;os.Stdin&#125;,</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... handle error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a>


<h4 id="Mock-S3-Client"><a href="#Mock-S3-Client" class="headerlink" title="Mock S3 Client"></a>Mock S3 Client</h4><p>使用 s3iface.S3API 接口而不是 S3 结构体，mock 时将接口嵌入结构体，从而只需要 mock 业务代码真正使用的 API 。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// myFunc uses an SDK service client to make a request to</span></span><br><span class="line"><span class="comment">// Amazon Simple Storage Service.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myFunc</span><span class="params">(svc s3iface.S3API)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="comment">// Make svc.AbortMultipartUpload request</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    sess := session.New()</span><br><span class="line">    svc := s3.New(sess)</span><br><span class="line"></span><br><span class="line">    myFunc(svc)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// In your _test.go file:</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Define a mock struct to be used in your unit tests of myFunc.</span></span><br><span class="line"><span class="keyword">type</span> mockS3Client <span class="keyword">struct</span> &#123;</span><br><span class="line">    s3iface.S3API</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *mockS3Client)</span> <span class="title">AbortMultipartUpload</span><span class="params">(input *s3.AbortMultipartUploadInput)</span> <span class="params">(*s3.AbortMultipartUploadOutput, error)</span></span> &#123;</span><br><span class="line">    <span class="comment">// mock response/functionality</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestMyFunc</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    <span class="comment">// Setup Test</span></span><br><span class="line">    mockSvc := &amp;mockS3Client&#123;&#125;</span><br><span class="line"></span><br><span class="line">    myfunc(mockSvc)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Verify myFunc's functionality</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="统计存储桶下文件总大小"><a href="#统计存储桶下文件总大小" class="headerlink" title="统计存储桶下文件总大小"></a>统计存储桶下文件总大小</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">s3cmd ls --recursive s3://code-pipeline-log/ | grep -v -E <span class="string">"(Bucket: |Prefix: |LastWriteTime|^$|--)"</span> | awk <span class="string">'BEGIN &#123;total=0&#125;&#123;total+=$3&#125;END&#123;print total/1024/1024" MB"&#125;'</span></span><br></pre></td></tr></table></figure>

<h4 id="s3-bench-测试"><a href="#s3-bench-测试" class="headerlink" title="s3 bench 测试"></a>s3 bench 测试</h4><p><a href="https://github.com/dvassallo/s3-benchmark" target="_blank" rel="external nofollow noopener noreferrer">https://github.com/dvassallo/s3-benchmark</a><br><a href="https://github.com/s3tester/s3tester" target="_blank" rel="external nofollow noopener noreferrer">https://github.com/s3tester/s3tester</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># cat ~/.aws/credentials</span></span><br><span class="line">[default]</span><br><span class="line">aws_access_key_id=MY_AK</span><br><span class="line">aws_secret_access_key=MY_SK</span><br><span class="line"></span><br><span class="line">./s3-benchmark --endpoint http://tos-s3-cn-qingdao.volces.com --bucket-name cr-bench-1 --region cn-qingdao --payloads-min=13 --payloads-max=15</span><br></pre></td></tr></table></figure>

<p>####</p>
<h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ul>
<li><a href="https://stackoverflow.com/a/43599414" target="_blank" rel="external nofollow noopener noreferrer">https://stackoverflow.com/a/43599414</a></li>
<li><a href="https://stackoverflow.com/questions/8975959/aws-s3-how-do-i-see-how-much-disk-space-is-using/29930473" target="_blank" rel="external nofollow noopener noreferrer">https://stackoverflow.com/questions/8975959/aws-s3-how-do-i-see-how-much-disk-space-is-using/29930473</a></li>
</ul>
]]></content>
      <categories>
        <category>存储</category>
      </categories>
      <tags>
        <tag>对象存储</tag>
      </tags>
  </entry>
  <entry>
    <title>TBD</title>
    <url>/post/270af770.html</url>
    <content><![CDATA[<h4 id="博客"><a href="#博客" class="headerlink" title="博客"></a>博客</h4><ol>
<li><a href="https://arthurchiao.art/" target="_blank" rel="external nofollow noopener noreferrer">https://arthurchiao.art/</a></li>
<li><a href="http://www.brendangregg.com/" target="_blank" rel="external nofollow noopener noreferrer">http://www.brendangregg.com/</a></li>
<li><a href="https://qcrao.com/" target="_blank" rel="external nofollow noopener noreferrer">https://qcrao.com/</a></li>
<li><a href="https://xargin.com/" target="_blank" rel="external nofollow noopener noreferrer">https://xargin.com/</a></li>
<li><a href="https://draveness.me/" target="_blank" rel="external nofollow noopener noreferrer">https://draveness.me/</a></li>
<li><a href="https://eddycjy.com/posts/" target="_blank" rel="external nofollow noopener noreferrer">https://eddycjy.com/posts/</a></li>
<li><a href="https://changkun.us/" target="_blank" rel="external nofollow noopener noreferrer">https://changkun.us/</a></li>
<li><a href="https://coolshell.cn/" target="_blank" rel="external nofollow noopener noreferrer">https://coolshell.cn/</a></li>
<li><a href="https://blog.csdn.net/dog250" target="_blank" rel="external nofollow noopener noreferrer">https://blog.csdn.net/dog250</a></li>
<li><a href="http://kerneltravel.net/blog/" target="_blank" rel="external nofollow noopener noreferrer">http://kerneltravel.net/blog/</a></li>
<li><a href="https://jiajunhuang.com/archive" target="_blank" rel="external nofollow noopener noreferrer">https://jiajunhuang.com/archive</a></li>
<li><a href="https://zdyxry.github.io/" target="_blank" rel="external nofollow noopener noreferrer">https://zdyxry.github.io/</a></li>
<li><a href="https://www.cnxct.com/" target="_blank" rel="external nofollow noopener noreferrer">https://www.cnxct.com/</a></li>
<li><a href="https://terenceli.github.io/archive.html" target="_blank" rel="external nofollow noopener noreferrer">https://terenceli.github.io/archive.html</a></li>
<li><a href="https://cizixs.com/archives/" target="_blank" rel="external nofollow noopener noreferrer">https://cizixs.com/archives/</a></li>
<li><a href="https://dave.cheney.net/" target="_blank" rel="external nofollow noopener noreferrer">https://dave.cheney.net/</a></li>
<li><a href="https://promacanthus.netlify.app/" target="_blank" rel="external nofollow noopener noreferrer">https://promacanthus.netlify.app/</a></li>
</ol><a id="more"></a>
<h4 id="开源项目"><a href="#开源项目" class="headerlink" title="开源项目"></a>开源项目</h4><ol>
<li><a href="https://github.com/skupperproject/skupper" target="_blank" rel="external nofollow noopener noreferrer">https://github.com/skupperproject/skupper</a></li>
<li><a href="https://github.com/cloudstateio/cloudstate" target="_blank" rel="external nofollow noopener noreferrer">https://github.com/cloudstateio/cloudstate</a></li>
<li><a href="https://github.com/dapr/dapr" target="_blank" rel="external nofollow noopener noreferrer">https://github.com/dapr/dapr</a></li>
<li><a href="https://github.com/kubesphere/kubesphere" target="_blank" rel="external nofollow noopener noreferrer">https://github.com/kubesphere/kubesphere</a></li>
<li><a href="https://github.com/virtual-kubelet/virtual-kubelet" target="_blank" rel="external nofollow noopener noreferrer">https://github.com/virtual-kubelet/virtual-kubelet</a></li>
<li><a href="https://github.com/hashicorp/golang-lru" target="_blank" rel="external nofollow noopener noreferrer">https://github.com/hashicorp/golang-lru</a></li>
<li><a href="https://github.com/bfenetworks/bfe" target="_blank" rel="external nofollow noopener noreferrer">https://github.com/bfenetworks/bfe</a></li>
<li><a href="https://github.com/go-playground/validator" target="_blank" rel="external nofollow noopener noreferrer">https://github.com/go-playground/validator</a></li>
<li><a href="https://github.com/dutchcoders/transfer.sh" target="_blank" rel="external nofollow noopener noreferrer">https://github.com/dutchcoders/transfer.sh</a></li>
<li><a href="https://github.com/hoanhan101/ultimate-go" target="_blank" rel="external nofollow noopener noreferrer">https://github.com/hoanhan101/ultimate-go</a></li>
<li><a href="https://github.com/libuv/libuv" target="_blank" rel="external nofollow noopener noreferrer">https://github.com/libuv/libuv</a></li>
<li><a href="https://github.com/libevent/libevent" target="_blank" rel="external nofollow noopener noreferrer">https://github.com/libevent/libevent</a></li>
<li><a href="https://github.com/davyxu/cellnet" target="_blank" rel="external nofollow noopener noreferrer">https://github.com/davyxu/cellnet</a></li>
<li><a href="https://github.com/x-way/iptables-tracer" target="_blank" rel="external nofollow noopener noreferrer">https://github.com/x-way/iptables-tracer</a></li>
<li><a href="https://github.com/wg/wrk" target="_blank" rel="external nofollow noopener noreferrer">https://github.com/wg/wrk</a></li>
<li><a href="https://github.com/spf13/afero" target="_blank" rel="external nofollow noopener noreferrer">https://github.com/spf13/afero</a></li>
<li><a href="https://github.com/openservicemesh/osm" target="_blank" rel="external nofollow noopener noreferrer">https://github.com/openservicemesh/osm</a></li>
<li><a href="https://github.com/bxcodec/go-clean-arch" target="_blank" rel="external nofollow noopener noreferrer">https://github.com/bxcodec/go-clean-arch</a></li>
<li><a href="https://github.com/kubernetes-sigs/cluster-api" target="_blank" rel="external nofollow noopener noreferrer">https://github.com/kubernetes-sigs/cluster-api</a></li>
<li><a href="https://github.com/vlang/v" target="_blank" rel="external nofollow noopener noreferrer">https://github.com/vlang/v</a></li>
<li><a href="https://github.com/kubevirt/kubevirt" target="_blank" rel="external nofollow noopener noreferrer">https://github.com/kubevirt/kubevirt</a></li>
<li><a href="https://github.com/onsi/ginkgo" target="_blank" rel="external nofollow noopener noreferrer">https://github.com/onsi/ginkgo</a></li>
</ol>
<h4 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h4><ol>
<li><a href="https://www.kernel.org/" target="_blank" rel="external nofollow noopener noreferrer">https://www.kernel.org/</a></li>
<li><a href="https://www.gnu.org/software/bash/manual/html_node/index.html" target="_blank" rel="external nofollow noopener noreferrer">https://www.gnu.org/software/bash/manual/html_node/index.html</a></li>
</ol>
<h4 id="书籍"><a href="#书籍" class="headerlink" title="书籍"></a>书籍</h4><ol>
<li><a href="https://changkun.de/golang/" target="_blank" rel="external nofollow noopener noreferrer">https://changkun.de/golang/</a></li>
<li><a href="https://draveness.me/golang/" target="_blank" rel="external nofollow noopener noreferrer">https://draveness.me/golang/</a></li>
<li><a href="https://qcrao91.gitbook.io/go/" target="_blank" rel="external nofollow noopener noreferrer">https://qcrao91.gitbook.io/go/</a></li>
<li><a href="https://chai2010.gitbooks.io/advanced-go-programming-book/content/" target="_blank" rel="external nofollow noopener noreferrer">https://chai2010.gitbooks.io/advanced-go-programming-book/content/</a></li>
<li><a href="https://yunlzheng.gitbook.io/prometheus-book/" target="_blank" rel="external nofollow noopener noreferrer">https://yunlzheng.gitbook.io/prometheus-book/</a></li>
<li><a href="https://linuxtools-rst.readthedocs.io/zh_CN/latest/index.html" target="_blank" rel="external nofollow noopener noreferrer">https://linuxtools-rst.readthedocs.io/zh_CN/latest/index.html</a></li>
</ol>
<h4 id="Premiere-Pro"><a href="#Premiere-Pro" class="headerlink" title="Premiere Pro"></a>Premiere Pro</h4><p><a href="https://www.zhihu.com/question/283792449?sort=created" target="_blank" rel="external nofollow noopener noreferrer">https://www.zhihu.com/question/283792449?sort=created</a></p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>TBD</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Shell 脚本 snippets</title>
    <url>/post/d2d8a73b.html</url>
    <content><![CDATA[<h4 id="重试逻辑"><a href="#重试逻辑" class="headerlink" title="重试逻辑"></a>重试逻辑</h4><p>参考：<a href="https://unix.stackexchange.com/q/82598" target="_blank" rel="external nofollow noopener noreferrer">https://unix.stackexchange.com/q/82598</a></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">n=0</span><br><span class="line">until [ <span class="string">"<span class="variable">$n</span>"</span> -ge 5 ]</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">   <span class="built_in">command</span> &amp;&amp; <span class="built_in">break</span>  <span class="comment"># substitute your command here</span></span><br><span class="line">   n=$((n+1))</span><br><span class="line">   sleep 15</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line"><span class="comment"># command 退出码为 0 则为 true 继续执行 break 而不会执行 sleep</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> &#123;1..5&#125;; <span class="keyword">do</span> <span class="built_in">command</span> &amp;&amp; <span class="built_in">break</span> || sleep 15; <span class="keyword">done</span></span><br><span class="line"><span class="comment"># 或者写成函数</span></span><br><span class="line"><span class="keyword">function</span> fail &#123;</span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$1</span> &gt;&amp;2</span><br><span class="line">  <span class="built_in">exit</span> 1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> retry &#123;</span><br><span class="line">  <span class="built_in">local</span> n=1</span><br><span class="line">  <span class="built_in">local</span> max=5</span><br><span class="line">  <span class="built_in">local</span> delay=15</span><br><span class="line">  <span class="keyword">while</span> <span class="literal">true</span>; <span class="keyword">do</span></span><br><span class="line">    <span class="string">"<span class="variable">$@</span>"</span> &amp;&amp; <span class="built_in">break</span> || &#123;</span><br><span class="line">      <span class="keyword">if</span> [[ <span class="variable">$n</span> -lt <span class="variable">$max</span> ]]; <span class="keyword">then</span></span><br><span class="line">        ((n++))</span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"Command failed. Attempt <span class="variable">$n</span>/<span class="variable">$max</span>:"</span></span><br><span class="line">        sleep <span class="variable">$delay</span>;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        fail <span class="string">"The command has failed after <span class="variable">$n</span> attempts."</span></span><br><span class="line">      <span class="keyword">fi</span></span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">done</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">retry ping invalidserver</span><br></pre></td></tr></table></figure><a id="more"></a>


<h4 id="检查环境变量是否设置"><a href="#检查环境变量是否设置" class="headerlink" title="检查环境变量是否设置"></a>检查环境变量是否设置</h4><p><a href="https://stackoverflow.com/a/307735" target="_blank" rel="external nofollow noopener noreferrer">https://stackoverflow.com/a/307735</a>，<a href="https://stackoverflow.com/a/39296723" target="_blank" rel="external nofollow noopener noreferrer">https://stackoverflow.com/a/39296723</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -z 检查目标变量值长度是否为零</span></span><br><span class="line"><span class="keyword">if</span> [[ -z <span class="string">"<span class="variable">$&#123;DEPLOY_ENV&#125;</span>"</span> ]]; <span class="keyword">then</span></span><br><span class="line">  MY_SCRIPT_VARIABLE=<span class="string">"Some default value because DEPLOY_ENV is undefined"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  MY_SCRIPT_VARIABLE=<span class="string">"<span class="variable">$&#123;DEPLOY_ENV&#125;</span>"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># or using a short-hand version</span></span><br><span class="line"></span><br><span class="line">[[ -z <span class="string">"<span class="variable">$&#123;DEPLOY_ENV&#125;</span>"</span> ]] &amp;&amp; MyVar=<span class="string">'default'</span> || MyVar=<span class="string">"<span class="variable">$&#123;DEPLOY_ENV&#125;</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># or even shorter use</span></span><br><span class="line">MyVar=<span class="string">"<span class="variable">$&#123;DEPLOY_ENV:-default_value&#125;</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 未设置则报错</span></span><br><span class="line">: <span class="string">"<span class="variable">$&#123;STATE?Need to set STATE&#125;</span>"</span></span><br><span class="line">: <span class="string">"<span class="variable">$&#123;DEST:?Need to set DEST non-empty&#125;</span>"</span></span><br><span class="line">[ -z <span class="string">"<span class="variable">$STATE</span>"</span> ] &amp;&amp; <span class="built_in">echo</span> <span class="string">"Need to set STATE"</span> &amp;&amp; <span class="built_in">exit</span> 1;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line"><span class="keyword">if</span> [[ ! -v DEPLOY_ENV ]]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"DEPLOY_ENV is not set"</span></span><br><span class="line"><span class="keyword">elif</span> [[ -z <span class="string">"<span class="variable">$DEPLOY_ENV</span>"</span> ]]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"DEPLOY_ENV is set to the empty string"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"DEPLOY_ENV has the value: <span class="variable">$DEPLOY_ENV</span>"</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>

<h4 id="让脚本执行更安全"><a href="#让脚本执行更安全" class="headerlink" title="让脚本执行更安全"></a>让脚本执行更安全</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> -euxo pipefail</span><br><span class="line"><span class="comment"># 默认情况下某行命令执行出错后脚本会继续执行</span></span><br><span class="line"><span class="comment"># set -e 使脚本执行出错则立即退出，不再执行后续命令， 如果想阻止命令执行失败退出，则可以在命令后增加 || true</span></span><br><span class="line">invalid_cmd || <span class="literal">true</span></span><br><span class="line"><span class="comment"># 默认对于管道连接的多个命令只要最后一个执行成功则就认为执行成功</span></span><br><span class="line"><span class="comment"># set -o pipefail 则会检查管道连接的所有的命令，只有所有命令都执行成功才算成功</span></span><br><span class="line">invalid_cmd | <span class="built_in">echo</span> <span class="string">"true"</span>  <span class="comment"># 默认该行命令被视为成功执行，设置 pipefail 则被视为失败</span></span><br><span class="line"><span class="comment"># 变量未设置时，默认为空值，引用不会报错</span></span><br><span class="line"><span class="comment"># set -u 让引用未设置的变量立即报错</span></span><br><span class="line"><span class="comment"># set -x 会在执行每条命令前先将其打印出来</span></span><br></pre></td></tr></table></figure>

<h4 id="使用临时目录"><a href="#使用临时目录" class="headerlink" title="使用临时目录"></a>使用临时目录</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># 创建临时目录并在脚本执行结束或中断时清理临时目录</span></span><br><span class="line"><span class="comment"># the directory of the script</span></span><br><span class="line">DIR=<span class="string">"<span class="variable">$( cd "$( dirname "$&#123;BASH_SOURCE[0]&#125;" )</span>"</span> &amp;&amp; <span class="built_in">pwd</span> )<span class="string">"</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># the temp directory used, within <span class="variable">$DIR</span></span></span><br><span class="line"><span class="string"># omit the -p parameter to create a temporal directory in the default location</span></span><br><span class="line"><span class="string"># -t 按指定格式命名文件夹</span></span><br><span class="line"><span class="string">TMP_DIR=`mktemp -d -p "</span><span class="variable">$DIR</span><span class="string">" -t test.XXXX`</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># check if tmp dir was created</span></span><br><span class="line"><span class="string">if [[ ! "</span><span class="variable">$TMP_DIR</span><span class="string">" || ! -d "</span><span class="variable">$TMP_DIR</span><span class="string">" ]]; then</span></span><br><span class="line"><span class="string">  echo "</span>Could not create temp dir<span class="string">"</span></span><br><span class="line"><span class="string">  exit 1</span></span><br><span class="line"><span class="string">fi</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># deletes the temp directory</span></span><br><span class="line"><span class="string">function cleanup &#123;</span></span><br><span class="line"><span class="string">  rm -rf "</span><span class="variable">$TMP_DIR</span><span class="string">"</span></span><br><span class="line"><span class="string">  echo "</span>Deleted temp working directory <span class="variable">$TMP_DIR</span><span class="string">"</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># register the cleanup function to be called on the EXIT signal</span></span><br><span class="line"><span class="string">trap cleanup EXIT</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># implementation of script starts here</span></span><br><span class="line"><span class="string">...</span></span><br></pre></td></tr></table></figure>

<h4 id="输出重定向"><a href="#输出重定向" class="headerlink" title="输出重定向"></a>输出重定向</h4><p>&amp; 是一个描述符，如果 1 或 2 前不加&amp;，会被当成一个普通文件。<br>1&gt;&amp;2 意思是把标准输出重定向到标准错误。<br>2&gt;&amp;1 意思是把标准错误输出重定向到标准输出。<br>&amp;&gt;filename 意思是把标准输出和标准错误输出都重定向到文件 filename 中。</p>
<h4 id="amp-amp-与"><a href="#amp-amp-与" class="headerlink" title="&amp;&amp; 与 ||"></a>&amp;&amp; 与 ||</h4><p>利用 &amp;&amp; 与 || 可以节省一些 if 判断，在一行语句中完成不同情况的处理。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 当且仅当 command1 的退出码为 0 时，command2 才会执行</span></span><br><span class="line">command1 &amp;&amp; command2</span><br><span class="line"><span class="comment"># 当且仅当 command1 的退出码不为 0 时， command2 才会执行</span></span><br><span class="line">command1 || command2</span><br><span class="line"><span class="comment"># 如下是示例， true 的作用是返回退出码 0 ， false 的作用是返回退出码 1</span></span><br><span class="line">[me@linuxbox]$ <span class="literal">true</span> || <span class="built_in">echo</span> <span class="string">"echo executed"</span></span><br><span class="line">[me@linuxbox]$ <span class="literal">false</span> || <span class="built_in">echo</span> <span class="string">"echo executed"</span></span><br><span class="line"><span class="built_in">echo</span> executed</span><br><span class="line">[me@linuxbox]$ <span class="literal">true</span> &amp;&amp; <span class="built_in">echo</span> <span class="string">"echo executed"</span></span><br><span class="line"><span class="built_in">echo</span> executed</span><br><span class="line">[me@linuxbox]$ <span class="literal">false</span> &amp;&amp; <span class="built_in">echo</span> <span class="string">"echo executed"</span></span><br><span class="line">[me@linuxbox]$</span><br><span class="line"><span class="comment"># 如下是应用，在打开目录失败时输出错误信息并退出，打开成功则继续执行</span></span><br><span class="line"><span class="built_in">cd</span> <span class="string">"<span class="variable">$some_directory</span>"</span> || error_exit <span class="string">"Cannot change directory! Aborting"</span></span><br><span class="line">rm *</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line"><span class="built_in">cd</span> <span class="string">"<span class="variable">$some_directory</span>"</span> &amp;&amp; rm ./*</span><br></pre></td></tr></table></figure>

<h4 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h4><p>参考：<a href="https://stackoverflow.com/a/185900" target="_blank" rel="external nofollow noopener noreferrer">https://stackoverflow.com/a/185900</a>，<a href="https://stackoverflow.com/a/35800451" target="_blank" rel="external nofollow noopener noreferrer">https://stackoverflow.com/a/35800451</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 以下逻辑在某行命令执行后退出码非 0 时打印错误并退出</span></span><br><span class="line"><span class="comment"># 在脚本退出码为 0 时清理临时目录</span></span><br><span class="line"><span class="comment"># 必要时加入 set -E ，等同于 set -o errtrace ，其效果是让 trap 能够捕获到函数中执行出错的命令</span></span><br><span class="line"><span class="built_in">set</span> -eE</span><br><span class="line"></span><br><span class="line">tempfiles=( )</span><br><span class="line"><span class="function"><span class="title">cleanup</span></span>() &#123;</span><br><span class="line">  rm -f <span class="string">"<span class="variable">$&#123;tempfiles[@]&#125;</span>"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">trap</span> cleanup 0</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">error</span></span>() &#123;</span><br><span class="line">  <span class="built_in">local</span> parent_lineno=<span class="string">"<span class="variable">$1</span>"</span></span><br><span class="line">  <span class="built_in">local</span> message=<span class="string">"<span class="variable">$2</span>"</span></span><br><span class="line">  <span class="built_in">local</span> code=<span class="string">"<span class="variable">$&#123;3:-1&#125;</span>"</span></span><br><span class="line">  <span class="keyword">if</span> [[ -n <span class="string">"<span class="variable">$message</span>"</span> ]] ; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"Error on or near line <span class="variable">$&#123;parent_lineno&#125;</span>: <span class="variable">$&#123;message&#125;</span>; exiting with status <span class="variable">$&#123;code&#125;</span>"</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"Error on or near line <span class="variable">$&#123;parent_lineno&#125;</span>; exiting with status <span class="variable">$&#123;code&#125;</span>"</span></span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line">  <span class="built_in">exit</span> <span class="string">"<span class="variable">$&#123;code&#125;</span>"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">trap</span> <span class="string">'error $&#123;LINENO&#125;'</span> ERR</span><br><span class="line"><span class="comment"># 手动触发方式</span></span><br><span class="line">error <span class="variable">$&#123;LINENO&#125;</span> <span class="string">"the foobar failed"</span> 2</span><br></pre></td></tr></table></figure>

<p>另一种处理方式，参考：<a href="https://medium.com/@dirk.avery/the-bash-trap-trap-ce6083f36700" target="_blank" rel="external nofollow noopener noreferrer">The Bash Trap Trap</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">set</span> -e</span><br><span class="line"><span class="built_in">trap</span> <span class="string">'catch $? $LINENO'</span> EXIT</span><br><span class="line"><span class="function"><span class="title">catch</span></span>() &#123;</span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"catching!"</span></span><br><span class="line">  <span class="keyword">if</span> [ <span class="string">"<span class="variable">$1</span>"</span> != <span class="string">"0"</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="comment"># error handling goes here</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"Error <span class="variable">$1</span> occurred on <span class="variable">$2</span>"</span></span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="title">simple</span></span>() &#123;</span><br><span class="line">  badcommand</span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"Hi from simple()!"</span></span><br><span class="line">&#125;</span><br><span class="line">simple</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"After simple call"</span></span><br></pre></td></tr></table></figure>

<h4 id="for-循环指定次数"><a href="#for-循环指定次数" class="headerlink" title="for 循环指定次数"></a>for 循环指定次数</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> &#123;1..200&#125;; <span class="keyword">do</span></span><br><span class="line">  dosomething</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<h4 id="set-e-出现非零返回值立即退出"><a href="#set-e-出现非零返回值立即退出" class="headerlink" title="set -e 出现非零返回值立即退出"></a><code>set -e</code> 出现非零返回值立即退出</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> -e： 执行的时候如果出现了返回值为非零，整个脚本就会立即退出</span><br><span class="line"><span class="built_in">set</span> +e： 执行的时候如果出现了返回值为非零将会继续执行下面的脚本</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> -e 命令用法总结如下：</span><br><span class="line">1. 当命令的返回值为非零状态时，则立即退出脚本的执行。</span><br><span class="line">2. 作用范围只限于脚本执行的当前进行，不作用于其创建的子进程（https://blog.csdn.net/fc34235/article/details/76598448 ）。</span><br><span class="line">3. 另外，当想根据命令执行的返回值，输出对应的<span class="built_in">log</span>时，最好不要采用<span class="built_in">set</span> -e选项，而是通过配合<span class="built_in">exit</span> 命令来达到输出<span class="built_in">log</span>并退出执行的目的。</span><br></pre></td></tr></table></figure>

<h4 id="设置工作目录"><a href="#设置工作目录" class="headerlink" title="设置工作目录"></a>设置工作目录</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">cd &quot;$(dirname &quot;$0&quot;)&quot;</span><br></pre></td></tr></table></figure>

<h4 id="捕捉信号并处理"><a href="#捕捉信号并处理" class="headerlink" title="捕捉信号并处理"></a>捕捉信号并处理</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="function"><span class="title">exit_script</span></span>() &#123;</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"Printing something special!"</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"Maybe executing other commands!"</span></span><br><span class="line">    <span class="built_in">trap</span> - SIGINT SIGTERM <span class="comment"># clear the trap</span></span><br><span class="line">    <span class="built_in">kill</span> -- -$$ <span class="comment"># Sends SIGTERM to child/sub processes</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">trap</span> exit_script SIGINT SIGTERM</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Some other text"</span></span><br><span class="line"><span class="comment">#other commands here</span></span><br><span class="line">sleep infinity</span><br></pre></td></tr></table></figure>

<h4 id="shell-脚本语法校验"><a href="#shell-脚本语法校验" class="headerlink" title="shell 脚本语法校验"></a>shell 脚本语法校验</h4><p>参考：<a href="https://stackoverflow.com/questions/171924/how-do-i-syntax-check-a-bash-script-without-running-it" target="_blank" rel="external nofollow noopener noreferrer">https://stackoverflow.com/questions/171924/how-do-i-syntax-check-a-bash-script-without-running-it</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bash -n tmp.sh</span><br><span class="line">// 或者安装 shellcheck 工具</span><br><span class="line">shellcheck tmp.sh</span><br></pre></td></tr></table></figure>

<h4 id="带超时的循环"><a href="#带超时的循环" class="headerlink" title="带超时的循环"></a>带超时的循环</h4><p>参考：<a href="https://stackoverflow.com/questions/27555727/timeouting-a-while-loop-in-linux-shell-script" target="_blank" rel="external nofollow noopener noreferrer">https://stackoverflow.com/questions/27555727/timeouting-a-while-loop-in-linux-shell-script</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">timeout 5 bash -c -- <span class="string">'while true; do printf ".";done'</span></span><br></pre></td></tr></table></figure>

<h4 id="打印带日期的日志"><a href="#打印带日期的日志" class="headerlink" title="打印带日期的日志"></a>打印带日期的日志</h4><p>参考：<a href="https://serverfault.com/a/310099" target="_blank" rel="external nofollow noopener noreferrer">https://serverfault.com/a/310099</a>,<a href="https://stackoverflow.com/a/1705761" target="_blank" rel="external nofollow noopener noreferrer">https://stackoverflow.com/a/1705761</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> $(date -u) <span class="string">"Some message or other"</span></span><br></pre></td></tr></table></figure>

<h4 id="判断文件是否存在"><a href="#判断文件是否存在" class="headerlink" title="判断文件是否存在"></a>判断文件是否存在</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// -f 判断文件存在</span><br><span class="line"><span class="keyword">if</span> [ ! -f <span class="string">"/usr/local/bin/hyperkube.bak"</span> ]; <span class="keyword">then</span> cp /usr/<span class="built_in">local</span>/bin/hyperkube /usr/<span class="built_in">local</span>/bin/hyperkube.bak; <span class="keyword">fi</span></span><br><span class="line">// -s 判断文件存在且不为空</span><br></pre></td></tr></table></figure>

<h4 id="判断字符串包含子串"><a href="#判断字符串包含子串" class="headerlink" title="判断字符串包含子串"></a>判断字符串包含子串</h4><p>参见：<a href="https://stackoverflow.com/questions/229551/how-to-check-if-a-string-contains-a-substring-in-bash" target="_blank" rel="external nofollow noopener noreferrer">https://stackoverflow.com/questions/229551/how-to-check-if-a-string-contains-a-substring-in-bash</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">string=<span class="string">'My string'</span>;</span><br><span class="line"><span class="comment"># 会进行整个字符串的匹配，不需要加通配符</span></span><br><span class="line"><span class="keyword">if</span> [[ <span class="variable">$string</span> =~ <span class="string">"My"</span> ]]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"It's there!"</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>

<h4 id><a href="#" class="headerlink" title="$@"></a>$@</h4><p>传递参数时 $@ 与 $* 不同，$@ 可以理解为不改变输入参数的结构继续向下级函数传递，参考：<a href="https://unix.stackexchange.com/a/78478" target="_blank" rel="external nofollow noopener noreferrer">https://unix.stackexchange.com/a/78478</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="function"><span class="title">bar</span></span>() &#123; <span class="built_in">echo</span> <span class="string">"<span class="variable">$1</span>:<span class="variable">$2</span>"</span>; &#125;</span><br><span class="line">$ <span class="function"><span class="title">foo</span></span>() &#123; bar <span class="string">"<span class="variable">$@</span>"</span>; &#125;</span><br><span class="line">$ foo <span class="string">"This is"</span> a <span class="built_in">test</span></span><br><span class="line">This is:a</span><br></pre></td></tr></table></figure>

<h4 id="获取指定序号后的剩余参数"><a href="#获取指定序号后的剩余参数" class="headerlink" title="获取指定序号后的剩余参数"></a>获取指定序号后的剩余参数</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 一种方式是使用 shift，shifttest.sh 包含如下内容</span></span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$1</span></span><br><span class="line"><span class="built_in">shift</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$1</span> <span class="variable">$2</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行脚本</span></span><br><span class="line">$ shifttest.sh 1 2 3</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">1</span><br><span class="line">2 3</span><br><span class="line">2 3</span><br><span class="line"></span><br><span class="line"><span class="comment"># 另外可以使用 $@ , r.sh 包含如下内容</span></span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"params only 2    : <span class="variable">$&#123;@:2:1&#125;</span>"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"params 2 and 3   : <span class="variable">$&#123;@:2:2&#125;</span>"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"params all from 2: <span class="variable">$&#123;@:2:99&#125;</span>"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"params all from 2: <span class="variable">$&#123;@:2&#125;</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行脚本</span></span><br><span class="line">$ r.sh 1 2 3 4 5 6 7 8 9 10</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">params only 2    : 2</span><br><span class="line">params 2 and 3   : 2 3</span><br><span class="line">params all from 2: 2 3 4 5 6 7 8 9 10</span><br><span class="line">params all from 2: 2 3 4 5 6 7 8 9 10</span><br></pre></td></tr></table></figure>

<h4 id="使用-eval-获取变量值"><a href="#使用-eval-获取变量值" class="headerlink" title="使用 eval 获取变量值"></a>使用 eval 获取变量值</h4><p><a href="https://unix.stackexchange.com/a/23117" target="_blank" rel="external nofollow noopener noreferrer">https://unix.stackexchange.com/a/23117</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">foo=10</span><br><span class="line">x=foo</span><br><span class="line"><span class="built_in">eval</span> y=<span class="string">'$'</span><span class="variable">$x</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$y</span></span><br><span class="line">10</span><br></pre></td></tr></table></figure>

<h4 id="分割字符串并赋值给多个变量"><a href="#分割字符串并赋值给多个变量" class="headerlink" title="分割字符串并赋值给多个变量"></a>分割字符串并赋值给多个变量</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">a=<span class="string">'111|222|333'</span></span><br><span class="line">OIFS=<span class="variable">$IFS</span>; IFS=<span class="string">"|"</span>; <span class="built_in">set</span> -- <span class="variable">$a</span>; aa=<span class="variable">$1</span>;bb=<span class="variable">$2</span>;cc=<span class="variable">$3</span>; IFS=<span class="variable">$OIFS</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$aa</span> <span class="variable">$bb</span> <span class="variable">$cc</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>VMware Workstation 虚拟机 root 分区扩容</title>
    <url>/post/eca5e5f3.html</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th align="center">Date</th>
<th align="center">Log</th>
</tr>
</thead>
<tbody><tr>
<td align="center">26/05/2019</td>
<td align="center">初始版本.</td>
</tr>
</tbody></table><h3 id="解决什么问题"><a href="#解决什么问题" class="headerlink" title="解决什么问题"></a>解决什么问题</h3><p>本文尝试解决的问题：</p><ul>
<li>在使用 VMware Workstation 安装 Centos 虚拟机后，发现根分区大小不够用，在不进行系统重装的前提下对根分区进行扩容。</li>
</ul><h3 id="具体步骤"><a href="#具体步骤" class="headerlink" title="具体步骤"></a>具体步骤</h3><p>基本过程是先通过 VMware Workstations 对虚拟物理磁盘设备进行扩容，然后进入系统后新建 LVM 分区，新建 PV，分配 PV 给 VG，扩容 LV，最后扩容文件系统。</p><a id="more"></a>



<h4 id="物理磁盘扩容"><a href="#物理磁盘扩容" class="headerlink" title="物理磁盘扩容"></a>物理磁盘扩容</h4><p>在 VMware Workstation 虚拟机详情中，对虚拟物理盘扩容，如图：<br><img src="https://cdn.nlark.com/yuque/0/2019/png/182657/1558855276765-9429af86-29d5-4e67-9dd1-2b5901f41d76.png#align=left&display=inline&height=521&name=image.png&originHeight=623&originWidth=892&size=90730&status=done&width=746" alt="image.png"></p>
<p>此时进入操作系统查看块设备详情，目标是增加 centos-root 容量：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># lsblk</span></span><br><span class="line">NAME            MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT</span><br><span class="line">sda               8:0    0  300G  0 disk</span><br><span class="line">├─sda1            8:1    0    1G  0 part /boot</span><br><span class="line">└─sda2            8:2    0   39G  0 part</span><br><span class="line">  ├─centos-root 253:0    0 35.1G  0 lvm  /</span><br><span class="line">  └─centos-swap 253:1    0  3.9G  0 lvm  [SWAP]</span><br><span class="line">sr0              11:0    1 1024M  0 rom</span><br></pre></td></tr></table></figure>

<h4 id="新建-LVM-分区"><a href="#新建-LVM-分区" class="headerlink" title="新建 LVM 分区"></a>新建 LVM 分区</h4><p>使用 fsdik 在 /dev/sda 上新建分区。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># fdisk /dev/sda</span></span><br><span class="line">Welcome to fdisk (util-linux 2.23.2).</span><br><span class="line"></span><br><span class="line">Changes will remain <span class="keyword">in</span> memory only, until you decide to write them.</span><br><span class="line">Be careful before using the write <span class="built_in">command</span>.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Command (m <span class="keyword">for</span> <span class="built_in">help</span>): n</span><br></pre></td></tr></table></figure>

<p>根据提示， 一直 Enter 采用默认设置即可，直到出现类似以下输出：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Partition 3 of <span class="built_in">type</span> Linux and of size 260 GiB is <span class="built_in">set</span></span><br></pre></td></tr></table></figure>

<p>之后，键入 t 进行分区类型设置，依次输入 3、8e 设置 LVM 分区：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Command (m <span class="keyword">for</span> <span class="built_in">help</span>): t</span><br><span class="line">Partition number (1-3, default 3): 3</span><br><span class="line">Hex code (<span class="built_in">type</span> L to list all codes): 8e</span><br><span class="line">Changed <span class="built_in">type</span> of partition <span class="string">'Linux'</span> to <span class="string">'Linux LVM'</span></span><br></pre></td></tr></table></figure>

<p>然后，键入 w 保存分区。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Command (m <span class="keyword">for</span> <span class="built_in">help</span>): w</span><br><span class="line">The partition table has been altered!</span><br><span class="line"></span><br><span class="line">Calling ioctl() to re-read partition table.</span><br><span class="line"></span><br><span class="line">WARNING: Re-reading the partition table failed with error 16: Device or resource busy.</span><br><span class="line">The kernel still uses the old table. The new table will be used at</span><br><span class="line">the next reboot or after you run partprobe(8) or kpartx(8)</span><br><span class="line">Syncing disks.</span><br></pre></td></tr></table></figure>

<p>使用以下命令扫描出新创建的分区：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># partprobe -s</span></span><br><span class="line">/dev/sda: msdos partitions 1 2 3</span><br></pre></td></tr></table></figure>

<p>或者如下命令扫描：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># partx -v -a /dev/sda</span></span><br></pre></td></tr></table></figure>

<p>此时，查看块设备详情可以看到新建的 /dev/sda3 分区：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># lsblk</span></span><br><span class="line">NAME            MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT</span><br><span class="line">sda               8:0    0  300G  0 disk</span><br><span class="line">├─sda1            8:1    0    1G  0 part /boot</span><br><span class="line">├─sda2            8:2    0   39G  0 part</span><br><span class="line">│ ├─centos-root 253:0    0 35.1G  0 lvm  /</span><br><span class="line">│ └─centos-swap 253:1    0  3.9G  0 lvm  [SWAP]</span><br><span class="line">└─sda3            8:3    0  260G  0 part</span><br><span class="line">sr0              11:0    1 1024M  0 rom</span><br></pre></td></tr></table></figure>

<h4 id="使用新分区扩容-LV"><a href="#使用新分区扩容-LV" class="headerlink" title="使用新分区扩容 LV"></a>使用新分区扩容 LV</h4><p>在磁盘分区的基础上创建物理卷：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># pvcreate /dev/sda3</span></span><br><span class="line">Physical volume <span class="string">"/dev/sda3"</span> successfully created</span><br></pre></td></tr></table></figure>

<p>使用新建的物理卷扩展卷组：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># vgextend centos /dev/sda3</span></span><br><span class="line">  Volume group <span class="string">"centos"</span> successfully extended</span><br></pre></td></tr></table></figure>

<p>扩容逻辑卷：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#  lvextend /dev/centos/root /dev/sda3</span></span><br><span class="line">  Size of logical volume centos/root changed from 35.12 GiB (8991 extents) to &lt;295.12 GiB (75550 extents).</span><br><span class="line">  Logical volume centos/root successfully resized.</span><br></pre></td></tr></table></figure>

<p>扩容文件系统：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># xfs_growfs /dev/mapper/centos-root</span></span><br><span class="line">meta-data=/dev/mapper/centos-root isize=512    agcount=4, agsize=2301440 blks</span><br><span class="line">         =                       sectsz=512   attr=2, projid32bit=1</span><br><span class="line">         =                       crc=1        finobt=0 spinodes=0</span><br><span class="line">data     =                       bsize=4096   blocks=9205760, imaxpct=25</span><br><span class="line">         =                       sunit=0      swidth=0 blks</span><br><span class="line">naming   =version 2              bsize=4096   ascii-ci=0 ftype=1</span><br><span class="line"><span class="built_in">log</span>      =internal               bsize=4096   blocks=4495, version=2</span><br><span class="line">         =                       sectsz=512   sunit=0 blks, lazy-count=1</span><br><span class="line">realtime =none                   extsz=4096   blocks=0, rtextents=0</span><br><span class="line">data blocks changed from 9205760 to 77363200</span><br></pre></td></tr></table></figure>

<p>最后查看块设备详情，扩容成功：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># lsblk</span></span><br><span class="line">NAME            MAJ:MIN RM   SIZE RO TYPE MOUNTPOINT</span><br><span class="line">sda               8:0    0   300G  0 disk</span><br><span class="line">├─sda1            8:1    0     1G  0 part /boot</span><br><span class="line">├─sda2            8:2    0    39G  0 part</span><br><span class="line">│ ├─centos-root 253:0    0 295.1G  0 lvm  /</span><br><span class="line">│ └─centos-swap 253:1    0   3.9G  0 lvm  [SWAP]</span><br><span class="line">└─sda3            8:3    0   260G  0 part</span><br><span class="line">  └─centos-root 253:0    0 295.1G  0 lvm  /</span><br><span class="line">sr0              11:0    1  1024M  0 rom</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Virtualization</category>
      </categories>
      <tags>
        <tag>云计算</tag>
        <tag>Virtaulization</tag>
      </tags>
  </entry>
  <entry>
    <title>Thanos基本功能总结</title>
    <url>/post/1f42eec9.html</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th align="center">Date</th>
<th align="center">Log</th>
</tr>
</thead>
<tbody><tr>
<td align="center">01/07/2018</td>
<td align="center">初始版本：根据杭州 Service Mesh 线下 Meet Up 中唐老师相关讲解内容和官方文档简单总结.</td>
</tr>
</tbody></table><p>Prometheus 和 Grafana 作为监控界的仙侣组合为我们进行系统运行状况的监控提供了极大的便利，简单说，Prometheus 对数据进行采集，Grafana 对对数据进行图表形式的展示。当然它们也提供了更多高级功能。</p><a id="more"></a>

<p>在规模不大且结构简单的系统中，Prometheus 的基本功能已经可以完全满足用户需求。但在一些复杂场景下 Prometheus 的应用会面临一些问题，Prometheus 本身应对这些问题略显吃力。而 Thanos 正是 Improbable-eng 团队为解决这些问题而开发的一款开源中间层框架，它对 Grafana 提供与 Prometheus 一致的数据源接口，同时可以无缝地部署到现有的 Prometheus 环境中，不需要对 Prometheus 做任何定制。</p>
<h3 id="Prometheus-面临的问题"><a href="#Prometheus-面临的问题" class="headerlink" title="Prometheus 面临的问题"></a>Prometheus 面临的问题</h3><ol>
<li>全局视图</li>
</ol>
<p>当 Prometheus 用于监控多个 Kubernetes 集群时，它并没有提供一种较好的全局统一的数据采集方式。举个例子，需要实现当有 60%的集群处于掉线状态时监控系统进行报警，通过 Prometheus 该如何实现？如何将来自不同集群的数据进行聚合？ 2. 高可用</p>
<p>Prometheus 如何方便的实现高可用？较为简单的方案是在同一个 server 上启动两个 Prometheus 实例，通过简单的反向代理实现高可。但问题是两个 Prometheus 实例的数据信息出现不一致时该如何处理，例如一段时间内其中一个实例的数据为空，另一个实例的数据可用，则在前端的不同查询可能会对同一时间段的信息展示出现完全不同的效果，影响监控人员的使用。因此需要进行数据合并。 3. 历史数据的处理</p>
<p>Prometheus 本身使用本地存储，为保证存储空间可用，会定时清理存储的监控数据，如果监控人员需要对长期的监控数据，例如 1 年的数据，进行分析，进而分析系统的潜在问题。对于 Prometheus 来说纵向扩充硬盘的体积是较为简单的解决方案，然而这种形式成本高昂，也不方便数据管理和迁移。</p>
<h3 id="Thanos-的解决方案"><a href="#Thanos-的解决方案" class="headerlink" title="Thanos 的解决方案"></a>Thanos 的解决方案</h3><p>Thanos 致力于通过一种简单的可无缝接入当前系统的方案解决这些问题。其主要功能点通过 Sidecar、Querier、Store 和 Compactor 来实现，这里做一个简单介绍。</p>
<ol>
<li>Sidecar</li>
</ol>
<p>Sidecar 作为一个单独的进程和已有的 Prometheus 实例运行在一个 server 上，互不影响。Sidecar 可以视为一个 Proxy 组件，所有对 Prometheus 的访问都通过 Sidecar 来代理进行。通过 Sidecar 还可以将采集到的数据直接备份到云端对象存储服务器。 2. Querier</p>
<p>所有的 Sidecar 与 Querier 直连，同时 Querier 实现了一套 Prometheus 官方的 HTTP API 从而保证对外提供与 Prometheus 一致的数据源接口，Grafana 可以通过同一个查询接口请求不同集群的数据，Querier 负责找到对应的集群并通过 Sidecar 获取数据。Querier 本身也是水平可扩展的，因而可以实现高可部署，而且 Querier 可以实现对高可部署的 Prometheus 的数据进行合并从而保证多次查询结果的一致性，从而解决全局视图和高可用的问题。 3. Store</p>
<p>Store 实现了一套和 Sidecar 完全一致的 API 提供给 Querier 用于查询 Sidecar 备份到云端对象存储的数据。因为 Sidecar 在完成数据备份后，Prometheus 会清理掉本地数据保证本地空间可用。所以当监控人员需要调取历史数据时只能去对象存储空间获取，而 Store 就提供了这样一个接口。Store Gateway 只会缓存对象存储的基本信息，例如存储块的索引，从而保证实现快速查询的同时占用较少本地空间。 4. Comactor</p>
<p>Compactor 主要用于对采集到的数据进行压缩，实现将数据存储至对象存储时节省空间。</p>
<h3 id="Thanos-的生产可用性"><a href="#Thanos-的生产可用性" class="headerlink" title="Thanos 的生产可用性"></a>Thanos 的生产可用性</h3><p>Thanos 诞生还不到一年，目前最新的发布版本为 0.1.0-rc.1，大量的生产实践还未看到，短期预计还不具备生产可用性，但是解决问题的理念值得长期关注。</p>
]]></content>
      <categories>
        <category>云计算</category>
      </categories>
      <tags>
        <tag>云计算</tag>
        <tag>Thanos</tag>
        <tag>Prometheus</tag>
      </tags>
  </entry>
  <entry>
    <title>VSCode 使用技巧</title>
    <url>/post/16a650d7.html</url>
    <content><![CDATA[<h4 id="Linux-下默认快捷键"><a href="#Linux-下默认快捷键" class="headerlink" title="Linux 下默认快捷键"></a>Linux 下默认快捷键</h4><ul>
<li><code>Ctrl+Alt+-</code>  返回上一个位置</li>
<li><code>Ctrl+Shift+-</code>  转到下一个位置</li>
</ul><h4 id="将-n-字符替换为换行符"><a href="#将-n-字符替换为换行符" class="headerlink" title="将 /n 字符替换为换行符"></a>将 /n 字符替换为换行符</h4><p>在替换为一栏中输入 <code>Ctrl+Enter</code> 可以输入换行符。</p>]]></content>
      <categories>
        <category>VSCode</category>
      </categories>
      <tags>
        <tag>VSCode</tag>
      </tags>
  </entry>
  <entry>
    <title>context 相关知识与用法</title>
    <url>/post/b246b51.html</url>
    <content><![CDATA[<h4 id="父子-context-cancel-的传递"><a href="#父子-context-cancel-的传递" class="headerlink" title="父子 context cancel 的传递"></a>父子 context cancel 的传递</h4><p>以下测试可以简单验证父 context cancel 会传递到子 context，子 context cancel 不会影响父 context。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"context"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ctx, cancel := context.WithCancel(context.Background())</span><br><span class="line">	newCtx, cancel1 := context.WithCancel(ctx)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">		&lt;-ctx.Done()</span><br><span class="line">		fmt.Printf(<span class="string">"parent cancelled %s\n"</span>, time.Now())</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">		&lt;-newCtx.Done()</span><br><span class="line">		fmt.Printf(<span class="string">"child cancelled %s\n"</span>, time.Now())</span><br><span class="line">	&#125;()</span><br><span class="line">	time.Sleep(<span class="number">1</span>*time.Second)</span><br><span class="line">    <span class="comment">// cancel()</span></span><br><span class="line">	cancel1()</span><br><span class="line">	time.Sleep(<span class="number">10</span>*time.Second)</span><br><span class="line">    <span class="comment">// cancel1()</span></span><br><span class="line">	cancel()</span><br><span class="line">	time.Sleep(<span class="number">10</span>*time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>context</tag>
      </tags>
  </entry>
  <entry>
    <title>client-go 的零零碎碎的用法</title>
    <url>/post/91373500.html</url>
    <content><![CDATA[<h4 id="使用-raw-url-操作资源对象"><a href="#使用-raw-url-操作资源对象" class="headerlink" title="使用 raw url 操作资源对象"></a>使用 raw url 操作资源对象</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">data, err := clientset.RESTClient().Get().AbsPath(<span class="string">"apis/metrics.k8s.io/v1beta1/nodes"</span>).DoRaw()</span><br></pre></td></tr></table></figure><h4 id="使用-dynamic-client-和-server-side-apply"><a href="#使用-dynamic-client-和-server-side-apply" class="headerlink" title="使用 dynamic client 和 server side apply"></a>使用 dynamic client 和 server side apply</h4><p>参考：<a href="https://ymmt2005.hatenablog.com/entry/2020/04/14/An_example_of_using_dynamic_client_of_k8s.io/client-go" target="_blank" rel="external nofollow noopener noreferrer">An example of using dynamic client of k8s.io/client-go</a></p><a id="more"></a>


<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"context"</span></span><br><span class="line">    <span class="string">"encoding/json"</span></span><br><span class="line"></span><br><span class="line">    <span class="string">"k8s.io/apimachinery/pkg/api/meta"</span></span><br><span class="line">    metav1 <span class="string">"k8s.io/apimachinery/pkg/apis/meta/v1"</span></span><br><span class="line">    <span class="string">"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"</span></span><br><span class="line">    <span class="string">"k8s.io/apimachinery/pkg/runtime/serializer/yaml"</span></span><br><span class="line">    <span class="string">"k8s.io/apimachinery/pkg/types"</span></span><br><span class="line">    <span class="string">"k8s.io/client-go/discovery"</span></span><br><span class="line">    <span class="string">"k8s.io/client-go/discovery/cached/memory"</span></span><br><span class="line">    <span class="string">"k8s.io/client-go/dynamic"</span></span><br><span class="line">    <span class="string">"k8s.io/client-go/rest"</span></span><br><span class="line">    <span class="string">"k8s.io/client-go/restmapper"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> deploymentYAML = <span class="string">`</span></span><br><span class="line"><span class="string">apiVersion: apps/v1</span></span><br><span class="line"><span class="string">kind: Deployment</span></span><br><span class="line"><span class="string">metadata:</span></span><br><span class="line"><span class="string">  name: nginx-deployment</span></span><br><span class="line"><span class="string">  namespace: default</span></span><br><span class="line"><span class="string">spec:</span></span><br><span class="line"><span class="string">  selector:</span></span><br><span class="line"><span class="string">    matchLabels:</span></span><br><span class="line"><span class="string">      app: nginx</span></span><br><span class="line"><span class="string">  template:</span></span><br><span class="line"><span class="string">    metadata:</span></span><br><span class="line"><span class="string">      labels:</span></span><br><span class="line"><span class="string">        app: nginx</span></span><br><span class="line"><span class="string">    spec:</span></span><br><span class="line"><span class="string">      containers:</span></span><br><span class="line"><span class="string">      - name: nginx</span></span><br><span class="line"><span class="string">        image: nginx:latest</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> decUnstructured = yaml.NewDecodingSerializer(unstructured.UnstructuredJSONScheme)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doSSA</span><span class="params">(ctx context.Context, cfg *rest.Config)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. Prepare a RESTMapper to find GVR</span></span><br><span class="line">    dc, err := discovery.NewDiscoveryClientForConfig(cfg)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    mapper := restmapper.NewDeferredDiscoveryRESTMapper(memory.NewMemCacheClient(dc))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. Prepare the dynamic client</span></span><br><span class="line">    dyn, err := dynamic.NewForConfig(cfg)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. Decode YAML manifest into unstructured.Unstructured</span></span><br><span class="line">    obj := &amp;unstructured.Unstructured&#123;&#125;</span><br><span class="line">    _, gvk, err := decUnstructured.Decode([]<span class="keyword">byte</span>(deploymentYAML), <span class="literal">nil</span>, obj)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. Find GVR</span></span><br><span class="line">    mapping, err := mapper.RESTMapping(gvk.GroupKind(), gvk.Version)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. Obtain REST interface for the GVR</span></span><br><span class="line">    <span class="keyword">var</span> dr dynamic.ResourceInterface</span><br><span class="line">    <span class="keyword">if</span> mapping.Scope.Name() == meta.RESTScopeNameNamespace &#123;</span><br><span class="line">        <span class="comment">// namespaced resources should specify the namespace</span></span><br><span class="line">        dr = dyn.Resource(mapping.Resource).Namespace(obj.GetNamespace())</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// for cluster-wide resources</span></span><br><span class="line">        dr = dyn.Resource(mapping.Resource)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6. Marshal object into JSON</span></span><br><span class="line">    data, err := json.Marshal(obj)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 7. Create or Update the object with SSA</span></span><br><span class="line">    <span class="comment">//     types.ApplyPatchType indicates SSA.</span></span><br><span class="line">    <span class="comment">//     FieldManager specifies the field owner ID.</span></span><br><span class="line">    _, err = dr.Patch(ctx, obj.GetName(), types.ApplyPatchType, data, metav1.PatchOptions&#123;</span><br><span class="line">        FieldManager: <span class="string">"sample-controller"</span>,</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="使用-leader-election-选主实现高可用"><a href="#使用-leader-election-选主实现高可用" class="headerlink" title="使用 leader election 选主实现高可用"></a>使用 leader election 选主实现高可用</h4><p>参考：<a href="https://carlosbecker.com/posts/k8s-leader-election" target="_blank" rel="external nofollow noopener noreferrer">Leader Election inside Kubernetes</a></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    v1 <span class="string">"k8s.io/api/core/v1"</span></span><br><span class="line">	metav1 <span class="string">"k8s.io/apimachinery/pkg/apis/meta/v1"</span></span><br><span class="line">	<span class="string">"k8s.io/client-go/kubernetes"</span></span><br><span class="line">	<span class="string">"k8s.io/client-go/rest"</span></span><br><span class="line">	<span class="string">"k8s.io/client-go/tools/clientcmd"</span></span><br><span class="line">	<span class="string">"k8s.io/client-go/tools/leaderelection"</span></span><br><span class="line">	<span class="string">"k8s.io/client-go/tools/leaderelection/resourcelock"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	envKubeConfigPath := os.Getenv(<span class="string">"KUBECONFIG"</span>)</span><br><span class="line">	<span class="keyword">if</span> envKubeConfigPath == <span class="string">""</span> &#123;</span><br><span class="line">		klog.Fatal(<span class="string">"KUBECONFIG env must be set for kubeconfig file path"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	leaseNamespace := os.Getenv(<span class="string">"LEASE_NAMESPACE"</span>)</span><br><span class="line">	<span class="keyword">if</span> leaseNamespace == <span class="string">""</span> &#123;</span><br><span class="line">		klog.Fatal(<span class="string">"LEASE_NAMESPACE must be set for leader election"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	config, err := clientcmd.BuildConfigFromFlags(<span class="string">""</span>, envKubeConfigPath)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		klog.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">	clientset, err := kubernetes.NewForConfig(config)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		klog.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">	inClusterConfig, err := rest.InClusterConfig()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		klog.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">	inClusterClient, err := kubernetes.NewForConfig(inClusterConfig)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		klog.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ctx, cancel := context.WithCancel(context.Background())</span><br><span class="line">	sigc := <span class="built_in">make</span>(<span class="keyword">chan</span> os.Signal, <span class="number">1</span>)</span><br><span class="line">	signal.Notify(sigc, syscall.SIGHUP, syscall.SIGINT, syscall.SIGTERM, syscall.SIGQUIT)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		&lt;-sigc</span><br><span class="line">		cancel()</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	id := uuid.New().String()</span><br><span class="line">	klog.Infof(<span class="string">"ResourceLock identity id: %s"</span>, id)</span><br><span class="line">	lock := &amp;resourcelock.LeaseLock&#123;</span><br><span class="line">		LeaseMeta: metav1.ObjectMeta&#123;</span><br><span class="line">			Name:      <span class="string">"k8s-events-exporter"</span>,</span><br><span class="line">			Namespace: leaseNamespace,</span><br><span class="line">		&#125;,</span><br><span class="line">		Client: inClusterClient.CoordinationV1(),</span><br><span class="line">		LockConfig: resourcelock.ResourceLockConfig&#123;</span><br><span class="line">			Identity: id,</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Start the leader election code loop</span></span><br><span class="line">	klog.Infof(<span class="string">"LeaderElectionConfig are: LeaseDuration %v second, RenewDeadline %v second, RetryPeriod %v second."</span>,</span><br><span class="line">		leaseDuration, renewDeadline, retryPeriod)</span><br><span class="line">	subCtx, subCancel := context.WithCancel(ctx)</span><br><span class="line">	leaderelection.RunOrDie(ctx, leaderelection.LeaderElectionConfig&#123;</span><br><span class="line">		Lock:            lock,</span><br><span class="line">		ReleaseOnCancel: <span class="literal">true</span>,</span><br><span class="line">		LeaseDuration:   leaseDuration * time.Second,</span><br><span class="line">		RenewDeadline:   renewDeadline * time.Second,</span><br><span class="line">		RetryPeriod:     retryPeriod * time.Second,</span><br><span class="line">		Callbacks: leaderelection.LeaderCallbacks&#123;</span><br><span class="line">			OnStartedLeading: <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">				run(subCtx, clientset)</span><br><span class="line">			&#125;,</span><br><span class="line">			OnStoppedLeading: <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">				klog.Warningf(<span class="string">"Leader %s lost"</span>, id)</span><br><span class="line">				subCancel()</span><br><span class="line">			&#125;,</span><br><span class="line">			OnNewLeader: <span class="function"><span class="keyword">func</span><span class="params">(identity <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">				<span class="comment">// we're notified when new leader elected</span></span><br><span class="line">				<span class="keyword">if</span> identity == id &#123;</span><br><span class="line">					klog.Infof(<span class="string">"Acquired the lock %s"</span>, identity)</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					klog.Infof(<span class="string">"Leader is %v for the moment"</span>, identity)</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;,</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="获取-clientset"><a href="#获取-clientset" class="headerlink" title="获取 clientset"></a>获取 clientset</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// use the current context in kubeconfig</span></span><br><span class="line">config, err := clientcmd.BuildConfigFromFlags(<span class="string">""</span>, *kubeconfig)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="built_in">panic</span>(err.Error())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// create the clientset</span></span><br><span class="line">clientset, err := kubernetes.NewForConfig(config)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="built_in">panic</span>(err.Error())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="批量删除资源"><a href="#批量删除资源" class="headerlink" title="批量删除资源"></a>批量删除资源</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//根据label批量删除pvc</span></span><br><span class="line">labelPvc := labels.SelectorFromSet(labels.Set(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;<span class="string">"app"</span>: redisClusterName&#125;))</span><br><span class="line">listPvcOptions := metav1.ListOptions&#123;</span><br><span class="line">    LabelSelector: labelPvc.String(),</span><br><span class="line">&#125;</span><br><span class="line">err = kubeClient.CoreV1().PersistentVolumeClaims(redisClusterNamespace).DeleteCollection(&amp;metav1.DeleteOptions&#123;&#125;, listPvcOptions)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> !errors.IsNotFound(err) &#123;</span><br><span class="line">        klog.Errorf(<span class="string">"Drop RedisCluster: %v/%v pvc error: %v"</span>, redisClusterNamespace, redisClusterName, err)</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="使用-fake-client-写单元测试"><a href="#使用-fake-client-写单元测试" class="headerlink" title="使用 fake client 写单元测试"></a>使用 fake client 写单元测试</h4><p>使用 interface ( kubernetes.Interface ) 而不是 struct ( kubernetes.Clientset )。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> namespaces</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line">	<span class="string">"k8s.io/api/core/v1"</span></span><br><span class="line">	metav1 <span class="string">"k8s.io/apimachinery/pkg/apis/meta/v1"</span></span><br><span class="line">	<span class="string">"k8s.io/client-go/kubernetes"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> KubernetesAPI <span class="keyword">struct</span> &#123;</span><br><span class="line">	Suffix <span class="keyword">string</span></span><br><span class="line">	Client  kubernetes.Interface</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewNamespaceWithPostfix creates a new namespace with a stable postfix</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(k KubernetesAPI)</span> <span class="title">NewNamespaceWithSuffix</span><span class="params">(namespace <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	ns := &amp;v1.Namespace&#123;</span><br><span class="line">		ObjectMeta: metav1.ObjectMeta&#123;</span><br><span class="line">			Name: fmt.Sprintf(<span class="string">"%s-%s"</span>, namespace, k.Suffix),</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	_, err := k.Client.CoreV1().Namespaces().Create(ns)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ackage namespaces</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"testing"</span></span><br><span class="line"></span><br><span class="line">	<span class="string">"k8s.io/apimachinery/pkg/apis/meta/v1"</span></span><br><span class="line">	testclient <span class="string">"k8s.io/client-go/kubernetes/fake"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestNewNamespaceWithSuffix</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	cases := []<span class="keyword">struct</span> &#123;</span><br><span class="line">		ns <span class="keyword">string</span></span><br><span class="line">	&#125;&#123;</span><br><span class="line">		&#123;</span><br><span class="line">			ns: <span class="string">"test"</span>,</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	api := &amp;KubernetesAPI&#123;</span><br><span class="line">		Suffix: <span class="string">"unit-test"</span>,</span><br><span class="line">		Client:  testclient.NewSimpleClientset(),</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> _, c := <span class="keyword">range</span> cases &#123;</span><br><span class="line">		<span class="comment">// create the postfixed namespace</span></span><br><span class="line">		err := api.NewNamespaceWithSuffix(c.ns)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			t.Fatal(err.Error())</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		_, err = api.Client.CoreV1().Namespaces().Get(<span class="string">"test-unit-test"</span>, v1.GetOptions&#123;&#125;)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			t.Fatal(err.Error())</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>kubernetes</category>
      </categories>
      <tags>
        <tag>kubernetes</tag>
        <tag>client-go</tag>
      </tags>
  </entry>
  <entry>
    <title>gRPC snippets</title>
    <url>/post/ab759786.html</url>
    <content><![CDATA[<h4 id="使用-gRPC-错误类型"><a href="#使用-gRPC-错误类型" class="headerlink" title="使用 gRPC 错误类型"></a>使用 gRPC 错误类型</h4><p>服务端返回  <code>codes.PermissionDenined</code>  错误：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	...</span><br><span class="line">	<span class="string">"google.golang.org/grpc/codes"</span></span><br><span class="line">	<span class="string">"google.golang.org/grpc/status"</span></span><br><span class="line">)</span><br><span class="line">...</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, status.Error(codes.PermissionDenied, <span class="string">"PERMISSION_DENIED_TEXT"</span>)</span><br></pre></td></tr></table></figure><a id="more"></a>


<p>客户端使用  <code>status</code>  库的  <code>FromError</code>  函数解析错误，使用<code>swicth</code> 语句判断错误类型并进行对应操作:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; client</span><br><span class="line">    assignvar, err :&#x3D; s.MyFunctionCall(ctx, ...)</span><br><span class="line">    if err !&#x3D; nil &#123;</span><br><span class="line">        if e, ok :&#x3D; status.FromError(err); ok &#123;</span><br><span class="line">            switch e.Code() &#123;</span><br><span class="line">            case codes.PermissionDenied:</span><br><span class="line">                fmt.Println(e.Message()) &#x2F;&#x2F; this will print PERMISSION_DENIED_TEST</span><br><span class="line">            case codes.Internal:</span><br><span class="line">                fmt.Println(&quot;Has Internal Error&quot;)</span><br><span class="line">            case codes.Aborted:</span><br><span class="line">                fmt.Println(&quot;gRPC Aborted the call&quot;)</span><br><span class="line">            default:</span><br><span class="line">                fmt.Println(e.Code(), e.Message())</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            fmt.Printf(&quot;not able to parse error returned %v&quot;, err)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="使用-metadata-进行用户认证"><a href="#使用-metadata-进行用户认证" class="headerlink" title="使用 metadata 进行用户认证"></a>使用 metadata 进行用户认证</h4><p>参考：<a href="https://github.com/grpc/grpc-go/issues/106" target="_blank" rel="external nofollow noopener noreferrer">https://github.com/grpc/grpc-go/issues/106</a>，通过添加拦截器的方式</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// client</span></span><br><span class="line">grpc.Dial(target,</span><br><span class="line">    grpc.WithInsecure(),</span><br><span class="line">    grpc.WithPerRPCCredentials(&amp;loginCreds&#123;</span><br><span class="line">    Username: <span class="string">"admin"</span>,</span><br><span class="line">    Password: <span class="string">"admin123"</span>,</span><br><span class="line">&#125;))</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> loginCreds <span class="keyword">struct</span> &#123;</span><br><span class="line">    Username, Password <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *loginCreds)</span> <span class="title">GetRequestMetadata</span><span class="params">(context.Context, ...<span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>, error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;</span><br><span class="line">        <span class="string">"username"</span>: c.Username,</span><br><span class="line">        <span class="string">"password"</span>: c.Password,</span><br><span class="line">    &#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *loginCreds)</span> <span class="title">RequireTransportSecurity</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// server</span></span><br><span class="line">grpc.NewServer(</span><br><span class="line">    grpc.StreamInterceptor(streamInterceptor),</span><br><span class="line">    grpc.UnaryInterceptor(unaryInterceptor)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">streamInterceptor</span><span class="params">(srv <span class="keyword">interface</span>&#123;&#125;, stream grpc.ServerStream, info *grpc.StreamServerInfo, handler grpc.StreamHandler)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> err := authorize(stream.Context()); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> handler(srv, stream)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">unaryInterceptor</span><span class="params">(ctx context.Context, req <span class="keyword">interface</span>&#123;&#125;, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler)</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> err := authorize(ctx); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> handler(ctx, req)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">authorize</span><span class="params">(ctx context.Context)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> md, ok := metadata.FromContext(ctx); ok &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(md[<span class="string">"username"</span>]) &gt; <span class="number">0</span> &amp;&amp; md[<span class="string">"username"</span>][<span class="number">0</span>] == <span class="string">"admin"</span> &amp;&amp;</span><br><span class="line">            <span class="built_in">len</span>(md[<span class="string">"password"</span>]) &gt; <span class="number">0</span> &amp;&amp; md[<span class="string">"password"</span>][<span class="number">0</span>] == <span class="string">"admin123"</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> AccessDeniedErr</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> EmptyMetadataErr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>官方文档关于认证的内容：<a href="https://grpc.io/docs/guides/auth/" target="_blank" rel="external nofollow noopener noreferrer">https://grpc.io/docs/guides/auth/</a>，支持基于 TLS 证书的认证过程，使用参考：<a href="https://mycodesmells.com/post/authentication-in-grpc" target="_blank" rel="external nofollow noopener noreferrer">https://mycodesmells.com/post/authentication-in-grpc</a>，这篇文章也说明 contextWithValue 的值无法通过 gRPC 通信传递，需要通过 metadata 传输用户信息。</li>
<li>使用 metadata：可以使用 metadata 传输一些用户认证或者业务无关的信息，类似于 Http 请求中的 Header。使用方法参考： <a href="http://ralphbupt.github.io/2017/05/27/gRPC%E4%B9%8Bmetadata/" target="_blank" rel="external nofollow noopener noreferrer">http://ralphbupt.github.io/2017/05/27/gRPC 之 metadata/</a> 以及原文 <a href="https://github.com/grpc/grpc-go/blob/master/Documentation/grpc-metadata.md#sending-metadata-1" target="_blank" rel="external nofollow noopener noreferrer">https://github.com/grpc/grpc-go/blob/master/Documentation/grpc-metadata.md#sending-metadata-1</a>。</li>
</ul>
<h4 id="grpc-gateway-实现-gRPC-server-提供-RESTful"><a href="#grpc-gateway-实现-gRPC-server-提供-RESTful" class="headerlink" title="grpc-gateway 实现 gRPC server 提供  RESTful"></a>grpc-gateway 实现 gRPC server 提供  RESTful</h4><p>实现在同一服务端的同一端口同时提供 gRPC 和 RESTful 服务，用于向后兼容及技术栈的平滑迁移。其基本原理是创建一个 HTTP  反向代理服务，将客户端的 HTTP 请求转换为 gRPC 客户端请求并向 gRPC 服务端发起调用。辅助命令工具的部署安装参考：<a href="https://grpc-ecosystem.github.io/grpc-gateway/docs/usage.html" target="_blank" rel="external nofollow noopener noreferrer">https://grpc-ecosystem.github.io/grpc-gateway/docs/usage.html</a>。<br><img src="https://cdn.nlark.com/yuque/0/2019/png/182657/1573718382911-c19287bb-bfb6-4d82-8970-00489693b8ad.png#align=left&display=inline&height=369&name=image.png&originHeight=369&originWidth=749&size=52841&status=done&style=none&width=749" alt="image.png"><br>会使用到以下命令：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 基于 proto 生成 go 代码，使用到 protoc-gen-go 可执行文件</span></span><br><span class="line"><span class="comment">// -I 参数用于指定 proto 文件中导入的外部 proto 文件的搜索路径</span></span><br><span class="line">protoc -I/usr/local/include -I. -I$GOPATH/src -I$GOPATH/src/github.com/grpc-ecosystem/grpc-gateway/third_party/googleapis --go_out=plugins=grpc:. service.proto</span><br><span class="line"><span class="comment">// 生成 grpc-web 的 js 代码，非必须，仅当欲使用 grpc-web，使用到 protoc-gen-grpc-web 可执行文件</span></span><br><span class="line">protoc service.proto --grpc-web_out=import_style=typescript,mode=grpcwebtext:./ --js_out=import_style=commonjs:.</span><br><span class="line"><span class="comment">// 生成 grpc-gateway 相关的 go 代码，使用到 protoc-gen-grpc-gateway 可执行文件</span></span><br><span class="line">protoc -I/usr/local/include -I. -I$GOPATH/src -I$GOPATH/src/github.com/grpc-ecosystem/grpc-gateway/third_party/googleapis  --grpc-gateway_out=logtostderr=<span class="literal">true</span>:. service.proto</span><br><span class="line"><span class="comment">// 生成 swagger 格式的 API 文档，使用到 protoc-gen-swagger 可执行文件</span></span><br><span class="line">protoc -I/usr/local/include -I. -I$GOPATH/src -I$GOPATH/src/github.com/grpc-ecosystem/grpc-gateway/third_party/googleapis --swagger_out=logtostderr=<span class="literal">true</span>:. service.proto</span><br></pre></td></tr></table></figure>

<p>使用 gRPC 错误类型的另一个好处是 grpc-gateway 会自动将其转换为对应的 HTTP 状态码而不是每次出错都返回 500，参见 grpc-gateway <a href="https://github.com/grpc-ecosystem/grpc-gateway/blob/master/runtime/errors.go" target="_blank" rel="external nofollow noopener noreferrer">源码</a>。<br>grpc-gateway 需要使用  google.api.http，参考  <a href="https://blog.csdn.net/xiaojia1100/article/details/79447283" target="_blank" rel="external nofollow noopener noreferrer">https://blog.csdn.net/xiaojia1100/article/details/79447283</a><br>可参考的实例：</p>
<ul>
<li><a href="https://medium.com/swlh/rest-over-grpc-with-grpc-gateway-for-go-9584bfcbb835" target="_blank" rel="external nofollow noopener noreferrer">https://medium.com/swlh/rest-over-grpc-with-grpc-gateway-for-go-9584bfcbb835</a></li>
<li><a href="https://forum.golangbridge.org/t/go-rest-grpc-api/13072/5" target="_blank" rel="external nofollow noopener noreferrer">https://forum.golangbridge.org/t/go-rest-grpc-api/13072/5</a></li>
</ul>
<h4 id="使用-Empty-类型"><a href="#使用-Empty-类型" class="headerlink" title="使用 Empty 类型"></a>使用 Empty 类型</h4><p>在 gRPC 中要求每个函数调用都有返回值，如果确实不需要返回值，则为了统一规范与重用，我们可以使用 google 提供的 Empty 类型，Empty 类型的对象在序列化和反序列化时会被视为空对象，其 JSON 形式表示为 <code>{}</code> ，使用方法：</p>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"google/protobuf/empty.proto"</span>;</span><br><span class="line"><span class="class"><span class="keyword">service</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">rpc</span> Bar(google.protobuf.Empty) <span class="keyword">returns</span> (google.protobuf.Empty)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="传输文件"><a href="#传输文件" class="headerlink" title="传输文件"></a>传输文件</h4><p><a href="https://ops.tips/blog/sending-files-via-grpc/" target="_blank" rel="external nofollow noopener noreferrer">https://ops.tips/blog/sending-files-via-grpc/</a></p>
]]></content>
      <categories>
        <category>gRPC</category>
      </categories>
      <tags>
        <tag>Go</tag>
        <tag>gRPC</tag>
      </tags>
  </entry>
  <entry>
    <title>helm 常用命令</title>
    <url>/post/848070c7.html</url>
    <content><![CDATA[<h4 id="helm-set-array"><a href="#helm-set-array" class="headerlink" title="helm set array"></a>helm set array</h4><p>value.yaml 中设置了如下值：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># values.yaml</span></span><br><span class="line"><span class="attr">keycloak:</span></span><br><span class="line">  <span class="attr">ingress:</span></span><br><span class="line">    <span class="attr">hosts:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"auth1"</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"auth2"</span></span><br></pre></td></tr></table></figure><p>有以下两种方式可以在 install 时 set 值：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">$</span> <span class="string">helm</span> <span class="string">install</span> <span class="string">codecentric/keycloak</span> <span class="string">--set</span> <span class="string">'keycloak.ingress.hosts=&#123;auth1,auth2&#125;'</span></span><br><span class="line"><span class="string">$</span> <span class="string">helm</span> <span class="string">install</span> <span class="string">codecentric/keycloak</span> <span class="string">--set</span> <span class="string">'keycloak.ingress.hosts[0]=auth1'</span> <span class="string">--set</span> <span class="string">'keycloak.ingress.hosts[1]=auth2'</span></span><br></pre></td></tr></table></figure><a id="more"></a>





<h4 id="value-中传递的-yaml-数组格式化为-json"><a href="#value-中传递的-yaml-数组格式化为-json" class="headerlink" title="value 中传递的 yaml 数组格式化为 json"></a>value 中传递的 yaml 数组格式化为 json</h4><p>value.yaml 中：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">organizations:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">"foo"</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">"bar"</span></span><br></pre></td></tr></table></figure>

<p>格式化为：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">organizations:</span> <span class="string">["foo",</span> <span class="string">"bar"</span><span class="string">]</span></span><br></pre></td></tr></table></figure>

<p>可使用：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">organizations:</span> <span class="string">&#123;</span> <span class="string">&#123;</span> <span class="string">.Values.organizations</span> <span class="string">|</span> <span class="string">toJson</span> <span class="string">&#125;</span> <span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="https://itnext.io/helm-chart-install-advanced-usage-of-the-set-argument-3e214b69c87a" target="_blank" rel="external nofollow noopener noreferrer">https://itnext.io/helm-chart-install-advanced-usage-of-the-set-argument-3e214b69c87a</a><br><a href="https://stackoverflow.com/questions/52839920/get-array-of-strings-from-helm-config/52840704" target="_blank" rel="external nofollow noopener noreferrer">https://stackoverflow.com/questions/52839920/get-array-of-strings-from-helm-config/52840704</a></p>
]]></content>
      <categories>
        <category>helm</category>
      </categories>
      <tags>
        <tag>helm</tag>
      </tags>
  </entry>
  <entry>
    <title>macOS 使用相关</title>
    <url>/post/e9aa727.html</url>
    <content><![CDATA[<h4 id="安装-source-code-pro-字体"><a href="#安装-source-code-pro-字体" class="headerlink" title="安装  source-code-pro 字体"></a>安装  source-code-pro 字体</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brew tap homebrew&#x2F;cask-fonts &amp;&amp; brew cask install font-source-code-pro</span><br></pre></td></tr></table></figure><h4 id="解决字体模糊"><a href="#解决字体模糊" class="headerlink" title="解决字体模糊"></a>解决字体模糊</h4><p>开启  HiDPI 参考：<a href="https://github.com/xzhih/one-key-hidpi" target="_blank" rel="external nofollow noopener noreferrer">https://github.com/xzhih/one-key-hidpi</a></p><a id="more"></a>


<h4 id="VMware-fusion-开机启动虚拟机"><a href="#VMware-fusion-开机启动虚拟机" class="headerlink" title="VMware fusion 开机启动虚拟机"></a>VMware fusion 开机启动虚拟机</h4><p>参考：<a href="https://gist.github.com/jasoncodes/613198/bb94f7d9a1aa0f1bbb42deddcbca9b2dc532ff7e" target="_blank" rel="external nofollow noopener noreferrer">https://gist.github.com/jasoncodes/613198/bb94f7d9a1aa0f1bbb42deddcbca9b2dc532ff7e</a></p>
<h4 id="homebrew-使用国内镜像源"><a href="#homebrew-使用国内镜像源" class="headerlink" title="homebrew 使用国内镜像源"></a>homebrew 使用国内镜像源</h4><p>安装 homebre</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;bin&#x2F;zsh -c &quot;$(curl -fsSL https:&#x2F;&#x2F;gitee.com&#x2F;cunkai&#x2F;HomebrewCN&#x2F;raw&#x2F;master&#x2F;Homebrew.sh)&quot;</span><br></pre></td></tr></table></figure>

<p>配置国内镜像源，参考：<a href="https://developer.aliyun.com/mirror/homebrew?spm=a2c6h.13651102.0.0.3e221b11ZOeaob" target="_blank" rel="external nofollow noopener noreferrer">https://developer.aliyun.com/mirror/homebrew?spm=a2c6h.13651102.0.0.3e221b11ZOeaob</a>，<a href="https://blog.csdn.net/iroguel/article/details/93481795" target="_blank" rel="external nofollow noopener noreferrer">https://blog.csdn.net/iroguel/article/details/93481795</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/usr/bin/ruby -e <span class="string">"<span class="variable">$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)</span>"</span></span><br></pre></td></tr></table></figure>

<h4 id="安装-iproute2"><a href="#安装-iproute2" class="headerlink" title="安装 iproute2"></a>安装 iproute2</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brew install iproute2mac</span><br></pre></td></tr></table></figure>

<h4 id="强制退出进程"><a href="#强制退出进程" class="headerlink" title="强制退出进程"></a>强制退出进程</h4><p>Command + Option + Shift + Esc</p>
<h4 id="安装-Docker"><a href="#安装-Docker" class="headerlink" title="安装 Docker"></a>安装 Docker</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">brew install --cask docker</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>开发工具</category>
      </categories>
      <tags>
        <tag>开发工具</tag>
        <tag>macOS</tag>
      </tags>
  </entry>
  <entry>
    <title>iptables 基础与操作</title>
    <url>/post/26e8b8c9.html</url>
    <content><![CDATA[<h4 id="防火墙"><a href="#防火墙" class="headerlink" title="防火墙"></a>防火墙</h4><p>从逻辑上讲，大体可分为网络防火墙和主机防火墙，网络防火墙在流量入口的最前端，保护后端网络中所有主机，主机防火墙在流量末端保护本机服务；从物理上讲，可分为硬件防火墙和软件防火墙，网络防火墙往往借助专用硬件设备及其可编程特性配置保护规则，实现高性能流量过滤，主机防火墙则多借助通用服务器和系统内核特性实现纯软件层面的过滤。部署 Linux 系统的主机上可借助内核的 Netfilter 框架实现流量过滤，iptables 正是基于 Netfilter 实现的应用最广的防火墙工具。和很多系统工具一样，iptables 由运行于内核空间的功能模块和运行于用户空间的入口程序共同构成，而我们常用的 iptables 命令行工具就是运行于用户空间的入口程序。iptables 虽然应用广泛，但其规则匹配过程的效率低下也受到诟病，尤其在 Kubernetes 等云原生应用场景中性能问题更为明显，这也促使基于 IPVS 的 kube-proxy 大规模取代了基于 iptables 的模式。从 CentOS 8 开始，旨在取代 iptables 的 nftables 开始成为默认的包过滤工具，它从设计上解决了 iptables 的缺陷并优化了使用体验，值得后续关注。另一项近期更为活跃的技术是 eBPF（extended BPF），起源于 92 年的 BSD Packet Filter，随后进行了全新设计并在 Linux 3.17 版本内核中以 eBPF 为名正式引入，传统的 BPF 以 cBPF 之名继续保留用于兼容。随后，eBPF 的应用领域不断拓宽，不再局限于网络流量的过滤与分析，大有成为 Linux 通用的性能监测基础架构的趋势，尤其在云原生时代，可观测性的重要性愈发突出，eBPF 大有可为。 bpfilter 就是基于 eBPF 构建的新一代包过滤内核模块，或许未来会替代 iptables/nftables ，但目前似乎进展缓慢，参考 <a href="https://lwn.net/Articles/822744/" target="_blank" rel="external nofollow noopener noreferrer">Rethinking bpfilter and user-mode helpers</a>。</p><a id="more"></a>
<h4 id="数据包经过防火墙的流程"><a href="#数据包经过防火墙的流程" class="headerlink" title="数据包经过防火墙的流程"></a>数据包经过防火墙的流程</h4><p>一个帮助理解的流程图：<br><img src="https://cdn.nlark.com/yuque/0/2020/png/182657/1598403804093-3e5e0ccb-8aca-4b18-ab91-73b8dd83c0bc.png#align=left&display=inline&height=400&margin=%5Bobject%20Object%5D&name=iptables.png&originHeight=533&originWidth=1012&size=56394&status=done&style=none&width=759" alt="iptables.png"><br>另一个更准确的流程图：<br><img src="https://cdn.nlark.com/yuque/0/2020/png/182657/1598402936150-d2584938-7100-4ffb-b675-1b578645cbc4.png#align=left&display=inline&height=764&margin=%5Bobject%20Object%5D&name=image.png&originHeight=3054&originWidth=2399&size=1900518&status=done&style=none&width=600" alt="image.png"></p>
<h4 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 列出规则 -v 显示详细信息，-x 显示计数器精确值，-L 后不跟链名则显示表中所有链的规则，-n 不进行地址反解</span></span><br><span class="line">iptables --line-numbers -nvx -t filter -L INPUT</span><br><span class="line"><span class="comment"># 在指定链的末尾添加规则</span></span><br><span class="line">iptables -t filter -A INPUT -s 192.168.1.146 -j DROP</span><br><span class="line"><span class="comment"># 在指定链的首部添加规则</span></span><br><span class="line">iptables -t filter -I INPUT -s 192.168.1.146 -j DROP</span><br><span class="line"><span class="comment"># 在指定行添加规则</span></span><br><span class="line">iptables -t filter -I INPUT 3 -s 192.168.1.146 -j DROP</span><br><span class="line"><span class="comment"># 删除指定行</span></span><br><span class="line">iptables -t filter -D INPUT 3</span><br><span class="line"><span class="comment"># 删除匹配行，若有多个匹配规则只会删除第一个</span></span><br><span class="line">iptables -t filter -D INPUT -s 192.168.1.146 -j DROP</span><br><span class="line"><span class="comment"># 删除指定链中的所有规则</span></span><br><span class="line">iptables -t filter -F INPUT</span><br><span class="line"><span class="comment"># 删除指定表中的所有规则</span></span><br><span class="line">iptables -t filter -F</span><br><span class="line"><span class="comment"># 导出规则到本地文件</span></span><br><span class="line">iptables-save &gt; /tmp/rules</span><br><span class="line"><span class="comment"># 从本地文件恢复规则</span></span><br><span class="line">iptables-restore &lt; /tmp/rules</span><br><span class="line"><span class="comment"># 指定报文流入的网卡进行过滤，-i 表示从哪个网卡流入，只有 PREOUTING/INPUT/FORWARD 链上能够使用</span></span><br><span class="line">iptables -t filter -i eth0 -I INPUT -d 192.168.1.8 -p tcp -m tcp --dport 8080 -j DROP</span><br><span class="line">iptables -t filter -i eth0 -I INPUT -s 192.168.1.8 -p tcp --dport 8000:8080 -j DROP</span><br><span class="line"><span class="comment"># 指定报文流出的网卡， -o 表示从哪个网卡流出，只有 FOREWARD/OUTPUT/POSTROUTING 链上能够使用</span></span><br><span class="line">iptables -t filter -o eth0 -I OUTPUT -d 192.168.1.8,192.168.3.4 -p tcp -m multiport --dports 8081,8893 -j DROP</span><br><span class="line">iptables -t filter -o eth0 -I OUTPUT -s 192.168.1.0/24 -p tcp -m multiport --dports 8081,8893 -j DROP</span><br><span class="line"><span class="comment"># 指定一段连续的地址</span></span><br><span class="line">iptables -t filter -I OUTPUT -m iprange --src-range 192.168.1.33-192.168.1.88 -p tcp -m multiport --dports 8081,8893 -j DROP</span><br><span class="line"><span class="comment"># 匹配字符串</span></span><br><span class="line">iptables -t filter -I INPUT -p tcp --sport 80 -m string --algo bm --string <span class="string">"dststr"</span> -j REJECT</span><br><span class="line"><span class="comment"># 限制连接数</span></span><br><span class="line">iptables -t filter -I INPUT -p tcp --dport 22 -m connlimit --connlimit-above 10 -j REJECT</span><br><span class="line"><span class="comment"># 限制请求速率</span></span><br><span class="line">iptables -t filter -I INPUT -p icmp -m <span class="built_in">limit</span> --<span class="built_in">limit</span>-burst 3 --<span class="built_in">limit</span> 10/second -j ACCEPT</span><br><span class="line"><span class="comment"># 根据 tcp-flag 限制请求包</span></span><br><span class="line">iptables -t filter -I INPUT -s 192.168.1.4 -p tcp -m tcp --dport 22 --tcp-flags SYN,ACK,FIN,RST,URG,PSH SYN -j REJECT</span><br><span class="line">iptables -t filter -I INPUT -s 192.168.1.4 -p tcp -m tcp --dport 22 --tcp-flags ALL SYN,ACK -j REJECT</span><br><span class="line">iptables -t filter -I INPUT -s 192.168.1.4 -p tcp -m tcp --dport 22 --syn -j REJECT</span><br><span class="line"><span class="comment"># 禁止别人 ping 本机</span></span><br><span class="line">iptables -t filter -I INPUT -p icmp -m icmp --icmp-type 8/0 -j REJECT</span><br><span class="line"><span class="comment"># 放行指定连接状态的数据包，注意这里的连接状态指的是 conntrack 表中维护的每一个连接的状态，而不是 TCP 协议的状态，conntrack 对 UDP 和 ICMP 同样维护有状态</span></span><br><span class="line">iptables -t filter -I INPUT -p tcp -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT</span><br></pre></td></tr></table></figure>

<h4 id="自定义链"><a href="#自定义链" class="headerlink" title="自定义链"></a>自定义链</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建自定义链</span></span><br><span class="line">iptables -t filter -N NEW_CHAIN</span><br><span class="line"><span class="comment"># 向自定义链添加规则</span></span><br><span class="line">iptables -t filter -I NEW_CHAIN -s 192.168.3.55 -p tcp --dport 80 -j DROP</span><br><span class="line"><span class="comment"># 必须在默认链中引用自定义链才能生效</span></span><br><span class="line">iptables -t filter -I INPUT -j NEW_CHAIN</span><br><span class="line"><span class="comment"># 删除自定义链需要先删除对它的引用并清空其中规则</span></span><br><span class="line">iptables -D INPUT 1</span><br><span class="line">iptables -F NEW_CHAIN</span><br><span class="line">iptables -X NEW_CHAIN</span><br></pre></td></tr></table></figure>

<h4 id="查看统计信息"><a href="#查看统计信息" class="headerlink" title="查看统计信息"></a>查看统计信息</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iptables -nvL [INPUT|FORWARD|OUTPUT|myCHAINNAME] --line-numbers | less</span><br></pre></td></tr></table></figure>

<h4 id="观测工具"><a href="#观测工具" class="headerlink" title="观测工具"></a>观测工具</h4><p><a href="https://github.com/commonism/iptables-trace" target="_blank" rel="external nofollow noopener noreferrer">https://github.com/commonism/iptables-trace</a><br><a href="https://github.com/x-way/iptables-tracer" target="_blank" rel="external nofollow noopener noreferrer">https://github.com/x-way/iptables-tracer</a></p>
<h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ul>
<li><a href="https://baijiahao.baidu.com/s?id=1598167710178783742픴=spider&for=pc" target="_blank" rel="external nofollow noopener noreferrer">linux 内核将用 BPF 给 iptables 换心</a></li>
<li><a href="https://medium.com/@ugendreshwarkudupudi/bpfilter-your-next-firewall-engine-5f7dc63ebc3" target="_blank" rel="external nofollow noopener noreferrer">BPFILTER: Your next Firewall Engine</a></li>
<li><a href="https://stuffphilwrites.com/2014/09/iptables-processing-flowchart/" target="_blank" rel="external nofollow noopener noreferrer">iptables Processing Flowchart</a></li>
<li><a href="http://www.zsythink.net/archives/1199/" target="_blank" rel="external nofollow noopener noreferrer">iptables 详解（1）：iptables 概念</a></li>
</ul>
<h4 id="阅读材料"><a href="#阅读材料" class="headerlink" title="阅读材料"></a>阅读材料</h4><p><a href="https://www.yuque.com/attachments/yuque/0/2020/pdf/182657/1597492482904-08b61238-07a2-4c27-ab75-f327c7f1da2e.pdf" target="_blank" rel="external nofollow noopener noreferrer">ebpf-firewall-LPC.pdf</a></p>
]]></content>
      <categories>
        <category>Linux,网络</category>
      </categories>
      <tags>
        <tag>网络</tag>
        <tag>iptables</tag>
      </tags>
  </entry>
  <entry>
    <title>实用容器镜像</title>
    <url>/post/8f9fb710.html</url>
    <content><![CDATA[<h4 id="基于-Alpine-的-logrotate-镜像"><a href="#基于-Alpine-的-logrotate-镜像" class="headerlink" title="基于 Alpine 的 logrotate 镜像"></a>基于 Alpine 的 logrotate 镜像</h4><p>借助 crond 实现定时执行 logrotate：<a href="https://github.com/linkyard/docker-logrotate" target="_blank" rel="external nofollow noopener noreferrer">https://github.com/linkyard/docker-logrotate</a>。</p>]]></content>
      <categories>
        <category>容器</category>
      </categories>
      <tags>
        <tag>容器</tag>
      </tags>
  </entry>
  <entry>
    <title>为 Proxmox 制作包含 cloud-init 的虚拟机模板</title>
    <url>/post/6c44975c.html</url>
    <content><![CDATA[<h4 id="安装-Centos"><a href="#安装-Centos" class="headerlink" title="安装 Centos"></a>安装 Centos</h4><p>在我搭建的 Proxmox 平台中使用了 Ceph 作为虚拟机的后端存储，为了提高虚拟机磁盘性能，在安装虚拟机的时候使用 LVM raid0 逻辑分区挂载根目录。</p><ul>
<li>在 install destination 中选中三块盘并勾选自行分区选项</li>
</ul><p><img src="https://cdn.nlark.com/yuque/0/2019/png/182657/1565763386484-e5ca7b70-8be9-4748-a45b-729056006387.png#align=left&display=inline&height=690&name=image.png&originHeight=690&originWidth=1038&size=159786&status=done&style=none&width=1038" alt="image.png"></p><ul>
<li>点击 automatically create lvm partition 自动创建分区，删除其它分区只保留 /boot 分区</li>
</ul><a id="more"></a>



<p><img src="https://cdn.nlark.com/yuque/0/2019/png/182657/1565763580611-942dc4e2-6db4-4dc3-8f80-8c34786c5b08.png#align=left&display=inline&height=751&name=image.png&originHeight=751&originWidth=1043&size=125930&status=done&style=none&width=1043" alt="image.png"></p>
<ul>
<li>点击 + 按钮添加新的分区，挂载点为根路径，容量超过磁盘最大容量，安装程序会自动校正到真实的最大可用容量。</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2019/png/182657/1565763613900-3375e62f-af48-4a23-a3c2-75d5883a1ce2.png#align=left&display=inline&height=769&name=image.png&originHeight=769&originWidth=1026&size=121666&status=done&style=none&width=1026" alt="image.png"></p>
<ul>
<li>点击 Modify 按钮修改新建分区的 RAID Level 为 RAID0。</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2019/png/182657/1565763651682-d3ed9a9e-6388-4d4f-802a-09929eaab7af.png#align=left&display=inline&height=769&name=image.png&originHeight=769&originWidth=1041&size=165004&status=done&style=none&width=1041" alt="image.png"></p>
<ul>
<li>以下是创建完成的分区，保存后按照常规步骤继续安装操作系统。</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2019/png/182657/1565763668133-da5c4ce4-c19a-493c-b20d-fa91ac1c38f9.png#align=left&display=inline&height=733&name=image.png&originHeight=733&originWidth=1020&size=132613&status=done&style=none&width=1020" alt="image.png"></p>
<h4 id="调整安装好的操作系统"><a href="#调整安装好的操作系统" class="headerlink" title="调整安装好的操作系统"></a>调整安装好的操作系统</h4><ul>
<li>进入操作系统，首先关闭 selinux、firewalld 和  NetworkManager。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl <span class="built_in">disable</span> --now firewalld NetworkManager</span><br><span class="line">setenforce 0</span><br><span class="line">sed -ri <span class="string">'/^[^#]*SELINUX=/s#=.+$#=disabled#'</span> /etc/selinux/config</span><br></pre></td></tr></table></figure>

<ul>
<li>安装 acpid cloud-init cloud-utils-growpart</li>
</ul>
<p>apcid 是为了可以使 kvm 可以关闭和重启虚拟机，qemu-guest-agent 使得 Proxmox 可以获取虚拟机的 IP 等信息。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install -y acpid cloud-init cloud-utils-growpart qemu-guest-agent</span><br><span class="line">systemctl <span class="built_in">enable</span> acpid</span><br><span class="line">systemctl <span class="built_in">enable</span> qemu-guest-agent</span><br></pre></td></tr></table></figure>

<ul>
<li>禁用默认 zeroconf 路线</li>
</ul>
<p>当系统无法连接 DHCP server 的时候，就会尝试通过 ZEROCONF 来获取 IP,并添加一条 169.254.0.0/16 的路由条目。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"NOZEROCONF=yes"</span> &gt;&gt; /etc/sysconfig/network</span><br></pre></td></tr></table></figure>

<ul>
<li>修改 sshd 不使用 dns 防止 ssh 连接慢</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sed -ri <span class="string">'/UseDNS/&#123;s@#@@;s@\s+.+@ no@&#125;'</span> /etc/ssh/sshd_config</span><br><span class="line">systemctl restart sshd</span><br></pre></td></tr></table></figure>

<ul>
<li>修改 cloud-init 配置</li>
</ul>
<p>分别是允许 root 登录，允许使用 password 登录，禁止第一次开机自动更新系统。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sed -ri <span class="string">'/disable_root/&#123;s#\S$#0#&#125;'</span> /etc/cloud/cloud.cfg</span><br><span class="line">sed -ri <span class="string">'/ssh_pwauth/&#123;s#\S$#1#&#125;'</span> /etc/cloud/cloud.cfg</span><br><span class="line">sed -ri <span class="string">'/package-update/s@^@#@'</span> /etc/cloud/cloud.cfg</span><br><span class="line">sed -ri <span class="string">'/update_etc_hosts/s@^@#@'</span> /etc/cloud/cloud.cfg</span><br></pre></td></tr></table></figure>

<ul>
<li>如有需要可以自行添加一些额外的配置</li>
</ul>
<p>我在  /sbin/ifup-local 中添加了如下配置用于配置特殊的路由以适应办公室网络环境。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">touch /sbin/ifup-local</span><br><span class="line">chmod +x /sbin/ifup-local</span><br><span class="line">cat /sbin/ifup-local</span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">ip r add 192.168.76.0/24 via 192.168.180.254</span><br><span class="line">ip r add 192.168.77.0/24 via 192.168.180.254</span><br><span class="line"><span class="built_in">exit</span> 0</span><br></pre></td></tr></table></figure>

<ul>
<li>关机，并在 Proxmox 中为之添加 CloudInit Drive。</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2019/png/182657/1565765481819-2158abbc-ff3a-4f5e-870f-40f545b0acd1.png#align=left&display=inline&height=633&name=image.png&originHeight=633&originWidth=719&size=92450&status=done&style=none&width=719" alt="image.png"></p>
<ul>
<li>填写相关 init 参数并 regenerate image。</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2019/png/182657/1565765613783-81f32306-e298-4d18-a553-128415466232.png#align=left&display=inline&height=388&name=image.png&originHeight=388&originWidth=533&size=35717&status=done&style=none&width=533" alt="image.png"></p>
<ul>
<li>启用 qemu-agent</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2019/png/182657/1565768472227-62c14d9c-88ec-47dd-b030-841d773cef94.png#align=left&display=inline&height=645&name=image.png&originHeight=645&originWidth=720&size=68736&status=done&style=none&width=720" alt="image.png"></p>
<ul>
<li>将虚拟机转为模板，之后就可以以此为基础创建新的虚拟机。</li>
</ul>
<h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a href="https://zhangguanzhang.github.io/2019/01/22/proxmox-cloud-init/" target="_blank" rel="external nofollow noopener noreferrer">proxmox 里使用 cloud-init 和一些笔记</a></p>
]]></content>
      <categories>
        <category>Proxmox</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag> 云计算</tag>
        <tag>Proxmox</tag>
        <tag>虚拟机</tag>
      </tags>
  </entry>
  <entry>
    <title>从 RESTful 到 gRPC-Web 的平滑切换</title>
    <url>/post/bd5bd15.html</url>
    <content><![CDATA[<h4 id="gRPC-Web"><a href="#gRPC-Web" class="headerlink" title="gRPC-Web"></a>gRPC-Web</h4><ul>
<li>安装</li>
</ul><p>参考<a href="https://grpc-ecosystem.github.io/grpc-gateway/docs/usage.html" target="_blank" rel="external nofollow noopener noreferrer">官方安装说明</a>，需要指出的是有可能如果出现以下报错：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">protoc: error while loading shared libraries: libprotobuf.so.20: cannot open shared object file: No such file or directory</span><br></pre></td></tr></table></figure><a id="more"></a>



<p>此时，需要执行以下命令更新环境变量中关于 LIB 的信息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo ldconfig</span><br><span class="line">或者</span><br><span class="line">export LD_LIBRARY_PATH&#x3D;&#x2F;usr&#x2F;local&#x2F;lib</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>RESTful</tag>
        <tag>gRPC-Web</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 kolla-ansible 部署 OpenStack</title>
    <url>/post/43354256.html</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th align="center">Date</th>
<th align="center">Log</th>
</tr>
</thead>
<tbody><tr>
<td align="center">26/05/2019</td>
<td align="center">初始版本.</td>
</tr>
</tbody></table><h3 id="解决什么问题"><a href="#解决什么问题" class="headerlink" title="解决什么问题"></a>解决什么问题</h3><p>本文尝试解决的问题：</p><ul>
<li>使用个人开发电脑搭建一套 OpenStack 开发环境。</li>
</ul><p>本文所有操作的前提是个人电脑搭建 Linux 操作系统且具有 16G 以上的内存资源和 足够大的硬盘空间。要完成整个系统的搭建，需要进行：</p><ul>
<li>准备三个控制节点和两个计算节点的虚拟机环境；</li>
<li>使用 kolla-ansible 部署 OpenStack。</li>
</ul><a id="more"></a>




<h3 id="准备虚拟机"><a href="#准备虚拟机" class="headerlink" title="准备虚拟机"></a>准备虚拟机</h3><p>首先，新建 /infra 目录用于存放本次部署产生所有的数据信息，包括安装文件和虚拟机磁盘文件。基于 VMware Workstation 创建虚拟机， VMware Workstation 安装过程不再赘述。使用 CentOS 7.6 最小系统镜像安装操作系统，镜像地址：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">https://mirrors.tuna.tsinghua.edu.cn/centos/7.6.1810/isos/x86_64/CentOS-7-x86_64-Minimal-1810.iso</span><br></pre></td></tr></table></figure>

<p>三个控制节点配置相同，可以在创建完成一个虚拟机后使用 VMware 提供的 clone 功能直接复制出其余的（复制得到的虚拟机需要重新生成 MAC 地址，否则会造成地址冲突），配置详情如下：<br><img src="https://cdn.nlark.com/yuque/0/2019/png/182657/1558868599415-e0c7d40e-0869-4bdb-b9cd-c03d2ca01291.png#align=left&display=inline&height=702&margin=%5Bobject%20Object%5D&name=image.png&originHeight=702&originWidth=891&size=68225&status=done&style=none&width=891" alt="image.png"><br>两个计算节点在上图配置的基础上提升了内存、处理器和硬盘配置，这里硬盘容量设置较大是为了后续在 OpenStack 环境中部署 Kubernetes 等其它系统做准备，可根据个人需要缩减：<br><img src="https://cdn.nlark.com/yuque/0/2019/png/182657/1558868727583-2c08f21e-a5cd-4226-9050-fe9a3a935143.png#align=left&display=inline&height=696&margin=%5Bobject%20Object%5D&name=image.png&originHeight=696&originWidth=885&size=68338&status=done&style=none&width=885" alt="image.png"><br>所有节点配置两张网卡：一张用于 OpenStack 管理网，通过 NAT 连接外网；一张用于 Neutron 网络，直接桥接到外部网络。可根据个人需求调整连接外部网络的方式，VMware 虚拟网络信息如下：<br><img src="https://cdn.nlark.com/yuque/0/2019/png/182657/1558869217104-6d5aa106-722c-4a3a-a398-6aec413ea9c2.png#align=left&display=inline&height=614&margin=%5Bobject%20Object%5D&name=image.png&originHeight=614&originWidth=617&size=55558&status=done&style=none&width=617" alt="image.png"><br>虚拟机创建完成后进入操作系统检查 IP 地址获取情况：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@controller_03 ~]<span class="comment"># ip a</span></span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">    inet 127.0.0.1/8 scope host lo</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 ::1/128 scope host</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">2: ens33: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000</span><br><span class="line">    link/ether 00:50:56:32:8a:b7 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 172.16.192.131/24 brd 172.16.192.255 scope global noprefixroute ens33</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 fe80::250:56ff:fe32:8ab7/64 scope link</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">3: ens36: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000</span><br><span class="line">    link/ether 00:50:56:34:89:62 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 192.168.1.10/24 brd 192.168.1.255 scope global noprefixroute dynamic ens36</span><br><span class="line">       valid_lft 82858sec preferred_lft 82858sec</span><br><span class="line">    inet6 fe80::91ef:7089:dc2e:d7f1/64 scope link noprefixroute</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br></pre></td></tr></table></figure>

<p>如果没有获取到 IP 可执行 dhclient 命令尝试获取 IP 地址，动态分配的 IP 地址只是为系统提供了临时连接外部网络的途径。为了后续的自动化部署，我们需要将每个节点连接管理网的网卡 IP 地址固定下来，并使用管理网网关为默认路由网关（一定要确认好网关地址），如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@controller_03 ~]<span class="comment"># cat /etc/sysconfig/network-scripts/ifcfg-ens33</span></span><br><span class="line">TYPE=Ethernet</span><br><span class="line">PROXY_METHOD=none</span><br><span class="line">BROWSER_ONLY=no</span><br><span class="line">BOOTPROTO=static</span><br><span class="line">DEFROUTE=yes</span><br><span class="line">NAME=ens33</span><br><span class="line">UUID=f7c0ccd3-10d2-4bd9-bc47-c6429cbc28a0</span><br><span class="line">DEVICE=ens33</span><br><span class="line">ONBOOT=yes</span><br><span class="line">IPADDR=172.16.192.131</span><br><span class="line">GATEWAY=172.16.192.2</span><br><span class="line">NETMASK=255.255.255.0</span><br><span class="line">DNS1=114.114.114.114</span><br><span class="line">DNS2=1.1.1.1</span><br><span class="line">DNS3=8.8.4.4</span><br></pre></td></tr></table></figure>

<p>给 Neutron 使用的网卡配置如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># cat /etc/sysconfig/network-scripts/ifcfg-ens36</span></span><br><span class="line">TYPE=Ethernet</span><br><span class="line">PROXY_METHOD=none</span><br><span class="line">BROWSER_ONLY=no</span><br><span class="line">BOOTPROTO=dhcp</span><br><span class="line">DEFROUTE=no</span><br><span class="line">NAME=ens36</span><br><span class="line">DEVICE=ens36</span><br><span class="line">ONBOOT=yes</span><br></pre></td></tr></table></figure>

<p>为了管理方便，我们将三个控制节点和两个计算节点的 hostname 分别设置为（主机名不能带下划线，否则部署 OpenStack 时报错）:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">controller-01</span><br><span class="line">controller-02</span><br><span class="line">controller-03</span><br><span class="line">compute-01</span><br><span class="line">compute-02</span><br></pre></td></tr></table></figure>

<p>为了方便命令行登录节点，可通过 ssh-copy-id 将宿主机 ssh public-key 拷贝到各虚拟节点，之后在 ssh 登录时无需再输入密码。<br>为了方便在所有虚拟机和宿主机之间共享文件，我们可以使用 VMware 的文件共享机制将宿主机目录挂载到虚拟机中。首先，在虚拟机的属性配置中添加要共享的文件夹，如下是将宿主机上的 /infra/vmshare 目录共享给虚拟机：<br><img src="https://cdn.nlark.com/yuque/0/2019/png/182657/1558870518738-a48e46b4-d616-4a1b-9c17-f11fc2595b76.png#align=left&display=inline&height=590&margin=%5Bobject%20Object%5D&name=image.png&originHeight=701&originWidth=886&size=70490&status=done&style=none&width=746" alt="image.png"></p>
<p>只有上图的设置还不够，我们需要进入到虚拟机内部将共享的文件夹挂载到本地目录才能使用，如下，该命令的涵义是将名称为 vmshare 的共享挂载到本地 /vmshare 目录：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vmhgfs-fuse .host:/vmshare /vmshare</span><br></pre></td></tr></table></figure>

<p>另外也可以将挂载信息写入到 /etc/fstab 使系统在启动时自动挂载：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">.host:/vmshare /vmshare fuse.vmhgfs-fuse allow_other 0 0</span><br></pre></td></tr></table></figure>

<p>部署 OpenStack 的时候需要使用到网卡的混杂模式，而在 Linux 下虚拟机没有权限完成该操作，可通过以下设置开放权限给虚拟机：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo chmod a+rw /dev/vmnet0</span><br><span class="line">sudo chmod a+rw /dev/vmnet8</span><br></pre></td></tr></table></figure>

<p>在使用图形化界面完成以上操作和配置后，我们将脱离 GUI 运行虚拟机，这样可以节省一些资源开支。执行以下命令以命令行形式运行虚拟机：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vmrun start /infra/openstack_controller_02/openstack_controller_02.vmx nogui</span><br></pre></td></tr></table></figure>

<p>现在，将所有节点都以 nogui 形式启动起来，vmrun list 可以看到它们：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(kolla) ➜  kolla vmrun list</span><br><span class="line">Total running VMs: 5</span><br><span class="line">/infra/openstack_controller_02/openstack_controller_02.vmx</span><br><span class="line">/infra/openstack_controller_03/openstack_controller_03.vmx</span><br><span class="line">/infra/openstack_controller_01/openstack_controller_01.vmx</span><br><span class="line">/infra/openstack_compute_01/openstack_compute_01.vmx</span><br><span class="line">/infra/openstack_compute_02/openstack_compute_02.vmx</span><br></pre></td></tr></table></figure>

<p>我们的虚拟机环境准备好了，开始使用 kolla-ansible 进行部署。</p>
<h3 id="使用-kolla-ansible-部署-OpenStack"><a href="#使用-kolla-ansible-部署-OpenStack" class="headerlink" title="使用 kolla-ansible 部署 OpenStack"></a>使用 kolla-ansible 部署 OpenStack</h3><p>参考 kolla-ansible <a href="https://docs.openstack.org/kolla-ansible/latest/user/quickstart.html" target="_blank" rel="external nofollow noopener noreferrer">官方文档</a>  进行部署。<br>创建一份虚拟 Python 环境用于本次部署，需要先安装 virtualenv ，我的宿主机环境是 ArchLinux，执行以下命令安装，其它 Linux 环境请自行 Google 安装方法：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yay -S python-virtualenv</span><br></pre></td></tr></table></figure>

<p>然后执行以下命令创建 kolla 虚拟环境：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">virtualenv -p python2 /infra/kolla</span><br></pre></td></tr></table></figure>

<p>使用以下命令激活虚拟 Python 环境 :</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">source</span> /infra/kolla/bin/activate</span><br></pre></td></tr></table></figure>

<p>安装 Ansible:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install ansible</span><br></pre></td></tr></table></figure>

<p>为了方便对所有节点执行一些共性的操作，我们临时创建一份 hosts 文件，如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(kolla) ➜  kolla cat /infra/hosts</span><br><span class="line">[OpenstackGroup:children]</span><br><span class="line"> nodes</span><br><span class="line"> controllers</span><br><span class="line"> computes</span><br><span class="line">[OpenstackGroup:vars]</span><br><span class="line"> ansible_ssh_user=root</span><br><span class="line"> ansible_ssh_pass=r00tme</span><br><span class="line"> ansible_port=22</span><br><span class="line">[nodes]</span><br><span class="line"> openstack_controller_01 ansible_host=172.16.192.129</span><br><span class="line"> openstack_controller_02 ansible_host=172.16.192.130</span><br><span class="line"> openstack_controller_03 ansible_host=172.16.192.131</span><br><span class="line"> openstack_compute_01 ansible_host=172.16.192.132</span><br><span class="line"> openstack_compute_02 ansible_host=172.16.192.133</span><br><span class="line">[contorllers]</span><br><span class="line"> openstack_controller_01 ansible_host=172.16.192.129</span><br><span class="line"> openstack_controller_02 ansible_host=172.16.192.130</span><br><span class="line"> openstack_controller_03 ansible_host=172.16.192.131</span><br><span class="line">[computes]</span><br><span class="line"> openstack_compute_01 ansible_host=172.16.192.132</span><br><span class="line"> openstack_compute_02 ansible_host=172.16.192.133</span><br></pre></td></tr></table></figure>

<p>启用 SELinux 会带来一些麻烦，影响 kolla 安装部署，因此我们使用 ansible 关闭所有节点的 SELinux 并重启系统使之生效：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ansible nodes -i /infra/hosts -m shell -a <span class="string">'sed -i "s#SELINUX=enforcing#SELINUX=disabled#g" /etc/selinux/config'</span></span><br><span class="line">ansible nodes -i /infra/hosts -m shell -a <span class="string">'reboot'</span></span><br></pre></td></tr></table></figure>

<p>另外，我们使用清华开源镜像替代 Pypi 官方仓库：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ansible nodes -i /infra/hosts -m shell -a <span class="string">'yum install -y wget'</span></span><br><span class="line">ansible nodes -i /infra/hosts -m shell -a <span class="string">'wget https://tuna.moe/oh-my-tuna/oh-my-tuna.py'</span></span><br><span class="line">ansible nodes -i /infra/hosts -m shell -a <span class="string">'python /root/oh-my-tuna.py'</span></span><br></pre></td></tr></table></figure>

<p>接下来，继续按照 kolla 文档安装 kolla-ansible：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install kolla-ansible</span><br><span class="line">sudo mkdir -p /etc/kolla</span><br><span class="line">sudo chown <span class="variable">$USER</span>:<span class="variable">$USER</span> /etc/kolla</span><br><span class="line">cp -r /infra/kolla/share/kolla-ansible/etc_examples/kolla/* /etc/kolla</span><br><span class="line">cp /infra/kolla/share/kolla-ansible/ansible/inventory/multinode /infra/kolla</span><br></pre></td></tr></table></figure>

<p>然后，配置 multinode inventory 文件，根据文档中的说明来进行配置即可：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(kolla) ➜  kolla cat multinode</span><br><span class="line"><span class="comment"># These initial groups are the only groups required to be modified. The</span></span><br><span class="line"><span class="comment"># additional groups are for more control of the environment.</span></span><br><span class="line">[control]</span><br><span class="line"><span class="comment"># 这里的配置和我们宿主机 hosts 配置要对应起来</span></span><br><span class="line">openstack_controller_01</span><br><span class="line">openstack_controller_02</span><br><span class="line">openstack_controller_03</span><br><span class="line"></span><br><span class="line"><span class="comment"># The above can also be specified as follows:</span></span><br><span class="line"><span class="comment">#control[01:03]     ansible_user=kolla</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 网路节点和控制节点对应</span></span><br><span class="line">[network]</span><br><span class="line">openstack_controller_01</span><br><span class="line">openstack_controller_02</span><br><span class="line">openstack_controller_03</span><br><span class="line"></span><br><span class="line"><span class="comment"># inner-compute is the groups of compute nodes which do not have</span></span><br><span class="line"><span class="comment"># external reachability.</span></span><br><span class="line"><span class="comment"># DEPRECATED, the group will be removed in S release of OpenStack,</span></span><br><span class="line"><span class="comment"># use variable neutron_compute_dvr_mode instead.</span></span><br><span class="line">[inner-compute]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 我们的两个计算节点都可以联通外网</span></span><br><span class="line"><span class="comment"># DEPRECATED, the group will be removed in S release of OpenStack,</span></span><br><span class="line"><span class="comment"># use variable neutron_compute_dvr_mode instead.</span></span><br><span class="line">[external-compute]</span><br><span class="line">openstack_compute_01</span><br><span class="line">openstack_compute_02</span><br><span class="line"></span><br><span class="line">[compute:children]</span><br><span class="line">inner-compute</span><br><span class="line">external-compute</span><br><span class="line"></span><br><span class="line"><span class="comment"># 监控节点可以选择控制节点中的任意一个</span></span><br><span class="line">[monitoring]</span><br><span class="line">openstack_controller_01</span><br><span class="line"></span><br><span class="line"><span class="comment"># When compute nodes and control nodes use different interfaces,</span></span><br><span class="line"><span class="comment"># you need to comment out "api_interface" and other interfaces from the globals.yml</span></span><br><span class="line"><span class="comment"># and specify like below:</span></span><br><span class="line"><span class="comment">#compute01 neutron_external_interface=eth0 api_interface=em1 storage_interface=em1 tunnel_interface=em1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 存储节点和计算节点复用</span></span><br><span class="line">[storage]</span><br><span class="line">openstack_compute_01</span><br><span class="line">openstack_compute_02</span><br><span class="line"></span><br><span class="line">[deployment]</span><br><span class="line">localhost       ansible_connection=<span class="built_in">local</span></span><br><span class="line"></span><br><span class="line">[baremetal:children]</span><br><span class="line">control</span><br><span class="line">network</span><br><span class="line">compute</span><br><span class="line">storage</span><br><span class="line">monitoring</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加了一项变量配置，指明登录虚拟机节点所需要的用户名和密码</span></span><br><span class="line">[baremetal:vars]</span><br><span class="line">ansible_ssh_user=root</span><br><span class="line">ansible_ssh_pass=r00tme</span><br><span class="line">ansible_port=22</span><br></pre></td></tr></table></figure>

<p>注意上述文件中的虚拟机名称应当可以在宿主机解析到其对应的 IP 地址，为此 宿主机 hosts 增加如下配置：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(kolla) ➜  kolla tail -n 5 /etc/hosts</span><br><span class="line">172.16.192.129 openstack_controller_01</span><br><span class="line">172.16.192.130 openstack_controller_02</span><br><span class="line">172.16.192.131 openstack_controller_03</span><br><span class="line">172.16.192.132 openstack_compute_01</span><br><span class="line">172.16.192.133 openstack_compute_02</span><br></pre></td></tr></table></figure>

<p>执行以下命令生成安装过程所需的数据库等各项基础设施密码：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kolla-genpwd</span><br></pre></td></tr></table></figure>

<p>然后修改 kolla 的全局配置文件  /etc/kolla/globals.yml :</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 所有OpenStack组件的基础镜像使用 centos</span></span><br><span class="line">kolla_base_distro: <span class="string">"centos"</span></span><br><span class="line"><span class="comment"># 选择社区编译好的安装源文件进行安装</span></span><br><span class="line">kolla_install_type: <span class="string">"binary"</span></span><br><span class="line"><span class="comment"># 选择安装 R 版 OpenStack</span></span><br><span class="line">openstack_release: <span class="string">"rocky"</span></span><br><span class="line"><span class="comment"># 设置管理网使用的网卡，即为我们为每个虚拟机添加的网卡之一</span></span><br><span class="line">network_interface: <span class="string">"ens33"</span></span><br><span class="line"><span class="comment"># 设置 Neutron 使用的网卡，即为我们为虚拟机添加的另外一块网卡</span></span><br><span class="line">neutron_external_interface: <span class="string">"ens36"</span></span><br><span class="line"><span class="comment"># 设置管理平台 VIP，该 IP 漂移在三个控制节点的管理网卡上，因此应是一个未被占用的和管理网段一致的 IP 地址</span></span><br><span class="line">kolla_internal_vip_address: <span class="string">"172.16.192.134"</span></span><br></pre></td></tr></table></figure>

<p>接下来，开始真正部署的第一步，在所有节点上安装部署依赖的基础软件包，安装过程可能有报错，可针对具体问题解决后重复执行安装命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kolla-ansible -i /infra/kolla/multinode bootstrap-servers</span><br></pre></td></tr></table></figure>

<p>第二步，检查环境是否已经准备好，配置是否有错漏，检查过程可能会抛出一些错误，不要惊慌，一般都有提示信息，按照提示去修改即可：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kolla-ansible -i /infra/kolla/multinode prechecks</span><br></pre></td></tr></table></figure>

<p>第三步，正式开始安装：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kolla-ansible -i /infra/kolla/multinode deploy</span><br></pre></td></tr></table></figure>

<p>如果在安装中出错，可以先找到错误原因并修复后，先清理上次安装后再重装：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kolla-ansible -i ./multinode destroy --yes-i-really-really-mean-it</span><br><span class="line">kolla-ansible -i /infra/kolla/multinode deploy</span><br></pre></td></tr></table></figure>

<h3 id="常见错误"><a href="#常见错误" class="headerlink" title="常见错误"></a>常见错误</h3><ul>
<li>在 bootstrap-servers 阶段遇到 Python uninstall request 包错误，可尝试如下方式解决：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install -I requests==2.9</span><br></pre></td></tr></table></figure>

<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul>
<li><a href="https://www.jianshu.com/p/c549a512c224" target="_blank" rel="external nofollow noopener noreferrer">Kolla 安装 Openstack</a></li>
</ul>
]]></content>
      <categories>
        <category>OpenStack</category>
      </categories>
      <tags>
        <tag> 云计算</tag>
        <tag>OpenStack</tag>
      </tags>
  </entry>
  <entry>
    <title>使用语雀、GitHub 和阿里云函数计算构建博客</title>
    <url>/post/b2362878.html</url>
    <content><![CDATA[<h3 id="使用语雀撰写博客"><a href="#使用语雀撰写博客" class="headerlink" title="使用语雀撰写博客"></a>使用语雀撰写博客</h3><p>最开始搭建自己的博客系统时，我会先写好 Markdown 文件，然后借助 Hexo 生成静态页面，之后部署到云主机上，配置好域名解析后就可以访问了。<br>虽然 Markdown 已经足够简明便捷，但语雀为我们提供了更友好的 Markdown 编辑器，使得撰写技术文档的体验有了质的提升，因此强烈推荐给大家使用。<br>语雀的使用也比较简单，首先登陆到<a href="https://yuque.com" target="_blank" rel="external nofollow noopener noreferrer">官网</a>使用手机号注册一个账号，然后创建一个知识库，在知识库就可以新建文档开始写文章了。撰写文档时，在快捷键 “/” 的帮助下可以快速插入代码、图片、视频、思维导图等，使用非常方便，更多的内容可以参考语雀官方的<a href="https://www.yuque.com/yuque/help" target="_blank" rel="external nofollow noopener noreferrer">使用文档</a>。<br>实际上，语雀本身也是一个文章发布平台，写好的文章只要被设置为可公开访问，别人就可以在语雀上订阅你的文章，但由于不能自定义域名等原因，目前仍然只是把它作为文档撰写工具，博客站点仍然借助其它平台实现。</p><a id="more"></a>
<h3 id="Hexo-与语雀同步"><a href="#Hexo-与语雀同步" class="headerlink" title="Hexo 与语雀同步"></a>Hexo 与语雀同步</h3><p><a href="https://hexo.io/" target="_blank" rel="external nofollow noopener noreferrer">Hexo</a> 是一款开源的静态站点生成工具，虽然 <a href="https://gohugo.io/" target="_blank" rel="external nofollow noopener noreferrer">Hugo</a> 使用起来可能更加方便，但由于个人十分喜欢 Hexo 的<a href="https://github.com/theme-next/hexo-theme-next" target="_blank" rel="external nofollow noopener noreferrer">这款</a>名为 Next 的博客主题，所以一直没有更换为 Hugo。<br>之前都是直接写好 Markdown 文件放在 Hexo 项目指定目录，然后从 Markdown 生成静态页面，换用了语雀之后则需要借助工具将语雀上的内容导出为 Markdown。语雀支持将文章导出为 Markdown 的操作，你可以在 Web 端简单点击后获取到所有文章的 Markdown 导出，更幸运的是我们可以利用开源工具<a href="https://github.com/x-cold/yuque-hexo" target="_blank" rel="external nofollow noopener noreferrer"> yuque-hexo</a> 将导出过程程序化。只需要安装好  yuque-hexo 插件并配置好语雀相关的参数即可。<br>具体的参数配置可以参考各个开源项目的文档，也可以参考<a href="https://github.com/XiaYinchang/xiayinchang.github.io" target="_blank" rel="external nofollow noopener noreferrer">我的 Hexo 项目</a>配置。我将同步操作和 Hexo 的生成静态文件命令合并成了一个 npm 脚本，只需要执行 <code>npm run generate</code>  即可完成同步以及静态文件的生成，生成的静态文件在当前目录 <code>pulic</code> 路径下。</p>
<h3 id="使用-GitHub-托管博客"><a href="#使用-GitHub-托管博客" class="headerlink" title="使用 GitHub 托管博客"></a>使用 GitHub 托管博客</h3><p>使用 Hexo 生成的静态页面必须通过网络服务器 Serve 起来才能被别人访问，之前我是使用廉价版的阿里云主机通过 Nginx 启动了 Http 服务器，使用下来发现访问速度比 GitHub 托管还慢，后续也使用过 coding.net 提供的 Pages 服务，访问速度很快，但是服务不太稳定，多次出现未知原因导致博客无法访问，最后决定还是用回 GitHub。<br>首先在 GitHub 上新建一个名称为 username.github.io 的代码仓库，我建的是  xiayinchang.github.io，根据官方文档的说法， username 需要和你的 GitHub 账户名称保持一致。然后将 Hexo 生成的静态文件（即 public 路径下的文件）添加到该代码仓库，push 到 GitHub 上即可。现在，就可以通过 username.github.io 这个地址访问到博客站点的内容。</p>
<h3 id="借助-GitHub-Action-实现静态文件的自动生成"><a href="#借助-GitHub-Action-实现静态文件的自动生成" class="headerlink" title="借助 GitHub Action 实现静态文件的自动生成"></a>借助 GitHub Action 实现静态文件的自动生成</h3><p>GitHub Action 是 GitHub 最新推出的 CICD 工具（完全可以取代第三方的 Travis CI 等工具），和 GitHub 的各项服务无缝集成，开源仓库可以免费使用，虽然有额度限制，但就博客静态文件的生成来说免费额度已经足够用了。GitHub Action 的概念还是很多的，有兴趣的话可以参阅<a href="https://help.github.com/en/actions/automating-your-workflow-with-github-actions" target="_blank" rel="external nofollow noopener noreferrer">这篇官方文档</a>。<br>简单说明一下使用方法，首先需要在 Hexo 项目中新建一个 .github 目录，然后在该目录下再新建  workflows 目录，在  workflows 中新建一个 yml 格式的文件用来定义工作流，如下，我建了两个 yml 文件定义了两种工作流，文件名称可以随便取，这里命名成 nodejs.yml 是因为生成静态文件需要使用 Nodejs，只要按照这种路径定义了工作流，就能被 GitHub Action 系统自动读取并解析，这是一种约定：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">➜  xiayinchang.github.io git:(src) tree -L <span class="number">3</span> .github</span><br><span class="line">.github</span><br><span class="line">└── workflows</span><br><span class="line">    ├── cron.yml</span><br><span class="line">    └── nodejs.yml</span><br></pre></td></tr></table></figure>

<p>简单介绍一下 nodejs.yml 这个文件定义的工作流，on 这行用来指定在发生什么事件（这里响应 push 和 repository_dispatch 两种事件，push 即为向该分支推送代码的事件， repository_dispatch 为自定义外部事件，稍后详说）时执行该工作流，jobs 可以定义多个 job 分别执行不同的工作，不同的 job 可以并行执行，不同 job 的执行环境（操作系统）可以不一样，这里只定义了一个名为 build 的 job，指定的运行环境是 Ubuntu，这个 job 又可以拆分成几个步骤，步骤按序执行，首先通过使用第三方定义好的 actions/checkout@master （这是 GitHub Action 的另一个强大之处，允许直接复用别人定义好的各种操作即 Action）可以实现从 GitHub 仓库（这里指定从当前仓库 xiayinchang.github.io 的 src 分支）拉取代码，然后借助  actions/setup-node@master 这个第三方 Action 实现 Nodejs 环境的配置，这里指定使用 Nodejs 13 版本，接着开始执行 Hexo 的构建，分为安装依赖包和生成静态文件两个命令，最后一步是借助  peaceiris/actions-gh-pages@v2.5.0 这个第三方 Action 将生成的静态文件 push 到指定仓库的指定分支（这里是 xiayinchang.github.io 仓库的 master 分支）。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">name: Node CI</span><br><span class="line"></span><br><span class="line">on: [push, repository_dispatch]</span><br><span class="line"></span><br><span class="line">jobs:</span><br><span class="line">  build:</span><br><span class="line">    runs-on: ubuntu-latest</span><br><span class="line"></span><br><span class="line">    strategy:</span><br><span class="line">      matrix:</span><br><span class="line">        node-version: [<span class="number">13.</span>x]</span><br><span class="line"></span><br><span class="line">    steps:</span><br><span class="line">      - uses: actions/checkout@master</span><br><span class="line">        with:</span><br><span class="line">          ref: src</span><br><span class="line">      - name: Use Node.js $&#123;&#123; matrix.node-version &#125;&#125;</span><br><span class="line">        uses: actions/setup-node@master</span><br><span class="line">        with:</span><br><span class="line">          node-version: $&#123;&#123; matrix.node-version &#125;&#125;</span><br><span class="line">      - name: npm install, build</span><br><span class="line">        run: |</span><br><span class="line">          npm install</span><br><span class="line">          npm run generate</span><br><span class="line">        env:</span><br><span class="line">          CI: <span class="literal">true</span></span><br><span class="line">          HEXO_ALGOLIA_INDEXING_KEY: $&#123;&#123; secrets.HEXO_ALGOLIA_INDEXING_KEY &#125;&#125;</span><br><span class="line">          YUQUE_TOKEN: $&#123;&#123; secrets.YUQUE_TOKEN &#125;&#125;</span><br><span class="line">      - name: Deploy</span><br><span class="line">        uses: peaceiris/actions-gh-pages@v2<span class="number">.5</span><span class="number">.0</span></span><br><span class="line">        env:</span><br><span class="line">          PERSONAL_TOKEN: $&#123;&#123; secrets.PERSONAL_TOKEN &#125;&#125;</span><br><span class="line">          PUBLISH_BRANCH: master</span><br><span class="line">          PUBLISH_DIR: ./public</span><br></pre></td></tr></table></figure>

<p>回过头查看上述工作流，涉及到了  xiayinchang.github.io 仓库的两个分支，一个是 src 分支，一个是 master 分支， src 分支保存的是 Hexo 项目的代码，用来生成静态文件，master 分支保存的是生成的静态文件，也是 GitHub Pages 服务的数据源，src 分支生成的静态文件要 push 到 master 分支才能被 GitHub Pages 使用，这是因为：根据 GitHub Pages 的说明，静态文件必须要放在 master 分支。<br>现在，只要修改了部分文章内容后，push 到  xiayinchang.github.io 仓库的 src 分支即会触发该工作流，完成从 Markdown 格式的源文件到博客静态文件的自动生成，并自动推送到 master 分支从而触发 GitHub Pages 的自动更新，进而完成博客站点的自动更新，此时再打开  xiayinchang.github.io 这个站点就能看到更新的文章内容已经显示在网页端了。</p>
<h3 id="语雀更新触发-GitHub-Action-自动构建"><a href="#语雀更新触发-GitHub-Action-自动构建" class="headerlink" title="语雀更新触发 GitHub Action 自动构建"></a>语雀更新触发 GitHub Action 自动构建</h3><h4 id="初步方案设计"><a href="#初步方案设计" class="headerlink" title="初步方案设计"></a>初步方案设计</h4><p>在上一步中虽然已经实现了自动生成静态文件，但是事件本身仍然需要我们手动生成，即手动 push 后触发自动构建，在这一步我们要实现的是在语雀上更新文章后就能触发 GitHub 的自动构建。语雀提供了 webhook 机制使得更新文章时能够触发外部事件，而 GitHub Action 能够通过我们之前提到过的  repository_dispatch 机制接收外部事件，如果能够将两者对接起来，也就实现了我们的目标，但这个过程并没有那么简单。<br>语雀支持的 webhook 是一个简单的 http url ，无法添加请求头和请求体，如下图所示:<br><img src="https://cdn.nlark.com/yuque/0/2019/png/182657/1574345326347-21a088e7-b99e-48ab-b4d4-03da8cd43dd5.png#align=left&display=inline&height=281&name=image.png&originHeight=562&originWidth=1454&size=81111&status=done&width=727" alt="image.png"><br>GitHub repository_dispatch 支持的外部事件必须具有以下请求头（包括认证信息）：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">curl -X POST \</span><br><span class="line">    -H <span class="string">"Authorization: token $&#123;GITHUB_TOKEN&#125;"</span> \</span><br><span class="line">    -H <span class="string">'Accept: application/vnd.github.everest-preview+json'</span> \</span><br><span class="line">    -d <span class="string">'&#123;"event_type":"rollback"&#125;'</span> \</span><br><span class="line">    https:<span class="comment">//api.github.com/repos/$&#123;GITHUB_REPO_OWNER&#125;/$&#123;GITHUB_REPO&#125;/dispatches</span></span><br></pre></td></tr></table></figure>

<p>所以直接在语雀 webhook 中添加 GitHub 事件的触发地址是不行的，因为无法添加必须的请求头信息，因此我们需要一个中间层把两者适配起来，示意图如下：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2019/svg/182657/1574346796484-cd1f3d51-6d05-4e95-a457-68f02556072e.svg#align=left&display=inline&height=53&name=yuque-github.svg&originHeight=53&originWidth=531&size=9035&status=done&width=531" alt="yuque-github.svg"></p>
<h4 id="基于虚拟机的中间层实现"><a href="#基于虚拟机的中间层实现" class="headerlink" title="基于虚拟机的中间层实现"></a>基于虚拟机的中间层实现</h4><p>最初，我在购买的阿里云主机上使用 Nodejs 创建了一个简单的 HTTP 服务来实现这个中间层，其代码如下，其基本逻辑和上图一致，首先是在 8888 端口上响应来自语雀的 hook 调用，然后再拼装出一个带有认证信息的 https 请求生成 GitHub 外部事件。这段代码虽然写的比较简陋，但是完全可以满足我们的需求实现语雀更新触发 GitHub 的自动构建和部署。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">"http"</span>);</span><br><span class="line"><span class="keyword">const</span> https = <span class="built_in">require</span>(<span class="string">"https"</span>);</span><br><span class="line"><span class="keyword">const</span> url = <span class="built_in">require</span>(<span class="string">"url"</span>);</span><br><span class="line"><span class="keyword">const</span> process = <span class="built_in">require</span>(<span class="string">"process"</span>);</span><br><span class="line">http</span><br><span class="line">  .createServer(<span class="function"><span class="keyword">function</span> (<span class="params">request, response</span>) </span>&#123;</span><br><span class="line">    response.writeHead(<span class="number">200</span>, &#123; <span class="string">"Content-type"</span>: <span class="string">"text/plan"</span> &#125;);</span><br><span class="line">    response.end(<span class="string">"ok"</span>);</span><br><span class="line">    pathName = url.parse(request.url).pathname;</span><br><span class="line">    <span class="keyword">if</span> (pathName === <span class="string">"/sync"</span> &amp;&amp; request.method === <span class="string">"POST"</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> data = <span class="built_in">JSON</span>.stringify(&#123;</span><br><span class="line">        event_type: <span class="string">"run-it"</span>,</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> options = &#123;</span><br><span class="line">        hostname: <span class="string">"api.github.com"</span>,</span><br><span class="line">        port: <span class="number">443</span>,</span><br><span class="line">        path: <span class="string">"/repos/XiaYinchang/xiayinchang.github.io/dispatches"</span>,</span><br><span class="line">        method: <span class="string">"POST"</span>,</span><br><span class="line">        headers: &#123;</span><br><span class="line">          <span class="string">"User-Agent"</span>: <span class="string">"curl/7.52.1"</span>,</span><br><span class="line">          <span class="string">"Content-Type"</span>: <span class="string">"application/json"</span>,</span><br><span class="line">          Accept: <span class="string">"application/vnd.github.everest-preview+json"</span>,</span><br><span class="line">          Authorization: <span class="string">"token $GITHUB_TOKEN"</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> req = https.request(options, (res) =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`statusCode: <span class="subst">$&#123;res.statusCode&#125;</span>`</span>);</span><br><span class="line"></span><br><span class="line">        res.on(<span class="string">"data"</span>, (d) =&gt; &#123;</span><br><span class="line">          process.stdout.write(d);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      req.on(<span class="string">"error"</span>, (error) =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.error(error);</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      req.write(data);</span><br><span class="line">      req.end();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  .listen(<span class="number">8888</span>);</span><br></pre></td></tr></table></figure>

<h4 id="基于阿里云函数计算的中间层实现"><a href="#基于阿里云函数计算的中间层实现" class="headerlink" title="基于阿里云函数计算的中间层实现"></a>基于阿里云函数计算的中间层实现</h4><p>后来发现阿里云函数计算有免费的额度可以使用，完全可以将我的虚拟机释放出来做其他事情，而且虚拟机两年后就到期了，这个函数计算至少坚挺几年问题不大，以下是阿里云官方文档关于函数计算的免费额度说明，前 100 万次调用免费，财大气粗的阿里云：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2019/png/182657/1574348003304-00176e01-df5f-452f-8a3e-d2b42ccbb19f.png#align=left&display=inline&height=159&name=image.png&originHeight=318&originWidth=1550&size=73916&status=done&width=775" alt="image.png"></p>
<p>根据我们的使用场景，需要部署一个函数能够处理语雀的 http post 请求，参考阿里云函数计算的<a href="https://help.aliyun.com/document_detail/74768.html?spm=a2c4g.11186623.6.604.233e68f4qM1FYl" target="_blank" rel="external nofollow noopener noreferrer">官方文档</a>，我创建了一个名为 sync_yuque 的函数，运行环境选择 Python 是因为使用 Nodejs 时发现阿里云的函数计算貌似只支持 Express 的一套 api，我之前写的 Nodejs 的代码都不好用了，然后发现根本不支持 Go 的环境，所以只好用 Python 的：<br><img src="https://cdn.nlark.com/yuque/0/2019/png/182657/1574348393403-568dcfe8-4c88-4cd5-9067-3fd4f9b098fe.png#align=left&display=inline&height=382&name=image.png&originHeight=764&originWidth=1648&size=99272&status=done&width=824" alt="image.png"><br>这个函数计算是可以在线编辑代码的，这个函数计算要求函数的命名有一定的规范，最后写的 Python 代码如下：<br><img src="https://cdn.nlark.com/yuque/0/2019/png/182657/1574348796118-0f1724a9-181f-4d26-8d47-417aa64642d0.png#align=left&display=inline&height=685&name=image.png&originHeight=1370&originWidth=1678&size=258218&status=done&width=839" alt="image.png"><br>还可以在线调试，点击执行手动触发了一波，看到 GitHub 那边果然被触发了，注意下图中的 Http 触发器有个点击复制的按钮，点击后复制的就是触发 Python 代码调用的 URL 地址，随后会将这个地址添加到语雀的 webhook 中：<br><img src="https://cdn.nlark.com/yuque/0/2019/png/182657/1574348964801-b5f5e678-23bd-4af9-b3ad-2a8fdb3eb129.png#align=left&display=inline&height=365&name=image.png&originHeight=1104&originWidth=2256&size=191252&status=done&width=746" alt="image.png"><br>GitHub Action 触发自动构建如下，可以看到触发的事件源确实是  repository_dispatch ：<br><img src="https://cdn.nlark.com/yuque/0/2019/png/182657/1574349095187-c0ee05f1-2140-4664-b999-fb46b18e5b1d.png#align=left&display=inline&height=319&name=image.png&originHeight=638&originWidth=2408&size=127346&status=done&width=1204" alt="image.png"><br>最后，将获取的 Http 函数调用地址添加到语雀的 webhook 中，如下：<br><img src="https://cdn.nlark.com/yuque/0/2019/png/182657/1574349534969-cee1fcaf-2bbc-4eff-9c8a-dc44fa6363b8.png#align=left&display=inline&height=522&name=image.png&originHeight=1044&originWidth=2132&size=157428&status=done&width=1066" alt="image.png"><br>现在，在语雀上对应知识库中更新任何一篇文章或者发布新的文章都会触发 GitHub 自动构建和部署，实现博客站点与语雀文章的同步更新，整个过程已经被自动化衔接起来，而你只需要关注写作本身。</p>
]]></content>
      <categories>
        <category>云计算</category>
      </categories>
      <tags>
        <tag>语雀</tag>
        <tag>GitHub</tag>
      </tags>
  </entry>
  <entry>
    <title>公钥与证书</title>
    <url>/post/3e994927.html</url>
    <content><![CDATA[<h4 id="OpenSSL-生成公钥、私钥对"><a href="#OpenSSL-生成公钥、私钥对" class="headerlink" title="OpenSSL 生成公钥、私钥对"></a>OpenSSL 生成公钥、私钥对</h4><ol>
<li>生成 RSA 公私钥对</li>
</ol><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">openssl genrsa -out private_key 4096</span><br><span class="line">openssl rsa -<span class="keyword">in</span> private_key -pubout -outform PEM -out public_key.pem</span><br></pre></td></tr></table></figure><ol start="2">
<li>生成 ED25519 公私钥对</li>
</ol><a id="more"></a>



<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">openssl genpkey -algorithm ED25519 -out private_key</span><br><span class="line">openssl pkey -<span class="keyword">in</span> private_key -pubout -out public_key</span><br></pre></td></tr></table></figure>

<h4 id="签名算法"><a href="#签名算法" class="headerlink" title="签名算法"></a>签名算法</h4><p>尽量使用 EdDSA （Ed25519）而不是 RSA，可以以更小的长度提供更高的安全性。</p>
<h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p>数字签名、数字证书与 HTTPS 是什么关系？ - 码海的回答 - 知乎 <a href="https://www.zhihu.com/question/52493697/answer/1622722013" target="_blank" rel="external nofollow noopener noreferrer">https://www.zhihu.com/question/52493697/answer/1622722013</a><br><a href="https://juejin.cn/post/6844903638117122056#heading-20" target="_blank" rel="external nofollow noopener noreferrer">https://juejin.cn/post/6844903638117122056#heading-20</a><br><a href="https://www.ruanyifeng.com/blog/2014/02/ssl_tls.html" target="_blank" rel="external nofollow noopener noreferrer">https://www.ruanyifeng.com/blog/2014/02/ssl_tls.html</a><br><a href="https://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html" target="_blank" rel="external nofollow noopener noreferrer">https://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html</a></p>
]]></content>
      <categories>
        <category>证书</category>
      </categories>
      <tags>
        <tag>证书</tag>
        <tag>公钥</tag>
        <tag>加密</tag>
      </tags>
  </entry>
  <entry>
    <title>基于 CentOS Minimal 镜像制作 Docker Base Image</title>
    <url>/post/8a546874.html</url>
    <content><![CDATA[<h4 id="使用镜像安装-centos-虚拟机"><a href="#使用镜像安装-centos-虚拟机" class="headerlink" title="使用镜像安装 centos 虚拟机"></a>使用镜像安装 centos 虚拟机</h4><p>使用 VirtualBox、VMware workstation 或者 Proxmox 等虚拟机管理平台创建虚拟机，在这里我使用 Proxmox 创建虚拟机。由于我们只是为了制作 Docker Base Image，虚拟机用完即删，给虚拟机分配的资源可随意配置。下图是我创建的虚拟机基本配置：</p><a id="more"></a>
<p><img src="https://cdn.nlark.com/yuque/0/2019/png/182657/1567131557233-c3e8da2b-10a6-495a-9805-fcb2f3683b77.png#align=left&display=inline&height=710&name=WX20190830-101825%402x.png&originHeight=710&originWidth=1438&size=138442&status=done&width=1438" alt="WX20190830-101825@2x.png"></p>
<p>这里使用 CentOS 7 1804 的 ISO 镜像安装虚拟机操作系统，安装系统的过程不再赘述，按照正常安装步骤操作即可。这里使用这个版本的操作系统镜像是因为我们自己的软件包都是基于这个版本的 centos 制作的，我需要这个版本的基础镜像通过安装这些软件包制作最后的工作镜像。读者可以根据自己的需要选择不同操作系统不同的版本。</p>
<h4 id="制作基础镜像"><a href="#制作基础镜像" class="headerlink" title="制作基础镜像"></a>制作基础镜像</h4><ul>
<li>配置网络（按需）</li>
</ul>
<p>如果你的网络是通过 DHCP 配置的这一步不需要，只需要检查一下能否联网并正常解析域名即可。否则，可能需要手动配置网络，具体 IP 地址根据自己的网络情况选择：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ip a add 192.168.180.150/24 dev eth0</span><br><span class="line">ip r default via 192.168.180.254 dev eth0</span><br></pre></td></tr></table></figure>

<p>另外设置一下 dns nameserver：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat /etc/resolv.conf</span><br><span class="line">nameserver 192.168.180.42</span><br></pre></td></tr></table></figure>

<ul>
<li>安装 docker-ce</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install -y yum-utils device-mapper-persistent-data lvm2</span><br><span class="line">yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo</span><br><span class="line">yum install -y docker-ce docker-ce-cli containerd.io</span><br><span class="line">systemctl <span class="built_in">enable</span> --now docker</span><br></pre></td></tr></table></figure>

<ul>
<li>获取制作脚本</li>
</ul>
<p>制作脚本从 Moby 项目获取，具体地址： <a href="https://github.com/moby/moby/tree/master/contrib" target="_blank" rel="external nofollow noopener noreferrer">https://github.com/moby/moby/tree/master/contrib</a>，读者可根据自己的需要下载针对不同操作系统的制作脚本，这里使用  mkimage-yum.sh。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install -y wget</span><br><span class="line">wget https://raw.githubusercontent.com/moby/moby/master/contrib/mkimage-yum.sh</span><br><span class="line">chmod +x mkimage-yum.sh</span><br></pre></td></tr></table></figure>

<ul>
<li>制作基础镜像</li>
</ul>
<p>执行以下脚本进行制作：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./mkimage-yum.sh centos</span><br></pre></td></tr></table></figure>

<p>制作完成后：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2019/png/182657/1567133343307-c8b7d86e-9a50-48ac-bfa8-d21c79e26c8c.png#align=left&display=inline&height=108&name=WX20190830-101825%402x.png&originHeight=108&originWidth=1662&size=30100&status=done&width=1662" alt="WX20190830-101825@2x.png"></p>
<p>然后就可以推送到内部镜像仓库中，并作为基础镜像来使用。</p>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>关于K8S中Pod带宽限制的问题</title>
    <url>/post/2c3c5a80.html</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th align="center">Date</th>
<th align="center">Log</th>
</tr>
</thead>
<tbody><tr>
<td align="center">13/01/2019</td>
<td align="center">初始版本.</td>
</tr>
</tbody></table><h3 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h3><p>因业务需求，需要对 K8S 集群中 Pod 的出入带宽进行限制，可能是因为该需求并不常见，能找到的参考资料不多，只能结合官网的一些简单说明开始了踩坑探索。</p><h3 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h3><p>根据官网<a href="https://kubernetes.io/docs/concepts/extend-kubernetes/compute-storage-net/" target="_blank" rel="external nofollow noopener noreferrer">该章节</a>的描述，感觉配置过程很简单的样子，总结一下：</p><ul>
<li>需要使用 CNI 网络插件，确保 kubelet 的启动参数中有 –network-plugin=cni</li>
<li>确保 –cni-conf-dir 和 –cni-bin-dir 存在，默认分别是 /etc/cni/net.d 和 /opt/cni/bin</li>
<li>修改 CNI 插件的配置如下：```yaml<br>{<br>“name”: “k8s-pod-network”,<br>“cniVersion”: “0.3.0”,<br>“plugins”:<br>[<br>{<br>“type”: “calico”,<br>“log_level”: “info”,<br>“datastore_type”: “kubernetes”,<br>“nodename”: “127.0.0.1”,<br>“ipam”: { “type”: “host-local”, “subnet”: “usePodCidr” },<br>“policy”: { “type”: “k8s” },<br>“kubernetes”: { “kubeconfig”: “/etc/cni/net.d/calico-kubeconfig” },<br>},<br>{ “type”: “bandwidth”, “capabilities”: { “bandwidth”: true } },<br>]<br>}</li>
</ul><a id="more"></a>



<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- 在 Pod 模板中添加以下注解即可：&#96;&#96;&#96;yaml</span><br><span class="line">apiVersion: v1</span><br><span class="line">  kind: Pod</span><br><span class="line">  metadata:</span><br><span class="line">  annotations:</span><br><span class="line">      kubernetes.io&#x2F;ingress-bandwidth: 1M</span><br><span class="line">      kubernetes.io&#x2F;egress-bandwidth: 1M</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure>

<p>以上几个条件，前两个已经默认满足，我部署的是 Kubernetes 1.13.1 版本，默认启用 CNI。关于第三个，官网没有说哪些 CNI 可以使用带宽限制，直接给出了一个 calico 的配置示例。因为部署 Kubernetes 时网络插件用的 Flannel ，决定直接改下 Flannel 的配置试试。</p>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><h4 id="基于-Flannel-的测试"><a href="#基于-Flannel-的测试" class="headerlink" title="基于 Flannel 的测试"></a>基于 Flannel 的测试</h4><p>登录到 master 节点， cd 到 /etc/cni/net.d，果然发现了一个名为 10-flannel.conflist 的配置文件孤零零躺着， cat 一下， 内容如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">&#123;</span></span><br><span class="line">  <span class="attr">"name":</span> <span class="string">"cbr0"</span><span class="string">,</span></span><br><span class="line">  <span class="attr">"plugins":</span></span><br><span class="line">    <span class="string">[</span></span><br><span class="line">      <span class="string">&#123;</span></span><br><span class="line">        <span class="attr">"type":</span> <span class="string">"flannel"</span><span class="string">,</span></span><br><span class="line">        <span class="attr">"delegate":</span> <span class="string">&#123;</span> <span class="attr">"hairpinMode":</span> <span class="literal">true</span><span class="string">,</span> <span class="attr">"isDefaultGateway":</span> <span class="literal">true</span> <span class="string">&#125;,</span></span><br><span class="line">      <span class="string">&#125;,</span></span><br><span class="line">      <span class="string">&#123;</span> <span class="attr">"type":</span> <span class="string">"portmap"</span><span class="string">,</span> <span class="attr">"capabilities":</span> <span class="string">&#123;</span> <span class="attr">"portMappings":</span> <span class="literal">true</span> <span class="string">&#125;</span> <span class="string">&#125;,</span></span><br><span class="line">    <span class="string">],</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<p>本着只增不减的原则，在配置中增加了 bandwidth 的配置，变成如下内容：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">&#123;</span></span><br><span class="line">  <span class="attr">"name":</span> <span class="string">"cbr0"</span><span class="string">,</span></span><br><span class="line">  <span class="attr">"plugins":</span></span><br><span class="line">    <span class="string">[</span></span><br><span class="line">      <span class="string">&#123;</span></span><br><span class="line">        <span class="attr">"type":</span> <span class="string">"flannel"</span><span class="string">,</span></span><br><span class="line">        <span class="attr">"delegate":</span> <span class="string">&#123;</span> <span class="attr">"hairpinMode":</span> <span class="literal">true</span><span class="string">,</span> <span class="attr">"isDefaultGateway":</span> <span class="literal">true</span> <span class="string">&#125;,</span></span><br><span class="line">      <span class="string">&#125;,</span></span><br><span class="line">      <span class="string">&#123;</span> <span class="attr">"type":</span> <span class="string">"portmap"</span><span class="string">,</span> <span class="attr">"capabilities":</span> <span class="string">&#123;</span> <span class="attr">"portMappings":</span> <span class="literal">true</span> <span class="string">&#125;</span> <span class="string">&#125;,</span></span><br><span class="line">      <span class="string">&#123;</span> <span class="attr">"type":</span> <span class="string">"bandwidth"</span><span class="string">,</span> <span class="attr">"capabilities":</span> <span class="string">&#123;</span> <span class="attr">"bandwidth":</span> <span class="literal">true</span> <span class="string">&#125;</span> <span class="string">&#125;,</span></span><br><span class="line">    <span class="string">],</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<p>然后执行 systemctl restart kubelet 重启了一下 kubelet 。再回头 cat 一下配置文件，发现增加的配置消失了…</p>
<p>猜测难道是因为 bandwidth 插件和 portmap 插件有冲突，然后强大的 K8S 来了个自动还原？</p>
<p>只能把 portmap 插件去掉再试试了… 然后重启 kubelet ，发现这次 bandwidth 没有消失。</p>
<p>配置变为：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">&#123;</span></span><br><span class="line">  <span class="attr">"name":</span> <span class="string">"cbr0"</span><span class="string">,</span></span><br><span class="line">  <span class="attr">"plugins":</span></span><br><span class="line">    <span class="string">[</span></span><br><span class="line">      <span class="string">&#123;</span></span><br><span class="line">        <span class="attr">"type":</span> <span class="string">"flannel"</span><span class="string">,</span></span><br><span class="line">        <span class="attr">"delegate":</span> <span class="string">&#123;</span> <span class="attr">"hairpinMode":</span> <span class="literal">true</span><span class="string">,</span> <span class="attr">"isDefaultGateway":</span> <span class="literal">true</span> <span class="string">&#125;,</span></span><br><span class="line">      <span class="string">&#125;,</span></span><br><span class="line">      <span class="string">&#123;</span> <span class="attr">"type":</span> <span class="string">"bandwidth"</span><span class="string">,</span> <span class="attr">"capabilities":</span> <span class="string">&#123;</span> <span class="attr">"bandwidth":</span> <span class="literal">true</span> <span class="string">&#125;</span> <span class="string">&#125;,</span></span><br><span class="line">    <span class="string">],</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<p>之后创建两个 deployment 测试，分别如下：</p>
<p>无带宽限制的 deployment：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">piVersion:</span> <span class="string">extensions/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">centos-deployment</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">centos</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">centos</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">centos</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">centos</span></span><br><span class="line">          <span class="attr">image:</span> <span class="string">xyc11223344/centos</span></span><br><span class="line">          <span class="attr">command:</span> <span class="string">["nginx",</span> <span class="string">"-g"</span><span class="string">,</span> <span class="string">"daemon off;"</span><span class="string">]</span></span><br><span class="line">          <span class="attr">ports:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>

<p>有带宽限制的 deployment：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">piVersion:</span> <span class="string">extensions/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">centos-deployment-01</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">centos-01</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">centos-01</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">centos-01</span></span><br><span class="line">      <span class="attr">annotations:</span></span><br><span class="line">        <span class="attr">kubernetes.io/ingress-bandwidth:</span> <span class="string">10M</span></span><br><span class="line">        <span class="attr">kubernetes.io/egress-bandwidth:</span> <span class="string">10M</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">centos-01</span></span><br><span class="line">          <span class="attr">image:</span> <span class="string">xyc11223344/centos</span></span><br><span class="line">          <span class="attr">command:</span> <span class="string">["nginx",</span> <span class="string">"-g"</span><span class="string">,</span> <span class="string">"daemon off;"</span><span class="string">]</span></span><br><span class="line">          <span class="attr">ports:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>

<p>部署后发现，又出错，提示 no bandwidth plugin 之类的…</p>
<p>想了想难道是没有 bandwidth 二进制包， cd 到 /opt/cni/bin 看了下，果然没有任何名为 bandwidth 的东西…</p>
<p>好吧，去 github 上下吧…</p>
<p>一通乱搜，找到了插件<a href="https://github.com/containernetworking/plugins" target="_blank" rel="external nofollow noopener noreferrer">项目地址</a>：</p>
<p>下载了最新 release 的 0.7.4 版本二进制包，解压开一看，无语，还是没有…</p>
<p>难道是我解压姿势不对？仔细看了看项目说明，明明是有的，好吧，看来要自己动手编译了。</p>
<p>编译的过程异乎寻常的顺利，前提是你的机子上已经配置好 Go 的开发环境，只需执行以下命令即可:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/containernetworking/plugins.git</span><br><span class="line"><span class="built_in">cd</span> plugins</span><br><span class="line">./build_linux.sh</span><br></pre></td></tr></table></figure>

<p>很快编译完了，在项目目录下出现了 bin 文件夹， ls 查看一下，有了：<br><img src="https://cdn.nlark.com/yuque/0/2019/png/182657/1575442963241-bc70c7cc-1ee4-4fb6-aecb-0507f46d33ad.png#align=left&display=inline&height=38&name=image.png&originHeight=38&originWidth=1166&size=27284&status=done&style=none&width=1166" alt="image.png"></p>
<p>scp 到 master 节点，放到/opt/cni/bin 目录下。</p>
<p>重启 kubelet，又报错…说是 config version is 0.1.0， plugin supports only [0.3.0, 0.3.1, 0.4.0]</p>
<p>完全摸不着头脑，只能靠猜了…</p>
<p>看了一下上边的 Flannel 配置，貌似没有版本号的信息，猜测没有版本号就意味采用了默认版本号，而默认版本号应该是 0.1.0 ，所以才会有上述错误。继续修改配置为：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">&#123;</span></span><br><span class="line">  <span class="attr">"name":</span> <span class="string">"cbr0"</span><span class="string">,</span></span><br><span class="line">  <span class="attr">"cniVersion":</span> <span class="string">"0.3.0"</span><span class="string">,</span></span><br><span class="line">  <span class="attr">"plugins":</span></span><br><span class="line">    <span class="string">[</span></span><br><span class="line">      <span class="string">&#123;</span></span><br><span class="line">        <span class="attr">"type":</span> <span class="string">"flannel"</span><span class="string">,</span></span><br><span class="line">        <span class="attr">"delegate":</span> <span class="string">&#123;</span> <span class="attr">"hairpinMode":</span> <span class="literal">true</span><span class="string">,</span> <span class="attr">"isDefaultGateway":</span> <span class="literal">true</span> <span class="string">&#125;,</span></span><br><span class="line">      <span class="string">&#125;,</span></span><br><span class="line">      <span class="string">&#123;</span> <span class="attr">"type":</span> <span class="string">"bandwidth"</span><span class="string">,</span> <span class="attr">"capabilities":</span> <span class="string">&#123;</span> <span class="attr">"bandwidth":</span> <span class="literal">true</span> <span class="string">&#125;</span> <span class="string">&#125;,</span></span><br><span class="line">    <span class="string">],</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<p>重启 kubelet ， 等了半天 Pod 还是创建不出来，再次 kubetl get events 看看又 TM 咋了…</p>
<p>报错 no interface 之类的…最后一丝侥幸心理也没了。老老实实换 Calico 吧。</p>
<h4 id="基于-Calico-的测试"><a href="#基于-Calico-的测试" class="headerlink" title="基于 Calico 的测试"></a>基于 Calico 的测试</h4><p>网络插件要从 Flannel 换为 Calico ，因为 Kubeadm init 时传进去的是 –pod-network-cidr=10.244.0.0/16 ， 和 Calico 的默认网段不一致，好吧，要替换一下了，执行以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 先卸掉flannel</span></span><br><span class="line">wget https://raw.githubusercontent.com/coreos/flannel/bc79dd1505b0c8681ece4de4c0d86c5cd2643275/Documentation/kube-flannel.yml</span><br><span class="line">kubectl delete -f kube-flannel.yml</span><br><span class="line"><span class="comment"># 删掉丫的防干扰</span></span><br><span class="line">rm -f /etc/cni/net.d/10-flannel.conflist</span><br><span class="line"><span class="comment"># 再装calico</span></span><br><span class="line">kubectl apply -f https://docs.projectcalico.org/v3.3/getting-started/kubernetes/installation/hosted/rbac-kdd.yaml</span><br><span class="line">wget https://docs.projectcalico.org/v3.3/getting-started/kubernetes/installation/hosted/kubernetes-datastore/calico-networking/1.7/calico.yaml</span><br><span class="line">sed <span class="string">'s/192.168.0.0/10.244.0.0/g'</span> calico.yaml</span><br><span class="line">kubectl apply -f calico.yaml</span><br></pre></td></tr></table></figure>

<p>再次进入到 /etc/cni/net.d 目录，惊喜的发现多了两个文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /etc/cni/net.d</span><br><span class="line">ls</span><br><span class="line">10-calico.conflist  calico-kubeconfig</span><br></pre></td></tr></table></figure>

<p>修改 10-calico.conflist 为如下内容，其实就是增加了 bandwidth 的配置项，去掉了 potmap 的配置项：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">&#123;</span></span><br><span class="line">  <span class="attr">"name":</span> <span class="string">"k8s-pod-network"</span><span class="string">,</span></span><br><span class="line">  <span class="attr">"cniVersion":</span> <span class="string">"0.3.0"</span><span class="string">,</span></span><br><span class="line">  <span class="attr">"plugins":</span></span><br><span class="line">    <span class="string">[</span></span><br><span class="line">      <span class="string">&#123;</span></span><br><span class="line">        <span class="attr">"type":</span> <span class="string">"calico"</span><span class="string">,</span></span><br><span class="line">        <span class="attr">"log_level":</span> <span class="string">"info"</span><span class="string">,</span></span><br><span class="line">        <span class="attr">"datastore_type":</span> <span class="string">"kubernetes"</span><span class="string">,</span></span><br><span class="line">        <span class="attr">"nodename":</span> <span class="string">"10-10-183-55"</span><span class="string">,</span></span><br><span class="line">        <span class="attr">"mtu":</span> <span class="number">1440</span><span class="string">,</span></span><br><span class="line">        <span class="attr">"ipam":</span> <span class="string">&#123;</span> <span class="attr">"type":</span> <span class="string">"host-local"</span><span class="string">,</span> <span class="attr">"subnet":</span> <span class="string">"usePodCidr"</span> <span class="string">&#125;,</span></span><br><span class="line">        <span class="attr">"policy":</span> <span class="string">&#123;</span> <span class="attr">"type":</span> <span class="string">"k8s"</span> <span class="string">&#125;,</span></span><br><span class="line">        <span class="attr">"kubernetes":</span> <span class="string">&#123;</span> <span class="attr">"kubeconfig":</span> <span class="string">"/etc/cni/net.d/calico-kubeconfig"</span> <span class="string">&#125;,</span></span><br><span class="line">      <span class="string">&#125;,</span></span><br><span class="line">      <span class="string">&#123;</span> <span class="attr">"type":</span> <span class="string">"bandwidth"</span><span class="string">,</span> <span class="attr">"capabilities":</span> <span class="string">&#123;</span> <span class="attr">"bandwidth":</span> <span class="literal">true</span> <span class="string">&#125;</span> <span class="string">&#125;,</span></span><br><span class="line">    <span class="string">],</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<p>重启 kubelet， 呵呵。Pod 终于 Running 了。<br><img src="https://cdn.nlark.com/yuque/0/2019/png/182657/1575442988039-9762993b-8113-4dae-b114-b305332405bd.png#align=left&display=inline&height=74&name=image.png&originHeight=74&originWidth=1218&size=63427&status=done&style=none&width=1218" alt="image.png"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 执行以下命令进入Pod</span></span><br><span class="line">kubectl <span class="built_in">exec</span> -it centos-deployment-01-699f7776f-5j6t5 bash</span><br><span class="line"><span class="comment"># 执行以下命令开个iperf server，iperf 什么的提前都装好了</span></span><br><span class="line">iperf -s</span><br><span class="line"><span class="comment"># 另外再开个窗口，执行以下命令进入另一个Pod</span></span><br><span class="line">kubectl <span class="built_in">exec</span> -it centos-deployment-57948c8598-jwkpr bash</span><br><span class="line"><span class="comment"># 执行以下命令进行测试</span></span><br><span class="line">iperf -c iperf -c 10.244.1.6 -t 10</span><br></pre></td></tr></table></figure>

<p>数据如下:</p>
<p>限速前：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2019/png/182657/1575443012295-d2bc2306-a82c-4223-95a1-7ca0567eaa11.png#align=left&display=inline&height=127&name=image.png&originHeight=127&originWidth=630&size=45608&status=done&style=none&width=630" alt="image.png"></p>
<p>限速后：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2019/png/182657/1575443032242-0bc4e6c4-f824-4821-b254-2d16eee44ce5.png#align=left&display=inline&height=126&name=image.png&originHeight=126&originWidth=660&size=49857&status=done&style=none&width=660" alt="image.png"></p>
<p>啊！真的限速了呢！可这限的什么鬼…</p>
<p>明明说好的 10M，怎么变成了 301K…</p>
<p>难道又是姿势不对？换了好多姿势，可每次数据都是不一样的吊诡…</p>
<p>上网搜吧…找到了一个 Github 上的 <a href="https://github.com/kubernetes/kubernetes/issues/70014" target="_blank" rel="external nofollow noopener noreferrer">issue</a> ，和我这个问题的症状相似又不太一样，而且看起来已经关闭了。</p>
<p>难道是我的 Kubernetes 版本太老了， 1.13.1 不是最新的吗？难道有新版本发布了？到 Github 上看了看还真有， 3 天前发布了 1.13.2。</p>
<p>好吧，开始升级：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 标准的使用kubeadm部署的集群的升级姿势</span></span><br><span class="line">kubeadm upgrade apply 1.13.2</span><br><span class="line"><span class="comment"># 提示可以升级，但是要先自己升级kubeadm kubelet kubectl</span></span><br><span class="line">yum install kubeadm</span><br><span class="line"><span class="comment"># 提示已经是最新了...看来官方源还没跟上步伐，只能从官网自己下二进制包吧</span></span><br><span class="line"><span class="comment"># 到这里https://github.com/kubernetes/kubernetes/blob/master/CHANGELOG-1.13.md下载最新版的linux-server端二进制包</span></span><br><span class="line"><span class="comment"># 解压后，用新的kubeadm kubectl kubelet 替换旧的</span></span><br><span class="line"><span class="comment"># 注意替换 kubelet 要先执行以下命令停止服务</span></span><br><span class="line">systemctl stop kubelet</span><br><span class="line"><span class="comment"># 替换后执行以下命令重启</span></span><br><span class="line">systemctl start kubelet</span><br><span class="line"><span class="comment"># 所有节点都替换这三大件</span></span><br><span class="line"><span class="comment"># 之后执行以下命令升级集群</span></span><br><span class="line">kubeadm upgrade plan 1.13.2</span><br></pre></td></tr></table></figure>

<p>升级完成之后，重新测试。结果真是忧伤，依然吊诡…</p>
<p>万般无奈之下，找到华为云容器团队的杜大师咨询了一下，大师不愧是大师，秒懂怎么回事儿，并教给我如下命令查看 tc 配置，因为说到底这个带宽限制还是通过 Linux TC 实现的:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tc qdisc show</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.nlark.com/yuque/0/2019/png/182657/1575443051065-4bc1bc1a-0b5a-4591-b3df-f57802fc1ff4.png#align=left&display=inline&height=274&name=image.png&originHeight=274&originWidth=823&size=150326&status=done&style=none&width=823" alt="image.png"></p>
<p>仔细看最后几行，10M 变成了 10K，和上述 70014 描述的 bug 一致，不过 burst 默认是 214747b 有点吊诡…</p>
<p>好吧，总结一下，功能是有的，只不过还有 bug。</p>
<p>折腾到这里，突然有点怀念 OpenShift ，那就测一下吧。</p>
<h4 id="基于-OpenShift-SDN-的测试"><a href="#基于-OpenShift-SDN-的测试" class="headerlink" title="基于 OpenShift-SDN 的测试"></a>基于 OpenShift-SDN 的测试</h4><p>先看一下 openshift 的零件，竟然也是标准 CNI：<br><img src="https://cdn.nlark.com/yuque/0/2019/png/182657/1575443067485-64bda488-ce15-45e7-9208-97030040af11.png#align=left&display=inline&height=220&name=image.png&originHeight=220&originWidth=586&size=68560&status=done&style=none&width=586" alt="image.png"></p>
<p>而且据说不用任何额外配置，直接支持带宽限制。所以，把上面的两个 deployment 直接部署，过了一会儿 Pod 就起来了。<br><img src="https://cdn.nlark.com/yuque/0/2019/png/182657/1575443083763-bea1fe29-ae77-4322-bf1f-0d955d4780a8.png#align=left&display=inline&height=74&name=image.png&originHeight=74&originWidth=684&size=42546&status=done&style=none&width=684" alt="image.png"></p>
<p>然后跑一下 iperf 试试，数据如下：<br><img src="https://cdn.nlark.com/yuque/0/2019/png/182657/1575443097570-ef5d3d03-4755-497c-8bbe-6ee3bbb73d03.png#align=left&display=inline&height=127&name=image.png&originHeight=127&originWidth=666&size=79395&status=done&style=none&width=666" alt="image.png"></p>
<p>看看这数据，真是相当整齐了，10M 就是 10M。</p>
<p>说到底，还是 OpenShift 好用啊。</p>
]]></content>
      <categories>
        <category>Kubernetes</category>
      </categories>
      <tags>
        <tag>Kubernetes</tag>
        <tag>云计算</tag>
      </tags>
  </entry>
  <entry>
    <title>喜欢的音乐</title>
    <url>/post/102c919d.html</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th align="center">Date</th>
<th align="center">Log</th>
</tr>
</thead>
<tbody><tr>
<td align="center">04/08/2017</td>
<td align="center">初始版本，增加’Stories’, ‘万神纪’, ‘手纸 拝启 十五の君’, ‘永遠語り～風ノ歌～’, ‘与君说’, ‘だんご大家族’.</td>
</tr>
<tr>
<td align="center">04/16/2017</td>
<td align="center">增加“锦鲤抄”。</td>
</tr>
</tbody></table><p>本文汇总了一些好听的歌。</p><h3 id="Stories"><a href="#Stories" class="headerlink" title="Stories"></a>Stories</h3><p>All Hail Lelouch !</p><a id="more"></a>


<center style="padding:0px;">  <p style="font: bold 20px arial,sans-serif; margin:0px; padding:0px;">All Hail Lelouch !</p>   <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=22805139&auto=0&height=66"></iframe>  </center>

<h3 id="万神纪"><a href="#万神纪" class="headerlink" title="万神纪"></a>万神纪</h3><center style="padding:0px;">    <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=459554803&auto=0&height=66"></iframe>   
<iframe src="https://player.bilibili.com/player.html?aid=8542373" frameborder="no" allowfullscreen="true"></iframe>
</center> 

<h3 id="锦鲤抄"><a href="#锦鲤抄" class="headerlink" title="锦鲤抄"></a>锦鲤抄</h3><center style="padding:0px;">
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=28188434&auto=0&height=66"></iframe>
<iframe src="https://player.bilibili.com/player.html?aid=9119029" frameborder="no" allowfullscreen="true"></iframe>
</center>  

<h3 id="手纸-拝启-十五の君-信-写给十五岁的自己"><a href="#手纸-拝启-十五の君-信-写给十五岁的自己" class="headerlink" title="手纸 拝启 十五の君 (信 写给十五岁的自己)"></a>手纸 拝启 十五の君 (信 写给十五岁的自己)</h3><center style="padding:0px;">

<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=550667&auto=1&height=66"></iframe>
</center>

<h3 id="永遠語り～風ノ歌～-永远语-风之歌"><a href="#永遠語り～風ノ歌～-永远语-风之歌" class="headerlink" title="永遠語り～風ノ歌～ (永远语 风之歌)"></a>永遠語り～風ノ歌～ (永远语 风之歌)</h3><center style="padding:0px;">
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=31168232&auto=0&height=66"></iframe>
</center>

<h3 id="与君说"><a href="#与君说" class="headerlink" title="与君说"></a>与君说</h3><center style="padding:0px;">
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=462688968&auto=0&height=66"></iframe>
<iframe src="https://player.bilibili.com/player.html?aid=7536941" frameborder="no" allowfullscreen="true"></iframe>
</center>

<h3 id="だんご大家族-团子大家族"><a href="#だんご大家族-团子大家族" class="headerlink" title="だんご大家族 (团子大家族)"></a>だんご大家族 (团子大家族)</h3><center style="padding:0px;">
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=760533&auto=0&height=66"></iframe>
</center>

<script src="https://cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script>
<script>window.onload = window.onresize = function() {  $(".fluid-vids").css({ margin: "0px", padding: "0px", height: "86px"});  $("center>iframe").css({ width: "97%" });  $("center>iframe").height($("center>iframe").width() * 0.60);  $("center>br").remove();}; </script>
]]></content>
      <categories>
        <category>音乐</category>
      </categories>
      <tags>
        <tag>音乐</tag>
      </tags>
  </entry>
  <entry>
    <title>前端知识点滴</title>
    <url>/post/a68ff6.html</url>
    <content><![CDATA[<h4 id="swagger-client"><a href="#swagger-client" class="headerlink" title="swagger-client"></a>swagger-client</h4><p>swagger-client 是一个 js 包，可以读取并解析  Swagger 2.0 和 OpenAPI 3 的 json 文档并生成可以对文档中定义的 API 进行调用的 client，简化 api 请求过程。</p><h4 id="文件下载"><a href="#文件下载" class="headerlink" title="文件下载"></a>文件下载</h4><p>服务端响应的 Header 中可以设置 <code>Content-Disposition: attachment; filename=test.txt</code>  指定文件名称，一般设置 <code>Content-Type: application/octet-stream</code>  对于小的文本文件也可以设置为  <code>Content-Type: text/plain; charset=utf-8</code>  告诉浏览器可以直接在浏览器窗口打开。</p><a id="more"></a>

<h4 id="更新依赖"><a href="#更新依赖" class="headerlink" title="更新依赖"></a>更新依赖</h4><p>npm-check-updates 可以帮助更新 package.json 中的所有依赖，其仍是通过 npm update 实现。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">npm i -g npm-check-updates</span><br><span class="line">npm-check-updates -u</span><br></pre></td></tr></table></figure>

<h4 id="Node-js-下载图片到本地"><a href="#Node-js-下载图片到本地" class="headerlink" title="Node.js 下载图片到本地"></a>Node.js 下载图片到本地</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">downloadPic</span>(<span class="params">src, dest</span>) </span>&#123;</span><br><span class="line">  request(src)</span><br><span class="line">    .pipe(fs.createWriteStream(dest))</span><br><span class="line">    .on(<span class="string">"close"</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"pic saved!"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用方式：</span></span><br><span class="line">downloadPic(imgList[<span class="number">0</span>], <span class="string">"./catpics/1.jpg"</span>);</span><br></pre></td></tr></table></figure>

<h4 id="Node-js-教程"><a href="#Node-js-教程" class="headerlink" title="Node.js 教程"></a>Node.js 教程</h4><ul>
<li>Node.js TypeScript 15 篇：<a href="https://wanago.io/2019/03/18/node-js-typescript-6-sending-http-requests-understanding-multipart-form-data/" target="_blank" rel="external nofollow noopener noreferrer">https://wanago.io/2019/03/18/node-js-typescript-6-sending-http-requests-understanding-multipart-form-data/</a>  篇介绍了如何在 Node.js 中使用  multipart/form-data 流式上传文件。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> FormData <span class="keyword">from</span> <span class="string">"form-data"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; request &#125; <span class="keyword">from</span> <span class="string">"http"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; createReadStream &#125; <span class="keyword">from</span> <span class="string">"fs"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> readStream = createReadStream(<span class="string">"./photo.jpg"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> form = <span class="keyword">new</span> FormData();</span><br><span class="line">form.append(<span class="string">"photo"</span>, readStream);</span><br><span class="line">form.append(<span class="string">"firstName"</span>, <span class="string">"Marcin"</span>);</span><br><span class="line">form.append(<span class="string">"lastName"</span>, <span class="string">"Wanago"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> req = request(</span><br><span class="line">  &#123;</span><br><span class="line">    host: <span class="string">"localhost"</span>,</span><br><span class="line">    port: <span class="string">"5000"</span>,</span><br><span class="line">    path: <span class="string">"/upload"</span>,</span><br><span class="line">    method: <span class="string">"POST"</span>,</span><br><span class="line">    headers: form.getHeaders(),</span><br><span class="line">  &#125;,</span><br><span class="line">  (response) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(response.statusCode); <span class="comment">// 200</span></span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">form.pipe(req);</span><br></pre></td></tr></table></figure>

<h4 id="Node-js-流式转存图片"><a href="#Node-js-流式转存图片" class="headerlink" title="Node.js 流式转存图片"></a>Node.js 流式转存图片</h4><p>下载的同时开始上传到七牛云：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> qiniu <span class="keyword">from</span> <span class="string">'qiniu'</span>;</span><br><span class="line"><span class="keyword">const</span> config: any = <span class="keyword">new</span> qiniu.conf.Config();</span><br><span class="line">config.zone = qiniu.zone.Zone_z2;</span><br><span class="line"><span class="keyword">const</span> formUploader = <span class="keyword">new</span> qiniu.form_up.FormUploader(config);</span><br><span class="line"><span class="keyword">const</span> putExtra = <span class="keyword">new</span> qiniu.form_up.PutExtra();</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> uploadFiles(urls: any[], <span class="attr">type</span>: string, token?: string) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!token) &#123;</span><br><span class="line">    token = <span class="keyword">await</span> get_token();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> keys = &#123;&#125;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> url <span class="keyword">of</span> urls) &#123;</span><br><span class="line">    <span class="keyword">let</span> requestUrl = url.url.trim();</span><br><span class="line">    <span class="keyword">if</span> (!requestUrl || !<span class="regexp">/(https?|ftp|file):\/\/\w+\.\w+/</span>.test(requestUrl)) &#123;</span><br><span class="line">      keys[url.id] = <span class="literal">null</span>;</span><br><span class="line">      <span class="keyword">continue</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> uploadFunc = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> readableStream = request(requestUrl);</span><br><span class="line">        <span class="keyword">const</span> key = <span class="string">`images/xxx_<span class="subst">$&#123;<span class="built_in">Date</span>.now()&#125;</span>.jpg`</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          formUploader.putStream(</span><br><span class="line">            token,</span><br><span class="line">            key,</span><br><span class="line">            readableStream,</span><br><span class="line">            putExtra,</span><br><span class="line">            (respErr, respBody, respInfo) =&gt; &#123;</span><br><span class="line">              <span class="keyword">if</span> (respInfo.statusCode == <span class="number">200</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> resolve(respBody &amp;&amp; respBody.key);</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> resolve(<span class="literal">null</span>);</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          );</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">          <span class="keyword">return</span> resolve(<span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> key = <span class="keyword">await</span> uploadFunc();</span><br><span class="line">    <span class="keyword">this</span>.app.logger.info(<span class="string">'key: '</span>, key);</span><br><span class="line">    keys[url.id] = key;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> keys;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="从-Html-文本中匹配所有-img-的地址"><a href="#从-Html-文本中匹配所有-img-的地址" class="headerlink" title="从 Html 文本中匹配所有 img 的地址"></a>从 Html 文本中匹配所有 img 的地址</h4><ol>
<li>从字符串中匹配出所有的 img 标签</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> str =</span><br><span class="line">  <span class="string">'this is test string &lt;img src="http:baidu.com/test.jpg" width=\'50\' &gt; 1 and the end &lt;img src="所有地址也能匹配.jpg" /&gt; 33! &lt;img src="/uploads/attached/image/20120426/20120426225658_92565.png" alt="" /&gt;'</span>;</span><br><span class="line"><span class="keyword">const</span> imgReg = <span class="regexp">/&lt;img.*?(?:&gt;|\/&gt;)/gi</span>;</span><br><span class="line"><span class="keyword">const</span> srcReg = <span class="regexp">/src=[\'\"]?([^\'\"]*)[\'\"]?/i</span>;</span><br><span class="line"><span class="keyword">const</span> arr = str.match(imgReg); <span class="comment">// arr 为包含所有img标签的数组</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>从数组中获取到所有的 src 地址</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">  <span class="keyword">const</span> src = arr[i].match(srcReg);</span><br><span class="line">  <span class="comment">//获取图片地址</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"图片地址"</span> + (i + <span class="number">1</span>) + <span class="string">"："</span> + src[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="cookie-的工作原理"><a href="#cookie-的工作原理" class="headerlink" title="cookie 的工作原理"></a>cookie 的工作原理</h4><ol>
<li>需要 cookie 是因为 HTTP 协议本身是无状态的，但是需要用户登录的网站显然是需要记录用户的登录状态给后端使用的，而这个状态应该对同一个域（同源）下的所有请求都有效，所以设计了 cookie，cookie 的设置和发送一般是不需要前端人员介入的（当然前端是可以使用 js 增删改查 cookie 的），设置是浏览器根据 HTTP 响应头中的 set-cookie 信息自动设置，发送也是浏览器根据 HTTP 请求的 URL 自动匹配后添加的。</li>
<li>HTTP 请求，Cookie 的使用过程：server 通过 HTTP Response 中的 “Set-Cookie: header” 把 cookie 发送给 client；client（用户的浏览器） 把 cookie 通过 HTTP Request 中的 “Cookie: header” 发送给 server；每次 HTTP 请求，Cookie 都会被发送。</li>
<li>HTTP 请求发送 Cookies 的条件：本地已经缓存有 cookies；根据请求的 URL 来匹配 cookies 的 domain、path 属性，如果都符合才会发送。</li>
<li>如下为 HTTP 响应头中设置 cookie 的示例，Expires 和 Max-Age 同时设置时后者优先级高，如果均未设置则默认有效期为 session，当浏览器关闭时失效，设置 Max-Age 为 0 使 cookie 立即失效即删除 cookie，HttpOnly 指明只允许浏览器自动处理，不允许使用 JavaScrit 操作该 cookie，Path 指定对哪些 Path 自动发送该 cookie，默认为 ／ 代表对所有路径有效，设置 domain 为顶级域名时可以在各子域名之间共享 cookie，如  Set-Cookie: name=value; domain=mydomain.com ，则可以在 sub1.mydomain.com／sub2.mydomain.com／subsub.subdomain.mydomain.com 之间共享该 cookie，无论最初的 set-cookie 响应头源自哪个 sub domain：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Set-Cookie: KEYCLOAK_SESSION&#x3D;umstor&#x2F;fe2ff4f2-6b3c-4d03-aaf1-0e79f09568c5&#x2F;9e4adcbc-cfec-4f57-9eb9-4bcc16877a23; Version&#x3D;1; Expires&#x3D;Sat, 30-Nov-2019 14:52:40 GMT; Max-Age&#x3D;36000; Path&#x3D;&#x2F;keycloak&#x2F;realms&#x2F;umstor&#x2F;</span><br><span class="line">Set-Cookie: KEYCLOAK_REMEMBER_ME&#x3D;; Version&#x3D;1; Comment&#x3D;Expiring cookie; Expires&#x3D;Thu, 01-Jan-1970 00:00:10 GMT; Max-Age&#x3D;0; Path&#x3D;&#x2F;keycloak&#x2F;realms&#x2F;umstor&#x2F;; HttpOnly</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>session 是服务端记录用户登录状态的机制，只不过需要借助 cookie 机制在浏览器每次发起请求时带上 session id。</li>
<li>使用 cookie 不是必须的，也可以将信息存在 localStorage 并通过 url 或 formdata 传输也是可行的，cookie 只不过因为是在协议层面支持因而使用起来可以更方便一些（自动设置和发送）。</li>
</ol>
<h4 id="前端的各种存储"><a href="#前端的各种存储" class="headerlink" title="前端的各种存储"></a>前端的各种存储</h4><ol>
<li>cookie 能够携带的数据较少，容量在 4KB 左右，在 HTTP Header 中携带太多数据会对性能有一定影响，因此引入了各种 storage，所以现在的 Web 程序中 cookie 的使用已经少了很多。</li>
<li>localStorage 和 sessionStorage 的大小均在  5M 左右，均有同源策略，仅在客户端保存，不像 cookie 通过协议的支持自动在客户端和服务端之间传输，需要编程人员自行通过 URL 或者请求体（响应体）进行传输并解析。</li>
<li>localStorage 的存储是永久的，除非人为删除否则一直存在；sessionStorage  与存储数据的脚本所在的标签页的有效期是相同的，一旦窗口或者标签页被关闭，那么所有通过 sessionStorage 存储的数据也会被删除。</li>
<li>localStorage: 在同一个浏览器内，同源文档之间共享 localStorage 数据，可以互相读取、覆盖。</li>
<li>sessionStorage: 与 localStorage 一样需要同一浏览器同源文档这一条件。不仅如此，sessionStorage 的作用域还被限定在了窗口中，也就是说，只有同一浏览器、同一窗口的同源文档（如同源的 iframe）才能共享数据。例如你在浏览器中打开了两个相同地址的页面 A、B, 虽然这两个页面的源完全相同，但是他们还是不能共享数据，因为他们是不同窗口中的。但是如果是一个窗口中，有两个同源的 iframe 元素的话，这两个 iframe 的 sessionStorage 是可以互通的</li>
<li>IndexedDB 是相比  localStorage 和  sessionStorage 除了提供了更大的存储空间（一般来说不少于 250MB，甚至没有上限），还提供查找接口，还能建立索引，支持事务。</li>
<li>IndexedDB 操作时不会锁死浏览器，用户依然可以进行其他操作，这与 LocalStorage 形成对比，后者的操作是同步的。异步设计是为了防止大量数据的读写，拖慢网页的表现。</li>
<li>就数据库类型而言，IndexedDB 不属于关系型数据库（不支持 SQL 查询语句），更接近 NoSQL 数据库。</li>
<li>WebSQL 相比 IndexedDB 支持 SQL 查询，但是目前只有谷歌浏览器支持，火狐不支持。</li>
<li>cache storage 是配合 PWA 使用的。</li>
</ol>
<h4 id="Chrome-控制台记录-XMLHttpRequest-请求"><a href="#Chrome-控制台记录-XMLHttpRequest-请求" class="headerlink" title="Chrome 控制台记录  XMLHttpRequest 请求"></a>Chrome 控制台记录  XMLHttpRequest 请求</h4><p><img src="https://cdn.nlark.com/yuque/0/2019/png/182657/1575432225980-3814e3a4-8a82-478e-8f1f-8713291450ea.png#align=left&display=inline&height=453&margin=%5Bobject%20Object%5D&name=image.png&originHeight=453&originWidth=961&size=68737&status=done&style=none&width=961" alt="image.png"></p>
<h4 id="关于-Token-的认识"><a href="#关于-Token-的认识" class="headerlink" title="关于 Token 的认识"></a>关于 Token 的认识</h4><ul>
<li>一个 Token 就是一些信息的集合；</li>
<li>在 Token 中包含足够多的信息，以便在后续请求中减少查询数据库的几率；</li>
<li>服务端需要对 cookie 和 HTTP Authrorization Header 进行 Token 信息的检查；</li>
<li>基于上一点，你可以用一套 token 认证代码来面对浏览器类客户端和非浏览器类客户端；</li>
<li>因为 token 是被签名的，所以我们可以认为一个可以解码认证通过的 token 是由我们系统发放的，其中带的信息是合法有效的；</li>
<li>Token 无法撤销的问题，一种解决方法是发放有效期较短的 Token，另一种是仍然使用 session 与浏览器端交互；</li>
<li>Token 与 session 可以同时使用，只不过面向不同的场景，Token 可以作为第三方进行 API 调用的认证方式，而 session 可作为前端交互时的选择；</li>
<li>当然也可以只用 Token 作为前端交互时的认证方式，但要面临 Token 无法撤销的问题；</li>
<li>如果你的用户数据可能需要和第三方共享，或者允许第三方调用 API 接口，用 Token；</li>
<li>在 Web 应用中，别再把 JWT 当做 session 使用，绝大多数情况下，传统的 cookie-session 机制工作得更好；</li>
<li>JWT 适合一次性的命令认证，颁发一个有效期极短的 JWT，即使暴露了危险也很小，由于每次操作都会生成新的 JWT，因此也没必要保存 JWT，真正实现无状态。</li>
</ul>
<h4 id="OAtuh-与-OpenID"><a href="#OAtuh-与-OpenID" class="headerlink" title="OAtuh 与 OpenID"></a>OAtuh 与 OpenID</h4><p>OAuth 的本意是一个应用允许另一个应用在用户授权的情况下访问自己的数据，OAuth 的设计本意更倾向于授权而非认证（当然授权用户信息就间接实现了认证）。OpenID 用于身份认证，允许你以同一个账户在多个网站登陆。它仅仅是为你的合法身份背书，当你以 Facebook 账号登陆某个站点之后，该站点无权访问你的在 Facebook 上的数据。OAuth 用于授权，允许被授权方访问授权方的用户数据。两者往往一起使用，实现认证和授权过程。</p>
<h4 id="单点登录的实现方式"><a href="#单点登录的实现方式" class="headerlink" title="单点登录的实现方式"></a>单点登录的实现方式</h4><ul>
<li>同域下不同站点的 SSO（跨站点）：两个站点如果在同域下，那么它们之间是可以共享 cookie 的。简单的说就是这种同域下不同站点的 sso 实现可以通过 cookie 来实现，当用户访问这个域下面的任意站点时，浏览器都会将这个 cookie 发送给站点对应的系统。</li>
<li>同域但不同子域名的 SSO（跨子域）： 通过在设置 cookie 时指定 domain，设置 domain 为顶级域名时可以在各子域名之间共享 cookie，如 Set-Cookie: name=value; domain=mydomain.com。</li>
<li>不同域的 SSO（跨域）：一种是简单的笨方法，使用 cookie，在各个应用之间重定向；一种是使用单独的 SSO 服务器。</li>
<li>使用单独的认证服务器已经是较为通用的方式。</li>
<li>参考：<a href="https://www.jianshu.com/p/8401582c0ef1" target="_blank" rel="external nofollow noopener noreferrer">SSO 三种情况的实现方式</a>。</li>
</ul>
<h4 id="访问资源时省略-URL-中的协议"><a href="#访问资源时省略-URL-中的协议" class="headerlink" title="访问资源时省略 URL 中的协议"></a>访问资源时省略 URL 中的协议</h4><p>便于自适应同时支持 http 和 https 的站点：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">&lt;img src=<span class="string">"//remotesite.com/image1.jpg"</span> /&gt;</span><br></pre></td></tr></table></figure>

<h4 id="长短连接与长短轮询"><a href="#长短连接与长短轮询" class="headerlink" title="长短连接与长短轮询"></a>长短连接与长短轮询</h4><p>HTTP 是无状态的，因此 HTTP 连接的说法是不合适的，由于 HTTP 基于 TCP 实现，所以提到连接应该指的是 TCP 连接。HTTP 协议是基于请求 / 响应模式的，因此只要服务端给了响应，本次 HTTP 请求就结束了，没有所谓的连接一说。TCP 连接是一个双向的通道，它是可以保持一段时间不关闭的，因此 TCP 连接才有真正的长连接和短连接这一说。<br>现在用的基本上都是 HTTP/1.1 协议，请求头中 Connection 都是 keep-alive。而且 HTTP 协议文档上也提到了，HTTP/1.1 默认是长连接，也就是默认 Connection 的值就是 keep-alive。<br>需要注意的是，HTTP/2 中则不会处理 <code>Connection: keep-alive</code> 的设置，这是因为在 HTTP/1.1 中虽然 keep-alive 是默认值，但是可以通过设置  <code>keep-live: close</code> 关闭长连接，在 HTTP/2 中默认也是长连接但却不允许在 HTTP 层去关闭，所以在 HTTP/2 的请求头中看不到 <code>Connection: keep-alive</code> 这样的设置，也不会对 <code>keep-live: close</code>  这样的设置作出处理。<br>只有服务端能够针对 Connection 请求头的设置作出处理才算是真正实现了连接保持。由于连接保持是 HTTP1.1 协议的一部分，所以只要实现了 HTTP1.1 协议的服务端都是可以进行连接保持的。<br>连接保持的主要作用是为了进行多个 HTTP 请求的复用，因为 TCP 连接的创建和销毁都是有成本的。<br>长连接并不是永久连接，如果一段时间内（具体的时间长短，是可以在 header 当中进行设置的，也就是所谓的超时时间），这个连接没有 HTTP 请求发出的话，那么这个长连接就会被断掉，否则的话，TCP 连接将会越来越多，直到把服务器的 TCP 连接数量撑爆到上限为止。<br>长轮询和短轮询最大的区别是，短轮询去服务端查询的时候，不管数据有没有变化，服务端立即返回。而长轮询则不是，在长轮询中，服务器如果检测到数据没有变化的话，将会把当前请求挂起一段时间（这个时间也叫作超时时间，一般是几十秒）。在这个时间里，服务器会去检测数据有没有变化，检测到变化就立即返回，否则就一直等到超时为止。<br>不管是长轮询还是短轮询，都不太适用于客户端数量太多的情况，因为每个服务器所能承载的 TCP 连接数是有上限的，这种轮询很容易把连接数顶满。<br>WebSocket 或者 <a href="https://www.ruanyifeng.com/blog/2017/05/server-sent_events.html" target="_blank" rel="external nofollow noopener noreferrer">SSE</a> 是应对客户数并发量较多的更好的选择。SSE 与 WebSocket 对比：<a href="https://www.ibm.com/developerworks/cn/web/wa-http-server-push-with-websocket-sse/index.html" target="_blank" rel="external nofollow noopener noreferrer">使用 WebSocket 和 SSE 实现 HTTP 服务器推送</a>。<br>一个 TCP 连接是否为长连接，是通过设置 HTTP 的 Connection Header 来决定的，而且是需要两边都设置才有效。而一种轮询方式是否为长轮询，是根据服务端的处理方式来决定的，与客户端没有关系。连接的长短是通过协议来规定和实现的。而轮询的长短，是服务器通过编程的方式手动挂起请求来实现的。</p>
<h4 id="HTTP-2-与-HTTP-1-1"><a href="#HTTP-2-与-HTTP-1-1" class="headerlink" title="HTTP/2 与 HTTP/1.1"></a>HTTP/2 与 HTTP/1.1</h4><ul>
<li>一般而言，浏览器只允许同时与同一个服务端建立最多 6 个 TCP 连接，所以通过浏览器查看控制台时往往会看到会有 6 个请求同时进行，这是 HTTP/1.1 的情况，因为无法进行多路复用，所以需要建立多个连接同时请求多个资源，另外对于每一个 TCP 连接来说，由于服务器必须按接受请求的顺序发送响应的规则限制，那么假设浏览器在一个（tcp）连接上发送了两个请求，那么服务器必须等第一个请求响应完毕才能发送第二个响应，会造成请求的阻塞，无法有效利用带宽。</li>
<li>HTTP/2 中引入了流的概念实现多路复用，一个域名只需要一个 TCP 连接完成所有的 HTTP 请求和响应，也不会有多个请求之间的阻塞，极大提高了效率。</li>
<li>HTTP/2 引入的服务端推送特性也允许服务端在客户端发出一个 HTTP 请求（例如 index.html ）后，主动推送可能相关的内容（例如 index.html 里需要引用的 js 和 css 文件）到客户端，减少了客户端发起请求的次数，提高效率。</li>
<li>HTTP/2 的头部压缩，二进制编码等新的特性也能提高传输效率。</li>
<li>虽然 HTTP/2 的实现与 TLS 并无强行关联，但是一般代理服务器（例如 Nginx ）只允许 HTTPS 模式下使用 HTTP/2 ；Go 语言的标准库实现的 HTTP/2 协议默认也要求使用 HTTPS（虽然也可以绕过）。</li>
<li><a href="https://medium.com/@factoryhr/http-2-the-difference-between-http-1-1-benefits-and-how-to-use-it-38094fa0e95b" target="_blank" rel="external nofollow noopener noreferrer">HTTP/2: the difference between HTTP/1.1, benefits and how to use it</a>；<a href="https://www.codercto.com/a/34433.html" target="_blank" rel="external nofollow noopener noreferrer">HTTP/2 协议详解</a>；<a href="https://hpbn.co/http2/#header-compression" target="_blank" rel="external nofollow noopener noreferrer">HTTP/2</a>；<a href="https://www.digitalocean.com/community/tutorials/http-1-1-vs-http-2-what-s-the-difference" target="_blank" rel="external nofollow noopener noreferrer">HTTP/1.1 vs HTTP/2: What’s the Difference?</a></li>
</ul>
<h4 id="Content-Encoding-gzip"><a href="#Content-Encoding-gzip" class="headerlink" title="Content-Encoding: gzip"></a>Content-Encoding: gzip</h4><p>服务端可以将静态文件进行 gzip 压缩后，在响应头中设置 Content-Encoding: gzip ，告知浏览器需通过解压缩来获取 Content-Type: text/html; charset=UTF-8 中指定类型的文件。一般用于加快传输速度。</p>
<h4 id="Token-刷新机制"><a href="#Token-刷新机制" class="headerlink" title="Token 刷新机制"></a>Token 刷新机制</h4><p>Token 由于无法撤销，所以有效期不宜太长，当 Token 到期后，需要获取新的 Token。Token 刷新的几种方式：</p>
<ul>
<li>用户登录后返回一个 Token，Token 有两个属性，过期时间和刷新时间，前端存储 Token，Token 过期后，在刷新时间过期之前使用该 Token 获取新的 Token；</li>
<li>用户登录后返回 Refresh Token 和 Access Token，Refresh Token 有效期更长，Access Token 过期后，使用 Refresh Token 获取新的 Access Token，后端服务校验 Access Token 不需要访问 Auth Server，而通过 Refresh Token 获取 Access Token 时需要访问 Auth Server。</li>
<li>参考：<a href="https://segmentfault.com/a/1190000017304793" target="_blank" rel="external nofollow noopener noreferrer">前后端分离中的无痛刷新 token 机制</a></li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>在 Go 中不要拷贝锁</title>
    <url>/post/6b348626.html</url>
    <content><![CDATA[<h3 id="原文"><a href="#原文" class="headerlink" title="原文"></a>原文</h3><p><a href="https://eli.thegreenplace.net/2018/beware-of-copying-mutexes-in-go/" target="_blank" rel="external nofollow noopener noreferrer">Beware of copying mutexes in Go</a></p><p>假设我们定义了一个包含一个映射表（ map）的结构体，我们想要使用结构体的方法去修改映射表的内容，如下是一个例子：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Container <span class="keyword">struct</span> &#123;</span><br><span class="line">  counters <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c Container)</span> <span class="title">inc</span><span class="params">(name <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">  c.counters[name]++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  c := Container&#123;counters: <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>&#123;<span class="string">"a"</span>: <span class="number">0</span>, <span class="string">"b"</span>: <span class="number">0</span>&#125;&#125;</span><br><span class="line"></span><br><span class="line">  doIncrement := <span class="function"><span class="keyword">func</span><span class="params">(name <span class="keyword">string</span>, n <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">      c.inc(name)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  doIncrement(<span class="string">"a"</span>, <span class="number">100000</span>)</span><br><span class="line"></span><br><span class="line">  fmt.Println(c.counters)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a>



<p>代码中 <code>Container</code> 包含了一个由计数器组成的映射表，使用计数器名称作为索引。<code>Container</code> 的 inc 方法会去增加指定计数器的值（假设指定计数器已经存在）。main 函数中使用 for 循环调用 inc 方法多次。<br>运行这段代码，输出如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">map[a:100000 b:0]</span><br></pre></td></tr></table></figure>

<p>现在我们想在两个 goroutine 中并发调用 inc 方法。由于我们担心竞争情况，我们使用一个互斥锁来保护关键区域:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">"fmt"</span></span><br><span class="line">  <span class="string">"sync"</span></span><br><span class="line">  <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Container <span class="keyword">struct</span> &#123;</span><br><span class="line">  sync.Mutex                       <span class="comment">// &lt;-- Added a mutex</span></span><br><span class="line">  counters <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c Container)</span> <span class="title">inc</span><span class="params">(name <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">  c.Lock()                         <span class="comment">// &lt;-- Added locking of the mutex</span></span><br><span class="line">  <span class="keyword">defer</span> c.Unlock()</span><br><span class="line">  c.counters[name]++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  c := Container&#123;counters: <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>&#123;<span class="string">"a"</span>: <span class="number">0</span>, <span class="string">"b"</span>: <span class="number">0</span>&#125;&#125;</span><br><span class="line"></span><br><span class="line">  doIncrement := <span class="function"><span class="keyword">func</span><span class="params">(name <span class="keyword">string</span>, n <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">      c.inc(name)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">go</span> doIncrement(<span class="string">"a"</span>, <span class="number">100000</span>)</span><br><span class="line">  <span class="keyword">go</span> doIncrement(<span class="string">"a"</span>, <span class="number">100000</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Wait a bit for the goroutines to finish</span></span><br><span class="line">  time.Sleep(<span class="number">300</span> * time.Millisecond)</span><br><span class="line">  fmt.Println(c.counters)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你预期的输出结果会是什么呢？我得到了如下输出：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">fatal error: concurrent <span class="keyword">map</span> writes</span><br><span class="line"></span><br><span class="line">goroutine <span class="number">5</span> [running]:</span><br><span class="line">runtime.throw(<span class="number">0x4b765b</span>, <span class="number">0x15</span>)</span><br><span class="line"></span><br><span class="line">&lt;...&gt; more goroutine stacks</span><br><span class="line">exit status <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>我们已经很小心地使用锁保护共享变量，那到底是哪里出错了？你能看出来如何去修复这个错误吗？提示：只需要一个字符的变动即可。<br>这段代码的问题在于 inc 方法定义在了 Container 上，而不是 _Container，因此每次调用 inc 方法 Container 实例都会被复制一次。换种说法，inc 是一个值接收器而不是指针接收器。因此 inc 的每次调用并不能真正修改最初的 Container 实例。<br>但是，等一下，既然如此，那为什么我们的第一个例子能够正常工作呢？在只有一个 goroutine 的例子中，我们也是按值传递了 c 到 inc 函数，但是它确实起作用了。main 函数确实观察到了 inc 函数对映射表的修改。这是因为映射表比较特殊：它是引用类型，而不是值类型。存在 Container 中的并不是真正的映射表的数据，而是一个指向映射表数据的指针。因此，就算我们创建了一个 Container 的副本，它的 counters 成员仍然保存了相同映射表数据的地址。<br>所以说第一个例子的代码也是错误的。尽管这段代码可以工作，但它显然违反了 Go 社区的<a href="https://golang.org/doc/faq#methods_on_values_or_pointers" target="_blank" rel="external nofollow noopener noreferrer">编程指南</a>：修改对象内容的方法应该定义在类型指针上，而不是类型值上。这里使用映射表给我造成了一个安全上的错觉。作为练习，尝试使用单个 int 类型的计数器替代最初例子中的映射表，然后注意 inc 方法只是修改了计数器的副本，所以在 main 函数中看不到这种修改的效果。<br>Mutex 是值类型（参见 <a href="https://golang.org/src/sync/mutex.go" target="_blank" rel="external nofollow noopener noreferrer">Go 源码</a>中的定义，注释中很清楚地写明了不要拷贝互斥锁），因此拷贝是错误的行为。拷贝只是创建了一个完全不同的新的互斥锁，因此它的互斥功能不再有效。<br>因此，针对上述代码的一个字符的修正就是在定义 inc 方法时在 Container 前添加一个 _ 号：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Container)</span> <span class="title">inc</span><span class="params">(name <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">  c.Lock()</span><br><span class="line">  <span class="keyword">defer</span> c.Unlock()</span><br><span class="line">  c.counters[name]++</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样， 就会将 c 的指针传入 inc 方法，实际上是对调用方持有的内存中同一个 Container 实例的引用。<br>这不是一个少见的错误。实际上， go vet 会对此发出警告：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">$ <span class="keyword">go</span> tool vet method-mutex-value-receiver.<span class="keyword">go</span></span><br><span class="line">method-mutex-value-receiver.<span class="keyword">go</span>:<span class="number">19</span>: inc passes lock by value: main.Container</span><br></pre></td></tr></table></figure>

<p>这种情况经常出现在 HTTP 处理函数中，这些处理函数在不需要开发人员显示使用 go 语句的情况下被并发地调用。我会在随后的博文中详述这一点。<br>我觉得这个问题对于认识 Go 语言中的值接收器和指针接收器的区别有很大的帮助。为了把问题说清楚，下面给出一个和之前代码无关的示例。这个例子用到了 Go 中使用 &amp; 操作符创建指针和使用 %p 格式化输出指针值的功能：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Container <span class="keyword">struct</span> &#123;</span><br><span class="line">  i <span class="keyword">int</span></span><br><span class="line">  s <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c Container)</span> <span class="title">byValMethod</span><span class="params">()</span></span> &#123;</span><br><span class="line">  fmt.Printf(<span class="string">"byValMethod got &amp;c=%p, &amp;(c.s)=%p\n"</span>, &amp;c, &amp;(c.s))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Container)</span> <span class="title">byPtrMethod</span><span class="params">()</span></span> &#123;</span><br><span class="line">  fmt.Printf(<span class="string">"byPtrMethod got &amp;c=%p, &amp;(c.s)=%p\n"</span>, c, &amp;(c.s))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> c Container</span><br><span class="line">  fmt.Printf(<span class="string">"in main &amp;c=%p, &amp;(c.s)=%p\n"</span>, &amp;c, &amp;(c.s))</span><br><span class="line"></span><br><span class="line">  c.byValMethod()</span><br><span class="line">  c.byPtrMethod()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果如下（这是在我的电脑上的输出，和你电脑上的变量地址可能不一样，但是地址之间的关系是一样的）：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">in main &amp;c=<span class="number">0xc00000a060</span>, &amp;(c.s)=<span class="number">0xc00000a068</span></span><br><span class="line">byValMethod got &amp;c=<span class="number">0xc00000a080</span>, &amp;(c.s)=<span class="number">0xc00000a088</span></span><br><span class="line">byPtrMethod got &amp;c=<span class="number">0xc00000a060</span>, &amp;(c.s)=<span class="number">0xc00000a068</span></span><br></pre></td></tr></table></figure>

<p>main 函数创建了一个 Container 实例并打印出了实例的地址及实例成员变量 s 的地址，接着调用了实例的两个方法。<br>byValMethod 方法有一个值接收器，它打印出的地址和 main 函数中打印出的不一样因为接收到的是 c 的一个副本。另一方面，byPtrMethod 方法有一个指针接收器并且它观察到的地址和 main 函数中的一致，因为它获取到的是最初的 c，而不是一个副本。</p>
<h3 id="译者补充"><a href="#译者补充" class="headerlink" title="译者补充"></a>译者补充</h3><h4 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h4><p>Go 语言中还有一种锁：读写锁（RWMutex），读写锁也是值类型，也不能拷贝。</p>
]]></content>
      <categories>
        <category>译文</category>
      </categories>
      <tags>
        <tag>译文</tag>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>常用 Kubernetes Operator</title>
    <url>/post/502c3f78.html</url>
    <content><![CDATA[<h4 id="Keycloak-Operator"><a href="#Keycloak-Operator" class="headerlink" title="Keycloak Operator"></a>Keycloak Operator</h4><p>支持多种认证和授权方式的统一认证中心方案 Keycloak 的官方 Operator: <a href="https://github.com/keycloak/keycloak-operator" target="_blank" rel="external nofollow noopener noreferrer">https://github.com/keycloak/keycloak-operator</a>。</p>]]></content>
      <categories>
        <category>Kubernetes</category>
      </categories>
      <tags>
        <tag>Kubernetes</tag>
        <tag>Operator</tag>
      </tags>
  </entry>
  <entry>
    <title>敏捷笔记</title>
    <url>/post/d753fa14.html</url>
    <content><![CDATA[<h4 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h4><p>Epic【史诗级故事】，可简单理解为软件的版本好了，不需要太详细的秒速，但是要说清楚这个版本需要哪些大功能。<br>Feature【特性】，你都在【史诗级故事】中说好了要哪些大功能了，那作为它的子级的【特性】自然就是每个你需要的大功能的描述，但是由于一个大功能的实现有许多众所周知或者实际做了才知道的前置的或者后发的条件，所以【特性】的完成一定被项目中所有成员认可是一个较长的过程，所以肯定还需要进一步细化。<br>Story【用户故事/积压工作项】，把特性细化了以后就是这个了，故事之所以叫故事是因为内容读起来就像故事，参考中小学生作文吧，故事的三要素：参与者、行为、结果，（管理员在 XX 界面点击了【XXX】按钮后，界面跳转至【XXXX】界面）仅供参考。可以看出，故事要细致，描述细节，有明确的验收标准，任何人看完都应该知道如何操作，测试人员也可以以此来作为测试用例。<br>Task【任务】，这是只有开发才知道的细节了，上面几个都是无论什么人都能看懂的东西，任务描述的应该是开发中的细节，比如（修改 AAA 类的 BBB 方法，提升执行效率）或者（将 XXX 功能的原有做法改为使用命令模式），只有开发才懂得的细节，由于此类工作也需要耗时，而且耗时可能还不短，这会违背“快速迭代”的基本价值观，所以当一个【故事】涉及到此类的行为时，就可能需要较长时间来迭代，所以应该在【故事】下建立【任务】来说明工作的具体内容。</p><a id="more"></a>
<h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="https://wiki.mbalib.com/wiki/%E6%95%8F%E6%8D%B7%E5%BC%80%E5%8F%91" target="_blank" rel="external nofollow noopener noreferrer">https://wiki.mbalib.com/wiki/%E6%95%8F%E6%8D%B7%E5%BC%80%E5%8F%91</a></p>
]]></content>
      <categories>
        <category>敏捷</category>
      </categories>
      <tags>
        <tag>敏捷</tag>
        <tag>agile</tag>
      </tags>
  </entry>
  <entry>
    <title>树莓派 3B 编译安装 zfs</title>
    <url>/post/6adad945.html</url>
    <content><![CDATA[<ul>
<li>安装依赖</li>
</ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt remove 3.6-trunk-rpi</span><br><span class="line">sudo apt update</span><br><span class="line">sudo apt install build-essential autoconf libtool gawk alien fakeroot</span><br><span class="line">sudo apt install dkms zlib1g-dev uuid-dev libattr1-dev libblkid-dev libselinux-dev libudev-dev libssl-dev parted lsscsi wget ksh</span><br><span class="line">sudo apt install python3-dev python3-setuptools python3-cffi</span><br></pre></td></tr></table></figure><a id="more"></a>


<ul>
<li>安装内核头文件</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt upgrade raspberrypi-kernel raspberrypi-kernel-headers</span><br></pre></td></tr></table></figure>

<ul>
<li>从<a href="https://github.com/zfsonlinux/zfs/releases" target="_blank" rel="external nofollow noopener noreferrer">这里</a>下载源代码并解压</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://github.com/zfsonlinux/zfs/releases/download/zfs-0.8.1/zfs-0.8.1.tar.gz &amp;&amp; tar zxf zfs-0.8.1.tar.gz</span><br></pre></td></tr></table></figure>

<ul>
<li>编译安装</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ../zfs-0.8.1</span><br><span class="line">autoreconf --install --force</span><br><span class="line">./configure --with-config=srpm</span><br><span class="line">sed -E <span class="string">'s/(^RPMBUILD = rpmbuild.*)/\1 --target=armhf/'</span> -i Makefile</span><br><span class="line">make pkg-utils deb-dkms</span><br><span class="line"><span class="keyword">for</span> deb <span class="keyword">in</span> *.deb; <span class="keyword">do</span> sudo dpkg -i <span class="string">"<span class="variable">$deb</span>"</span>; <span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<ul>
<li>重启系统</li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>存储</tag>
        <tag>树莓派</tag>
      </tags>
  </entry>
  <entry>
    <title>正则表达式</title>
    <url>/post/2f57a694.html</url>
    <content><![CDATA[<h4 id="匹配除空格以外的字符"><a href="#匹配除空格以外的字符" class="headerlink" title="匹配除空格以外的字符"></a>匹配除空格以外的字符</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">\S+ 或 [^\s]+</span><br></pre></td></tr></table></figure><h4 id><a href="#" class="headerlink" title="(?!), (?:), (?=)"></a>(?!), (?:), (?=)</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(?:pattern)</span><br><span class="line">非获取匹配，匹配pattern但不获取匹配结果，不进行存储供以后使用。这在使用或字符“(|)”来组合一个模式的各个部分是很有用。例如“industr(?:y|ies)”就是一个比“industry|industries”更简略的表达式。</span><br><span class="line">(?=pattern)</span><br><span class="line">非获取匹配，正向肯定预查，在任何匹配pattern的字符串开始处匹配查找字符串，该匹配不需要获取供以后使用。例如，“Windows(?=95|98|NT|2000)”能匹配“Windows2000”中的“Windows”，但不能匹配“Windows3.1”中的“Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。</span><br><span class="line">(?!pattern)</span><br><span class="line">非获取匹配，正向否定预查，在任何不匹配pattern的字符串开始处匹配查找字符串，该匹配不需要获取供以后使用。例如“Windows(?!95|98|NT|2000)”能匹配“Windows3.1”中的“Windows”，但不能匹配“Windows2000”中的“Windows”。</span><br><span class="line">(?&lt;=pattern)</span><br><span class="line">非获取匹配，反向肯定预查，与正向肯定预查类似，只是方向相反。例如，“(?&lt;=95|98|NT|2000)Windows”能匹配“2000Windows”中的“Windows”，但不能匹配“3.1Windows”中的“Windows”。</span><br><span class="line">(?&lt;!pattern)</span><br><span class="line">非获取匹配，反向否定预查，与正向否定预查类似，只是方向相反。例如“(?&lt;!95|98|NT|2000)Windows”能匹配“3.1Windows”中的“Windows”，但不能匹配“2000Windows”中的“Windows”。这个地方不正确，有问题</span><br><span class="line">(?P&lt;profile&gt;pattern)</span><br><span class="line">?P&lt;value&gt;的意思就是命名一个名字为value的组，匹配规则符合后面的 pattern</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>正则</category>
      </categories>
      <tags>
        <tag>正则</tag>
      </tags>
  </entry>
  <entry>
    <title>物联网导论-读书笔记</title>
    <url>/post/3b6b3aeb.html</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th align="center">Date</th>
<th align="center">Log</th>
</tr>
</thead>
<tbody><tr>
<td align="center">05/05/2017</td>
<td align="center">初始版本，增加第一章、第二章笔记。</td>
</tr>
</tbody></table><p>本文汇总了在阅读&lt;物联网导论&gt;过程中所做的总结，记录，以及补充内容。</p><h3 id="物联网概述"><a href="#物联网概述" class="headerlink" title="物联网概述"></a>物联网概述</h3><ul>
<li>存在的，就是上网的。</li>
<li>物联网是一个基于互联网、传统电信网等信息承载体，让所有能够被独立寻址的普通物理对象实现互联互通的网络。它具有普通对象设备化、自治终端互联化和普通服务智能化三个重要特征。</li>
<li>根据信息生成、传输、处理和应用的原则，可以把物联网分为四层：感知识别层、网络构建层、管理服务层和综合应用层。</li>
<li>从网络的角度来观察，物联网具有以下几个特点：在网络终端层面呈现联网终端规模化、感知识别普适化的特点，在通信层面呈现异构设备互联化的特点，在数据层面呈现管理处理智能化的特点，在应用层面呈现应用服务链条化的特点。</li>
<li>互联互通的对象从人延展到物体，不仅人与人要交流，物和物也要互通。在物联网时代，能主动认知和控制自己之外的对象的，可以称作是具有主动智能的，而有能力使得自身被智能主体所认知和控制的，可以称作是拥有被动智能的。被动智能也是智能。</li>
<li>互联互通方式的扩展，也就是网络通信模式的扩展，亦即更深层次的广泛与全面。</li>
<li>环境监测应用最为成熟，智能物流当前最为热门，智能交通正在起步，智能建筑还是未来的事。</li>
</ul><a id="more"></a>


<h3 id="感知识别"><a href="#感知识别" class="headerlink" title="感知识别"></a>感知识别</h3><h4 id="自动识别与-RFID"><a href="#自动识别与-RFID" class="headerlink" title="自动识别与 RFID"></a>自动识别与 RFID</h4><ul>
<li>光符号识别技术：初衷是让机器按照人类的方式来阅读和识别，结果是促进了人工智能和图像处理等领域的发展。</li>
<li>语音识别技术：语音控制、语音输入、语音导航等。</li>
<li>生物量识别技术：虹膜识别技术-认证精确度高，多用于机场口岸； 指纹识别技术-犯罪记录追踪等。</li>
<li>IC 卡技术：一种数据存储系统，通过内置 EEPROM 来存储数据，必要时可加入计算能力。公交卡（非接触式），电话卡（接触式）。</li>
<li>条形码技术：一维条形码-例如 ISBN 图书码；二维条形码-现已常用。</li>
<li>射频识别技术（RFID）：利用射频信号通过空间耦合（交变磁场或电磁场）实现无接触信息传递并通过所传递的信息达到自动识别目的。</li>
<li>RFID 一般由传送器、接收器、微处理器、天线和标签五个部分组成； 传送器、接收器和微处理器通常都被封装在一起称为阅读器。</li>
</ul>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>读书</tag>
        <tag>笔记</tag>
        <tag>物联网</tag>
      </tags>
  </entry>
  <entry>
    <title>系统测试-学习笔记</title>
    <url>/post/785a571c.html</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th align="center">Date</th>
<th align="center">Log</th>
</tr>
</thead>
<tbody><tr>
<td align="center">05/04/2017</td>
<td align="center">初始版本，增加测试基础知识。</td>
</tr>
</tbody></table><p>本文汇总了在学习视频课程&lt;系统测试&gt;过程中所做的总结，记录。</p><h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><ul>
<li>测试的概念：整个研发过程中对文档、流程、产品等进行确认和验证的一系列活动。</li>
<li>证明软件不能工作。</li>
<li>破坏性的工作。</li>
<li>目标：发现缺陷，度量质量，预防问题。</li>
<li>技术能力：测试、编程、网络、数据库。</li>
<li>业务知识：行业标准、规范。</li>
<li>沟通能力：开发、产品、客户。</li>
</ul><a id="more"></a>


<h4 id="软件研发模型"><a href="#软件研发模型" class="headerlink" title="软件研发模型"></a>软件研发模型</h4><ul>
<li>软件生命周期：从软件构思到发行或丢弃的过程。</li>
<li>大爆炸模型：没有组织、没有流程、没有文档，现已少用。</li>
<li>瀑布模型：每个过程顺序衔接，一次性通过，有严格的进入和退出条件，有大量的文档，不能后退，开发周期较长，适用于需求明确且很少变更的项目。</li>
<li>增量模型：采用随时间进展而交错的线性序列，每个序列产生一个可发布的增量、每个增量产生一个可操作的产品、第一个增量是核心产品；开始时不用投入大量资源，但需要开放式的开发体系架构，管控风险较大；适用于需求经常变更的场景。</li>
<li>螺旋模型：每一圈都经过计划、风险分析、实施、评估过程；由文档和风险驱动，有利于提高大型项目开发的质量和效率；建设周期长、风险大；适用于需求经常变化的大型复杂系统。</li>
<li>快速原型模型：快速构建原型，便于与用户沟通进一步细化需求，在新获取需求基础上进行系统开发；可避免需求模糊带来的风险；快速开发以及频繁修改可能造成开发质量降低；适用于用户需求不明的场景。</li>
<li>双 V 模型：开发与测试同步进行，开发保证设计被实现，测试验证是否正确；测试接入早，有利于保证产品质量；对于测试开发技术要求比较高；适用于需求明确的场景。</li>
<li>敏捷模型：将大的项目分为多个相互联系，但也可以独立运行的小项目，并分别完成，在此过程中软件一直处于可用状态；最重要的是尽早并持续交付可用的产品；对于工程人员个人业务素质要求较高；轻量、高效、低风险，适用于中小型开发团队；变化的模型，按需和其它模型结合。</li>
</ul>
<h4 id="软件缺陷"><a href="#软件缺陷" class="headerlink" title="软件缺陷"></a>软件缺陷</h4><ul>
<li>概念：破坏软件正常运行的问题。</li>
<li>术语：故障-fault；缺点-defect；失败-failure；事件-incident；偏差-variance；改进-improvement；缺陷-bug…</li>
<li>缺陷修复成本随开发阶段推进呈数量级增长。</li>
<li>引入原因：软件的复杂性、沟通缺失、设计与开发与测试理解偏差、程序设计错误、项目进度压力、需求变化、文档贫乏…</li>
</ul>
<h4 id="测试分类"><a href="#测试分类" class="headerlink" title="测试分类"></a>测试分类</h4><ul>
<li>测试类型：功能-用的对、性能-用的快、安全-用的放心、可靠-随便怎么用、可用-用的爽、兼容-到处可用…</li>
<li>测试阶段：单元测试-对代码函数的测试，一般由开发人员完成；集成测试-接口或模块或子系统之间的对接；系统测试-产品完成可能包括软硬件；验收测试-内测（α 测试），公测（β 测试），生产环境测试，可能是在开发方（模拟用户）测试，也可能在客户方测试。</li>
<li>测试过程：分析-依据需求分析；设计-测试方案、用例；实现-用例的开发；执行。</li>
<li>测试技术：自动化；手工。</li>
<li>测试手段：静态-不执行程序，审查代码，文档；动态-执行程序。</li>
<li>测试方法：黑盒-系统测试大量采用；灰盒-集成测试采用，有时偏白，有时偏黑；白盒-单元测试采用。</li>
</ul>
<h3 id="测试的实施"><a href="#测试的实施" class="headerlink" title="测试的实施"></a>测试的实施</h3><h4 id="测试十大原则"><a href="#测试十大原则" class="headerlink" title="测试十大原则"></a>测试十大原则</h4><ul>
<li>测试是一个持续进行的过程，而不是一个阶段</li>
<li>测试必须被计划、控制，并且被提供时间和资源</li>
<li>测试应当有重点</li>
<li>测试不是为了证程序的正确性，而是为了证明程序不能工作</li>
<li>测试是不可能穷尽的，当测试出口条件满足时就可以停止测试</li>
<li>测试是开发的朋友，不是开发的敌人</li>
<li>测试人员应当站在公正的立场上进行测试，如实的记录和报告缺陷</li>
<li>测试自动化能解决一部分问题，但不是全部</li>
<li>测试不能仅仅包括功能性的验证，还应当包含性能、可靠性、可维护性、安全性等方面的验证</li>
<li>并非所有的软件缺陷都需要修复（时间、修复之后引入更多问题）</li>
</ul>
<h4 id="测试十大误区"><a href="#测试十大误区" class="headerlink" title="测试十大误区"></a>测试十大误区</h4><ul>
<li>调试（开发人员排故）和测试（测试人员发现错误）是一样的</li>
<li>测试组应当为保证质量负责</li>
<li>过分依赖 Beta 测试</li>
<li>把测试作为新员工的一个过渡工作</li>
<li>把不合格的开发人员安排做测试</li>
<li>关注于测试的执行而忽略测试的设计：分析和设计是很难的，是重点</li>
<li>测试自动化是万能的</li>
<li>测试是可以穷尽的</li>
<li>测试是为了证明软件的正确性</li>
<li>测试是鼓噪乏味，缺乏创造力的工作</li>
</ul>
<h4 id="测试十大最佳实践"><a href="#测试十大最佳实践" class="headerlink" title="测试十大最佳实践"></a>测试十大最佳实践</h4><ul>
<li>尽早频繁地进行测试是降低项目成本，提高质量的一个好的实践</li>
<li>尽早的产生一个综合的主测试计划</li>
<li>对质量要求较高的产品或大型复杂的产品成立独立的测试组</li>
<li>在每个开发阶段，使用测试和评价的结果作为是否可以通过的标准</li>
<li>开发和维护一个测试需求和目标的风险优先级列表</li>
<li>把测试产出物作为产品的一部分等同管理起来，使用相同的评价标准和过程</li>
<li>提供集成化的测试工具和测试基础支持</li>
<li>加强测试度量工作和缺陷分析工作，不断的改进测试</li>
<li>加强测试的培训并且为测试人员提供技能发展的通道</li>
<li>加强沟通，让项目组内所有的人员都了解测试的重要性和测试工作</li>
</ul>
<p>参考资料：  <a href="http://study.163.com/course/courseMain.htm?courseId=1003097001" target="_blank" rel="external nofollow noopener noreferrer">系统测试-测试基础，类型，用例设计方法</a></p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>系统测试</tag>
      </tags>
  </entry>
  <entry>
    <title>认证与鉴权</title>
    <url>/post/df65a2b0.html</url>
    <content><![CDATA[<h4 id="IAM"><a href="#IAM" class="headerlink" title="IAM"></a>IAM</h4><p>可帮助理解 IAM 的博客：<a href="https://blog.gruntwork.io/a-comprehensive-guide-to-authenticating-to-aws-on-the-command-line-63656a686799" target="_blank" rel="external nofollow noopener noreferrer">https://blog.gruntwork.io/a-comprehensive-guide-to-authenticating-to-aws-on-the-command-line-63656a686799</a></p><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4>]]></content>
      <categories>
        <category>认证与鉴权</category>
      </categories>
      <tags>
        <tag>认证</tag>
        <tag>鉴权</tag>
      </tags>
  </entry>
  <entry>
    <title>统一认证中心方案调研</title>
    <url>/post/c851306f.html</url>
    <content><![CDATA[<h4 id="为什么需要认证中心"><a href="#为什么需要认证中心" class="headerlink" title="为什么需要认证中心"></a>为什么需要认证中心</h4><p>认证（Authentication）和授权（Athorization）是企业级服务的基本功能，企业级应用的开发必须考虑到如何使提供的产品与用户已有的认证和授权体系结合起来，更进一步能够基于该体系提供开发接口给其它应用调用。如下图所示，不同的用户可能已经有不同的认证体系，有的用户可能用的是<br>LDAP，这是种比较老的认证方式，SAML 新一些，最新的是<br>OpenID，这些不同的认证后端都应当可以接入到统一认证中心，从而能够更好地管理用户和进行授权。</p><a id="more"></a>
<p><img src="https://cdn.nlark.com/yuque/0/2019/png/182657/1568099807740-b6f23b9f-79f7-4f1e-8c5b-e7e6dcc812c7.png#align=left&display=inline&height=121&name=image.png&originHeight=121&originWidth=531&size=9511&status=done&style=none&width=531" alt="image.png"></p>
<h4 id="OpenID"><a href="#OpenID" class="headerlink" title="OpenID"></a>OpenID</h4><p>如上图所示，不论用户已有的认证体系是基于什么协议的，通过认证中心我们将其统一转换为 OpenID 协议从而方便应用服务的开发，协议的转换可以交由 Keystone 和 Keycloak 等开源方案来解决， 而 OpenID 是我们开发环节必须要涉及到的内容，因此需要搞清楚其原理。<br>OpenID 是 OAuth 2.0 协议的扩展，主要增强了认证功能，因此认识 OpenID 需要从 OAuth 2.0 开始。OAuth 2.0 协议的应用实际上已经相当广泛，现在很多网站都允许使用微信扫码登录，这个登录过程其实就是 OAuth 2.0 协议的一种实现。下面以<a href="https://www.ituring.com.cn" target="_blank" rel="external nofollow noopener noreferrer">图灵社区</a>使用微信账号登录为例说明整个过程：</p>
<ol>
<li>第一步：打开图灵社区登录页面<a href="https://account.ituring.com.cn/log-in" target="_blank" rel="external nofollow noopener noreferrer">https://account.ituring.com.cn/log-in</a>，点击微信登录图标</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2019/png/182657/1568101991767-538e6965-086f-4f6a-bc9e-ddaad3dd6acc.png#align=left&display=inline&height=301&name=image.png&originHeight=416&originWidth=466&size=22980&status=done&style=none&width=337" alt="image.png"></p>
<ol start="2">
<li>第二步：页面跳转至微信认证中心</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https:&#x2F;&#x2F;open.weixin.qq.com&#x2F;connect&#x2F;qrconnect?appid&#x3D;wx3a6700225b70af1f&amp;redirect_uri&#x3D;https%3A%2F%2Faccount.ituring.com.cn%2Fsignin-wechat&amp;response_type&#x3D;code&amp;scope&#x3D;snsapi_login&amp;state&#x3D;7nh23BdGirIHwjyH79bzV6YjF-55Vn7AzzZIjFZZnKrFxCmAsisTRfSCD7ikv_PMx7uFjsdQPUA8A94MzuZxPOAAvqd1P-0-oo2HGw0yatvKc4hZFU0-ZpEBHt2gqkXqXHAI-0wpyATNbXv14mDzcJSPR-OST90-XwoHpwD0fCXlM3sGdzYHHHPb74bW4dMHSeOThBkhpJvD6oE_k0TFAwQd4cIFV9-gj5tYRelAawc</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.nlark.com/yuque/0/2019/png/182657/1568102224149-f1424311-b431-4989-b589-b89f2fe08d2c.png#align=left&display=inline&height=337&name=image.png&originHeight=422&originWidth=347&size=54611&status=done&style=none&width=277" alt="image.png"></p>
<ol start="3">
<li>第三步：用户微信扫码进行授权确认</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2019/png/182657/1568102587868-68ff5b22-2254-47f9-86a7-109ad9a01934.png#align=left&display=inline&height=377&name=%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20190910155905.png&originHeight=1508&originWidth=1077&size=105137&status=done&style=none&width=269" alt="微信图片_20190910155905.png"></p>
<ol start="4">
<li>第四步: 登录成功，返回图灵社区主页。</li>
</ol>
<p>这里的四步是我们能够直观看到的步骤，实际上背后的交互逻辑如下：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2019/png/182657/1568106057222-f82dd3f8-d2ac-427a-ab9f-05d3fd651fe1.png#align=left&display=inline&height=514&name=auth-center-02.png&originHeight=514&originWidth=733&size=66359&status=done&style=none&width=733" alt="auth-center-02.png"></p>
<p>交互过程中涉及到的 OAuth 术语有：</p>
<ul>
<li>Resource owner:： 用户</li>
<li>Client：需要授权的应用，这里指图灵社区</li>
<li>Authorization server：认证中心，这里指微信开发中心</li>
<li>Resource server： 拥有 Client 所需资源的服务端，这里指存储有用户基本信息的微信 API 服务端</li>
<li>Access token：Client 与 Resource Server 交互时的凭证</li>
<li>Scope： 通常指一个可用 api 资源的集合，这里的 scope 值为 snsapi_login 意味着 client 请求的这个集合只包含登录用的基本操作 API ，如查询用户基本信息，而不能去操作用户，如更改用户名</li>
<li>Consent： 同意，这里指用户同意授权图灵社区获取自己的基本信息</li>
</ul>
<p>更具体的交互过程参考：</p>
<ul>
<li><a href="https://mp.weixin.qq.com/wiki?action=doc&id=mp1421140842" target="_blank" rel="external nofollow noopener noreferrer">微信官方文档</a></li>
<li><a href="https://www.cnblogs.com/0201zcr/p/5131602.html" target="_blank" rel="external nofollow noopener noreferrer">cnblog-微信公众平台开发 —— 微信授权登录（OAuth2.0）</a></li>
</ul>
<h4 id="Keystone-与-Keycloak"><a href="#Keystone-与-Keycloak" class="headerlink" title="Keystone 与 Keycloak"></a>Keystone 与 Keycloak</h4><p>Keystone 是 OpenStack 社区的统一认证项目，主要是作为 OpenStack 多租户管理的基础组件 ，由于 OpenStack 所有项目的设计都具有松耦合的特点， Keystone 项目完全可以单独拿出来使用，另外 Keystone 也充当了 OpenStack 项目的服务注册中心。<br>Keycloak 是 RedHat 维护的统一认证项目，是其商业产品  RH-SSO 的上游项目。<br>下面对两个项目做对比说明。</p>
<ul>
<li>基本信息</li>
</ul>
<p>下表显示的基本信息为 2019 年 09 月 15 日的情况：</p>
<p>| 比较项 | <strong>Keystone</strong> | <strong>Keycloak</strong><br>|<br>| :—: | :—: | :—: |<br>| 开发语言 | Python | Java |<br>| 开源 | 是 | 是，有商业版 |<br>| 维护方 | OpenStack 社区 | RedHat 及社区 |<br>| 贡献者数量 | 433 | 328 |<br>| 提交数 | 14250 | 11665 |<br>| 最近一年的提交数 | <img src="https://cdn.nlark.com/yuque/0/2019/png/182657/1568554312502-222a3c04-cfb8-44a0-b25d-428c7c56684e.png#align=left&display=inline&height=132&name=image.png&originHeight=132&originWidth=721&size=5838&status=done&width=721" alt="image.png"> | <img src="https://cdn.nlark.com/yuque/0/2019/png/182657/1568554290207-8a67772f-52fc-4d4b-9778-7a934ed22ac6.png#align=left&display=inline&height=140&name=image.png&originHeight=140&originWidth=726&size=5728&status=done&width=726" alt="image.png"> |<br>| LDAP 集成 | 支持 | 支持 |<br>| 支持的数据库 | MySQL | h2，MySQL，Postgres |<br>| UI | 无独立 UI，界面集成在 Horizon 中 | 有独立 UI，可以定制主题以适应需要 |<br>| SDK<br>| 不区分 Admin 和 普通用户 SDK ，<a href="https://github.com/openstack/js-openstack-lib" target="_blank" rel="external nofollow noopener noreferrer">js SDK  </a>有但不完善，<a href="https://github.com/openstack/python-keystoneclient" target="_blank" rel="external nofollow noopener noreferrer"> Python SDK </a>最完善，<a href="https://github.com/gophercloud/gophercloud" target="_blank" rel="external nofollow noopener noreferrer">Go SDK </a>相对完善。 | 区分 Admin 和 普通用户 SDK ，Admin SDK 提供了管理用户、角色和应用认证等的功能，普用户 SDK 主要实现认证和授权功能， Admin SDK Java 版本最完善， Node 版次之， <a href="https://github.com/Nerzal/gocloak" target="_blank" rel="external nofollow noopener noreferrer">Go</a> 版为非官方维护，较为完善。普通用户 SDK 同样是 Java 最为完善，其次是 JavaScript 、Node、Python 等，由于其遵循标准的 OpenID 认证流程，故各种语言已有的 OpenID Client 都可以直接使用。<br>|<br>| Rest API | <a href="https://docs.openstack.org/api-ref/identity/v3/" target="_blank" rel="external nofollow noopener noreferrer">v3 </a>版本文档：<a href="https://docs.openstack.org/api-ref/identity/v3/" target="_blank" rel="external nofollow noopener noreferrer">https://docs.openstack.org/api-ref/identity/v3/</a> | 7.0 版本的 <a href="https://www.keycloak.org/docs-api/7.0/rest-api/index.html" target="_blank" rel="external nofollow noopener noreferrer">Admin API</a> 文档<br>：<a href="https://www.keycloak.org/docs-api/7.0/rest-api/index.html" target="_blank" rel="external nofollow noopener noreferrer">https://www.keycloak.org/docs-api/7.0/rest-api/index.html</a> |<br>| 基于 Kubernetes 部署 | 官方有使用 <a href="https://github.com/openstack/openstack-helm" target="_blank" rel="external nofollow noopener noreferrer">Helm charts </a>部署整个 OpenStack 集群的方案，没有专门的使用 Kubernetes 部署 Keystone 的方案，可从   OpenStack helm charts 中抽离，但有一定的工作量。<br>| 有非官方的 <a href="https://github.com/codecentric/helm-charts" target="_blank" rel="external nofollow noopener noreferrer">Helm charts </a>用于部署高可用 Keycloak 集群，经试用满足需求。另外最近官方新开了 <a href="https://github.com/keycloak/keycloak-operator" target="_blank" rel="external nofollow noopener noreferrer">keycloak-operator</a> 仓库，下一步有可能提供基于 CRD 的部署支持。<br>|<br>| 非侵入式认证 | 未见官方支持方案 | 官方提供 <a href="https://github.com/keycloak/keycloak-gatekeeper" target="_blank" rel="external nofollow noopener noreferrer">keycloak-gatekeeper</a> 项目通过 proxy 方式代理前端请求，认证过程由代理完成，业务代码中不需要加入认证处理的内容，方便现有业务的无侵入接入认证。可以结合 Nginx-Ingress 等 API Gateway 使用。<br>|</p>
<ul>
<li>基本概念</li>
</ul>
<p>Keystone 和 Keycloak 有一部分概念是相同的，有一部分是相似的（即涵义基本相同，名称不同），还有一部分是各自独有的，下表对照说明：</p>
<p>| 比较项 | <strong>Keystone</strong> | <strong>Keycloak</strong><br>|<br>| :—: | :—: | :—: |<br>| 用户 | Users：用户必须属于某一个域（domain），用户名非全局唯一，而是域内唯一。 | Users：概念一致。 |<br>| 用户组 | Groups：用户组包含一组用户，用户组必须属于某一个域（domain）。 | Groups：概念一致。 |<br>| 项目 | Projects： OpenStack 中为方便多租户管理的概念。OpenStack 中的虚拟机、虚拟盘等资源必须是属于某一个项目，而项目本身必须是属于某一个域（domain）。<br>| 无 |<br>| 域 | Domains： 域是项目、用户组、用户的容器，Keystone 提供默认域（Default）。对所有用户、项目和用户组的操作都必须提供域信息。域名全局唯一。 | Realms：和 Domains 概念一致，Keycloak 提供默认域（Master）。 |<br>| 角色 | Roles：用于约束用户在某种资源上可以进行的操作，从而实现基于角色的授权（RBAC）。可以对单个用户或某组用户授予操作某个项目或某个域的某种角色。角色名域内唯一。 | Roles： 概念一致。<br>|<br>| Token | Token：用于在向资源服务器请求资源时标示自身身份。根据用途的不同和有效范围可分为多种 token。 | Token：用途一致，实现 token 使用的算法有所区别 |<br>| 服务目录 | Catalog：服务目录，用于集中注册和管理 OpenStack 各种服务，方便松耦合的各项服务之间互相发现和调用。<br>| 无 |<br>| 客户端认证 | Application Credentials：应用凭证，与用户绑定的一种凭证，拥有与用户一致的权限（Role），也可以在创建时指定，专门给 client 端在无需使用用户和密码进行登录时使用。<br>Credentials：与用户名和密码基本等同的凭证，只不过是以 EC2 方式提供的凭证，包括 accekey 和 secret key。 | Clients： 和 OAuth 术语基本一致，只能由管理员用户创建，和普通用户并无绑定关系。使用标准认证协议 OpenID（OAuth 2.0）或者 SAML2 。可以配置成需要用户登录认证或者直接访问。 |<br>| 认证提供方 | Identity Provider：第三方认证提供方，用于替代 Keystone 的认证功能， 例如 Github、微信等，只要是支持的标准协议就可以接入， Keystone 支持 SAML2 和 OpenID<br>。Keystone 既可以接入第三方认证提供方，其本身也可以作为认证提供方供其它服务调用。当作为认证提供方时支持 SAML2 和 OAuth1.0a 对外服务，不支持 OpenID。<br>| Identity Provider：概念一致，但是作为认证提供方时支持 SAML2 和 OpenID。<br>|</p>
<ul>
<li>结论</li>
</ul>
<p>通过对比，可以知道 Keystone 更多是为 OpenStack 专门设计的，虽然也支持标准协议的接入，但这并不是其核心和重点功能，而 Keycloak 一开始就是作为独立的认证中心进行设计的，完全建立在标准认证协议之上，并为此提供了完善的周边工具，因此选择使用 Keycloak 作为基础进行认证中心的实现更合适。</p>
<h4 id="引入-Keycloak-后的架构"><a href="#引入-Keycloak-后的架构" class="headerlink" title="引入 Keycloak 后的架构"></a>引入 Keycloak 后的架构</h4><ul>
<li>引入 Keycloak 之前的架构</li>
</ul>
<p>这是最初的架构，客户端请求经过 API 网关分发到不同的服务，而服务在业务代码中维护用户的认证和授权过程，并且用户的管理包括用户、角色以及用户角色的绑定都由后端服务自己进行。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2019/png/182657/1568620339129-62544ce7-0f22-40be-9ac3-e8479f90b590.png#align=left&display=inline&height=231&name=image.png&originHeight=231&originWidth=476&size=12341&status=done&style=none&width=476" alt="image.png"></p>
<ul>
<li>引入 Keycloak 之后</li>
</ul>
<p>由于我们的服务都是基于 Kubernetes 部署的，我们使用了 ingress-nginx 作为 API 网关， ingress-nginx 可以视为 nginx 为 Kubernetes 定制的版本，功能受到 Kubernetes Ingress 定义的限制，虽然支持使用 OAuth 2.0 对接外部认证服务，但本身并不支持对接外部授权服务。如果使用 ingress-nginx 对接 Keycloak 认证，则总体架构变为下图所示，Ingress 负责进行认证，各个后端服务仍然需要自行去处理授权。<br><img src="https://cdn.nlark.com/yuque/0/2019/png/182657/1568621100341-781dba8e-5d5d-4349-80d4-50449397caff.png#align=left&display=inline&height=341&name=image.png&originHeight=341&originWidth=569&size=16799&status=done&style=none&width=569" alt="image.png"><br>更进一步，使用 keycloak-gatekeeper 进行认证和授权，这样后端服务将完全和认证与授权解耦，只关注业务逻辑，这样解耦的一个好处是，更换认证提供方对于后端服务是无感的，更加灵活。<br><img src="https://cdn.nlark.com/yuque/0/2019/png/182657/1568622013241-ade99ea1-a5b4-4da8-8c98-0c07cefd3044.png#align=left&display=inline&height=281&name=image.png&originHeight=281&originWidth=637&size=13836&status=done&style=none&width=637" alt="image.png"></p>
<ul>
<li>keycloak-gatekeeper</li>
</ul>
<p>keycloak-gatekeeper 是 Keycloak 官方使用 Go 语言开发的请求代理转发组件，集成了认证和授权功能，对服务的请求只有经过了 gatekeeper 的验证才会被转发到下一环节，否则将直接返回未授权响应。一个示例 keycloak-gatekeeper 如下， 对于 /admin 路径下资源的请求必须具有相应的角色才能继续进行。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># is the url for retrieve the OpenID configuration - normally the &lt;server&gt;&#x2F;auth&#x2F;realm&#x2F;&lt;realm_name&gt;</span><br><span class="line">discovery-url: https:&#x2F;&#x2F;keycloak.example.com&#x2F;auth&#x2F;realms&#x2F;&lt;REALM_NAME&gt;</span><br><span class="line"># the client id for the &#39;client&#39; application</span><br><span class="line">client-id: &lt;CLIENT_ID&gt;</span><br><span class="line"># the secret associated to the &#39;client&#39; application</span><br><span class="line">client-secret: &lt;CLIENT_SECRET&gt;</span><br><span class="line"># the interface definition you wish the proxy to listen, all interfaces is specified as &#39;:&lt;port&gt;&#39;, unix sockets as unix:&#x2F;&#x2F;&lt;REL_PATH&gt;|&lt;&#x2F;ABS PATH&gt;</span><br><span class="line">listen: 127.0.0.1:3000</span><br><span class="line"># whether to enable refresh tokens</span><br><span class="line">enable-refresh-tokens: true</span><br><span class="line"># the location of a certificate you wish the proxy to use for TLS support</span><br><span class="line">tls-cert:</span><br><span class="line"># the location of a private key for TLS</span><br><span class="line">tls-private-key:</span><br><span class="line"># the redirection url, essentially the site url, note: &#x2F;oauth&#x2F;callback is added at the end</span><br><span class="line">redirection-url: http:&#x2F;&#x2F;127.0.0.1:3000</span><br><span class="line"># the encryption key used to encode the session state</span><br><span class="line">encryption-key: &lt;ENCRYPTION_KEY&gt;</span><br><span class="line"># the upstream endpoint which we should proxy request</span><br><span class="line">upstream-url: http:&#x2F;&#x2F;127.0.0.1:80</span><br><span class="line"># additional scopes to add to add to the default (openid+email+profile)</span><br><span class="line">scopes:</span><br><span class="line">- vpn-user</span><br><span class="line"># a collection of resource i.e. urls that you wish to protect</span><br><span class="line">resources:</span><br><span class="line">- uri: &#x2F;admin&#x2F;test</span><br><span class="line">  # the methods on this url that should be protected, if missing, we assuming all</span><br><span class="line">  methods:</span><br><span class="line">  - GET</span><br><span class="line">  # a list of roles the user must have in order to access urls under the above</span><br><span class="line">  # If all you want is authentication ONLY, simply remove the roles array - the user must be authenticated but</span><br><span class="line">  # no roles are required</span><br><span class="line">  roles:</span><br><span class="line">  - openvpn:vpn-user</span><br><span class="line">  - openvpn:prod-vpn</span><br><span class="line">  - test</span><br><span class="line">- uri: &#x2F;admin&#x2F;*</span><br><span class="line">  methods:</span><br><span class="line">  - GET</span><br><span class="line">  roles:</span><br><span class="line">  - openvpn:vpn-user</span><br><span class="line">  - openvpn:commons-prod-vpn</span><br></pre></td></tr></table></figure>

<h4 id="扩展阅读资料"><a href="#扩展阅读资料" class="headerlink" title="扩展阅读资料"></a>扩展阅读资料</h4><p><a href="https://www.infoq.cn/article/identity-authentication-of-architecture-in-micro-service" target="_blank" rel="external nofollow noopener noreferrer">深入聊聊微服务架构的身份认证问题</a></p>
]]></content>
      <categories>
        <category>Kubernetes</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>限制单位时间请求次数</title>
    <url>/post/cb6f39ed.html</url>
    <content><![CDATA[<h4 id="Rate-Limit"><a href="#Rate-Limit" class="headerlink" title="Rate Limit"></a>Rate Limit</h4><p>在众多的反向代理服务器中，实现请求次数限制的功能往往称作 rate-limit。   Rate-limit 在公网环境下实际上主要是为了防止 DoS 攻击。Rate-limit 实现了对每个客户端单位时间内请求次数的限制，例如 5 r/s，就是限制每个客户端 1s 之内针对该服务端只能发起 5 个 Http 请求。其原理往往是基于客户端请求中的某些标志性信息（一般是 IP）使用某种限流算法在服务端做出相应处理：如果该客户端的单位时间请求次数超出限制，服务端直接返回状态码为 429 的响应，在 Http 规范中，状态码 429 含义为“请求次数过多”。</p><a id="more"></a>
<h4 id="限流算法"><a href="#限流算法" class="headerlink" title="限流算法"></a>限流算法</h4><p>常用的限流算法有两种：漏桶和令牌桶。<br>漏桶算法：请求先进入到漏桶中，漏桶以一定的速率将请求转给后端处理, 当请求速率过大会直接溢出即返回状态码为 429 的响应。漏桶对以不规则速率进入的请求进行了整形，使其以固定的速率被处理，往往被反向代理服务器用于保护真正的后端服务。<br>令牌桶算法：系统会按固定时间向桶中放入令牌, 如果桶已经满了就不再加了。新请求来临时，会各自拿走一个令牌并被转给后端服务处理, 如果没有令牌可拿就拒绝服务即返回状态码为 429 的响应。<br>假设漏桶和令牌桶均处于最佳状态（漏桶为空，令牌桶已满），当出现突发大流量时，对于漏桶，一部分请求被置于桶中，超出桶容量的请求被拒绝服务，而桶中的请求会以固定速率转给后端处理，因此必然存在排队情况，也就意味着请求可能存在较大的响应延时，这对后端服务来说是友好的，因为大流量经过漏桶已经被整形为平滑的请求序列，对后端压力较小，只不过压力较小可能意味着资源利用不充分；对于令牌桶来说，一部分请求立即获得令牌并且被立即转给服务后端处理，超出桶容量的请求一样被拒绝服务，转给后端服务的请求会被立即处理，因此响应延时会小很多，但是后端服务器会直接受到大流量的冲击，因此对后端服务不是很友好，不过这个问题并不严重，后端服务器的处理能力往往是很强的，只要设定的桶容量适宜，这些流量冲击一般不构成威胁，反而能够更充分的利用服务端资源。<br>除了应对突发流量时的较大差别，漏桶和令牌桶对于一般情况下的请求限速效果是类似的。<br>Nginx 的 Http 限速模块  <a href="http://nginx.org/en/docs/http/ngx_http_limit_req_module.html" target="_blank" rel="external nofollow noopener noreferrer">ngx_http_limit_req_module</a>  使用的是漏桶算法。OpenResty 的限速模块 <a href="https://github.com/openresty/lua-resty-limit-traffic" target="_blank" rel="external nofollow noopener noreferrer">lua-resty-limit-traffic</a> 支持配置使用漏桶或者令牌桶，配置方法可参考<a href="https://developpaper.com/gateway-rate-limit-network-rate-limitation-scheme/" target="_blank" rel="external nofollow noopener noreferrer">这篇文章</a>。</p>
<h4 id="针对-S3-请求的限速方案"><a href="#针对-S3-请求的限速方案" class="headerlink" title="针对 S3 请求的限速方案"></a>针对 S3 请求的限速方案</h4><p>进行限速的第一步是要确定使用什么信息来区分不同的客户端，一般来讲客户端 IP 使用的较为广泛，在 Nginx 和 OpenResty 的限速模块中都有现成的可获取客户端 IP 的变量 ，分别是  $binary_remote_addr 和  ngx.var.binary_remote_addr。当然还有一些其它的信息也可以用以区分客户端从而分别进行限速，例如 Http 请求头中的 Authorization 信息等。这里需要对 S3 进行限速，区分不同客户端使用的是 s3 的 accesskey。 根据 s3 协议<a href="https://docs.aws.amazon.com/zh_cn/AmazonS3/latest/API/sigv4-auth-using-authorization-header.html" target="_blank" rel="external nofollow noopener noreferrer">文档</a>，这个 accesskey 包含在请求信息的 Authorization 请求头中，但需要去提取出来才能用，因此需要对限速的逻辑进行定制以实现从 Authorization 中提取 accesskey 并基于此实现限速。无论对 Nginx 还是 OpenResty 的限速模块进行定制开发都是可以实现这个功能，但最终选择使用另外一个反向代理服务器 Envoy 来进行定制开发，这是因为：Envoy 对扩展开发原生就有非常友好的支持，扩展模块和 Envoy 本身的核心模块是完全解耦的，它们通过 grpc 进行通信，使用 grpc 的另一个好处就是可以使用任何开发语言实现扩展模块而不用关心 Envoy 本身使用的开发语言，因此完全可以采用一种开发人员最熟悉的语言去实现扩展模块逻辑，相比之下， Nginx 或者 OpenResty 的扩展开发只能使用 C 语言或者 Lua 。由于这种扩展模块的解耦，对扩展模块的更改并不需要重新编译打包 Envoy 本身的镜像，而 OpenResty 就必须重新打包整个镜像。因此，最终决定采用 Envoy 实现对 S3 的请求限速，其基本原理如下图所示，所有的客户端请求都要经过 envoy 的处理，针对每个请求 envoy 将其请求头中的 Authorization 信息作为参数向 rate-limiter 发起 rpc 调用以确定该请求是否应该被接受，如果是则将该请求转发给后端 rgw 服务进一步处理，如果否则直接返回状态码为 429 的响应。rate-limiter（采用令牌桶算法） 从 Authorization 信息中提取出 accesskey 并以此为 key 去检索出相应的桶中是否有令牌存在，进而决定是否应该接受该请求。<br>Envoy 的限速服务 gRPC 接口定义：<br><a href="https://github.com/envoyproxy/envoy/blob/master/api/envoy/service/ratelimit/v2/rls.proto" target="_blank" rel="external nofollow noopener noreferrer">https://github.com/envoyproxy/envoy/blob/master/api/envoy/service/ratelimit/v2/rls.proto</a><br>Envoy go 版本控制平面生成的代码：<br><a href="https://github.com/envoyproxy/go-control-plane/blob/master/envoy/service/ratelimit/v2/rls.pb.go" target="_blank" rel="external nofollow noopener noreferrer">https://github.com/envoyproxy/go-control-plane/blob/master/envoy/service/ratelimit/v2/rls.pb.go</a><br><img src="https://cdn.nlark.com/yuque/0/2019/png/182657/1570516385891-e3718bb2-93bc-46d8-ad5e-d5514de1a882.png#align=left&display=inline&height=201&name=rate%20limit%20using%20envoy.png&originHeight=201&originWidth=541&size=11509&status=done&width=541" alt="rate limit using envoy.png"></p>
<h4 id="Rate-limiter"><a href="#Rate-limiter" class="headerlink" title="Rate-limiter"></a>Rate-limiter</h4><p>这里采用 Go 语言实现 Rate-limiter 扩展模块。为每个 accesskey 维护一个令牌桶，令牌发放速率可调节，accesskey 和令牌桶的对应关系通过 map 结构维护。accesskey 和其限速值均存于数据库中，Rate-limiter 定期从数据库中同步限速信息并依次调节令牌桶发放速率，存储数据库中的限速值可通过控制平面 API 进行调整。添加一个全局限速值，存于数据库中，Rate-limiter 服务启动时从数据库中读取，该值可以通过控制平面 API 进行设置，值为 0 时涵义是不进行全局限速，当有携带新的 accesskey 的请求到来时，只记录下该 accesskey 的存在，不自动进行限速处理，除非用户指定要对其限速，非零值则意味着对新接入的 accesskey 自动添加限速规则，创建令牌桶进行限速。<br>初始状态下每个令牌桶中令牌数量为 0 ，随着时间推移，令牌数量逐渐增加，直到令牌桶满，令牌数量保存在内存中，一旦 Rate-limiter 重启则令牌数量重新初始化为 0. 若需要在分布式环境下保存令牌数量，则最好使用 Redis 作为存储后端。</p>
<h4 id="Envoy-限流方案的实现参考"><a href="#Envoy-限流方案的实现参考" class="headerlink" title="Envoy 限流方案的实现参考"></a>Envoy 限流方案的实现参考</h4><ul>
<li>一个较为完整的实现案例：<a href="https://venilnoronha.io/envoy-grpc-and-rate-limiting" target="_blank" rel="external nofollow noopener noreferrer">https://venilnoronha.io/envoy-grpc-and-rate-limiting</a></li>
<li>Lyft 贡献了一个开源项目，同样是实现了一个 gRPC Server 供 Envoy 调用，使用 Redis 存储数据，可对数据库、消息队列等多种后端应用进行限速：<a href="https://github.com/lyft/ratelimit" target="_blank" rel="external nofollow noopener noreferrer">https://github.com/lyft/ratelimit</a></li>
</ul>
<h4 id="不使用-Envoy-的方案"><a href="#不使用-Envoy-的方案" class="headerlink" title="不使用 Envoy 的方案"></a>不使用 Envoy 的方案</h4><p>由于 Go 社区官方提供了一种可以创建简单反向代理服务器的工具包，也可以通过直接编写一个反向代理工具进行简单的 Http 限速，从而避免使用 Envoy 限速要引入 Envoy 本身和一个 rate-limiter grpc server 两个容器的问题，其基本的结构如下：<br><img src="https://cdn.nlark.com/yuque/0/2019/png/182657/1571380553625-7cd700cf-3ff5-488c-96e3-3a15b7e07953.png#align=left&display=inline&height=81&name=image.png&originHeight=81&originWidth=541&size=6154&status=done&width=541" alt="image.png"><br>其中 rate-limiter 不再是一个 grpc server ， 而是一个 http 反向代理服务器，直接接收来自客户端的请求，并通过限流算法决定是否应该接受该请求，对于接受的请求转给后端 rgw 进行处理，对于不接受的请求直接返回状态码为 429 的 Http 响应。<br>rate-limiter 和 rgw 作为两个容器部署于 K8S 同一个 Pod 中，同时还可以实现带宽限制和请求数限制同时使用。</p>
<h4 id="控制平面-API"><a href="#控制平面-API" class="headerlink" title="控制平面 API"></a>控制平面 API</h4><p>这里控制平面也使用 grpc 协议，主要实现添加 accesskey，设置限速值等操作。</p>
]]></content>
      <categories>
        <category>Envoy</category>
      </categories>
      <tags>
        <tag>RateLimit</tag>
        <tag>S3</tag>
      </tags>
  </entry>
</search>
