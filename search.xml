<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Go 实现长轮询：一个服务端超时设置的故事</title>
    <url>/post/46e95013.html</url>
    <content><![CDATA[<p><a name="2PGKt"></a></p><h3 id="原文"><a href="#原文" class="headerlink" title="原文"></a>原文</h3><p><a href="https://lucasroesler.com/2018/07/golang-long-polling-a-tale-of-server-timeouts/" target="_blank" rel="external nofollow noopener noreferrer">Golang long-polling: a tale of server timeouts</a></p><p>我最近花了一周时间来实现 HTTP 长轮询。和软件开发中经常发生的一样，经过漫长的 debug 过程，我最终的修复方案涉及到的代码只有一行。</p><p>在现代 Web 应用开发中实时更新正变得很常见。正好，我最近就在我的一个服务上实现了长轮询。Web 应用获取实时更新有以下几种方式：</p><a id="more"></a>



<ol>
<li>短轮询：Web 应用按照指定的时间间隔不断的发出请求，比如每秒一次。</li>
<li>长轮询：Web 应用重复地进行 HTTP 请求，但是每个请求的存活时间比较长。只有服务端有更新或者请求超时，该请求才会被响应，随后 Web 应用立即发起一个新的请求。</li>
<li>HTTP 流：Web 应用发起一个持久的 HTTP 请求，且请求不会被关闭。一旦服务端有更新就会立即发送部分响应，可以使用类似 ndjson 的形式。</li>
<li>WebSocket：同样地 Web 应用发起一个持久的允许双向通信的请求。</li>
</ol>
<p>有很多原因告诫我们永远不要用第一种方式，而是选择 2-4 中的某一种。在我们的使用场景中，我们想要给已经存在的 REST API 添加只读的获取实时更新的特性，所以长轮询看起来是一种非常自然和简单的实现方式。<br>不幸的是，基本上没有关于长轮询的标准或规范。这意味着一切只能自己动手。我们设计了如下的请求序列：<br><img src="https://cdn.nlark.com/yuque/0/2019/png/182657/1575783155078-b299a29e-2114-4667-ad30-947580207315.png#align=left&display=inline&height=526&name=image.png&originHeight=526&originWidth=579&size=95727&status=done&style=none&width=579" alt="image.png"><br>注意请求超时时我们返回 304（未改变） 状态码而不是 504（服务端超时）。我们使用了请求头 prefer 来发送轮询参数。<br>下面是一个实现了上述轮询序列的简单例子（只是使用了 URL 传递查询参数）：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="string">"context"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="string">"fmt"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="string">"io/ioutil"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="string">"log"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="string">"math/rand"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="string">"net/http"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="string">"net/http/httptest"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="string">"time"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getLongPollDuration</span><span class="params">(r *http.Request)</span> <span class="title">time</span>.<span class="title">Duration</span></span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	timeout, err := time.ParseDuration(r.URL.Query().Get(<span class="string">"wait"</span>))</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">return</span> <span class="number">15</span> * time.Second</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	log.Printf(<span class="string">"found custom timeout: %s"</span>, timeout)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">return</span> timeout</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getResource</span><span class="params">(ctx context.Context)</span> <span class="title">string</span></span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">return</span> <span class="string">"&#123;\"id\": 1, \"updatedAt\": \""</span> + time.Now().Format(time.RFC3339) + <span class="string">"\"&#125;"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">waitForResource</span><span class="params">(ctx context.Context, wait time.Duration)</span> <span class="title">string</span></span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">// randomly wait up to 15 seconds for a "resource changed event"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	r := rand.Intn(<span class="number">15</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	ticker := time.Tick(time.Duration(r) * time.Second)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	waiter := time.Tick(wait)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	log.Printf(<span class="string">"will wait up to %s for the resource"</span>, wait)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">select</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">case</span> &lt;-ctx.Done():</span></pre></td></tr><tr><td class="code"><pre><span class="line">		log.Printf(<span class="string">"Received context cancel"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">return</span> <span class="string">""</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">case</span> ts := &lt;-waiter:</span></pre></td></tr><tr><td class="code"><pre><span class="line">		log.Printf(<span class="string">"Received method timeout: %s"</span>, ts)</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">return</span> <span class="string">""</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">case</span> ts := &lt;-ticker:</span></pre></td></tr><tr><td class="code"><pre><span class="line">		log.Printf(<span class="string">"Received resource update at: %s"</span>, ts)</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">return</span> <span class="string">"&#123;\"id\": 1, \"updatedAt\": \""</span> + ts.Format(time.RFC3339) + <span class="string">"\"&#125;"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">resourceFunc</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	index := r.URL.Query().Get(<span class="string">"index"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">if</span> index != <span class="string">""</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		timeout := getLongPollDuration(r)</span></pre></td></tr><tr><td class="code"><pre><span class="line">		response := waitForResource(r.Context(), timeout)</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">if</span> response == <span class="string">""</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			<span class="comment">// write long poll timeout</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">			w.WriteHeader(http.StatusNotModified)</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		fmt.Fprintf(w, response)</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">return</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	response := getResource(r.Context())</span></pre></td></tr><tr><td class="code"><pre><span class="line">	fmt.Fprintf(w, response)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	ts := httptest.NewServer(http.HandlerFunc(resourceFunc))</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">defer</span> ts.Close()</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">// you should always set these timeouts, otherwise requests</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">// can never timeout</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	ts.Config.ReadTimeout = <span class="number">10</span> * time.Second</span></pre></td></tr><tr><td class="code"><pre><span class="line">	ts.Config.WriteTimeout = <span class="number">10</span> * time.Second</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	res, err := http.Get(ts.URL + <span class="string">"?index=2&amp;wait=15s"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		log.Fatal(err)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	resourceResp, err := ioutil.ReadAll(res.Body)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	res.Body.Close()</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		log.Fatal(err)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	fmt.Printf(<span class="string">"%s\n"</span>, res.Status)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	fmt.Printf(<span class="string">"%s"</span>, resourceResp)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>当使用 Nginx 作为代理暴露这个服务时，问题由于下面一行代码变得麻烦起来：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ts.Config.WriteTimeout = <span class="number">10</span> * time.Second</span></pre></td></tr></table></figure>
<p>在我们最初的 API 的实现中，我们将服务端超时时间设置为了 10 秒，但是在我实现长轮询的时候我把超时时间设置为了 15 秒。这导致了 Nginx 偶发性地返回 502 错误。Nginx 会报出如下错误：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">upstream prematurely closed connection while reading response header from upstream</span></pre></td></tr></table></figure>
<p>最终发现，这个错误消息是准确的并且指向了确切的问题（go 由于超时时间到达关闭了请求，但是我的处理函数仍然在请求关闭后尝试去写入内容），但是在网上搜索的结果并没有提供太多帮助。最后，我断断续续花了一周时间跟踪调试直到确定是配置问题。WriteTimeout 最短也需要设置为与允许的长轮询等待时间一样长，在我们的场景中是 60 秒。<br>但愿其他陷入同样 Nginx 错误的人能够先再次检查他们的服务端超时时间设置。另外，可以查阅<a href="https://blog.cloudflare.com/the-complete-guide-to-golang-net-http-timeouts/" target="_blank" rel="external nofollow noopener noreferrer">这篇文章</a>关于 go 中各种服务端超时的详情。</p>
]]></content>
      <categories>
        <category>译文</category>
      </categories>
      <tags>
        <tag>译文</tag>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>IO 同步、异步及阻塞、非阻塞</title>
    <url>/post/d830a7d8.html</url>
    <content><![CDATA[<p><a name="yo1iZ"></a></p><h4 id="网络-IO"><a href="#网络-IO" class="headerlink" title="网络 IO"></a>网络 IO</h4><p>一般情况下，一次网络 IO 读操作会涉及两个系统对象：(1) 用户进程 (线程) Process；(2) 内核对象 kernel，两个处理阶段：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[1] Waiting for the data to be ready - 等待数据准备好</span></pre></td></tr><tr><td class="code"><pre><span class="line">[2] Copying the data from the kernel to the process - 将数据从内核空间的buffer拷贝到用户空间进程的buffer</span></pre></td></tr></table></figure><a id="more"></a>


<p>阻塞与非阻塞指的是用户进程在发起调用后等待调用结果的状态，同步与异步指的是内核如何处理用户调用并如何将结果返回给用户进程。<br>阻塞与非阻塞关注的是单个进程（线程）的执行状态，同步和异步关注的是程序之间的协作关系（这里主要是用户进程与内核之间）。<br>异步一定不会造成阻塞，因此只有同步时才有阻塞与非阻塞之分。异步的实现一般是通过函数回调来实现，例如 Node.js 的回调函数，参见：<a href="https://www.cnblogs.com/chenyangyao/p/libuv_threadpool.html" target="_blank" rel="external nofollow noopener noreferrer">https://www.cnblogs.com/chenyangyao/p/libuv_threadpool.html</a>。<br>同步与异步的一个区别是，同步函数调用时返回的即为最终数据，异步调用不立即返回数据，可以在执行一些其他任务之后再来查看调用结果或者是在接到事件通知后查看结果。<br>异步 IO 中内核会负责将数据拷贝到用户态（或者使用内存映射），然后通知用户进程使用即可，而同步 IO 需要用户进程自行通过系统调用从内核拷贝数据。<br>同步 IO 中，对同一个描述符的操作必须是有序的。异步 IO 中，可以允许多方同时对同一个描述符发送 IO 请求，或者一次发送多个请求，当然需要有机制去区分这些请求。同步是线性的，异步可以认为是并发的（联想到 HTTP/1.1 和 HTTP/2 在发起大量 HTTP 请求时的不同表现）。<br>从总体的 CPU 效率来看，非阻塞不一定比阻塞更好，如果非阻塞是通过轮询查询数据是否准备好，虽然轮询的过程中可能穿插一些其它工作，但大概率会因为数据没有 ready 而致使 CPU 空转，虽然当前进程获取的时间片多了，但却存在大量的浪费，还不如进程阻塞被挂起，CPU 忙其它的工作。<br>阻塞、非阻塞、多路 IO 复用，都是同步 IO。真正的异步 IO 需要内核的深度参与。换句话说，只有用户线程在操作 IO 的时候根本不去考虑 IO 的执行全部都交给内核去完成，而自己只等待一个完成信号的时候，才是真正的异步 IO。所以，拉一个子线程去轮询、去死循环，或者使用 select、poll、epool，都不是异步。<br>Linux 中不存在完全异步的网络 IO，AIO 由于没有完善的网络 API，目前主要用于文件 IO，例如数据库或分布式存储后端，参见：<a href="https://www.zhihu.com/question/26943558" target="_blank" rel="external nofollow noopener noreferrer">https://www.zhihu.com/question/26943558</a>。<br>虽然 Linux 中主流的网络 IO 模型都是同步 IO ，但是基于多路复用和回调机制的 epoll 也是够用的。<br><a name="DchjO"></a></p>
<h4 id="五类-IO-模型"><a href="#五类-IO-模型" class="headerlink" title="五类 IO 模型"></a>五类 IO 模型</h4><ol>
<li>完全阻塞</li>
</ol>
<p>两个处理阶段均阻塞。一个线程只处理一个连接。<br><img src="https://cdn.nlark.com/yuque/0/2019/png/182657/1575800282968-bce27934-e535-49b8-8c25-2945f7d2ce70.png#align=left&display=inline&height=291&name=image.png&originHeight=291&originWidth=550&size=33321&status=done&style=none&width=550" alt="image.png"></p>
<ol start="2">
<li>非阻塞</li>
</ol>
<p>检查数据是否准备好的阶段即阶段一不阻塞（一般是通过轮询实现，虽然不阻塞，但是一样低效，此时调用方处于忙等待，不被挂起，消耗 CPU 资源），阶段二阻塞。一个线程处理一个连接。<br><img src="https://cdn.nlark.com/yuque/0/2019/png/182657/1575800363874-2e57da37-f74c-4dd4-b75c-6a7db13bb99d.png#align=left&display=inline&height=291&name=image.png&originHeight=291&originWidth=550&size=40341&status=done&style=none&width=550" alt="image.png"></p>
<ol start="3">
<li>IO 多路复用</li>
</ol>
<p>两个阶段均阻塞，但是一个线程可以处理多个连接。虽然阶段一阻塞，但是被阻塞线程可以被挂起，阻塞期间不消耗 CPU 资源。<br><img src="https://cdn.nlark.com/yuque/0/2019/png/182657/1575800468227-7354dc16-071b-459d-a472-33103ef6e76d.png#align=left&display=inline&height=299&name=image.png&originHeight=299&originWidth=550&size=42845&status=done&style=none&width=550" alt="image.png"></p>
<ol start="4">
<li>信号驱动 IO</li>
</ol>
<p>阶段一创建信号即可，不需要监测描述符，不阻塞，阶段二阻塞。<br><img src="https://cdn.nlark.com/yuque/0/2019/png/182657/1575800792427-fc0c4e8f-336a-4c86-a3b0-646238b5c2ca.png#align=left&display=inline&height=313&name=image.png&originHeight=313&originWidth=550&size=44205&status=done&style=none&width=550" alt="image.png"></p>
<ol start="5">
<li>异步 IO</li>
</ol>
<p>两个阶段均不阻塞。<br><img src="https://cdn.nlark.com/yuque/0/2019/png/182657/1575800815863-ec7fe271-d1a0-4e49-a4ba-8e5d5990e151.png#align=left&display=inline&height=327&name=image.png&originHeight=327&originWidth=550&size=41762&status=done&style=none&width=550" alt="image.png"></p>
<ol start="6">
<li>总体比较</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2019/png/182657/1575804118240-0ad5c30f-e984-45fc-b945-a6ca192fefa7.png#align=left&display=inline&height=328&name=image.png&originHeight=328&originWidth=587&size=87015&status=done&style=none&width=587" alt="image.png"><br></p>
<p><a name="wE13p"></a></p>
<h4 id="IO-多路复用"><a href="#IO-多路复用" class="headerlink" title="IO 多路复用"></a>IO 多路复用</h4><p>IO 多路复用是 Linux 网络编程用到的主流的 IO 模型。select，poll，epoll 都是 IO 多路复用的机制。I/O 多路复用通过一种机制，可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。 select，poll，epoll 本质上都是同步 I/O，因为他们都需要在读写事件就绪后由用户进程负责执行读写，且读写过程是阻塞的，而异步 I/O 则无需用户进程负责读写，异步 I/O 的实现会负责把数据从内核拷贝到用户空间。可以查阅三个分别使用 <a href="http://www.cnblogs.com/Anker/archive/2013/08/14/3258674.html" target="_blank" rel="external nofollow noopener noreferrer">select</a>，<a href="http://www.cnblogs.com/Anker/archive/2013/08/15/3261006.html" target="_blank" rel="external nofollow noopener noreferrer">poll</a>，<a href="http://www.cnblogs.com/Anker/archive/2013/08/17/3263780.html" target="_blank" rel="external nofollow noopener noreferrer">epoll</a> 编写的 echo 示例程序帮助理解三种机制的工作过程。<br>select 仅仅知道有 IO 事件发生，却并不知道发生在哪个 socket 上（可能有一个，多个甚至全部），所以只能无差别轮询所有 socket 找出可读或可写的 socket 进行操作。由于是轮询所以是 O(n)  的时间复杂度，socket 越多则轮询时间越长。<br>select 主要有三个问题：①被监控的描述符集合大小被宏控制为 1024 （64 位机是2048），数量太少；②描述符集合需要从用户空间拷贝到内核空间，我们希望不要拷贝；③当被监控的描述符中有 IO 事件发生时，我们希望通知更精细一点，可以直接从通知中获取存在可读事件的描述符集合，而不是需要遍历整个描述符集合。<br>poll 本质上和 select 没有区别，poll 只是解决了 select 的第一个问题即描述符集合大小限制的问题，poll 使用了 pollfd 结构而不是 select 的 fd_set 结构，基于链表来存储描述符，所以没有最大连接数的限制。但是，poll 并没有改变大量描述符被复制于用户态和内核态的地址空间之间，以及个别描述符就绪触发整体描述符集合的遍历的低效问题。poll 随着监控的 socket 集合的增加性能线性下降，poll 不适合用于大并发场景。<br>epoll 可以理解为 event poll，不同于无差别轮询，epoll 会把哪个 socket 发生了怎样的 IO 事件通知我们。所以我们说 epoll 实际上是事件驱动的（每个事件关联上 socket ），此时我们对这些 socket 的操作都是有意义的（复杂度降低到了 O(1)）。Epoll 最大的优点就在于它只管 “活跃” 的连接，而跟连接总数无关，因此在实际的网络环境中，Epoll 的效率就会远远高于 select 和 poll。<br>epoll 解决 select 遗留的问题时主要借助两种思想：引入中间层和变集中处理为分散处理。每次调用 select 时都会进行一次描述符集合从用户空间到内核空间的拷贝，但实际上由于连续两次调用时描述符集合的变化很小，没必要每次都重新准备整个描述符集合，所以在 epoll 中引入了 epoll_ctl 系统调用，将描述符的增删改和高频调用的 epoll_wait 隔离开，在最初通过 epoll_create 创建 epoll 描述符后，会立即将监听 socket 的描述符通过 epoll_ctl 调用加入到描述符集合中，随后只有在需要监控的描述符集合发生变化时才会通过 epoll_ctl 去增删改，而 epoll_wait 调用并不会重新复制描述符集合到内核空间，这样就将 select 中的大块的内存拷贝（集中处理）分散为了低频的小块内存拷贝（分散处理）。同时，对于高频 epoll_wait 调用返回可读就绪的描述符集合时的拷贝问题，epoll 通过内核与用户空间 mmap (内存映射) 同一块内存来解决。mmap 将用户空间的一块地址和内核空间的一块地址同时映射到相同的一块物理内存地址（不管是用户空间还是内核空间都是虚拟地址，最终要通过地址映射映射到物理地址），使得这块物理内存对内核和对用户均可见，减少用户态和内核态之间的数据交换。<br>另外，epoll 通过 epoll_ctl 来对监控的描述符集合来进行增、删、改，那么必须涉及到描述符的快速查找问题，于是，一个低时间复杂度的增、删、改、查的数据结构来组织被监控的描述符集合是必不可少的了。在 linux 2.6.8 之前的内核，epoll 使用散列表来组织描述符集合，于是在创建 epoll 描述符的时候，epoll 需要初始化散列表的大小。于是 epoll_create (int size) 有一个参数 size，以便内核根据 size 的大小来分配散列表的大小。在 linux 2.6.8 以后的内核中，epoll 使用红黑树来组织监控的描述符集合，于是 epoll_create (int size) 的参数 size 实际上已经没有意义了。<br>epoll 巧妙的引入一个中间层解决了大量监控 socket 的无效遍历问题。epoll 在中间层上为每个监控的 socket 准备了一个单独的回调函数 epoll_callback_sk，而对于 select，所有的 socket 都共用一个相同的回调函数。正是这个单独的回调 epoll_callback_sk 使得每个 socket 都能单独处理自身，当自己就绪的时候将自身 socket 挂入 epoll 的 ready_list。同时，epoll 引入了一个睡眠队列 single_epoll_wait_list，分割了两类睡眠等待。process 不再睡眠在所有的 socket 的睡眠队列上，而是睡眠在 epoll 的睡眠队列上等待“任意一个 socket 可读就绪”事件。而中间 wait_entry_sk 则代替 process 睡眠在具体的 socket 上，当 socket 就绪的时候，它就可以处理自身了。<br>关于更多 epoll 边沿触发和水平触发的内容参考：<a href="https://cloud.tencent.com/developer/article/1005481" target="_blank" rel="external nofollow noopener noreferrer">https://cloud.tencent.com/developer/article/1005481</a>。简单理解，边沿触发只有新的数据到达时会被触发（就算有未读完的数据也必须等到新数据到来后触发才能继续读），而水平触发只要有数据可读就会被触发（可能是上次触发后数据未读完）。而相对的，边沿触发由于只会在新的数据到来时才会通知到用户进程，所以 epoll_wait 返回的描述符集合可能会小于使用水平触发，所以有边沿触发效率更高的说法。但假如那些被边沿触发忽略掉的而被水平触发返回的可读描述符仍然是你需要读取的对象，那水平触发可能效率更高，因为你可以更快的读完剩余数据而不是必须等到新数据的到来。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>IO</tag>
      </tags>
  </entry>
  <entry>
    <title>前端知识点滴</title>
    <url>/post/a68ff6.html</url>
    <content><![CDATA[<p><a name="Cmvxj"></a></p><h4 id="swagger-client"><a href="#swagger-client" class="headerlink" title="swagger-client"></a>swagger-client</h4><p>swagger-client 是一个 js 包，可以读取并解析 Swagger 2.0 和 OpenAPI 3 的 json 文档并生成可以对文档中定义的 API 进行调用的 client，简化 api 请求过程。</p><p><a name="ZYwuU"></a></p><h4 id="文件下载"><a href="#文件下载" class="headerlink" title="文件下载"></a>文件下载</h4><p>服务端响应的 Header 中可以设置 <code>Content-Disposition: attachment; filename=test.txt</code>  指定文件名称，一般设置 <code>Content-Type: application/octet-stream</code> 对于小的文本文件也可以设置为 <code>Content-Type: text/plain; charset=utf-8</code>  告诉浏览器可以直接在浏览器窗口打开。 </p><a id="more"></a>



<p><a name="J8dcQ"></a></p>
<h4 id="更新依赖"><a href="#更新依赖" class="headerlink" title="更新依赖"></a>更新依赖</h4><p>npm-check-updates 可以帮助更新 package.json 中的所有依赖，其仍是通过 npm update 实现。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">npm i -g npm-check-updates</span></pre></td></tr><tr><td class="code"><pre><span class="line">npm-check-updates -u</span></pre></td></tr></table></figure>

<p><a name="QukkD"></a></p>
<h4 id="Node-js-下载图片到本地"><a href="#Node-js-下载图片到本地" class="headerlink" title="Node.js 下载图片到本地"></a>Node.js 下载图片到本地</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">downloadPic</span>(<span class="params">src, dest</span>)</span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    request(src).pipe(fs.createWriteStream(dest)).on(<span class="string">'close'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">console</span>.log(<span class="string">'pic saved!'</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 使用方式：</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">downloadPic(imgList[<span class="number">0</span>],<span class="string">'./catpics/1.jpg'</span>);</span></pre></td></tr></table></figure>

<p><a name="0i9jz"></a></p>
<h4 id="Node-js-教程"><a href="#Node-js-教程" class="headerlink" title="Node.js 教程"></a>Node.js 教程</h4><ul>
<li>Node.js TypeScript 15 篇：<a href="https://wanago.io/2019/03/18/node-js-typescript-6-sending-http-requests-understanding-multipart-form-data/" target="_blank" rel="external nofollow noopener noreferrer">https://wanago.io/2019/03/18/node-js-typescript-6-sending-http-requests-understanding-multipart-form-data/</a> 篇介绍了如何在 Node.js 中使用 multipart/form-data 流式上传文件。<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> FormData <span class="keyword">from</span> <span class="string">'form-data'</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; request &#125; <span class="keyword">from</span> <span class="string">'http'</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createReadStream &#125; <span class="keyword">from</span> <span class="string">'fs'</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"> </span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> readStream = createReadStream(<span class="string">'./photo.jpg'</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"> </span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> form = <span class="keyword">new</span> FormData();</span></pre></td></tr><tr><td class="code"><pre><span class="line">form.append(<span class="string">'photo'</span>, readStream);</span></pre></td></tr><tr><td class="code"><pre><span class="line">form.append(<span class="string">'firstName'</span>, <span class="string">'Marcin'</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">form.append(<span class="string">'lastName'</span>, <span class="string">'Wanago'</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"> </span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> req = request(</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    host: <span class="string">'localhost'</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    port: <span class="string">'5000'</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    path: <span class="string">'/upload'</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    method: <span class="string">'POST'</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    headers: form.getHeaders(),</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  response =&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">console</span>.log(response.statusCode); <span class="comment">// 200</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">);</span></pre></td></tr><tr><td class="code"><pre><span class="line"> </span></pre></td></tr><tr><td class="code"><pre><span class="line">form.pipe(req);</span></pre></td></tr></table></figure>

</li>
</ul>
<p><a name="U3Nur"></a></p>
<h4 id="Node-js-流式转存图片"><a href="#Node-js-流式转存图片" class="headerlink" title="Node.js 流式转存图片"></a>Node.js 流式转存图片</h4><p>下载的同时开始上传到七牛云：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> qiniu <span class="keyword">from</span> <span class="string">'qiniu'</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> config: any = <span class="keyword">new</span> qiniu.conf.Config();</span></pre></td></tr><tr><td class="code"><pre><span class="line">config.zone = qiniu.zone.Zone_z2;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> formUploader = <span class="keyword">new</span> qiniu.form_up.FormUploader(config);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> putExtra = <span class="keyword">new</span> qiniu.form_up.PutExtra();</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> uploadFiles(urls: any[], <span class="attr">type</span>: string, token?: string) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">if</span> (!token) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    token = <span class="keyword">await</span> get_token();</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">let</span> keys = &#123;&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> url <span class="keyword">of</span> urls) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">let</span> requestUrl = url.url.trim();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (!requestUrl || !<span class="regexp">/(https?|ftp|file):\/\/\w+\.\w+/</span>.test(requestUrl)) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      keys[url.id] = <span class="literal">null</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">continue</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">const</span> uploadFunc = <span class="keyword">async</span> () =&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">let</span> readableStream = request(requestUrl);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">const</span> key = <span class="string">`images/xxx_<span class="subst">$&#123;<span class="built_in">Date</span>.now()&#125;</span>.jpg`</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">          formUploader.putStream(</span></pre></td></tr><tr><td class="code"><pre><span class="line">            token,</span></pre></td></tr><tr><td class="code"><pre><span class="line">            key,</span></pre></td></tr><tr><td class="code"><pre><span class="line">            readableStream,</span></pre></td></tr><tr><td class="code"><pre><span class="line">            putExtra,</span></pre></td></tr><tr><td class="code"><pre><span class="line">            (respErr, respBody, respInfo) =&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">              <span class="keyword">if</span> (respInfo.statusCode == <span class="number">200</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">return</span> resolve(respBody &amp;&amp; respBody.key);</span></pre></td></tr><tr><td class="code"><pre><span class="line">              &#125; <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">return</span> resolve(<span class="literal">null</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">              &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">          );</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">          <span class="keyword">return</span> resolve(<span class="literal">null</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">const</span> key = <span class="keyword">await</span> uploadFunc();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">this</span>.app.logger.info(<span class="string">'key: '</span>, key);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    keys[url.id] = key;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">return</span> keys;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p><a name="INlLR"></a></p>
<h4 id="从-Html-文本中匹配所有-img-的地址"><a href="#从-Html-文本中匹配所有-img-的地址" class="headerlink" title="从 Html 文本中匹配所有 img 的地址"></a>从 Html 文本中匹配所有 img 的地址</h4><ol>
<li><p>从字符串中匹配出所有的 img 标签</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> str = <span class="string">"this is test string &lt;img src=\"http:baidu.com/test.jpg\" width='50' &gt; 1 and the end &lt;img src=\"所有地址也能匹配.jpg\" /&gt; 33! &lt;img src=\"/uploads/attached/image/20120426/20120426225658_92565.png\" alt=\"\" /&gt;"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> imgReg = <span class="regexp">/&lt;img.*?(?:&gt;|\/&gt;)/gi</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> srcReg = <span class="regexp">/src=[\'\"]?([^\'\"]*)[\'\"]?/i</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = str.match(imgReg);  <span class="comment">// arr 为包含所有img标签的数组</span></span></pre></td></tr></table></figure>
</li>
<li><p>从数组中获取到所有的 src 地址</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"> <span class="keyword">const</span> src = arr[i].match(srcReg);</span></pre></td></tr><tr><td class="code"><pre><span class="line"> <span class="comment">//获取图片地址</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">console</span>.log(<span class="string">'图片地址'</span>+(i+<span class="number">1</span>)+<span class="string">'：'</span>+src[<span class="number">1</span>]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

</li>
</ol>
<p><a name="Jf3qz"></a></p>
<h4 id="cookie-的工作原理"><a href="#cookie-的工作原理" class="headerlink" title="cookie 的工作原理"></a>cookie 的工作原理</h4><ol>
<li><p>需要 cookie 是因为 HTTP 协议本身是无状态的，但是需要用户登录的网站显然是需要记录用户的登录状态给后端使用的，而这个状态应该对同一个域（同源）下的所有请求都有效，所以设计了 cookie，cookie 的设置和发送一般是不需要前端人员介入的（当然前端是可以使用 js 增删改查 cookie 的），设置是浏览器根据 HTTP 响应头中的 set-cookie 信息自动设置，发送也是浏览器根据 HTTP 请求的 URL 自动匹配后添加的。</p>
</li>
<li><p>HTTP 请求，Cookie 的使用过程：server 通过 HTTP Response 中的 “Set-Cookie: header” 把 cookie 发送给 client；client（用户的浏览器） 把 cookie 通过 HTTP Request 中的 “Cookie: header” 发送给 server；每次 HTTP 请求，Cookie 都会被发送。</p>
</li>
<li><p>HTTP 请求发送 Cookies 的条件：本地已经缓存有 cookies；根据请求的 URL 来匹配 cookies 的 domain、path 属性，如果都符合才会发送。</p>
</li>
<li><p>如下为HTTP 响应头中设置 cookie 的示例，Expires 和 Max-Age 同时设置时后者优先级高，如果均未设置则默认有效期为 session，当浏览器关闭时失效，设置 Max-Age 为 0 使 cookie 立即失效即删除cookie，HttpOnly 指明只允许浏览器自动处理，不允许使用 JavaScrit 操作该 cookie，Path 指定对哪些 Path 自动发送该 cookie，默认为 ／ 代表对所有路径有效，设置 domain 为顶级域名时可以在各子域名之间共享 cookie，如 Set-Cookie: name=value; domain=mydomain.com ，则可以在 sub1.mydomain.com／sub2.mydomain.com／subsub.subdomain.mydomain.com 之间共享该 cookie，无论最初的 set-cookie 响应头源自哪个 sub domain：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Set-Cookie: KEYCLOAK_SESSION&#x3D;umstor&#x2F;fe2ff4f2-6b3c-4d03-aaf1-0e79f09568c5&#x2F;9e4adcbc-cfec-4f57-9eb9-4bcc16877a23; Version&#x3D;1; Expires&#x3D;Sat, 30-Nov-2019 14:52:40 GMT; Max-Age&#x3D;36000; Path&#x3D;&#x2F;keycloak&#x2F;realms&#x2F;umstor&#x2F;</span></pre></td></tr><tr><td class="code"><pre><span class="line">Set-Cookie: KEYCLOAK_REMEMBER_ME&#x3D;; Version&#x3D;1; Comment&#x3D;Expiring cookie; Expires&#x3D;Thu, 01-Jan-1970 00:00:10 GMT; Max-Age&#x3D;0; Path&#x3D;&#x2F;keycloak&#x2F;realms&#x2F;umstor&#x2F;; HttpOnly</span></pre></td></tr></table></figure>
</li>
<li><p>session 是服务端记录用户登录状态的机制，只不过需要借助 cookie 机制在浏览器每次发起请求时带上 session id。</p>
</li>
<li><p>使用 cookie 不是必须的，也可以将信息存在 localStorage 并通过 url 或 formdata 传输也是可行的，cookie 只不过因为是在协议层面支持因而使用起来可以更方便一些（自动设置和发送）。</p>
</li>
</ol>
<p><a name="XMjkR"></a></p>
<h4 id="前端的各种存储"><a href="#前端的各种存储" class="headerlink" title="前端的各种存储"></a>前端的各种存储</h4><ol>
<li>cookie 能够携带的数据较少，容量在 4KB 左右，在 HTTP Header 中携带太多数据会对性能有一定影响，因此引入了各种 storage，所以现在的 Web 程序中 cookie 的使用已经少了很多。</li>
<li>localStorage 和 sessionStorage 的大小均在 5M 左右，均有同源策略，仅在客户端保存，不像 cookie 通过协议的支持自动在客户端和服务端之间传输，需要编程人员自行通过 URL 或者请求体（响应体）进行传输并解析。</li>
<li>localStorage 的存储是永久的，除非人为删除否则一直存在；sessionStorage 与存储数据的脚本所在的标签页的有效期是相同的，一旦窗口或者标签页被关闭，那么所有通过 sessionStorage 存储的数据也会被删除。</li>
<li>localStorage: 在同一个浏览器内，同源文档之间共享 localStorage 数据，可以互相读取、覆盖。</li>
<li>sessionStorage: 与 localStorage 一样需要同一浏览器同源文档这一条件。不仅如此，sessionStorage 的作用域还被限定在了窗口中，也就是说，只有同一浏览器、同一窗口的同源文档（如同源的 iframe）才能共享数据。例如你在浏览器中打开了两个相同地址的页面 A、B, 虽然这两个页面的源完全相同，但是他们还是不能共享数据，因为他们是不同窗口中的。但是如果是一个窗口中，有两个同源的 iframe 元素的话，这两个 iframe 的 sessionStorage 是可以互通的</li>
<li>IndexedDB 是相比 localStorage 和 sessionStorage 除了提供了更大的存储空间（一般来说不少于 250MB，甚至没有上限），还提供查找接口，还能建立索引，支持事务。</li>
<li>IndexedDB 操作时不会锁死浏览器，用户依然可以进行其他操作，这与 LocalStorage 形成对比，后者的操作是同步的。异步设计是为了防止大量数据的读写，拖慢网页的表现。</li>
<li>就数据库类型而言，IndexedDB 不属于关系型数据库（不支持 SQL 查询语句），更接近 NoSQL 数据库。</li>
<li>WebSQL 相比 IndexedDB 支持 SQL 查询，但是目前只有谷歌浏览器支持，火狐不支持。</li>
<li>cache storage 是配合 PWA 使用的。</li>
</ol>
<p><a name="AgS2R"></a></p>
<h4 id="Chrome-控制台记录-XMLHttpRequest-请求"><a href="#Chrome-控制台记录-XMLHttpRequest-请求" class="headerlink" title="Chrome 控制台记录 XMLHttpRequest 请求"></a>Chrome 控制台记录 XMLHttpRequest 请求</h4><p><img src="https://cdn.nlark.com/yuque/0/2019/png/182657/1575432225980-3814e3a4-8a82-478e-8f1f-8713291450ea.png#align=left&display=inline&height=453&name=image.png&originHeight=453&originWidth=961&size=68737&status=done&style=none&width=961" alt="image.png"></p>
<p><a name="C3n8N"></a></p>
<h4 id="关于-Token-的认识"><a href="#关于-Token-的认识" class="headerlink" title="关于 Token 的认识"></a>关于 Token 的认识</h4><ul>
<li>一个 Token 就是一些信息的集合；</li>
<li>在 Token 中包含足够多的信息，以便在后续请求中减少查询数据库的几率；</li>
<li>服务端需要对 cookie 和 HTTP Authrorization Header 进行 Token 信息的检查；</li>
<li>基于上一点，你可以用一套 token 认证代码来面对浏览器类客户端和非浏览器类客户端；</li>
<li>因为 token 是被签名的，所以我们可以认为一个可以解码认证通过的 token 是由我们系统发放的，其中带的信息是合法有效的；</li>
<li>Token 无法撤销的问题，一种解决方法是发放有效期较短的 Token，另一种是仍然使用 session 与浏览器端交互；</li>
<li>Token 与 session 可以同时使用，只不过面向不同的场景，Token 可以作为第三方进行 API 调用的认证方式，而 session 可作为前端交互时的选择；</li>
<li>当然也可以只用 Token 作为前端交互时的认证方式，但要面临 Token 无法撤销的问题；</li>
<li>如果你的用户数据可能需要和第三方共享，或者允许第三方调用 API 接口，用 Token；</li>
<li>在 Web 应用中，别再把 JWT 当做 session 使用，绝大多数情况下，传统的 cookie-session 机制工作得更好；</li>
<li>JWT 适合一次性的命令认证，颁发一个有效期极短的 JWT，即使暴露了危险也很小，由于每次操作都会生成新的 JWT，因此也没必要保存 JWT，真正实现无状态。</li>
</ul>
<p><a name="qpaVf"></a></p>
<h4 id="OAtuh-与-OpenID"><a href="#OAtuh-与-OpenID" class="headerlink" title="OAtuh 与 OpenID"></a>OAtuh 与 OpenID</h4><p>OAuth 的本意是一个应用允许另一个应用在用户授权的情况下访问自己的数据，OAuth 的设计本意更倾向于授权而非认证（当然授权用户信息就间接实现了认证）。OpenID 用于身份认证，允许你以同一个账户在多个网站登陆。它仅仅是为你的合法身份背书，当你以 Facebook 账号登陆某个站点之后，该站点无权访问你的在 Facebook 上的数据。OAuth 用于授权，允许被授权方访问授权方的用户数据。两者往往一起使用，实现认证和授权过程。</p>
<p><a name="51Wxa"></a></p>
<h4 id="单点登录的实现方式"><a href="#单点登录的实现方式" class="headerlink" title="单点登录的实现方式"></a>单点登录的实现方式</h4><ul>
<li>同域下不同站点的 SSO（跨站点）：两个站点如果在同域下，那么它们之间是可以共享 cookie 的。简单的说就是这种同域下不同站点的 sso 实现可以通过 cookie 来实现，当用户访问这个域下面的任意站点时，浏览器都会将这个 cookie 发送给站点对应的系统。</li>
<li>同域但不同子域名的 SSO（跨子域）： 通过在设置 cookie 时指定 domain，设置 domain 为顶级域名时可以在各子域名之间共享 cookie，如 Set-Cookie: name=value; domain=mydomain.com。</li>
<li>不同域的 SSO（跨域）：一种是简单的笨方法，使用 cookie，在各个应用之间重定向；一种是使用单独的 SSO 服务器。</li>
<li>使用单独的认证服务器已经是较为通用的方式。</li>
<li>参考：<a href="https://www.jianshu.com/p/8401582c0ef1" target="_blank" rel="external nofollow noopener noreferrer">SSO 三种情况的实现方式</a>。</li>
</ul>
<p><a name="J0Ng0"></a></p>
<h4 id="访问资源时省略-URL-中的协议"><a href="#访问资源时省略-URL-中的协议" class="headerlink" title="访问资源时省略 URL 中的协议"></a>访问资源时省略 URL 中的协议</h4><p>便于自适应同时支持 http 和 https 的站点：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">&lt;img src=<span class="string">"//remotesite.com/image1.jpg"</span> /&gt;</span></pre></td></tr></table></figure>

<p><a name="ON9zB"></a></p>
<h4 id="长短连接与长短轮询"><a href="#长短连接与长短轮询" class="headerlink" title="长短连接与长短轮询"></a>长短连接与长短轮询</h4><p>HTTP 是无状态的，因此 HTTP 连接的说法是不合适的，由于 HTTP 基于 TCP 实现，所以提到连接应该指的是 TCP 连接。HTTP 协议是基于请求 / 响应模式的，因此只要服务端给了响应，本次 HTTP 请求就结束了，没有所谓的连接一说。TCP 连接是一个双向的通道，它是可以保持一段时间不关闭的，因此 TCP 连接才有真正的长连接和短连接这一说。<br>现在用的基本上都是 HTTP/1.1 协议，请求头中 Connection 都是 keep-alive。而且 HTTP 协议文档上也提到了，HTTP/1.1 默认是长连接，也就是默认 Connection 的值就是 keep-alive。<br>需要注意的是，HTTP/2 中则不会处理 <code>Connection: keep-alive</code> 的设置，这是因为在 HTTP/1.1 中虽然 keep-alive 是默认值，但是可以通过设置 <code>keep-live: close</code> 关闭长连接，在 HTTP/2 中默认也是长连接但却不允许在 HTTP 层去关闭，所以在 HTTP/2 的请求头中看不到 <code>Connection: keep-alive</code> 这样的设置，也不会对 <code>keep-live: close</code>  这样的设置作出处理。<br>只有服务端能够针对 Connection 请求头的设置作出处理才算是真正实现了连接保持。由于连接保持是 HTTP1.1 协议的一部分，所以只要实现了 HTTP1.1 协议的服务端都是可以进行连接保持的。<br>连接保持的主要作用是为了进行多个 HTTP 请求的复用，因为 TCP 连接的创建和销毁都是有成本的。<br>长连接并不是永久连接，如果一段时间内（具体的时间长短，是可以在 header 当中进行设置的，也就是所谓的超时时间），这个连接没有 HTTP 请求发出的话，那么这个长连接就会被断掉，否则的话，TCP 连接将会越来越多，直到把服务器的 TCP 连接数量撑爆到上限为止。<br>长轮询和短轮询最大的区别是，短轮询去服务端查询的时候，不管数据有没有变化，服务端立即返回。而长轮询则不是，在长轮询中，服务器如果检测到数据没有变化的话，将会把当前请求挂起一段时间（这个时间也叫作超时时间，一般是几十秒）。在这个时间里，服务器会去检测数据有没有变化，检测到变化就立即返回，否则就一直等到超时为止。<br>不管是长轮询还是短轮询，都不太适用于客户端数量太多的情况，因为每个服务器所能承载的 TCP 连接数是有上限的，这种轮询很容易把连接数顶满。<br>WebSocket 或者 <a href="https://www.ruanyifeng.com/blog/2017/05/server-sent_events.html" target="_blank" rel="external nofollow noopener noreferrer">SSE</a> 是应对客户数并发量较多的更好的选择。SSE 与 WebSocket 对比：<a href="https://www.ibm.com/developerworks/cn/web/wa-http-server-push-with-websocket-sse/index.html" target="_blank" rel="external nofollow noopener noreferrer">使用 WebSocket 和 SSE 实现 HTTP 服务器推送</a>。<br>一个 TCP 连接是否为长连接，是通过设置 HTTP 的 Connection Header 来决定的，而且是需要两边都设置才有效。而一种轮询方式是否为长轮询，是根据服务端的处理方式来决定的，与客户端没有关系。连接的长短是通过协议来规定和实现的。而轮询的长短，是服务器通过编程的方式手动挂起请求来实现的。<br><a name="2fgCI"></a></p>
<h4 id="HTTP-2-与-HTTP-1-1"><a href="#HTTP-2-与-HTTP-1-1" class="headerlink" title="HTTP/2 与 HTTP/1.1"></a>HTTP/2 与 HTTP/1.1</h4><ul>
<li>一般而言，浏览器只允许同时与同一个服务端建立最多 6 个 TCP 连接，所以通过浏览器查看控制台时往往会看到会有 6 个请求同时进行，这是 HTTP/1.1 的情况，因为无法进行多路复用，所以需要建立多个连接同时请求多个资源，另外对于每一个 TCP 连接来说，由于服务器必须按接受请求的顺序发送响应的规则限制，那么假设浏览器在一个（tcp）连接上发送了两个请求，那么服务器必须等第一个请求响应完毕才能发送第二个响应，会造成请求的阻塞，无法有效利用带宽。</li>
<li>HTTP/2 中引入了流的概念实现多路复用，一个域名只需要一个 TCP 连接完成所有的 HTTP 请求和响应，也不会有多个请求之间的阻塞，极大提高了效率。</li>
<li>HTTP/2 引入的服务端推送特性也允许服务端在客户端发出一个 HTTP 请求（例如 index.html ）后，主动推送可能相关的内容（例如 index.html 里需要引用的 js 和 css 文件）到客户端，减少了客户端发起请求的次数，提高效率。</li>
<li>HTTP/2 的头部压缩，二进制编码等新的特性也能提高传输效率。</li>
<li>虽然 HTTP/2 的实现与 TLS 并无强行关联，但是一般代理服务器（例如 Nginx ）只允许 HTTPS 模式下使用 HTTP/2 ；Go 语言的标准库实现的 HTTP/2 协议默认也要求使用 HTTPS（虽然也可以绕过）。</li>
<li><a href="https://medium.com/@factoryhr/http-2-the-difference-between-http-1-1-benefits-and-how-to-use-it-38094fa0e95b" target="_blank" rel="external nofollow noopener noreferrer">HTTP/2: the difference between HTTP/1.1, benefits and how to use it</a>；<a href="https://www.codercto.com/a/34433.html" target="_blank" rel="external nofollow noopener noreferrer">HTTP/2 协议详解</a>；<a href="https://hpbn.co/http2/#header-compression" target="_blank" rel="external nofollow noopener noreferrer">HTTP/2</a>；<a href="https://www.digitalocean.com/community/tutorials/http-1-1-vs-http-2-what-s-the-difference" target="_blank" rel="external nofollow noopener noreferrer">HTTP/1.1 vs HTTP/2: What’s the Difference?</a></li>
</ul>
<br>



]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>Keycloak 使用过程记录</title>
    <url>/post/e4c4afae.html</url>
    <content><![CDATA[<p><a name="Cmvxj"></a></p><h4 id="keycloak-js-sdk"><a href="#keycloak-js-sdk" class="headerlink" title="keycloak js sdk"></a>keycloak js sdk</h4><p>Angular 版本的 SDK ：<a href="https://www.npmjs.com/package/keycloak-angular" target="_blank" rel="external nofollow noopener noreferrer">https://www.npmjs.com/package/keycloak-angular</a>。为了实现 Token 刷新可以采用以下方式：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">keycloak.onTokenExpired = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">console</span>.log(<span class="string">'token expired'</span>, keycloak.token);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    keycloak.updateToken(<span class="number">30</span>).success(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">console</span>.log(<span class="string">'successfully get a new token'</span>, keycloak.token);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ...</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;).error(<span class="function"><span class="params">()</span> =&gt;</span> &#123;...&#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><a id="more"></a>



<p><a name="O4e8p"></a></p>
<h4 id="Keycloak-使用-LDAP"><a href="#Keycloak-使用-LDAP" class="headerlink" title="Keycloak 使用 LDAP"></a>Keycloak 使用 LDAP</h4><p><a href="https://codehumsafar.wordpress.com/tag/ldap-with-keycloak/" target="_blank" rel="external nofollow noopener noreferrer">https://codehumsafar.wordpress.com/tag/ldap-with-keycloak/</a></p>
]]></content>
      <categories>
        <category>认证</category>
      </categories>
      <tags>
        <tag>认证</tag>
      </tags>
  </entry>
  <entry>
    <title>Kubernetes CSI</title>
    <url>/post/d1098827.html</url>
    <content><![CDATA[<p><a name="ekedR"></a></p><h4 id="Volume"><a href="#Volume" class="headerlink" title="Volume"></a>Volume</h4><p>在 Kubernetes 中，容器运行结束后其文件系统也随即被销毁，因此无法在容器中直接存储需要持久化的数据；另一方面，Kubernetes 以 Pod 为单位管理多个有一定关联关系的容器，这些容器之间的数据共享也是一个需要解决的一个问题。为此，Kubernetes 中引入了 Volume 的概念，与 Docker 中 Volume 概念的不同之处在于 Kubernetes 中的 Volume 有着完善的生命周期管理，一个 Volume 的生命周期和对应的 Pod 的一致，因此 Pod 中的容器的重启不会造成 Volume 中数据的丢失，且多个容器可以通过挂载同一个 Volume 共享数据，另外单个 Pod 支持使用多个多种类型的 Volume。通过 Volume 的抽象，容器只需要挂载 Volume 到文件系统的某个目录使用它而不必关心 Volume 的存储后端到底是什么类型。<br><a name="P9ayc"></a></p><a id="more"></a>

<h4 id="存储插件"><a href="#存储插件" class="headerlink" title="存储插件"></a>存储插件</h4><p>Kubernetes 支持的 Volume 存储后端多种多样，包括 RBD/GlusterFS/NFS/azureDisk/awsElasticBlockStore 等各种开源的和来自云厂商的存储产品，为此 Kubernetes 中维护了大量协议相关或是厂商相关的存储插件代码（in-tree，即代码包含在 Kubernetes 核心代码中），它们和 Kubernetes 的核心可执行文件一同维护、编译、构建和交付，这对于 Kubernetes 的核心开发人员以及存储插件开发人员都是不友好的，使得开发和调试过程较为麻烦且存储插件的代码质量难以保证，为此社区最开始引入了 FlexVolume 插件机制（out-tree，Kubernetes 核心代码中只包含作为调用方相关的不变的代码，存储类型相关的代码由存储提供方自行维护），FlexVolume 等同于可被 Pod 直接使用的一种 Volume 后端存储，在执行 Volume 创建和挂载时 Kubernetes 中调用 FlexVolume 的代码依据不同的存储类型调用预先配置好路径的可执行文件完成相关操作，因此 FlexVolume 的工作过程依赖于一系列预先在每台宿主机上预先配置好的可执行文件（例如，使用 Ceph 需要在每个节点上装好 rbd），安装过程极其麻烦。<br><a name="y01o3"></a></p>
<h4 id="CSI-的引入"><a href="#CSI-的引入" class="headerlink" title="CSI 的引入"></a>CSI 的引入</h4><p>CSI(Container Storage Interface) 可以看作是 FlexVolume 的一种升级，其典型区别是 CSI 使用 gRPC 协议调用第三方存储后端而不是直接调用可执行文件，并且 CSI 在接口的标准化和功能特性升级上做了更多优化，并为开发和部署存储插件提供了参考模型，使得存储插件开放人员可以更灵活地开发插件并以 Kubernetes 原生的形式（通过 Deployment 和 DaemonSet 等）来部署插件而不是在宿主机上安装程序包，对于开发和使用群体都更为友好。<br>CSI 已经被确认为 Kubernetes 主流的存储接口规范，In-tree 的存储插件将逐步迁移至 CSI 方式实现，新的特性将只在 CSI 中增加而不会增加到 FlexVolume 中，未来第三方存储插件将彻底从 Kubernetes 核心代码中移除。 目前 CSI 独有的新特性有：VolumeSnapshot（创建卷快照，并从快照恢复）、Volume clone（从已有卷复制一个新的卷）。<br>另外非要重要的是，CSI 是由来自 Kubernetes，Mesos， Docker 等社区的成员联合制定的一个行业标准接口规范，这意味存储提供商开发的 CSI 驱动只要稍加修改就可以在不同的平台上使用，大大扩展了 CSI 的用户群体。<br>CSI 在逻辑上将存储驱动分为两个组件 Controller Plugin 和 Node Plugin：从功能上看，Controller Plugin 与 Kubernetes 控制平面交互，实现 Volume 的创建，Node Plugin 与 Kubelet 协同实现将 Volume 挂载给容器使用；从部署的角度看，Controller Plugin 既可以部署在 Master 节点也可以部署在 Node 节点，一般使用 Deployment 或 StatefulSet 部署，Node Plugin 需要在所有需使用该存储的 Node 上部署，一般使用 DaemonSet 部署。<br><a name="PsvTR"></a></p>
<h4 id="CSI-接口规范"><a href="#CSI-接口规范" class="headerlink" title="CSI 接口规范"></a>CSI 接口规范</h4><p>存储驱动需要实现三种 gRPC 服务：Identity Service, Controller Service, Node Service。 Controller Plugin 需要实现 Identity Service 和 Controller Service； Node Plugin 需要实现 Identity Service 和 Node Service。 三种服务定义的基本接口如下：</p>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">service</span> <span class="title">Identity</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// 获取插件的版本和名称</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">rpc</span> GetPluginInfo(GetPluginInfoRequest)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">    <span class="keyword">returns</span> (GetPluginInfoResponse) &#123;&#125;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">  // 返回插件所支持的功能</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">  // 主要检测插件是否实现 Controller Service 和是否支持卷访问拓扑限制</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">  // 插件的相同版本的所有实例，必须返回相同的功能集</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">  <span class="keyword">rpc</span> GetPluginCapabilities(GetPluginCapabilitiesRequest)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">    <span class="keyword">returns</span> (GetPluginCapabilitiesResponse) &#123;&#125;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">  // 验证插件是否处于健康和就绪状态</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">  <span class="keyword">rpc</span> Probe (ProbeRequest)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">    <span class="keyword">returns</span> (ProbeResponse) &#123;&#125;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">&#125;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">service Controller &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">  // 创建卷</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">  // 请求参数包括：名字、卷容量、卷功能（表明是块存储卷还是文件系统卷，以及访问模式）</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">  // 、参数、数据源（snapshot,clone），以及卷拓扑限制等</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">  <span class="keyword">rpc</span> CreateVolume (CreateVolumeRequest)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">    <span class="keyword">returns</span> (CreateVolumeResponse) &#123;&#125;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">  // 删除指定 volume ID 的存储卷</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">  <span class="keyword">rpc</span> DeleteVolume (DeleteVolumeRequest)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">    <span class="keyword">returns</span> (DeleteVolumeResponse) &#123;&#125;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">  // 使存储卷在某个所需节点上可用即 volume attach</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">  // 如 Ceph RBD 需要将卷 rbd map 到某个节点上</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">  <span class="keyword">rpc</span> ControllerPublishVolume (ControllerPublishVolumeRequest)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">    <span class="keyword">returns</span> (ControllerPublishVolumeResponse) &#123;&#125;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">  // 执行 ControllerPublishVolume 相反的操作</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">  // 使卷在某个节点上不可用，例如将 volume 从某个节点 detach</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">  <span class="keyword">rpc</span> ControllerUnpublishVolume (ControllerUnpublishVolumeRequest)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">    <span class="keyword">returns</span> (ControllerUnpublishVolumeResponse) &#123;&#125;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">  // 验证预先配置的卷是否满足容器编排系统的需求</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">  // 可以指定卷功能（表明是块存储卷还是文件系统卷，以及访问模式）、卷属性以及卷拓扑限制等进行验证</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">  <span class="keyword">rpc</span> ValidateVolumeCapabilities (ValidateVolumeCapabilitiesRequest)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">    <span class="keyword">returns</span> (ValidateVolumeCapabilitiesResponse) &#123;&#125;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">  // 返回所有可用的存储卷，支持分页</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">  <span class="keyword">rpc</span> ListVolumes (ListVolumesRequest)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">    <span class="keyword">returns</span> (ListVolumesResponse) &#123;&#125;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">    </span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">  // 返回存储资源池总可用容量。如存储容量有限，则需要执行此操作</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">  // 假设存储资源池只能提供 1TB 的存储空间,配置和创建新卷时，应检测存储资源池的可用存储容量</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">  <span class="keyword">rpc</span> GetCapacity (GetCapacityRequest)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">    <span class="keyword">returns</span> (GetCapacityResponse) &#123;&#125;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">  </span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">  // 返回 Controller 插件支持的功能</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">  // 比如有些 controller plugin 不支持 GetCapacity，有些则不支持 CreateSnapshot 等</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">  <span class="keyword">rpc</span> ControllerGetCapabilities (ControllerGetCapabilitiesRequest)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">    <span class="keyword">returns</span> (ControllerGetCapabilitiesResponse) &#123;&#125;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">  </span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">  // 创建指定 volume ID 的存储快照，用来备份数据</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">  <span class="keyword">rpc</span> CreateSnapshot (CreateSnapshotRequest)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">    <span class="keyword">returns</span> (CreateSnapshotResponse) &#123;&#125;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">  // 删除指定 ID 的存储快照</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">  <span class="keyword">rpc</span> DeleteSnapshot (DeleteSnapshotRequest)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">    <span class="keyword">returns</span> (DeleteSnapshotResponse) &#123;&#125;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">  // 返回所有可用的存储快照，支持分页</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">  <span class="keyword">rpc</span> ListSnapshots (ListSnapshotsRequest)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">    <span class="keyword">returns</span> (ListSnapshotsResponse) &#123;&#125;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">  // 实现磁盘扩容</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">  // 例如 rbd resize</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">  <span class="keyword">rpc</span> ControllerExpandVolume (ControllerExpandVolumeRequest)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">    <span class="keyword">returns</span> (ControllerExpandVolumeResponse) &#123;&#125;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">&#125;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">service Node &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">  // CO 调用此方法以将 volume mount 到指定路径,通常，此路径是节点上的全局路径</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">  // 此方法调用必须在 NodePublishVolume 之前，NodeStageVolume 是每个卷/每节点执行一次</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">  // 在 Kubernetes 中，RBD 卷在 attach 到节点后，会将其 mount 到全局目录，然后 mount 到 pod 目录（通过 NodePublishVolume）</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">  // 两步 mount 操作的原因是因为 Kubernetes 允许多个 pod 使用单个卷</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">  <span class="keyword">rpc</span> NodeStageVolume (NodeStageVolumeRequest)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">    <span class="keyword">returns</span> (NodeStageVolumeResponse) &#123;&#125;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">  // 执行 NodeStageVolume 相反的操作，从指定目录 unmount 卷</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">  <span class="keyword">rpc</span> NodeUnstageVolume (NodeUnstageVolumeRequest)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">    <span class="keyword">returns</span> (NodeUnstageVolumeResponse) &#123;&#125;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">  // CO 调用此方法将卷从指定全局路径 mount 到目标路径</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">  // 通常做的操作是 bind mount，bind mount 允许将路径 mount 到另一个路径</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">  // 此方法调用必须在 NodeStageVolume 之后，NodePublishVolume 是每个卷/每个工作负载执行一次</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">  <span class="keyword">rpc</span> NodePublishVolume (NodePublishVolumeRequest)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">    <span class="keyword">returns</span> (NodePublishVolumeResponse) &#123;&#125;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">  // 执行 NodePublishVolume 相反操作，从目标路径 unmount 卷</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">  <span class="keyword">rpc</span> NodeUnpublishVolume (NodeUnpublishVolumeRequest)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">    <span class="keyword">returns</span> (NodeUnpublishVolumeResponse) &#123;&#125;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">  </span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">  // 获取指定 Volume 的使用统计信息</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">  // 包括总容量、可用容量和已用容量</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">  // 如果 Volume 是以块设备模式使用则不返回可用容量和已用容量</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">  <span class="keyword">rpc</span> NodeGetVolumeStats (NodeGetVolumeStatsRequest)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">    <span class="keyword">returns</span> (NodeGetVolumeStatsResponse) &#123;&#125;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">  // 实现文件系统扩容</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">  // 如 xfs_growfs</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">  <span class="keyword">rpc</span> NodeExpandVolume(NodeExpandVolumeRequest)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">    <span class="keyword">returns</span> (NodeExpandVolumeResponse) &#123;&#125;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">  // 返回 node plugin 支持的功能</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">  <span class="keyword">rpc</span> NodeGetCapabilities (NodeGetCapabilitiesRequest)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">    <span class="keyword">returns</span> (NodeGetCapabilitiesResponse) &#123;&#125;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">  </span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">  // 获取 node 节点信息</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">  // 返回值包括  node ID，节点上最多可发布的 volume 数量，以及 node 可访问的拓扑信息</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">  <span class="keyword">rpc</span> NodeGetInfo (NodeGetInfoRequest)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">    <span class="keyword">returns</span> (NodeGetInfoResponse) &#123;&#125;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">&#125;</span></span></pre></td></tr></table></figure>
<p><a name="oSDGP"></a></p>
<h4 id="CSI-插件结构"><a href="#CSI-插件结构" class="headerlink" title="CSI 插件结构"></a>CSI 插件结构</h4><p>CSI 规范中要求 gRPC 通信基于 Unix Socket 完成，因此调用方和存储插件需要部署在同一台宿主机上。基于 Kubernetes 集群的安全性考虑，第三方存储厂商提供的驱动被视为不受信任的，因此一般不部署在 Master 节点，即存储驱动中的 Controller Plugin 往往不部署在 Master节点，但 Kubernetes 控制平面是部署在 Master 节点上的，因此它们之间无法使用基于 Unix Socket 的 gRPC 进行通信，所以需要引入辅助组件实现 Controller Plugin 和 Kubernetes 的协同，辅助组件通过 Kubernetes HTTP API 监听相关对象的变化并通过 gRPC 调用 Controller Plugin 完成 Volume 的创建和删除等操作。而这部分辅助组件的功能对各种第三方存储驱动往往是通用的，所以 CSI 兴趣小组帮助完成了这些辅助组件的开发，存储驱动开发人员只需要将其以 sidecar 的形式引入到部署中即可。</p>
<p>CSI 社区提供的辅助组件如下：</p>
<ul>
<li>external-provisioner</li>
</ul>
<p>如果 CSI 插件提供 CREATE_DELETE_VOLUME 能力，则需实现 Controller Service 的 CreateVolume 和DeleteVolume 接口。external-provisioner watch 到指定 StorageClass 的 PersistentVolumeClaim 资源状态变更，会自动调用这两个接口。</p>
<ul>
<li>external-attacher</li>
</ul>
<p>如果 CSI 插件提供 PUBLISH_UNPUBLISH_VOLUME 能力，则需实现 Controller Service 的 ControllerPublishVolume 和 ControllerUnpublishVolume 接口。external-attacher watch 到 VolumeAttachment 资源状态变更，会自动调用这两个接口。</p>
<ul>
<li>external-snapshotter</li>
</ul>
<p>如果 CSI 插件提供 CREATE_DELETE_SNAPSHOT 能力，则需实现 Controller Service 的 CreateSnapshot 和 DeleteSnapshot 接口。external-snapshotter watch 到指定 SnapshotClass 的 VolumeSnapshot 资源状态变更，会自动调用这两个接口。</p>
<ul>
<li>external-resizer</li>
</ul>
<p>如果 CSI 插件提供 EXPAND_VOLUME 能力，则需实现 Controller Service 的 ControllerExpandVolume 接口。external-resizer watch 到 PersistentVolumeClaim 资源的容量发生变更，会自动地调用这个接口。</p>
<ul>
<li>node-driver-registrar</li>
</ul>
<p>CSI 插件需实现 Node Service 的 NodeGetInfo 接口后。当 Node Plugin 部署到 kubernetes 的 node 节点时，该 sidecar 会自动调用接口获取 CSI 插件信息，并向 kubelet 进行注册。</p>
<ul>
<li>livenessprobe</li>
</ul>
<p>通过 livenessprobe 辅助组件，kubernetes 即可检测到 CSI 插件相关 pod 的健康状态，当不正常时自动重启相应 pod。<br>逻辑上独立的 Controller Plugin 和 Node Plugin 可以由一个可执行程序（可称为 CSI Plugin）实现，通过启动参数决定提供 Controller 相关的服务还是 Node 相关的服务，CSI 插件添加辅助组件后，其部署结构如下：<br><img src="https://cdn.nlark.com/yuque/0/2019/png/182657/1572510560003-83653de0-138b-4eff-b364-e99bc0d5b2db.png#align=left&display=inline&height=1080&name=image.png&originHeight=1080&originWidth=1920&size=357131&status=done&style=none&width=1920" alt="image.png"><br><a name="dnqUc"></a></p>
<h4 id="Ceph-CSI-的实现"><a href="#Ceph-CSI-的实现" class="headerlink" title="Ceph CSI 的实现"></a>Ceph CSI 的实现</h4><p>Ceph CSI 的源代码仓库地址：<a href="https://github.com/ceph/ceph-csi" target="_blank" rel="external nofollow noopener noreferrer">https://github.com/ceph/ceph-csi</a>，源码编译后只生成一个可执行文件 cephcsi，根据传入的 –type 参数确定启动 cephfs 还是 rbd 相关的服务， 通过传入的 –nodeserver=true 指明启动 Node Service，通过 –controllerserver=true 致命启动 Controller Service，因此 ceph-csi 通过单一可执行文件同时实现了分别针对 rbd 和 cephfs 提供的 Identity、Controller 和 Node 三种服务。其部署结构和上图基本一致， Controller Service 与社区提供的 csi-provisioner 、csi-snapshotter、csi-attacher 共同组成了一个 StatefulSet , Node Service 与社区提供的 csi-node-driver-registrar 共同组成了一个 Deployment。<br>Ceph CSI 的代码结构如下，除了一些辅助性的代码，核心代码主要在 cmd 和 pkg 目录下，在 Go 项目中 cmd 目录一般是 main 函数所在的目录，也就是程序的编译和运行入口，所以 ceph csi 最后编译生成一个可执行文件与 cephcsi.go 同名，pkg 目录下则是被 cephcsi 引用的各种包的具体实现，其中 cephfs 目录下包含针对 cephfs 提供的实现 CSI 接口规范的代码， rbd 目录下是针对块存储的代码，csi-common 是共用的代码和类型定义， liveness 是提供 csi 插件存活状态探针的代码：<br><img src="https://cdn.nlark.com/yuque/0/2019/png/182657/1572848810789-0d219333-3ddf-4f8d-bd76-11fb8ae4fcf3.png#align=left&display=inline&height=710&name=DeepinScreenshot_select-area_20191104142608.png&originHeight=710&originWidth=230&size=33434&status=done&style=none&width=230" alt="DeepinScreenshot_select-area_20191104142608.png"><br>cephcsi.go 的引用关系如下图所示， 首先通过 init 函数读取命令行参数并解析存入 config 变量，然后根据配置参数使用 NewDriver 创建不同的 Driver （cephfs 或者 rbd），并调用相关 Driver 的 Run 方法启动 rpc server：<br><img src="https://cdn.nlark.com/yuque/0/2019/png/182657/1572859417047-7bdd41d3-eb75-41bf-ac51-1a74c89d486b.png#align=left&display=inline&height=1649&name=image.png&originHeight=1649&originWidth=764&size=325870&status=done&style=none&width=764" alt="image.png"></p>
<p>以 rbd Driver 为例，Controller Service 相关接口的实现如下：</p>
<ul>
<li>CreateVolume：根据传入的参数执行 rbd create 命令创建 image；</li>
<li>DeleteVolume：根据传入的参数执行 rbd rm 命令删除 image；</li>
<li>CreateSnapshot：根据传入的参数先执行 rbd snap create 创建快照，再执行 rbd snap protect 对快照加保护，再通过 rbd snap ls 获取快照信息，取消保护，将快照信息返回给调用方；</li>
<li>DeleteSnapshot： 根据传入的参数执行 rbd snap rm 删除快照；</li>
<li>扩容相关接口未实现。</li>
</ul>
<p>Node Service 相关接口的实现如下：</p>
<ul>
<li>NodeStageVolume：根据传入的参数执行 rbd map 命令将 image 映射为指定节点上的块设备，通过 mkdir 系统调用在指定节点上创建全局挂载目录，根据传入的文件系统类型参数执行 mkfs.* (ext4, xfs) 命令在 rbd 设备上创建文件系统并将其 mount 到之前创建的全局挂载目录，并将挂载点权限设置为 0777 允许所有容器访问（不安全）。</li>
<li>NodePublishVolume：根据传入的参数创建针对某个容器的挂载路径，并将 NodeStageVolume 阶段创建的全局挂载路径 bind mount 到该容器路径。</li>
<li>NodeUnpublishVolume：NodePublishVolume 的逆操作，对容器挂载路径执行 umount 操作并删除路径。</li>
<li>NodeUnstageVolume：NodeStageVolume 的逆操作，对全局挂载路径执行 umount 操作并删除路径。</li>
</ul>
<p>Identity Service 接口实现：</p>
<ul>
<li>GetPluginCapabilities：返回 rbd Driver 的能力信息，这里返回 PluginCapability_Service_CONTROLLER_SERVICE，表明实现了 Controller Service，特别说明实现了 Controller Service 是因为 Node service 是必须的，而 Controller Service 被设计为可选的。</li>
</ul>
<p><a name="a7snF"></a></p>
<h4 id="阅读材料"><a href="#阅读材料" class="headerlink" title="阅读材料"></a>阅读材料</h4><p>csi 社区文档：<a href="https://kubernetes-csi.github.io/docs/" target="_blank" rel="external nofollow noopener noreferrer">https://kubernetes-csi.github.io/docs/</a><br>csi 标准文档： <a href="https://github.com/container-storage-interface/spec/blob/master/spec.md" target="_blank" rel="external nofollow noopener noreferrer">https://github.com/container-storage-interface/spec/blob/master/spec.md</a></p>
]]></content>
      <categories>
        <category>Kubernetes</category>
      </categories>
      <tags>
        <tag>Kubernetes</tag>
        <tag>云计算</tag>
      </tags>
  </entry>
  <entry>
    <title>Kubernetes 中使用 Nginx-Ingress 对外部请求进行认证</title>
    <url>/post/f901e5ff.html</url>
    <content><![CDATA[<p><a name="2PGKt"></a></p><h3 id="原文"><a href="#原文" class="headerlink" title="原文"></a>原文</h3><p><a href="https://medium.com/@ankit.wal/authenticate-requests-to-apps-on-kubernetes-using-nginx-ingress-and-an-authservice-37bf189670ee" target="_blank" rel="external nofollow noopener noreferrer">Authenticate requests to apps on kubernetes using Nginx-Ingress and an AuthService</a><br></p><p>在诸如 Kubernetes 的集群上部署微服务的一种常见模式是将认证过程委托给外部认证服务或者是将认证过程抽取为单独的微服务部署在当前集群，其基本结构如下图所示：</p><a id="more"></a>


<p><img src="https://cdn.nlark.com/yuque/0/2019/png/182657/1575344848404-ec7c7588-8044-46e0-a3f8-46d682a8329c.png#align=left&display=inline&height=1058&name=image.png&originHeight=1058&originWidth=1246&size=76582&status=done&style=none&width=1246" alt="image.png"></p>
<p>通过将对所有 API 调用的认证过程委托给独立的认证服务可以避免在每个业务微服务中都要实现认证插件，从而使得开发团队可以专注于业务逻辑的开发，避免重复的工作。本文介绍了使用 ingress-nginx 注解配置外部认证服务实现用户身份验证与授权。</p>
<p><a name="kEL2C"></a></p>
<h3 id="Authentication-Annotations"><a href="#Authentication-Annotations" class="headerlink" title="Authentication Annotations"></a>Authentication Annotations</h3><p><a name="0hiT0"></a></p>
<h4 id="auth-url"><a href="#auth-url" class="headerlink" title="auth-url"></a>auth-url</h4><p>Nginx-inkress 是一个相当成熟的为部署在 kubernetes 上的工作流提供外部入口的解决方案，它带有很多开箱即用的特性。这些特性大多数都可以通过简单地向服务的 ingress yaml 文件中添加注解来使用。这里需要使用其中专门用于对接外部认证的注解 ‘auth-url’ 。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">nginx.ingress.kubernetes.io/auth-url: <span class="string">"url to auth service"</span></span></pre></td></tr></table></figure>
<p>这个注解告诉 ingress-nginx 控制器先将传入的请求转发给认证服务，然后如果认证服务返回状态码为 200 OK 的响应，则将请求继续转发到下游服务。例如:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">apiVersion: extensions/v1beta1 </span></pre></td></tr><tr><td class="code"><pre><span class="line">kind: Ingress</span></pre></td></tr><tr><td class="code"><pre><span class="line">metadata:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  annotations:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    nginx.ingress.kubernetes.io/auth-url: http:<span class="comment">//auth-service.prod.svc.cluster.local/authenticate</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  namespace: prod </span></pre></td></tr><tr><td class="code"><pre><span class="line">  name: ingress-<span class="keyword">with</span>-auth</span></pre></td></tr><tr><td class="code"><pre><span class="line">spec: </span></pre></td></tr><tr><td class="code"><pre><span class="line">  rules:</span></pre></td></tr><tr><td class="code"><pre><span class="line">   - host: api.microservice<span class="number">-1.</span>myapp.com</span></pre></td></tr><tr><td class="code"><pre><span class="line">      http:</span></pre></td></tr><tr><td class="code"><pre><span class="line">        paths:</span></pre></td></tr><tr><td class="code"><pre><span class="line">        - path: <span class="regexp">/secure/</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">          backend:</span></pre></td></tr><tr><td class="code"><pre><span class="line">            serviceName: microservice<span class="number">-1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            servicePort: <span class="number">8080</span></span></pre></td></tr></table></figure>
<p>上面的 ingress 配置指示 ingress-nginx 将所有路径为 <code>api.microservice-1.myapp.com/secure/</code> 的外部请求首先转发到部署在集群内的认证服务的 <code>/authenticate</code> 端点，其基本过程如下：</p>
<ol>
<li>客户端向 <code>api.microservice-1.myapp.com/secure/*</code> 发起 API 请求；</li>
<li>请求到达 ingress-nginx 控制器，控制器将其转给认证服务的 <code>/authenticate</code> 端点；</li>
<li>如果认证服务返回 <code>200 Ok</code> 则继续讲该请求转给 <code>microservice-1</code> 服务。</li>
</ol>
<p><a name="Zd1lp"></a></p>
<h4 id="auth-response-headers"><a href="#auth-response-headers" class="headerlink" title="auth-response-headers"></a>auth-response-headers</h4><p>我们可以使用  auth-response-headers 注解让认证服务传递一些信息到下游的业务应用。例如，认证服务在进行认证的过程中可以解析出用户名或用户 ID ，并将用户信息传递给  <code>microservice-1</code> 服务：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">apiVersion: extensions/v1beta1 </span></pre></td></tr><tr><td class="code"><pre><span class="line">kind: Ingress</span></pre></td></tr><tr><td class="code"><pre><span class="line">metadata:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  annotations:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    nginx.ingress.kubernetes.io/auth-url: http:<span class="comment">//auth-service.prod.svc.cluster.local/authenticate</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    nginx.ingress.kubernetes.io/auth-response-headers: UserID</span></pre></td></tr><tr><td class="code"><pre><span class="line">  namespace: prod </span></pre></td></tr><tr><td class="code"><pre><span class="line">  name: ingress-<span class="keyword">with</span>-auth</span></pre></td></tr><tr><td class="code"><pre><span class="line">spec: </span></pre></td></tr><tr><td class="code"><pre><span class="line">  rules:</span></pre></td></tr><tr><td class="code"><pre><span class="line">   - host: api.microservice<span class="number">-1.</span>myapp.com</span></pre></td></tr><tr><td class="code"><pre><span class="line">      http:</span></pre></td></tr><tr><td class="code"><pre><span class="line">        paths:</span></pre></td></tr><tr><td class="code"><pre><span class="line">        - path: <span class="regexp">/secure/</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">          backend:</span></pre></td></tr><tr><td class="code"><pre><span class="line">            serviceName: microservice<span class="number">-1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            servicePort: <span class="number">8080</span></span></pre></td></tr></table></figure>

<ol>
<li>客户端向 api.microservice-1.myapp.com/secure/* 发起 API 请求；</li>
<li>请求到达 ingress-nginx 控制器，控制器将其转给认证服务的 /authenticate 端点；</li>
<li>认证服务在认证过程中解析出 <code>UserID</code>，在返回的 <code>200 Ok</code> 响应中带上 <code>UserID</code> 头信息；</li>
<li>ingress-nginx 控制器从认证服务的响应中获取 UserID 信息并添加到初始的客户端请求头中，并将客户请求传递给 <code>microservice-1</code> 服务。</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2019/png/182657/1575347734772-e086bf98-4064-49c8-9f46-6f951898dc86.png#align=left&display=inline&height=1064&name=image.png&originHeight=1064&originWidth=1248&size=81349&status=done&style=none&width=1248" alt="image.png"></p>
<p><a name="xK7hi"></a></p>
<h3 id="译者补充"><a href="#译者补充" class="headerlink" title="译者补充"></a>译者补充</h3><p><a name="mCRS2"></a></p>
<h4 id="keycloak-auth"><a href="#keycloak-auth" class="headerlink" title="keycloak-auth"></a>keycloak-auth</h4><p>在看到这篇文章之前，我们已经进行了类似的实践，我们的认证中心基于 <a href="https://github.com/keycloak/keycloak" target="_blank" rel="external nofollow noopener noreferrer">keycloak</a> 实现，keycloak 部署于 Kubernetes 集群内，为了能够无侵入地为已有的业务微服务（实现所用的语言有 Go 和 Python）添加基于 keycloak 的认证过程，我们希望能够使用类似 <a href="https://github.com/keycloak/keycloak-gatekeeper" target="_blank" rel="external nofollow noopener noreferrer">keycloak-gatekeeper</a> 的机制在请求到达业务微服务之前实现认证和授权。keycloak-gatekeeper 实现了认证／授权／反向代理的功能，它可以根据配置的规则，针对每个 HTTP 请求（Method 和 URL）进行基于角色的授权，通过认证和授权的请求会代理向业务微服务发起请求。由于我们已经使用 ingress-nginx 作为服务入口即反向代理服务器，所以 keycloak-gatekeeper 反向代理的功能是我们不需要的，因此我对 keycloak-gatekeeper 做了一些裁剪形成了 <a href="https://github.com/XiaYinchang/nginx-ingress-keycloak-auth" target="_blank" rel="external nofollow noopener noreferrer">nginx-ingress-keycloak-auth</a>，主要完成了以下改造：</p>
<ol>
<li>移除反向代理相关代码。</li>
<li>与 ingress-nginx auth-url 接口对接起来，针对通过授权的请求直接返回 200（不再执行反向代理）。</li>
<li>在入口中间件中（EntrypointMiddleware）中将 <code>req *http.Request</code> 对象的 URL 和 Method 信息更改为从 ingress-nginx 传递的 “X-Original-Url” 和 “X-Original-Method” 请求头解析出的内容以便复用原有的认证和授权逻辑。</li>
<li>对代码结构进行了调整使其更符合 Go 项目的通用项目结构模式。</li>
</ol>
<p><a name="pWbqx"></a></p>
<h4 id="LDAP-对接-ingress-nginx"><a href="#LDAP-对接-ingress-nginx" class="headerlink" title="LDAP 对接 ingress-nginx"></a>LDAP 对接 ingress-nginx</h4><p><a href="https://github.com/kubernetes/ingress-nginx/issues/1676#issuecomment-427033748" target="_blank" rel="external nofollow noopener noreferrer">https://github.com/kubernetes/ingress-nginx/issues/1676#issuecomment-427033748</a></p>
<p><a name="elPJY"></a></p>
<h4 id="ingress-nginx-生成配置的模板"><a href="#ingress-nginx-生成配置的模板" class="headerlink" title="ingress-nginx 生成配置的模板"></a>ingress-nginx 生成配置的模板</h4><p><a href="https://github.com/kubernetes/ingress-nginx/blob/b286c2a3364888de32cb60c4771e57a1ed8e5735/rootfs/etc/nginx/template/nginx.tmpl" target="_blank" rel="external nofollow noopener noreferrer">https://github.com/kubernetes/ingress-nginx/blob/b286c2a3364888de32cb60c4771e57a1ed8e5735/rootfs/etc/nginx/template/nginx.tmpl</a></p>
<p><a name="dh0i1"></a></p>
<h4 id="Go-实现的一个-JWT-Validator"><a href="#Go-实现的一个-JWT-Validator" class="headerlink" title="Go 实现的一个 JWT Validator"></a>Go 实现的一个 JWT Validator</h4><p><a href="https://github.com/carlpett/nginx-subrequest-auth-jwt" target="_blank" rel="external nofollow noopener noreferrer">https://github.com/carlpett/nginx-subrequest-auth-jwt</a></p>
]]></content>
      <categories>
        <category>译文</category>
      </categories>
      <tags>
        <tag>译文</tag>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>在 Go 中不要拷贝锁</title>
    <url>/post/6b348626.html</url>
    <content><![CDATA[<p><a name="2PGKt"></a></p><h3 id="原文"><a href="#原文" class="headerlink" title="原文"></a>原文</h3><p><a href="https://eli.thegreenplace.net/2018/beware-of-copying-mutexes-in-go/" target="_blank" rel="external nofollow noopener noreferrer">Beware of copying mutexes in Go</a></p><p>假设我们定义了一个包含一个映射表（ map）的结构体，我们想要使用结构体的方法去修改映射表的内容，如下是一个例子：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Container <span class="keyword">struct</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  counters <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c Container)</span> <span class="title">inc</span><span class="params">(name <span class="keyword">string</span>)</span></span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  c.counters[name]++</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  c := Container&#123;counters: <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>&#123;<span class="string">"a"</span>: <span class="number">0</span>, <span class="string">"b"</span>: <span class="number">0</span>&#125;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  doIncrement := <span class="function"><span class="keyword">func</span><span class="params">(name <span class="keyword">string</span>, n <span class="keyword">int</span>)</span></span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      c.inc(name)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  doIncrement(<span class="string">"a"</span>, <span class="number">100000</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  fmt.Println(c.counters)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><a id="more"></a>



<p>代码中 <code>Container</code> 包含了一个由计数器组成的映射表，使用计数器名称作为索引。<code>Container</code> 的 inc 方法会去增加指定计数器的值（假设指定计数器已经存在）。main 函数中使用 for 循环调用 inc 方法多次。<br>运行这段代码，输出如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">map[a:100000 b:0]</span></pre></td></tr></table></figure>
<p>现在我们想在两个 goroutine 中并发调用 inc 方法。由于我们担心竞争情况，我们使用一个互斥锁来保护关键区域:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="string">"fmt"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="string">"sync"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="string">"time"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Container <span class="keyword">struct</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  sync.Mutex                       <span class="comment">// &lt;-- Added a mutex</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  counters <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c Container)</span> <span class="title">inc</span><span class="params">(name <span class="keyword">string</span>)</span></span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  c.Lock()                         <span class="comment">// &lt;-- Added locking of the mutex</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">defer</span> c.Unlock()</span></pre></td></tr><tr><td class="code"><pre><span class="line">  c.counters[name]++</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  c := Container&#123;counters: <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>&#123;<span class="string">"a"</span>: <span class="number">0</span>, <span class="string">"b"</span>: <span class="number">0</span>&#125;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  doIncrement := <span class="function"><span class="keyword">func</span><span class="params">(name <span class="keyword">string</span>, n <span class="keyword">int</span>)</span></span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      c.inc(name)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">go</span> doIncrement(<span class="string">"a"</span>, <span class="number">100000</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">go</span> doIncrement(<span class="string">"a"</span>, <span class="number">100000</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// Wait a bit for the goroutines to finish</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  time.Sleep(<span class="number">300</span> * time.Millisecond)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  fmt.Println(c.counters)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>你预期的输出结果会是什么呢？我得到了如下输出：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">fatal error: concurrent <span class="keyword">map</span> writes</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">goroutine <span class="number">5</span> [running]:</span></pre></td></tr><tr><td class="code"><pre><span class="line">runtime.throw(<span class="number">0x4b765b</span>, <span class="number">0x15</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&lt;...&gt; more goroutine stacks</span></pre></td></tr><tr><td class="code"><pre><span class="line">exit status <span class="number">2</span></span></pre></td></tr></table></figure>
<p>我们已经很小心地使用锁保护共享变量，那到底是哪里出错了？你能看出来如何去修复这个错误吗？提示：只需要一个字符的变动即可。<br>这段代码的问题在于 inc 方法定义在了 Container 上，而不是 *Container，因此每次调用 inc 方法 Container 实例都会被复制一次。换种说法，inc 是一个值接收器而不是指针接收器。因此 inc 的每次调用并不能真正修改最初的 Container 实例。<br>但是，等一下，既然如此，那为什么我们的第一个例子能够正常工作呢？在只有一个 goroutine 的例子中，我们也是按值传递了 c 到 inc 函数，但是它确实起作用了。main 函数确实观察到了 inc 函数对映射表的修改。这是因为映射表比较特殊：它是引用类型，而不是值类型。存在 Container 中的并不是真正的映射表的数据，而是一个指向映射表数据的指针。因此，就算我们创建了一个 Container 的副本，它的 counters 成员仍然保存了相同映射表数据的地址。<br>所以说第一个例子的代码也是错误的。尽管这段代码可以工作，但它显然违反了 Go 社区的<a href="https://golang.org/doc/faq#methods_on_values_or_pointers" target="_blank" rel="external nofollow noopener noreferrer">编程指南</a>：修改对象内容的方法应该定义在类型指针上，而不是类型值上。这里使用映射表给我造成了一个安全上的错觉。作为练习，尝试使用单个 int 类型的计数器替代最初例子中的映射表，然后注意 inc 方法只是修改了计数器的副本，所以在 main 函数中看不到这种修改的效果。<br>Mutex 是值类型（参见 <a href="https://golang.org/src/sync/mutex.go" target="_blank" rel="external nofollow noopener noreferrer">Go 源码</a>中的定义，注释中很清楚地写明了不要拷贝互斥锁），因此拷贝是错误的行为。拷贝只是创建了一个完全不同的新的互斥锁，因此它的互斥功能不再有效。<br>因此，针对上述代码的一个字符的修正就是在定义 inc 方法时在 Container 前添加一个 * 号：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Container)</span> <span class="title">inc</span><span class="params">(name <span class="keyword">string</span>)</span></span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  c.Lock()</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">defer</span> c.Unlock()</span></pre></td></tr><tr><td class="code"><pre><span class="line">  c.counters[name]++</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>这样， 就会将 c 的指针传入 inc 方法，实际上是对调用方持有的内存中同一个 Container 实例的引用。<br>这不是一个少见的错误。实际上， go vet 会对此发出警告：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">$ <span class="keyword">go</span> tool vet method-mutex-value-receiver.<span class="keyword">go</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">method-mutex-value-receiver.<span class="keyword">go</span>:<span class="number">19</span>: inc passes lock by value: main.Container</span></pre></td></tr></table></figure>
<p>这种情况经常出现在 HTTP 处理函数中，这些处理函数在不需要开发人员显示使用 go 语句的情况下被并发地调用。我会在随后的博文中详述这一点。<br>我觉得这个问题对于认识 Go 语言中的值接收器和指针接收器的区别有很大的帮助。为了把问题说清楚，下面给出一个和之前代码无关的示例。这个例子用到了 Go 中使用 &amp; 操作符创建指针和使用 %p 格式化输出指针值的功能：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Container <span class="keyword">struct</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  i <span class="keyword">int</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  s <span class="keyword">string</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c Container)</span> <span class="title">byValMethod</span><span class="params">()</span></span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  fmt.Printf(<span class="string">"byValMethod got &amp;c=%p, &amp;(c.s)=%p\n"</span>, &amp;c, &amp;(c.s))</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Container)</span> <span class="title">byPtrMethod</span><span class="params">()</span></span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  fmt.Printf(<span class="string">"byPtrMethod got &amp;c=%p, &amp;(c.s)=%p\n"</span>, c, &amp;(c.s))</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">var</span> c Container</span></pre></td></tr><tr><td class="code"><pre><span class="line">  fmt.Printf(<span class="string">"in main &amp;c=%p, &amp;(c.s)=%p\n"</span>, &amp;c, &amp;(c.s))</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  c.byValMethod()</span></pre></td></tr><tr><td class="code"><pre><span class="line">  c.byPtrMethod()</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>输出结果如下（这是在我的电脑上的输出，和你电脑上的变量地址可能不一样，但是地址之间的关系是一样的）：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">in main &amp;c=<span class="number">0xc00000a060</span>, &amp;(c.s)=<span class="number">0xc00000a068</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">byValMethod got &amp;c=<span class="number">0xc00000a080</span>, &amp;(c.s)=<span class="number">0xc00000a088</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">byPtrMethod got &amp;c=<span class="number">0xc00000a060</span>, &amp;(c.s)=<span class="number">0xc00000a068</span></span></pre></td></tr></table></figure>
<p>main 函数创建了一个 Container 实例并打印出了实例的地址及实例成员变量 s 的地址，接着调用了实例的两个方法。<br>byValMethod 方法有一个值接收器，它打印出的地址和 main 函数中打印出的不一样因为接收到的是 c 的一个副本。另一方面，byPtrMethod 方法有一个指针接收器并且它观察到的地址和 main 函数中的一致，因为它获取到的是最初的 c，而不是一个副本。</p>
<p><a name="xK7hi"></a></p>
<h3 id="译者补充"><a href="#译者补充" class="headerlink" title="译者补充"></a>译者补充</h3><p><a name="mCRS2"></a></p>
<h4 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h4><p>Go 语言中还有一种锁：读写锁（RWMutex），读写锁也是值类型，也不能拷贝。</p>
]]></content>
      <categories>
        <category>译文</category>
      </categories>
      <tags>
        <tag>译文</tag>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>Ceph 常用操作</title>
    <url>/post/e8bac896.html</url>
    <content><![CDATA[<p><a name="BdT88"></a></p><h4 id="删除-rbd-image-时提示有-watcher"><a href="#删除-rbd-image-时提示有-watcher" class="headerlink" title="删除 rbd image 时提示有 watcher"></a>删除 rbd image 时提示有 watcher</h4><p>查看该 image 信息</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@openstack-compute-02:~<span class="comment"># rbd info vm-109-cloudinit --pool cloud-disk</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">rbd image <span class="string">'vm-109-cloudinit'</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">        size 4 MiB <span class="keyword">in</span> 1 objects</span></pre></td></tr><tr><td class="code"><pre><span class="line">        order 22 (4 MiB objects)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        snapshot_count: 0</span></pre></td></tr><tr><td class="code"><pre><span class="line">        id: 85a71142d8c136</span></pre></td></tr><tr><td class="code"><pre><span class="line">        block_name_prefix: rbd_data.85a71142d8c136</span></pre></td></tr><tr><td class="code"><pre><span class="line">        format: 2</span></pre></td></tr><tr><td class="code"><pre><span class="line">        features: layering, exclusive-lock, object-map, fast-diff, deep-flatten</span></pre></td></tr><tr><td class="code"><pre><span class="line">        op_features: </span></pre></td></tr><tr><td class="code"><pre><span class="line">        flags: </span></pre></td></tr><tr><td class="code"><pre><span class="line">        create_timestamp: Wed Aug 28 10:04:09 2019</span></pre></td></tr><tr><td class="code"><pre><span class="line">        access_timestamp: Mon Sep  2 13:59:31 2019</span></pre></td></tr><tr><td class="code"><pre><span class="line">        modify_timestamp: Mon Sep  2 13:59:31 2019</span></pre></td></tr></table></figure><a id="more"></a>



<p>从 info 中 block_name_prefix: rbd_data.85a71142d8c136 获知 rados 对象名称为 rbd_header.85a71142d8c136 ，然后列出对象所有 watcher：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@openstack-compute-02:~<span class="comment"># rados listwatchers --pool cloud-disk rbd_header.85a71142d8c136</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">watcher=192.168.180.116:0/2072981162 client.27537920 cookie=139876735669120</span></pre></td></tr></table></figure>

<p>或者直接通过 rbd 命令列出 watcher：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@openstack-compute-02:~<span class="comment"># rbd status --pool cloud-disk vm-109-cloudinit</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Watchers:</span></pre></td></tr><tr><td class="code"><pre><span class="line">        watcher=192.168.180.116:0/2072981162 client.27537920 cookie=139876735669120</span></pre></td></tr></table></figure>

<p>将 watcher 加入黑名单：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ceph osd blacklist add 192.168.180.116:0/2072981162</span></pre></td></tr></table></figure>

<p>此时再次查看 image 的 watcher ：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@openstack-compute-02:~<span class="comment"># rbd status --pool cloud-disk vm-109-cloudinit</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Watchers: none</span></pre></td></tr></table></figure>

<p>没有了 watcher 我们就可以继续删除该 image ：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rbd rm --pool cloud-disk vm-109-cloudinit</span></pre></td></tr></table></figure>

<p>然后将 watcher 从黑名单剔除或者不手动操作，默认1个小时后自动恢复：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@openstack-compute-02:~<span class="comment"># ceph osd blacklist ls</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">listed 1 entries</span></pre></td></tr><tr><td class="code"><pre><span class="line">192.168.180.116:0/2072981162 2019-09-03 11:19:24.466205</span></pre></td></tr><tr><td class="code"><pre><span class="line">root@openstack-compute-02:~<span class="comment"># ceph osd blacklist rm 192.168.180.116:0/2072981162</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">un-blacklisting 192.168.180.116:0/2072981162</span></pre></td></tr><tr><td class="code"><pre><span class="line">root@openstack-compute-02:~<span class="comment"># ceph osd blacklist clear</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"> removed all blacklist entries</span></pre></td></tr><tr><td class="code"><pre><span class="line">root@openstack-compute-02:~<span class="comment"># ceph osd blacklist ls</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">listed 0 entries</span></pre></td></tr></table></figure>

<p><a name="uB6Bh"></a></p>
<h4 id="scrub-errors-修复"><a href="#scrub-errors-修复" class="headerlink" title="scrub errors 修复"></a>scrub errors 修复</h4><p>错误如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@umstor21:~<span class="comment"># ceph -s</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  cluster:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    id:     d6aadfd6-9e08-4000-98bd-a5a14f59ef97</span></pre></td></tr><tr><td class="code"><pre><span class="line">    health: HEALTH_ERR</span></pre></td></tr><tr><td class="code"><pre><span class="line">            30 scrub errors</span></pre></td></tr><tr><td class="code"><pre><span class="line">            Reduced data availability: 25 pgs inactive</span></pre></td></tr><tr><td class="code"><pre><span class="line">            Possible data damage: 1 pg inconsistent</span></pre></td></tr><tr><td class="code"><pre><span class="line">            Degraded data redundancy: 60273/2821944 objects degraded (2.136%), 68 pgs degraded, 57 pgs undersized</span></pre></td></tr><tr><td class="code"><pre><span class="line"> </span></pre></td></tr><tr><td class="code"><pre><span class="line">  services:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    mon: 3 daemons, quorum openstack-compute-04,openstack-compute-02,openstack-compute-03 (age 63m)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    mgr: openstack-compute-02(active, since 8d), standbys: openstack-compute-04, openstack-compute-03</span></pre></td></tr><tr><td class="code"><pre><span class="line">    mds: cephfs:1 &#123;0=openstack-compute-04=up:active&#125; 2 up:standby</span></pre></td></tr><tr><td class="code"><pre><span class="line">    osd: 19 osds: 18 up (since 8m), 18 <span class="keyword">in</span> (since 53m); 57 remapped pgs</span></pre></td></tr><tr><td class="code"><pre><span class="line"> </span></pre></td></tr><tr><td class="code"><pre><span class="line">  data:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    pools:   12 pools, 1076 pgs</span></pre></td></tr><tr><td class="code"><pre><span class="line">    objects: 1.41M objects, 5.3 TiB</span></pre></td></tr><tr><td class="code"><pre><span class="line">    usage:   4.9 TiB used, 11 TiB / 16 TiB avail</span></pre></td></tr><tr><td class="code"><pre><span class="line">    pgs:     2.323% pgs not active</span></pre></td></tr><tr><td class="code"><pre><span class="line">             60273/2821944 objects degraded (2.136%)</span></pre></td></tr><tr><td class="code"><pre><span class="line">             1006 active+clean</span></pre></td></tr><tr><td class="code"><pre><span class="line">             32   active+undersized+degraded+remapped+backfill_wait</span></pre></td></tr><tr><td class="code"><pre><span class="line">             18   undersized+degraded+remapped+backfill_wait+peered</span></pre></td></tr><tr><td class="code"><pre><span class="line">             11   active+recovery_wait+degraded</span></pre></td></tr><tr><td class="code"><pre><span class="line">             7    undersized+degraded+remapped+backfilling+peered</span></pre></td></tr><tr><td class="code"><pre><span class="line">             1    active+recovery_wait</span></pre></td></tr><tr><td class="code"><pre><span class="line">             1    active+clean+inconsistent</span></pre></td></tr><tr><td class="code"><pre><span class="line"> </span></pre></td></tr><tr><td class="code"><pre><span class="line">  io:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    recovery: 40 MiB/s, 21 objects/s</span></pre></td></tr></table></figure>

<p>查看详细信息：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@umstor21:~<span class="comment"># ceph health detail</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">HEALTH_ERR 30 scrub errors; Reduced data availability: 25 pgs inactive; Possible data damage: 1 pg inconsistent; Degraded data redundancy: 59572/2821944 objects degraded (2.111%), 68 pgs degraded, 57 pgs undersized</span></pre></td></tr><tr><td class="code"><pre><span class="line">OSD_SCRUB_ERRORS 30 scrub errors</span></pre></td></tr><tr><td class="code"><pre><span class="line">PG_AVAILABILITY Reduced data availability: 25 pgs inactive</span></pre></td></tr><tr><td class="code"><pre><span class="line">    pg 1.1 is stuck inactive <span class="keyword">for</span> 3867.682789, current state undersized+degraded+remapped+backfill_wait+peered, last acting [26]</span></pre></td></tr><tr><td class="code"><pre><span class="line">    pg 1.1b is stuck inactive <span class="keyword">for</span> 3867.800588, current state undersized+degraded+remapped+backfill_wait+peered, last acting [24]</span></pre></td></tr><tr><td class="code"><pre><span class="line">    pg 1.26 is stuck inactive <span class="keyword">for</span> 3867.806862, current state undersized+degraded+remapped+backfill_wait+peered, last acting [6]</span></pre></td></tr><tr><td class="code"><pre><span class="line">    pg 1.35 is stuck inactive <span class="keyword">for</span> 3867.794765, current state undersized+degraded+remapped+backfill_wait+peered, last acting [5]</span></pre></td></tr><tr><td class="code"><pre><span class="line">    pg 1.3a is stuck inactive <span class="keyword">for</span> 3867.628287, current state undersized+degraded+remapped+backfilling+peered, last acting [11]</span></pre></td></tr><tr><td class="code"><pre><span class="line">    pg 1.3e is stuck inactive <span class="keyword">for</span> 3867.807629, current state undersized+degraded+remapped+backfill_wait+peered, last acting [6]</span></pre></td></tr><tr><td class="code"><pre><span class="line">    pg 1.41 is stuck inactive <span class="keyword">for</span> 3867.794638, current state undersized+degraded+remapped+backfill_wait+peered, last acting [24]</span></pre></td></tr><tr><td class="code"><pre><span class="line">    pg 1.4b is stuck inactive <span class="keyword">for</span> 3867.674743, current state undersized+degraded+remapped+backfilling+peered, last acting [26]</span></pre></td></tr><tr><td class="code"><pre><span class="line">    pg 1.5e is stuck inactive <span class="keyword">for</span> 3867.717186, current state undersized+degraded+remapped+backfilling+peered, last acting [10]</span></pre></td></tr><tr><td class="code"><pre><span class="line">    pg 1.64 is stuck inactive <span class="keyword">for</span> 3867.809421, current state undersized+degraded+remapped+backfill_wait+peered, last acting [6]</span></pre></td></tr><tr><td class="code"><pre><span class="line">    pg 1.68 is stuck inactive <span class="keyword">for</span> 3867.806775, current state undersized+degraded+remapped+backfill_wait+peered, last acting [6]</span></pre></td></tr><tr><td class="code"><pre><span class="line">    pg 1.86 is stuck inactive <span class="keyword">for</span> 3867.805018, current state undersized+degraded+remapped+backfill_wait+peered, last acting [6]</span></pre></td></tr><tr><td class="code"><pre><span class="line">    pg 1.8c is stuck inactive <span class="keyword">for</span> 3867.668131, current state undersized+degraded+remapped+backfill_wait+peered, last acting [4]</span></pre></td></tr><tr><td class="code"><pre><span class="line">    pg 1.a4 is stuck inactive <span class="keyword">for</span> 3867.759708, current state undersized+degraded+remapped+backfilling+peered, last acting [22]</span></pre></td></tr><tr><td class="code"><pre><span class="line">    pg 1.c7 is stuck inactive <span class="keyword">for</span> 3867.765074, current state undersized+degraded+remapped+backfill_wait+peered, last acting [22]</span></pre></td></tr><tr><td class="code"><pre><span class="line">    pg 1.d9 is stuck inactive <span class="keyword">for</span> 3867.588416, current state undersized+degraded+remapped+backfilling+peered, last acting [12]</span></pre></td></tr><tr><td class="code"><pre><span class="line">    pg 1.f9 is stuck inactive <span class="keyword">for</span> 3867.797908, current state undersized+degraded+remapped+backfill_wait+peered, last acting [5]</span></pre></td></tr><tr><td class="code"><pre><span class="line">    pg 1.148 is stuck inactive <span class="keyword">for</span> 3867.800417, current state undersized+degraded+remapped+backfill_wait+peered, last acting [24]</span></pre></td></tr><tr><td class="code"><pre><span class="line">    pg 1.14b is stuck inactive <span class="keyword">for</span> 3867.807076, current state undersized+degraded+remapped+backfill_wait+peered, last acting [6]</span></pre></td></tr><tr><td class="code"><pre><span class="line">    pg 1.15e is stuck inactive <span class="keyword">for</span> 3867.716724, current state undersized+degraded+remapped+backfill_wait+peered, last acting [10]</span></pre></td></tr><tr><td class="code"><pre><span class="line">    pg 1.164 is stuck inactive <span class="keyword">for</span> 3867.760788, current state undersized+degraded+remapped+backfill_wait+peered, last acting [22]</span></pre></td></tr><tr><td class="code"><pre><span class="line">    pg 1.177 is stuck inactive <span class="keyword">for</span> 3867.795676, current state undersized+degraded+remapped+backfilling+peered, last acting [5]</span></pre></td></tr><tr><td class="code"><pre><span class="line">    pg 1.17e is stuck inactive <span class="keyword">for</span> 3867.809061, current state undersized+degraded+remapped+backfill_wait+peered, last acting [6]</span></pre></td></tr><tr><td class="code"><pre><span class="line">    pg 1.181 is stuck inactive <span class="keyword">for</span> 3867.669194, current state undersized+degraded+remapped+backfilling+peered, last acting [4]</span></pre></td></tr><tr><td class="code"><pre><span class="line">    pg 1.1ce is stuck inactive <span class="keyword">for</span> 3867.757812, current state undersized+degraded+remapped+backfill_wait+peered, last acting [22]</span></pre></td></tr><tr><td class="code"><pre><span class="line">PG_DAMAGED Possible data damage: 1 pg inconsistent</span></pre></td></tr><tr><td class="code"><pre><span class="line">    pg 1.8d is active+clean+inconsistent, acting [6,11]</span></pre></td></tr><tr><td class="code"><pre><span class="line">PG_DEGRADED Degraded data redundancy: 59572/2821944 objects degraded (2.111%), 68 pgs degraded, 57 pgs undersized</span></pre></td></tr><tr><td class="code"><pre><span class="line">    pg 1.1 is stuck undersized <span class="keyword">for</span> 564.241756, current state undersized+degraded+remapped+backfill_wait+peered, last acting [26]</span></pre></td></tr><tr><td class="code"><pre><span class="line">    pg 1.1b is stuck undersized <span class="keyword">for</span> 3264.748374, current state undersized+degraded+remapped+backfill_wait+peered, last acting [24]</span></pre></td></tr><tr><td class="code"><pre><span class="line">    pg 1.26 is stuck undersized <span class="keyword">for</span> 564.326041, current state undersized+degraded+remapped+backfill_wait+peered, last acting [6]</span></pre></td></tr><tr><td class="code"><pre><span class="line">    pg 1.35 is stuck undersized <span class="keyword">for</span> 564.277686, current state undersized+degraded+remapped+backfill_wait+peered, last acting [5]</span></pre></td></tr><tr><td class="code"><pre><span class="line">    pg 1.3a is stuck undersized <span class="keyword">for</span> 3264.718236, current state undersized+degraded+remapped+backfilling+peered, last acting [11]</span></pre></td></tr><tr><td class="code"><pre><span class="line">    pg 1.3e is stuck undersized <span class="keyword">for</span> 564.326326, current state undersized+degraded+remapped+backfill_wait+peered, last acting [6]</span></pre></td></tr><tr><td class="code"><pre><span class="line">    pg 1.41 is stuck undersized <span class="keyword">for</span> 3264.744338, current state undersized+degraded+remapped+backfill_wait+peered, last acting [24]</span></pre></td></tr><tr><td class="code"><pre><span class="line">    pg 1.4b is stuck undersized <span class="keyword">for</span> 3264.740569, current state undersized+degraded+remapped+backfilling+peered, last acting [26]</span></pre></td></tr><tr><td class="code"><pre><span class="line">    pg 1.5e is stuck undersized <span class="keyword">for</span> 3264.315873, current state undersized+degraded+remapped+backfilling+peered, last acting [10]</span></pre></td></tr><tr><td class="code"><pre><span class="line">    pg 1.64 is stuck undersized <span class="keyword">for</span> 3264.792433, current state undersized+degraded+remapped+backfill_wait+peered, last acting [6]</span></pre></td></tr><tr><td class="code"><pre><span class="line">    pg 1.68 is stuck undersized <span class="keyword">for</span> 567.346719, current state undersized+degraded+remapped+backfill_wait+peered, last acting [6]</span></pre></td></tr><tr><td class="code"><pre><span class="line">    pg 1.86 is stuck undersized <span class="keyword">for</span> 3264.777395, current state undersized+degraded+remapped+backfill_wait+peered, last acting [6]</span></pre></td></tr><tr><td class="code"><pre><span class="line">    pg 1.8c is stuck undersized <span class="keyword">for</span> 3264.756387, current state undersized+degraded+remapped+backfill_wait+peered, last acting [4]</span></pre></td></tr><tr><td class="code"><pre><span class="line">    pg 1.a4 is stuck undersized <span class="keyword">for</span> 3264.668182, current state undersized+degraded+remapped+backfilling+peered, last acting [22]</span></pre></td></tr><tr><td class="code"><pre><span class="line">    pg 1.15e is stuck undersized <span class="keyword">for</span> 3264.387945, current state undersized+degraded+remapped+backfill_wait+peered, last acting [10]</span></pre></td></tr><tr><td class="code"><pre><span class="line">    pg 1.164 is stuck undersized <span class="keyword">for</span> 3264.727217, current state undersized+degraded+remapped+backfill_wait+peered, last acting [22]</span></pre></td></tr><tr><td class="code"><pre><span class="line">    pg 1.177 is stuck undersized <span class="keyword">for</span> 564.278243, current state undersized+degraded+remapped+backfilling+peered, last acting [5]</span></pre></td></tr><tr><td class="code"><pre><span class="line">    pg 1.17e is stuck undersized <span class="keyword">for</span> 3264.792153, current state undersized+degraded+remapped+backfill_wait+peered, last acting [6]</span></pre></td></tr><tr><td class="code"><pre><span class="line">    pg 1.181 is stuck undersized <span class="keyword">for</span> 3264.761056, current state undersized+degraded+remapped+backfilling+peered, last acting [4]</span></pre></td></tr><tr><td class="code"><pre><span class="line">    pg 1.1ce is stuck undersized <span class="keyword">for</span> 3264.675284, current state undersized+degraded+remapped+backfill_wait+peered, last acting [22]</span></pre></td></tr><tr><td class="code"><pre><span class="line">    pg 5.9 is active+recovery_wait+degraded, acting [22,8,14]</span></pre></td></tr><tr><td class="code"><pre><span class="line">    pg 5.11 is active+recovery_wait+degraded, acting [8,4,24]</span></pre></td></tr><tr><td class="code"><pre><span class="line">    pg 5.21 is active+recovery_wait+degraded, acting [4,5,26]</span></pre></td></tr><tr><td class="code"><pre><span class="line">    pg 5.2f is active+recovery_wait+degraded, acting [8,2,22]</span></pre></td></tr><tr><td class="code"><pre><span class="line">    pg 5.3f is active+recovery_wait+degraded, acting [9,12,0]</span></pre></td></tr><tr><td class="code"><pre><span class="line">    pg 5.4c is active+recovery_wait+degraded, acting [9,26,1]</span></pre></td></tr><tr><td class="code"><pre><span class="line">    pg 5.50 is active+recovery_wait+degraded, acting [24,9,0]</span></pre></td></tr><tr><td class="code"><pre><span class="line">    pg 5.51 is active+recovery_wait+degraded, acting [22,12,3]</span></pre></td></tr><tr><td class="code"><pre><span class="line">    pg 5.55 is active+recovery_wait+degraded, acting [4,11,9]</span></pre></td></tr><tr><td class="code"><pre><span class="line">    pg 7.7 is active+recovery_wait+degraded, acting [24,10,5]</span></pre></td></tr><tr><td class="code"><pre><span class="line">    pg 9.3 is stuck undersized <span class="keyword">for</span> 3264.586508, current state active+undersized+degraded+remapped+backfill_wait, last acting [9,6]</span></pre></td></tr><tr><td class="code"><pre><span class="line">    pg 12.3 is stuck undersized <span class="keyword">for</span> 3264.749745, current state active+undersized+degraded+remapped+backfill_wait, last acting [24,12]</span></pre></td></tr><tr><td class="code"><pre><span class="line">    pg 12.5 is stuck undersized <span class="keyword">for</span> 3264.749762, current state active+undersized+degraded+remapped+backfill_wait, last acting [24,12]</span></pre></td></tr><tr><td class="code"><pre><span class="line">    pg 12.18 is stuck undersized <span class="keyword">for</span> 3264.586508, current state active+undersized+degraded+remapped+backfill_wait, last acting [9,10]</span></pre></td></tr><tr><td class="code"><pre><span class="line">    pg 12.1d is stuck undersized <span class="keyword">for</span> 3264.671133, current state active+undersized+degraded+remapped+backfill_wait, last acting [22,2]</span></pre></td></tr><tr><td class="code"><pre><span class="line">    pg 12.2c is stuck undersized <span class="keyword">for</span> 565.278100, current state active+undersized+degraded+remapped+backfill_wait, last acting [5,2]</span></pre></td></tr><tr><td class="code"><pre><span class="line">    pg 12.31 is stuck undersized <span class="keyword">for</span> 3264.439978, current state active+undersized+degraded+remapped+backfill_wait, last acting [10,26]</span></pre></td></tr><tr><td class="code"><pre><span class="line">    pg 12.3b is stuck undersized <span class="keyword">for</span> 3264.791588, current state active+undersized+degraded+remapped+backfill_wait, last acting [6,11]</span></pre></td></tr><tr><td class="code"><pre><span class="line">    pg 12.3c is stuck undersized <span class="keyword">for</span> 3264.749388, current state active+undersized+degraded+remapped+backfill_wait, last acting [3,26]</span></pre></td></tr><tr><td class="code"><pre><span class="line">    pg 12.68 is stuck undersized <span class="keyword">for</span> 3264.750611, current state active+undersized+degraded+remapped+backfill_wait, last acting [26,6]</span></pre></td></tr><tr><td class="code"><pre><span class="line">    pg 12.74 is stuck undersized <span class="keyword">for</span> 565.313175, current state active+undersized+degraded+remapped+backfill_wait, last acting [6,5]</span></pre></td></tr><tr><td class="code"><pre><span class="line">    pg 12.78 is stuck undersized <span class="keyword">for</span> 3264.753912, current state active+undersized+degraded+remapped+backfill_wait, last acting [3,24]</span></pre></td></tr><tr><td class="code"><pre><span class="line">    pg 12.81 is stuck undersized <span class="keyword">for</span> 3264.781922, current state active+undersized+degraded+remapped+backfill_wait, last acting [6,26]</span></pre></td></tr><tr><td class="code"><pre><span class="line">    pg 12.85 is stuck undersized <span class="keyword">for</span> 565.276004, current state active+undersized+degraded+remapped+backfill_wait, last acting [5,26]</span></pre></td></tr><tr><td class="code"><pre><span class="line">    pg 12.8b is stuck undersized <span class="keyword">for</span> 3264.788455, current state active+undersized+degraded+remapped+backfill_wait, last acting [0,23]</span></pre></td></tr><tr><td class="code"><pre><span class="line">    pg 12.8c is stuck undersized <span class="keyword">for</span> 3264.721783, current state active+undersized+degraded+remapped+backfill_wait, last acting [12,0]</span></pre></td></tr><tr><td class="code"><pre><span class="line">    pg 12.8e is stuck undersized <span class="keyword">for</span> 567.299698, current state active+undersized+degraded+remapped+backfill_wait, last acting [8,22]</span></pre></td></tr><tr><td class="code"><pre><span class="line">    pg 12.94 is stuck undersized <span class="keyword">for</span> 565.277670, current state active+undersized+degraded+remapped+backfill_wait, last acting [5,23]</span></pre></td></tr><tr><td class="code"><pre><span class="line">    pg 12.a0 is stuck undersized <span class="keyword">for</span> 568.309205, current state active+undersized+degraded+remapped+backfill_wait, last acting [26,1]</span></pre></td></tr><tr><td class="code"><pre><span class="line">    pg 12.a3 is active+undersized+degraded+remapped+backfill_wait, acting [12,4]</span></pre></td></tr><tr><td class="code"><pre><span class="line">    pg 15.1 is active+recovery_wait+degraded, acting [3,9,6]</span></pre></td></tr></table></figure>

<p>修复 pg</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ceph pg repair &lt;pg_id&gt;</span></pre></td></tr></table></figure>

<p><a name="RAYxC"></a></p>
<h4 id="删除-Monitor"><a href="#删除-Monitor" class="headerlink" title="删除 Monitor"></a>删除 Monitor</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl stop ceph-mon@openstack-compute-02.service</span></pre></td></tr><tr><td class="code"><pre><span class="line">ceph mon remove openstack-compute-02</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 移除 ceph.conf 中的相关信息</span></pre></td></tr></table></figure>

<p><a name="0zXsv"></a></p>
<h4 id="ceph-ansible-部署"><a href="#ceph-ansible-部署" class="headerlink" title="ceph-ansible 部署"></a>ceph-ansible 部署</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/ceph/ceph-ansible.git</span></pre></td></tr><tr><td class="code"><pre><span class="line">git checkout v4.0.0</span></pre></td></tr><tr><td class="code"><pre><span class="line">// 在部署节点安装</span></pre></td></tr><tr><td class="code"><pre><span class="line">yum install -y ansible python-notario</span></pre></td></tr><tr><td class="code"><pre><span class="line">rpm -i http://download-ib01.fedoraproject.org/pub/epel/testing/7/x86_64/Packages/p/python2-notario-0.0.14-1.el7.noarch.rpm</span></pre></td></tr><tr><td class="code"><pre><span class="line">// 在所有节点安装</span></pre></td></tr><tr><td class="code"><pre><span class="line">yum install -y python-netaddr</span></pre></td></tr></table></figure>
<p>cd  到 ceph-ansible ， 创建 hosts 文件如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[CephGroup:children]</span></pre></td></tr><tr><td class="code"><pre><span class="line">mons</span></pre></td></tr><tr><td class="code"><pre><span class="line">osds</span></pre></td></tr><tr><td class="code"><pre><span class="line">mdss</span></pre></td></tr><tr><td class="code"><pre><span class="line">mgrs</span></pre></td></tr><tr><td class="code"><pre><span class="line">rgws</span></pre></td></tr><tr><td class="code"><pre><span class="line">[CephGroup:vars]</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 最好事先配好免密</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">ansible_ssh_user=root</span></pre></td></tr><tr><td class="code"><pre><span class="line">ansible_ssh_pass=<span class="built_in">test</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">ansible_port=22</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">[mons]</span></pre></td></tr><tr><td class="code"><pre><span class="line">ceph-csi-01</span></pre></td></tr><tr><td class="code"><pre><span class="line">ceph-csi-02</span></pre></td></tr><tr><td class="code"><pre><span class="line">ceph-csi-03</span></pre></td></tr><tr><td class="code"><pre><span class="line">[osds]</span></pre></td></tr><tr><td class="code"><pre><span class="line">ceph-csi-01</span></pre></td></tr><tr><td class="code"><pre><span class="line">ceph-csi-02</span></pre></td></tr><tr><td class="code"><pre><span class="line">ceph-csi-03</span></pre></td></tr><tr><td class="code"><pre><span class="line">[mdss]</span></pre></td></tr><tr><td class="code"><pre><span class="line">ceph-csi-01</span></pre></td></tr><tr><td class="code"><pre><span class="line">ceph-csi-02</span></pre></td></tr><tr><td class="code"><pre><span class="line">ceph-csi-03</span></pre></td></tr><tr><td class="code"><pre><span class="line">[mgrs]</span></pre></td></tr><tr><td class="code"><pre><span class="line">ceph-csi-01</span></pre></td></tr><tr><td class="code"><pre><span class="line">ceph-csi-02</span></pre></td></tr><tr><td class="code"><pre><span class="line">ceph-csi-03</span></pre></td></tr><tr><td class="code"><pre><span class="line">[rgws]</span></pre></td></tr><tr><td class="code"><pre><span class="line">ceph-csi-01</span></pre></td></tr><tr><td class="code"><pre><span class="line">ceph-csi-02</span></pre></td></tr><tr><td class="code"><pre><span class="line">ceph-csi-03</span></pre></td></tr></table></figure>
<p>cd 到 group_vars 目录：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cp all.yml.sample all.yml</span></pre></td></tr><tr><td class="code"><pre><span class="line">// 取消注释并修改以下字段</span></pre></td></tr><tr><td class="code"><pre><span class="line">ceph_origin: repository</span></pre></td></tr><tr><td class="code"><pre><span class="line">ceph_repository: community</span></pre></td></tr><tr><td class="code"><pre><span class="line">ceph_stable_release: nautilus</span></pre></td></tr><tr><td class="code"><pre><span class="line">monitor_interface: eth0</span></pre></td></tr><tr><td class="code"><pre><span class="line">public_network: 10.23.0.0/16</span></pre></td></tr><tr><td class="code"><pre><span class="line">radosgw_interface: eth0</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">cp osd.yml.sample osd.yml</span></pre></td></tr><tr><td class="code"><pre><span class="line">// 添加安装盘信息</span></pre></td></tr><tr><td class="code"><pre><span class="line">devices:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  - /dev/vdb</span></pre></td></tr><tr><td class="code"><pre><span class="line">  - /dev/vdc</span></pre></td></tr><tr><td class="code"><pre><span class="line">  - /dev/vdd</span></pre></td></tr></table></figure>
<p>回到项目根目录执行安装:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ansible-playbook -i hosts -v site.yml</span></pre></td></tr></table></figure>

<p><a name="BMg3M"></a></p>
<h4 id="ceph-ansible-添加-osd"><a href="#ceph-ansible-添加-osd" class="headerlink" title="ceph-ansible 添加 osd"></a>ceph-ansible 添加 osd</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &#x2F;opt&#x2F;ceph-ansible</span></pre></td></tr><tr><td class="code"><pre><span class="line">cp infrastructure-playbooks&#x2F;add-osd.yml .&#x2F;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 修改 group_vars&#x2F;all.yml 磁盘信息</span></pre></td></tr><tr><td class="code"><pre><span class="line">ansible-playbook -vv -i hosts --limit 192.168.203.143 add-osd.yml</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 新增一个 osd 宿主节点和在已有的 osd 节点上增加一块盘步骤一样</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 添加完 osd 如果卡在 restart osd daemon 可通过执行以下命令解决</span></pre></td></tr><tr><td class="code"><pre><span class="line">ceph osd unset noup</span></pre></td></tr></table></figure>

<p><a name="knNuf"></a></p>
<h4 id="rbd-image-使用"><a href="#rbd-image-使用" class="headerlink" title="rbd image 使用"></a>rbd image 使用</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 创建大小为 1G 的 image</span></pre></td></tr><tr><td class="code"><pre><span class="line">rbd create rbd&#x2F;myimage --size 1024</span></pre></td></tr><tr><td class="code"><pre><span class="line">rbd map rbd&#x2F;myimage</span></pre></td></tr><tr><td class="code"><pre><span class="line">mkfs.xfs &#x2F;dev&#x2F;rbd0</span></pre></td></tr><tr><td class="code"><pre><span class="line">mkdir &#x2F;data</span></pre></td></tr><tr><td class="code"><pre><span class="line">mount &#x2F;dev&#x2F;rbd0 &#x2F;data</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 扩容</span></pre></td></tr><tr><td class="code"><pre><span class="line">rbd resize --image&#x3D;rbd&#x2F;myimage --size 10G</span></pre></td></tr><tr><td class="code"><pre><span class="line">xfs_growfs &#x2F;data</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 卸载</span></pre></td></tr><tr><td class="code"><pre><span class="line">umount &#x2F;data</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 检查占用设备的进程</span></pre></td></tr><tr><td class="code"><pre><span class="line">fuser -m -v &#x2F;dev&#x2F;rbd0</span></pre></td></tr><tr><td class="code"><pre><span class="line">rbd unmap &#x2F;dev&#x2F;rbd0</span></pre></td></tr><tr><td class="code"><pre><span class="line">rbd rm rbd&#x2F;myimage</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; rbd image 转换 format，也可用于 image 复制</span></pre></td></tr><tr><td class="code"><pre><span class="line">rbd export rbd&#x2F;myrbd - | rbd import --image-format 2 - rbd&#x2F;myrbd_v2</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; rbd bench</span></pre></td></tr><tr><td class="code"><pre><span class="line">rados bench -p rbd 20 -b 4K write -t 1 --no-cleanup</span></pre></td></tr><tr><td class="code"><pre><span class="line">rbd create --size 4G test</span></pre></td></tr><tr><td class="code"><pre><span class="line">rbd bench-write test</span></pre></td></tr></table></figure>

<p><a name="Z5LCG"></a></p>
<h4 id="Cinder-创建-Volume-副本并-Boot-with-it"><a href="#Cinder-创建-Volume-副本并-Boot-with-it" class="headerlink" title="Cinder 创建 Volume 副本并 Boot with it"></a>Cinder 创建 Volume 副本并 Boot with it</h4><p>OpenStack: import existing Ceph volumes in Cinder：<a href="https://ceph.com/geen-categorie/openstack-import-existing-ceph-volumes-in-cinder/" target="_blank" rel="external nofollow noopener noreferrer">https://ceph.com/geen-categorie/openstack-import-existing-ceph-volumes-in-cinder/</a></p>
<p><a name="xGnOB"></a></p>
<h4 id="查看并修改-crushmap"><a href="#查看并修改-crushmap" class="headerlink" title="查看并修改 crushmap"></a>查看并修改 crushmap</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 获取集群 crushmap</span></pre></td></tr><tr><td class="code"><pre><span class="line">ceph osd getcrushmap -o &#123;file1&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;file1&#125; 为自定义的文件名，该文件为二进制文件，不可编辑。要想编辑此文件，需要用工具将其反编译解析，如 crushtool 工具。</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">2 反编译 crushmap</span></pre></td></tr><tr><td class="code"><pre><span class="line">crushtool -d &#123;file1&#125; -o &#123;file2&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">反编译二进制文件 &#123;file1&#125; 得到可编辑文件 &#123;file2&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">3. 编辑 crushmap</span></pre></td></tr><tr><td class="code"><pre><span class="line">按自我需求修改可编辑文件 &#123;file2&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">4. 编译 crushmap</span></pre></td></tr><tr><td class="code"><pre><span class="line">要想编辑后的文件机器能够识别，必须用工具编译它生成二进制文件。</span></pre></td></tr><tr><td class="code"><pre><span class="line">crushtool -c &#123;file2&#125; -o &#123;file3&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">5. 注入 crushmap</span></pre></td></tr><tr><td class="code"><pre><span class="line">要想新的 crushmap 在集群中生效，必须将其注入要集群。</span></pre></td></tr><tr><td class="code"><pre><span class="line">ceph osd setcrushmap -i &#123;file3&#125;</span></pre></td></tr></table></figure>
<p>基本理解：<a href="https://www.dovefi.com/post/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3crush1%E7%90%86%E8%A7%A3crush_map%E6%96%87%E4%BB%B6/" target="_blank" rel="external nofollow noopener noreferrer">深入理解 ceph crush (1)—- 理解 crush map 文件</a>／Crush算法：<a href="http://www.xuxiaopang.com/2016/11/08/easy-ceph-CRUSH/" target="_blank" rel="external nofollow noopener noreferrer">大话 Ceph–CRUSH 那点事儿</a>／Crush 查看：<a href="https://www.jianshu.com/p/2355701459e9" target="_blank" rel="external nofollow noopener noreferrer">Ceph 实践之 Crushmap 相关</a>。</p>
<p><a name="7Rb6C"></a></p>
<h4 id="OSD-过度使用内存"><a href="#OSD-过度使用内存" class="headerlink" title="OSD 过度使用内存"></a>OSD 过度使用内存</h4><p>在使用 Bluestore 时，bluestore_cache_autotune 默认已经启用，Bluestore 会将 OSD 堆内存使用量保持在指定的大小之下，通过配置选项 osd_memory_target 来控制，默认为 4G。对于内存较少但 OSD 节点较多的情况，仍然会可能造成内存几乎全部被 OSD 所用，最终致使宿主机死机。可以通过两种方式来缓解这种情况，一种是在启用自动配置时调小 osd_memory_target 值，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[osd]</span></pre></td></tr><tr><td class="code"><pre><span class="line">osd memory target &#x3D; 2147483648</span></pre></td></tr></table></figure>
<p>另一种是禁用自动配置并手动指定缓存大小：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[osd]</span></pre></td></tr><tr><td class="code"><pre><span class="line">bluestore_cache_autotune &#x3D; False</span></pre></td></tr><tr><td class="code"><pre><span class="line">bluestore_min_alloc_size_ssd &#x3D; 32768</span></pre></td></tr><tr><td class="code"><pre><span class="line">bluestore_min_alloc_size_hdd &#x3D; 32768</span></pre></td></tr><tr><td class="code"><pre><span class="line">bluestore_min_alloc_size &#x3D; 32768</span></pre></td></tr><tr><td class="code"><pre><span class="line">bluestore_cache_kv_max &#x3D; 6442450944</span></pre></td></tr><tr><td class="code"><pre><span class="line">bluestore_cache_kv_ratio &#x3D; 0.990000</span></pre></td></tr><tr><td class="code"><pre><span class="line">bluestore_cache_meta_ratio &#x3D; 0.010000</span></pre></td></tr><tr><td class="code"><pre><span class="line">bluestore_cache_size &#x3D; 12884901888</span></pre></td></tr><tr><td class="code"><pre><span class="line">bluestore_cache_size_hdd &#x3D; 12884901888</span></pre></td></tr><tr><td class="code"><pre><span class="line">bluestore_cache_size_ssd &#x3D; 12884901888</span></pre></td></tr></table></figure>

<p><a name="SnsuP"></a></p>
<h4 id="ceph-查看存储池-IO"><a href="#ceph-查看存储池-IO" class="headerlink" title="ceph 查看存储池 IO"></a>ceph 查看存储池 IO</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ceph osd pool stats</span></pre></td></tr></table></figure>

<p><a name="x0FF4"></a></p>
<h4 id="ceph-usage"><a href="#ceph-usage" class="headerlink" title="ceph  usage"></a>ceph  usage</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ceph df</span></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>Ceph</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Ceph</tag>
      </tags>
  </entry>
  <entry>
    <title>Kubernetes 实践</title>
    <url>/post/9caa466a.html</url>
    <content><![CDATA[<p><a name="BdT88"></a></p><h4 id="taint"><a href="#taint" class="headerlink" title="taint"></a>taint</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 去除所有节点 mater taint 使之可调度</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">kubectl taint nodes --all node-role.kubernetes.io/master-</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 为节点添加 taint</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">kubectl taint nodes node1 node-role.kubernetes.io=master:NoSchedule</span></pre></td></tr></table></figure><a id="more"></a>


<p><a name="O6MDK"></a></p>
<h4 id="toleration"><a href="#toleration" class="headerlink" title="toleration"></a>toleration</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 容忍所有</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">tolerations:</span></pre></td></tr><tr><td class="code"><pre><span class="line">- operator: <span class="string">"Exists"</span></span></pre></td></tr></table></figure>

<p><a name="QJzQf"></a></p>
<h4 id="etcd"><a href="#etcd" class="headerlink" title="etcd"></a>etcd</h4><ul>
<li>命令行读写</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export ETCDCTL_API&#x3D;3</span></pre></td></tr><tr><td class="code"><pre><span class="line">export ETCDCTL_CACERT&#x3D;&#x2F;etc&#x2F;kubernetes&#x2F;pki&#x2F;etcd&#x2F;ca.crt</span></pre></td></tr><tr><td class="code"><pre><span class="line">export ETCDCTL_CERT&#x3D;&#x2F;etc&#x2F;kubernetes&#x2F;pki&#x2F;etcd&#x2F;healthcheck-client.crt</span></pre></td></tr><tr><td class="code"><pre><span class="line">export ETCDCTL_KEY&#x3D;&#x2F;etc&#x2F;kubernetes&#x2F;pki&#x2F;etcd&#x2F;healthcheck-client.key</span></pre></td></tr><tr><td class="code"><pre><span class="line">export ETCDCTL_ENDPOINTS&#x3D;192.168.180.7:2379,192.168.180.8:2379,192.168.180.9:2379</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 列出所有键值对</span></pre></td></tr><tr><td class="code"><pre><span class="line">etcdctl get &quot;&quot; --prefix&#x3D;true</span></pre></td></tr><tr><td class="code"><pre><span class="line">etcdctl get &quot;&quot; --from-key</span></pre></td></tr></table></figure>

<ul>
<li>备份</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">etcdctl --endpoints&#x3D;https:&#x2F;&#x2F;127.0.0.1:2379 --cacert&#x3D;&#x2F;etc&#x2F;kubernetes&#x2F;pki&#x2F;etcd&#x2F;ca.crt --cert&#x3D;&#x2F;etc&#x2F;kubernetes&#x2F;pki&#x2F;etcd&#x2F;healthcheck-client.crt --key&#x3D;&#x2F;etc&#x2F;kubernetes&#x2F;pki&#x2F;etcd&#x2F;healthcheck-client.key snapshot save etcd-snapshot.db</span></pre></td></tr></table></figure>

<ul>
<li>磁盘读写速度过慢造成的故障</li>
</ul>
<p>如果 etcd pod 的 log 中会存在大量的类似 “etcdserver: read-only range request “key:…” with result “…” took too long (…) to execute” 的报错，大概率是磁盘损坏造成的读写速度过慢导致的，etcd 的数据存储在 /var/lib/etcd 目录下。</p>
<p><a name="kPMVq"></a></p>
<h4 id="证书"><a href="#证书" class="headerlink" title="证书"></a>证书</h4><ul>
<li>为 Ingress Host 生成自签名证书<ul>
<li>简易方法</li>
</ul>
</li>
</ul>
<p>参考：<a href="https://kubernetes.github.io/ingress-nginx/user-guide/tls/" target="_blank" rel="external nofollow noopener noreferrer">https://kubernetes.github.io/ingress-nginx/user-guide/tls/</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">KEY_FILE=dashboard_key</span></pre></td></tr><tr><td class="code"><pre><span class="line">CERT_FILE=dashboard_cert</span></pre></td></tr><tr><td class="code"><pre><span class="line">CERT_NAME=dashboard_tls</span></pre></td></tr><tr><td class="code"><pre><span class="line">HOST=kubernetes-dashboard.test</span></pre></td></tr><tr><td class="code"><pre><span class="line">openssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout <span class="variable">$&#123;KEY_FILE&#125;</span> -out <span class="variable">$&#123;CERT_FILE&#125;</span> -subj <span class="string">"/CN=<span class="variable">$&#123;HOST&#125;</span>/O=<span class="variable">$&#123;HOST&#125;</span>"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">kubectl create secret tls <span class="variable">$&#123;CERT_NAME&#125;</span> --key <span class="variable">$&#123;KEY_FILE&#125;</span> --cert <span class="variable">$&#123;CERT_FILE&#125;</span></span></pre></td></tr></table></figure>

<ul>
<li>定制</li>
</ul>
<p>参考： <a href="https://mritd.me/2017/03/04/how-to-use-nginx-ingress/" target="_blank" rel="external nofollow noopener noreferrer">https://mritd.me/2017/03/04/how-to-use-nginx-ingress/</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 生成 CA 自签证书 ， 也可以直接使用 /etc/kubernetes/pki/ 下的 CA 证书</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">mkdir cert &amp;&amp; <span class="built_in">cd</span> cert</span></pre></td></tr><tr><td class="code"><pre><span class="line">openssl genrsa -out ca-key.pem 2048</span></pre></td></tr><tr><td class="code"><pre><span class="line">openssl req -x509 -new -nodes -key ca-key.pem -days 10000 -out ca.pem -subj <span class="string">"/CN=kube-ca"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 编辑 openssl 配置</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">cp /etc/pki/tls/openssl.cnf .</span></pre></td></tr><tr><td class="code"><pre><span class="line">vim openssl.cnf</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 主要修改如下</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">[req]</span></pre></td></tr><tr><td class="code"><pre><span class="line">req_extensions = v3_req <span class="comment"># 这行默认注释关着的 把注释删掉</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 下面配置是新增的</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">[ v3_req ]</span></pre></td></tr><tr><td class="code"><pre><span class="line">basicConstraints = CA:FALSE</span></pre></td></tr><tr><td class="code"><pre><span class="line">keyUsage = nonRepudiation, digitalSignature, keyEncipherment</span></pre></td></tr><tr><td class="code"><pre><span class="line">subjectAltName = @alt_names</span></pre></td></tr><tr><td class="code"><pre><span class="line">[alt_names]</span></pre></td></tr><tr><td class="code"><pre><span class="line">DNS.1 = harbor.sh.umcloud.network</span></pre></td></tr><tr><td class="code"><pre><span class="line">DNS.2 = gitlab.sh.umcloud.network</span></pre></td></tr><tr><td class="code"><pre><span class="line">DNS.3 = minio.sh.umcloud.network</span></pre></td></tr><tr><td class="code"><pre><span class="line">DNS.4 = registry.sh.umcloud.network</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 生成证书</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">openssl genrsa -out ingress-key.pem 2048</span></pre></td></tr><tr><td class="code"><pre><span class="line">openssl req -new -key ingress-key.pem -out ingress.csr -subj <span class="string">"/CN=kube-ingress"</span> -config openssl.cnf</span></pre></td></tr><tr><td class="code"><pre><span class="line">openssl x509 -req -<span class="keyword">in</span> ingress.csr -CA ca.pem -CAkey ca-key.pem -CAcreateserial -out ingress.pem -days 365 -extensions v3_req -extfile openssl.cnf</span></pre></td></tr><tr><td class="code"><pre><span class="line">kubectl create secret tls gitlab-ce-gitlab-tls --key ingress-key.pem --cert ingress.pem -n gitlab-ce</span></pre></td></tr></table></figure>

<ul>
<li>查看证书内容</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">openssl x509 -in ca.crt -text -noout</span></pre></td></tr><tr><td class="code"><pre><span class="line">openssl s_client -showcerts -connect www.baidu.com:443</span></pre></td></tr></table></figure>

<ul>
<li>检查证书过期时间</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubeadm alpha certs check-expiration</span></pre></td></tr></table></figure>

<p><a name="xUZC5"></a></p>
<h4 id="Kubeadm"><a href="#Kubeadm" class="headerlink" title="Kubeadm"></a>Kubeadm</h4><ul>
<li>kubeadm join … -v 10</li>
</ul>
<p>kubeadm 添加第二个 master 节点时出现以下错误：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">I0724 10:27:10.396559   31977 token.go:141] [discovery] Requesting info from <span class="string">"https://192.168.2.65:6445"</span> again to validate TLS against the pinned public key</span></pre></td></tr><tr><td class="code"><pre><span class="line">I0724 10:27:10.397359   31977 round_trippers.go:419] curl -k -v -XGET  -H <span class="string">"User-Agent: kubeadm/v1.14.1 (linux/amd64) kubernetes/b739410"</span> -H <span class="string">"Accept: application/json, */*"</span> <span class="string">'https://192.168.2.65:6445/api/v1/namespaces/kube-public/configmaps/cluster-info'</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">I0724 10:27:10.403962   31977 round_trippers.go:438] GET https://192.168.2.65:6445/api/v1/namespaces/kube-public/configmaps/cluster-info  <span class="keyword">in</span> 6 milliseconds</span></pre></td></tr><tr><td class="code"><pre><span class="line">I0724 10:27:10.403989   31977 round_trippers.go:444] Response Headers:</span></pre></td></tr><tr><td class="code"><pre><span class="line">I0724 10:27:10.404036   31977 token.go:147] [discovery] Failed to request cluster info, will try again: [Get https://192.168.2.65:6445/api/v1/namespaces/kube-public/configmaps/cluster-info: x509: certificate has expired or is not yet valid]</span></pre></td></tr></table></figure>
<p>错误表明 kubeadm 已经成功从 kube-public 命名空间下的 cluster-info confgimap 中获取到了集群信息，然后在验证集群证书的有效性时出错。<code>x509: certificate has expired or is not yet valid</code> 一般是由于系统时间错误导致，可以先用 date 命令确定本地时间是否正确。如果本地时间错误，可以尝试使用 ntp 同步系统时间。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ntpdate cn.pool.ntp.org</span></pre></td></tr><tr><td class="code"><pre><span class="line">// 如果找不到 ntp 命令，可以使用如下的命令进行安装</span></pre></td></tr><tr><td class="code"><pre><span class="line">yum instal ntp</span></pre></td></tr></table></figure>

<ul>
<li>kubeadm 部署时 config 文件</li>
</ul>
<p>参考：<a href="https://godoc.org/k8s.io/kubernetes/cmd/kubeadm/app/apis/kubeadm/v1beta2" target="_blank" rel="external nofollow noopener noreferrer">https://godoc.org/k8s.io/kubernetes/cmd/kubeadm/app/apis/kubeadm/v1beta2</a>，kubelet 自定义配置参考：<a href="https://godoc.org/k8s.io/kubelet/config/v1beta1#KubeletConfiguration" target="_blank" rel="external nofollow noopener noreferrer">https://godoc.org/k8s.io/kubelet/config/v1beta1#KubeletConfiguration</a>。一个需要注意的地方是<br>一个单 master 节点集群配置参考，需要注意的是虽然在下面的配置中已经设置了 failSwapOn 为 false，但是 kubeadm 并不会去检测该配置，仍然会报错，不过该报错可以被忽略，因为这个设置随后确实会被添加到 kubelet 的配置中并生效，因此 init 时执行 <code>sudo kubeadm init --config kubeadm.yml --ignore-preflight-errors=all</code> 即可：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: kubeadm.k8s.io/v1beta2</span></pre></td></tr><tr><td class="code"><pre><span class="line">imageRepository: gcr.azk8s.cn/google-containers</span></pre></td></tr><tr><td class="code"><pre><span class="line">kind: ClusterConfiguration</span></pre></td></tr><tr><td class="code"><pre><span class="line">kubernetesVersion: v1.16.0</span></pre></td></tr><tr><td class="code"><pre><span class="line">networking:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  serviceSubnet: 10.96.0.0/12</span></pre></td></tr><tr><td class="code"><pre><span class="line">  podSubnet: 10.244.0.0/16</span></pre></td></tr><tr><td class="code"><pre><span class="line">apiServer:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  extraArgs:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">bind</span>-address: 0.0.0.0</span></pre></td></tr><tr><td class="code"><pre><span class="line">    feature-gates: <span class="string">"EphemeralContainers=true"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  extraVolumes:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  - name: <span class="string">"timezone"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    hostPath: <span class="string">"/etc/localtime"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    mountPath: <span class="string">"/etc/localtime"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    readOnly: <span class="literal">true</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    pathType: File</span></pre></td></tr><tr><td class="code"><pre><span class="line">controllerManager:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  extraArgs:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">bind</span>-address: 0.0.0.0</span></pre></td></tr><tr><td class="code"><pre><span class="line">    feature-gates: <span class="string">"EphemeralContainers=true"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  extraVolumes:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  - name: <span class="string">"timezone"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    hostPath: <span class="string">"/etc/localtime"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    mountPath: <span class="string">"/etc/localtime"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    readOnly: <span class="literal">true</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    pathType: File</span></pre></td></tr><tr><td class="code"><pre><span class="line">scheduler:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  extraArgs:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    address: 0.0.0.0</span></pre></td></tr><tr><td class="code"><pre><span class="line">    feature-gates: <span class="string">"EphemeralContainers=true"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  extraVolumes:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  - name: <span class="string">"timezone"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    hostPath: <span class="string">"/etc/localtime"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    mountPath: <span class="string">"/etc/localtime"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    readOnly: <span class="literal">true</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    pathType: File</span></pre></td></tr><tr><td class="code"><pre><span class="line">---</span></pre></td></tr><tr><td class="code"><pre><span class="line">apiVersion: kubeproxy.config.k8s.io/v1alpha1</span></pre></td></tr><tr><td class="code"><pre><span class="line">clusterCIDR: 10.244.0.0/16</span></pre></td></tr><tr><td class="code"><pre><span class="line">iptables:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  masqueradeAll: <span class="literal">false</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  minSyncPeriod: 0s</span></pre></td></tr><tr><td class="code"><pre><span class="line">  syncPeriod: 30s</span></pre></td></tr><tr><td class="code"><pre><span class="line">ipvs:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  excludeCIDRs: null</span></pre></td></tr><tr><td class="code"><pre><span class="line">  minSyncPeriod: 0s</span></pre></td></tr><tr><td class="code"><pre><span class="line">  scheduler: rr</span></pre></td></tr><tr><td class="code"><pre><span class="line">  syncPeriod: 30s</span></pre></td></tr><tr><td class="code"><pre><span class="line">kind: KubeProxyConfiguration</span></pre></td></tr><tr><td class="code"><pre><span class="line">mode: ipvs</span></pre></td></tr><tr><td class="code"><pre><span class="line">---</span></pre></td></tr><tr><td class="code"><pre><span class="line">apiVersion: kubelet.config.k8s.io/v1beta1</span></pre></td></tr><tr><td class="code"><pre><span class="line">cgroupDriver: systemd</span></pre></td></tr><tr><td class="code"><pre><span class="line">failSwapOn: <span class="literal">false</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">kind: KubeletConfiguration</span></pre></td></tr></table></figure>

<ul>
<li>内核配置参考<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[xyc-pc ~]<span class="comment"># cat /etc/modules-load.d/ipvs.conf </span></span></pre></td></tr><tr><td class="code"><pre><span class="line">ip_vs</span></pre></td></tr><tr><td class="code"><pre><span class="line">ip_vs_lc</span></pre></td></tr><tr><td class="code"><pre><span class="line">ip_vs_wlc</span></pre></td></tr><tr><td class="code"><pre><span class="line">ip_vs_rr</span></pre></td></tr><tr><td class="code"><pre><span class="line">ip_vs_wrr</span></pre></td></tr><tr><td class="code"><pre><span class="line">ip_vs_lblc</span></pre></td></tr><tr><td class="code"><pre><span class="line">ip_vs_lblcr</span></pre></td></tr><tr><td class="code"><pre><span class="line">ip_vs_dh</span></pre></td></tr><tr><td class="code"><pre><span class="line">ip_vs_sh</span></pre></td></tr><tr><td class="code"><pre><span class="line">ip_vs_nq</span></pre></td></tr><tr><td class="code"><pre><span class="line">ip_vs_sed</span></pre></td></tr><tr><td class="code"><pre><span class="line">ip_vs_ftp</span></pre></td></tr><tr><td class="code"><pre><span class="line">nf_conntrack</span></pre></td></tr><tr><td class="code"><pre><span class="line">br_netfilter</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">//使其临时生效</span></pre></td></tr><tr><td class="code"><pre><span class="line">ipvs_modules=<span class="string">"ip_vs ip_vs_lc ip_vs_wlc ip_vs_rr ip_vs_wrr ip_vs_lblc ip_vs_lblcr ip_vs_dh ip_vs_sh ip_vs_nq ip_vs_sed ip_vs_ftp nf_conntrack br_netfilter"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> kernel_module <span class="keyword">in</span> <span class="variable">$&#123;ipvs_modules&#125;</span>; <span class="keyword">do</span> modprobe <span class="variable">$&#123;kernel_module&#125;</span> &gt; /dev/null 2&gt;&amp;1;<span class="keyword">done</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">[xyc-pc ~]<span class="comment"># cat /etc/sysctl.conf </span></span></pre></td></tr><tr><td class="code"><pre><span class="line">net.bridge.bridge-nf-call-iptables=1</span></pre></td></tr><tr><td class="code"><pre><span class="line">net.bridge.bridge-nf-call-ip6tables=1</span></pre></td></tr><tr><td class="code"><pre><span class="line">vm.max_map_count=262144</span></pre></td></tr><tr><td class="code"><pre><span class="line">vm.swappiness=0</span></pre></td></tr><tr><td class="code"><pre><span class="line">net.core.somaxconn=32768</span></pre></td></tr><tr><td class="code"><pre><span class="line">net.ipv4.tcp_syncookies=0</span></pre></td></tr><tr><td class="code"><pre><span class="line">net.ipv4.conf.all.rp_filter=1</span></pre></td></tr><tr><td class="code"><pre><span class="line">net.ipv4.ip_forward=1</span></pre></td></tr><tr><td class="code"><pre><span class="line">net.core.default_qdisc=fq_codel</span></pre></td></tr><tr><td class="code"><pre><span class="line">//使其临时生效</span></pre></td></tr><tr><td class="code"><pre><span class="line">sysctl -p /etc/sysctl.conf</span></pre></td></tr></table></figure>

</li>
</ul>
<p><a name="UYIkL"></a></p>
<h4 id="Helm"><a href="#Helm" class="headerlink" title="Helm"></a>Helm</h4><ul>
<li>从模板生成本地文件<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir yamls</span></pre></td></tr><tr><td class="code"><pre><span class="line">helm fetch --untar --untardir . &#39;stable&#x2F;redis&#39; #makes a directory called redis </span></pre></td></tr><tr><td class="code"><pre><span class="line">helm template --output-dir &#39;.&#x2F;yamls&#39; &#39;.&#x2F;redis&#39; #redis dir (local helm chart), export to yamls dir</span></pre></td></tr></table></figure>

</li>
</ul>
<p><a name="O0gNe"></a></p>
<h4 id="ingress-nginx"><a href="#ingress-nginx" class="headerlink" title="ingress-nginx"></a>ingress-nginx</h4><p>为转向上游的请求添加 header：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">apiVersion: extensions/v1beta1</span></pre></td></tr><tr><td class="code"><pre><span class="line">kind: Ingress</span></pre></td></tr><tr><td class="code"><pre><span class="line">metadata:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  annotations:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ingress.kubernetes.io/configuration-snippet: |-</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">set</span> $best_http_host "usergate.dev.choicesaas.cn";</span></pre></td></tr><tr><td class="code"><pre><span class="line">      proxy_set_header Host                   $best_http_host;</span></pre></td></tr><tr><td class="code"><pre><span class="line">...</span></pre></td></tr></table></figure>

<p><a name="sM7pt"></a></p>
<h4 id="使用-subPath-挂载-Volume"><a href="#使用-subPath-挂载-Volume" class="headerlink" title="使用 subPath 挂载 Volume"></a>使用 subPath 挂载 Volume</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apiVersion: apps&#x2F;v1</span></pre></td></tr><tr><td class="code"><pre><span class="line">kind: Deployment</span></pre></td></tr><tr><td class="code"><pre><span class="line">metadata:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  name: mysql</span></pre></td></tr><tr><td class="code"><pre><span class="line">spec:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  selector:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    matchLabels:</span></pre></td></tr><tr><td class="code"><pre><span class="line">      app: mysql</span></pre></td></tr><tr><td class="code"><pre><span class="line">  strategy:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    type: Recreate</span></pre></td></tr><tr><td class="code"><pre><span class="line">  template:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    metadata:</span></pre></td></tr><tr><td class="code"><pre><span class="line">      labels:</span></pre></td></tr><tr><td class="code"><pre><span class="line">        app: mysql</span></pre></td></tr><tr><td class="code"><pre><span class="line">    spec:</span></pre></td></tr><tr><td class="code"><pre><span class="line">      containers:</span></pre></td></tr><tr><td class="code"><pre><span class="line">      - image: mysql:5.6</span></pre></td></tr><tr><td class="code"><pre><span class="line">        name: mysql</span></pre></td></tr><tr><td class="code"><pre><span class="line">        env:</span></pre></td></tr><tr><td class="code"><pre><span class="line">          # Use secret in real usage</span></pre></td></tr><tr><td class="code"><pre><span class="line">        - name: MYSQL_ROOT_PASSWORD</span></pre></td></tr><tr><td class="code"><pre><span class="line">          value: password</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ports:</span></pre></td></tr><tr><td class="code"><pre><span class="line">        - containerPort: 3306</span></pre></td></tr><tr><td class="code"><pre><span class="line">          name: mysql</span></pre></td></tr><tr><td class="code"><pre><span class="line">        volumeMounts:</span></pre></td></tr><tr><td class="code"><pre><span class="line">        - name: mysql-configmap-volume</span></pre></td></tr><tr><td class="code"><pre><span class="line">          mountPath: &#x2F;etc&#x2F;mysql&#x2F;conf.d&#x2F;binlog_format.cnf</span></pre></td></tr><tr><td class="code"><pre><span class="line">          subPath: binlog_format.cnf</span></pre></td></tr><tr><td class="code"><pre><span class="line">      volumes:</span></pre></td></tr><tr><td class="code"><pre><span class="line">      - name: mysql-configmap-volume</span></pre></td></tr><tr><td class="code"><pre><span class="line">        configMap:</span></pre></td></tr><tr><td class="code"><pre><span class="line">          name: mysql-configmap</span></pre></td></tr><tr><td class="code"><pre><span class="line">          items:</span></pre></td></tr><tr><td class="code"><pre><span class="line">          - key: mysql_binlog_format.cnf</span></pre></td></tr><tr><td class="code"><pre><span class="line">            path: binlog_format.cnf</span></pre></td></tr></table></figure>

<p><a name="aFRRf"></a></p>
<h4 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h4><ul>
<li>sealos</li>
</ul>
<p>开发测试可以使用 <a href="https://github.com/fanux/sealos" target="_blank" rel="external nofollow noopener noreferrer">sealos</a> 这个工具，通过离线安装包部署 Kubernetes，省心实用，但是作者在改过的 Kubeadm 代码里夹杂了一些私货令人不喜。</p>
<p><a name="iiFsk"></a></p>
<h4 id="十二因素应用"><a href="#十二因素应用" class="headerlink" title="十二因素应用"></a>十二因素应用</h4><ul>
<li>十二因素的提出早于 Kubernetes 的大规模使用，但是一些因素和基于 Kubernetes 的服务开发部署有着很好的吻合。可参考： <a href="https://skyao.io/learning-cloudnative/factor/" target="_blank" rel="external nofollow noopener noreferrer">https://skyao.io/learning-cloudnative/factor/</a> ，<a href="https://blog.csdn.net/zeb_perfect/article/details/52536411" target="_blank" rel="external nofollow noopener noreferrer">https://blog.csdn.net/zeb_perfect/article/details/52536411</a>， <a href="https://12factor.net/" target="_blank" rel="external nofollow noopener noreferrer">https://12factor.net/</a></li>
<li>关于基准代码的理解：每个应用应该使用单独的代码仓库，如果多个应用有需要共享的基准代码，则应当将这部分共享代码组织为一个单独的代码仓库。<table>
<thead>
<tr>
<th align="center">Factor</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Codebase<br>基准代码</td>
<td align="center">One codebase tracked in revision control, many deploys<br>一份基准代码，多份部署</td>
</tr>
<tr>
<td align="center">Dependencies<br>依赖</td>
<td align="center">Explicitly declare and isolate dependencies<br>显式声明依赖关系</td>
</tr>
<tr>
<td align="center">Config<br>配置</td>
<td align="center">Store config in the environment<br>在环境中存储配置</td>
</tr>
<tr>
<td align="center">Backing services<br>后端服务</td>
<td align="center">Treat backing services as attached resources<br>把后端服务当作附加资源</td>
</tr>
<tr>
<td align="center">Build, release, run<br>构建，发布，运行</td>
<td align="center">Strictly separate build and run stages<br>严格分离构建和运行</td>
</tr>
<tr>
<td align="center">Processes<br>进程</td>
<td align="center">Execute the app as one or more stateless processes<br>以一个或多个无状态进程运行应用</td>
</tr>
<tr>
<td align="center">Port binding<br>端口绑定</td>
<td align="center">Export services via port binding<br>通过端口绑定提供服务</td>
</tr>
<tr>
<td align="center">Concurrency<br>并发</td>
<td align="center">Scale out via the process model<br>通过进程模型进行扩展</td>
</tr>
<tr>
<td align="center">Disposability<br>易处理</td>
<td align="center">Maximize robustness with fast startup and graceful shutdown<br>快速启动和优雅终止可最大化健壮性</td>
</tr>
<tr>
<td align="center">Dev/prod parity<br>开发环境与线上环境等价</td>
<td align="center">Keep development, staging, and production as similar as possible<br>尽可能的保持开发，预发布，线上环境相同</td>
</tr>
<tr>
<td align="center">Logs<br>日志</td>
<td align="center">Treat logs as event streams<br>把日志当作事件流</td>
</tr>
<tr>
<td align="center">Admin processes<br>管理进程</td>
<td align="center">Run admin/management tasks as one-off processes<br>后台管理任务当作一次性进程运行</td>
</tr>
</tbody></table>
</li>
</ul>
<p><a name="COum0"></a></p>
<h4 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h4><ul>
<li>helm init 使用 azure 镜像</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">helm init --stable-repo-url  http:&#x2F;&#x2F;mirror.azure.cn&#x2F;kubernetes&#x2F;charts&#x2F;</span></pre></td></tr><tr><td class="code"><pre><span class="line">helm repo add incubator http:&#x2F;&#x2F;mirror.azure.cn&#x2F;kubernetes&#x2F;charts-incubator&#x2F;</span></pre></td></tr></table></figure>

<ul>
<li>awk 打印第一列</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl get pods -n rook-ceph -owide |grep -i Evicted | awk &#39;&#123;print $1&#125;&#39;| xargs kubectl delete pod -n rook-ceph</span></pre></td></tr></table></figure>

<ul>
<li>cut 获取第一列</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl get pods -n rook-ceph | grep -i Evicted | sed &#39;s&#x2F;\s\s*&#x2F; &#x2F;g&#39; |cut -d&quot; &quot; -f1 | xargs kubectl delete pod -n rook-ceph --force --grace-period&#x3D;0</span></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>Kubernetes</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>ArchLinux 常用命令</title>
    <url>/post/bda105fe.html</url>
    <content><![CDATA[<p><a name="BdT88"></a></p><h4 id="yay-使用相关"><a href="#yay-使用相关" class="headerlink" title="yay 使用相关"></a>yay 使用相关</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装包时覆盖本地已存在文件</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">yay deluge --force</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 查看所有安装的文件及其路径</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">yay -Ql deluge</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 查找时按照指定 filed 排序</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">yay wechat --sortby &lt;votes|popularity|id|baseid|name|base|submitted|modified&gt;</span></pre></td></tr></table></figure><a id="more"></a>


<p><a name="aQrbN"></a></p>
<h4 id="Network-Manage-使用-SSTP-VPN"><a href="#Network-Manage-使用-SSTP-VPN" class="headerlink" title="Network-Manage 使用 SSTP VPN"></a>Network-Manage 使用 SSTP VPN</h4><p>需要安装客户端软件： <code>network-manager-sstp</code></p>
<p><a name="xaHEP"></a></p>
<h4 id="配置-javaws-Web-端访问物理服务器终端"><a href="#配置-javaws-Web-端访问物理服务器终端" class="headerlink" title="配置 javaws Web 端访问物理服务器终端"></a>配置 javaws Web 端访问物理服务器终端</h4><p>到<a href="https://github.com/frekele/oracle-java/releases" target="_blank" rel="external nofollow noopener noreferrer">这里</a>下载 Oracle JDK 并解压，将解压得到的文件夹移动至 jvm 目录，例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">wget https:<span class="comment">//github.com/frekele/oracle-java/releases/download/8u212-b10/jre-8u212-linux-x64.tar.gz</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">tar zxvf jre<span class="number">-8</span>u212-linux-x64.tar.gz</span></pre></td></tr><tr><td class="code"><pre><span class="line">sudo mv /home/xyc/Downloads/jre1<span class="number">.8</span><span class="number">.0</span>_212 /usr/lib/jvm/</span></pre></td></tr></table></figure>
<p>查看已有的 JDK：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">➜  Downloads archlinux-java status                                                                             </span></pre></td></tr><tr><td class="code"><pre><span class="line">Available Java environments:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  java<span class="number">-13</span>-openjdk</span></pre></td></tr><tr><td class="code"><pre><span class="line">  java<span class="number">-8</span>-openjdk/jre</span></pre></td></tr><tr><td class="code"><pre><span class="line">  jre1<span class="number">.8</span><span class="number">.0</span>_212 (<span class="keyword">default</span>)</span></pre></td></tr></table></figure>
<p>设置默认 Java 环境为新添加的 JDK：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">sudo archlinux-java <span class="keyword">set</span> jre1.8.0_212</span></pre></td></tr></table></figure>
<p>修改 <code>/usr/lib/jvm/jre1.8.0_212/lib/security/java.security</code> 文件调整设置为：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">jdk.tls.disabledAlgorithms=NULL</span></pre></td></tr></table></figure>
<p>打开 <code>jcontrol</code> 程序将物理机终端地址加入白名单，如：<code>http://192.168.181.134:80</code>。<br>重新打开浏览器即可。</p>
<p><a name="AM6Pq"></a></p>
<h4 id="pacman-查看软件包安装的文件"><a href="#pacman-查看软件包安装的文件" class="headerlink" title="pacman 查看软件包安装的文件"></a>pacman 查看软件包安装的文件</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bin sudo pacman -Ql cni-plugins</span></pre></td></tr><tr><td class="code"><pre><span class="line">cni-plugins &#x2F;usr&#x2F;</span></pre></td></tr><tr><td class="code"><pre><span class="line">cni-plugins &#x2F;usr&#x2F;lib&#x2F;</span></pre></td></tr><tr><td class="code"><pre><span class="line">cni-plugins &#x2F;usr&#x2F;lib&#x2F;cni&#x2F;</span></pre></td></tr><tr><td class="code"><pre><span class="line">...</span></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>ArchLinux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 实用命令集合</title>
    <url>/post/b489449e.html</url>
    <content><![CDATA[<p><a name="CYJKi"></a></p><h4 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h4><ul>
<li>按指定格式输出Images信息</li>
</ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker images --format <span class="string">"&#123;&#123;.ID&#125;&#125;: &#123;&#123;.Repository&#125;&#125;"</span></span></pre></td></tr></table></figure><table>
<thead>
<tr>
<th align="left">Placeholder</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>.ID</code></td>
<td align="left">Image ID</td>
</tr>
<tr>
<td align="left"><code>.Repository</code></td>
<td align="left">Image repository</td>
</tr>
<tr>
<td align="left"><code>.Tag</code></td>
<td align="left">Image tag</td>
</tr>
</tbody></table><a id="more"></a>



<ul>
<li>使用镜像下载 docker image</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker pull golang:1.13.0 =&gt; docker pull dockerhub.azk8s.cn/library/golang:1.13.0</span></pre></td></tr><tr><td class="code"><pre><span class="line">docker pull rook/ceph:v1.0.6 =&gt; docker pull dockerhub.azk8s.cn/rook/ceph:v1.0.6</span></pre></td></tr><tr><td class="code"><pre><span class="line">docker pull gcr.io/kubernetes-helm/tiller:v2.9.1 =&gt; docker pull gcr.azk8s.cn/kubernetes-helm/tiller:v2.9.1</span></pre></td></tr><tr><td class="code"><pre><span class="line">docker pull k8s.gcr.io/kube-apiserver:v1.14.1 =&gt; docker pull gcr.azk8s.cn/google-containers/kube-apiserver:v1.14.1</span></pre></td></tr><tr><td class="code"><pre><span class="line">docker pull quay.io/k8scsi/csi-node-driver-registrar:v1.1.0 =&gt; docker pull quay.azk8s.cn/k8scsi/csi-node-driver-registrar:v1.1.0</span></pre></td></tr></table></figure>

<ul>
<li>新建容器时加入已有容器网络</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run --name b2 -it --network container:b1 --rm busybox:latest</span></pre></td></tr></table></figure>

<ul>
<li><p>docker 容器的四种网络模型：Bridge, Host, Container, None</p>
<p>   参考： <a href="https://juejin.im/post/5c3363bf6fb9a049e2322cdb" target="_blank" rel="external nofollow noopener noreferrer">Docker 的网络模式详解</a></p>
</li>
<li><p>查看 docker registry 中的镜像信息</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -X GET https:&#x2F;&#x2F;myregistry:5000&#x2F;v2&#x2F;_catalog</span></pre></td></tr><tr><td class="code"><pre><span class="line">curl -X GET https:&#x2F;&#x2F;myregistry:5000&#x2F;v2&#x2F;ubuntu&#x2F;tags&#x2F;list</span></pre></td></tr></table></figure>

<p><a name="LzPfH"></a></p>
<h4 id="CentOS"><a href="#CentOS" class="headerlink" title="CentOS"></a>CentOS</h4><ul>
<li><p>升级系统内核</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rpm --import https://www.elrepo.org/RPM-GPG-KEY-elrepo.org</span></pre></td></tr><tr><td class="code"><pre><span class="line">rpm -Uvh http://www.elrepo.org/elrepo-release-7.0-2.el7.elrepo.noarch.rpm</span></pre></td></tr><tr><td class="code"><pre><span class="line">yum --enablerepo=elrepo-kernel install kernel-ml</span></pre></td></tr><tr><td class="code"><pre><span class="line">awk -F\<span class="string">' '</span><span class="variable">$1</span>==<span class="string">"menuentry "</span> &#123;<span class="built_in">print</span> i++ <span class="string">" : "</span> <span class="variable">$2</span>&#125;<span class="string">' /etc/grub2.cfg</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">grub2-set-default 0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">grub2-mkconfig -o /boot/grub2/grub.cfg</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">reboot</span></span></pre></td></tr></table></figure>
</li>
<li><p>安装fish</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /etc/yum.repos.d/</span></pre></td></tr><tr><td class="code"><pre><span class="line">wget https://download.opensuse.org/repositories/shells:fish:release:2/CentOS_7/shells:fish:release:2.repo</span></pre></td></tr><tr><td class="code"><pre><span class="line">yum install fish -y</span></pre></td></tr></table></figure>
</li>
<li><p>创建网桥</p>
</li>
</ul>
<p>可以直接在配置文件修改，如下创建网桥 br0：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># cat /etc/sysconfig/network-scripts/ifcfg-br0 </span></span></pre></td></tr><tr><td class="code"><pre><span class="line">TYPE=Bridge</span></pre></td></tr><tr><td class="code"><pre><span class="line">BOOTPROTO=static</span></pre></td></tr><tr><td class="code"><pre><span class="line">DEFROUTE=yes</span></pre></td></tr><tr><td class="code"><pre><span class="line">NAME=br0</span></pre></td></tr><tr><td class="code"><pre><span class="line">DEVICE=br0</span></pre></td></tr><tr><td class="code"><pre><span class="line">ONBOOT=yes</span></pre></td></tr><tr><td class="code"><pre><span class="line">IPADDR=192.168.180.136</span></pre></td></tr><tr><td class="code"><pre><span class="line">NETMASK=255.255.255.0</span></pre></td></tr><tr><td class="code"><pre><span class="line">GATEWAY=192.168.180.254</span></pre></td></tr><tr><td class="code"><pre><span class="line">DNS1=114.114.114.114</span></pre></td></tr></table></figure>


<p>加入物理网卡 em1 到网桥</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># cat /etc/sysconfig/network-scripts/ifcfg-em1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">TYPE=Ethernet</span></pre></td></tr><tr><td class="code"><pre><span class="line">BOOTPROTO=static</span></pre></td></tr><tr><td class="code"><pre><span class="line">DEFROUTE=no</span></pre></td></tr><tr><td class="code"><pre><span class="line">NAME=em1</span></pre></td></tr><tr><td class="code"><pre><span class="line">DEVICE=em1</span></pre></td></tr><tr><td class="code"><pre><span class="line">ONBOOT=yes</span></pre></td></tr><tr><td class="code"><pre><span class="line">BRIDGE=br0</span></pre></td></tr></table></figure>


<ul>
<li>创建 veth 并持久化</li>
</ul>
<p>创建两对 veth 并加入到网桥，脚本如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># cat /root/config_veth.sh </span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">ip link add dev veth0 <span class="built_in">type</span> veth peer name veth1</span></pre></td></tr><tr><td class="code"><pre><span class="line">ip link add dev veth2 <span class="built_in">type</span> veth peer name veth3</span></pre></td></tr><tr><td class="code"><pre><span class="line">ip link <span class="built_in">set</span> dev veth0 up</span></pre></td></tr><tr><td class="code"><pre><span class="line">ip link <span class="built_in">set</span> dev veth1 up</span></pre></td></tr><tr><td class="code"><pre><span class="line">ip link <span class="built_in">set</span> dev veth2 up</span></pre></td></tr><tr><td class="code"><pre><span class="line">ip link <span class="built_in">set</span> dev veth3 up</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">exit</span> 0</span></pre></td></tr></table></figure>

<p>执行上述脚本，只是临时创建虚拟网卡，系统重启后又会消失，目前没找到持久化方法，所以只能退而求其次，将上述脚本做成一个服务，在每次系统启动时自动执行以上操作：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># cat /usr/lib/systemd/system/veth.service </span></span></pre></td></tr><tr><td class="code"><pre><span class="line">[Unit]</span></pre></td></tr><tr><td class="code"><pre><span class="line">Description=Create veths</span></pre></td></tr><tr><td class="code"><pre><span class="line">After=network-pre.target dbus.service</span></pre></td></tr><tr><td class="code"><pre><span class="line">Before=network.target network.service</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">[Service]</span></pre></td></tr><tr><td class="code"><pre><span class="line">ExecStart=/root/config_veth.sh</span></pre></td></tr><tr><td class="code"><pre><span class="line">Restart=on-failure</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">[Install]</span></pre></td></tr><tr><td class="code"><pre><span class="line">WantedBy=multi-user.target</span></pre></td></tr></table></figure>

<p>创建完上述文件，不要忘了执行 systemctl enable –now veth 启用服务；而对于虚拟网卡设备的配置仍然放在网络配置文件目录下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># cat /etc/sysconfig/network-scripts/ifcfg-veth0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">DEVICE=veth0</span></pre></td></tr><tr><td class="code"><pre><span class="line">DEVICETYPE=veth</span></pre></td></tr><tr><td class="code"><pre><span class="line">VETH_PEER=veth1</span></pre></td></tr><tr><td class="code"><pre><span class="line">BRIDGE=br0</span></pre></td></tr><tr><td class="code"><pre><span class="line">ONBOOT=yes</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># cat /etc/sysconfig/network-scripts/ifcfg-veth1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">DEVICE=veth1</span></pre></td></tr><tr><td class="code"><pre><span class="line">DEVICETYPE=veth</span></pre></td></tr><tr><td class="code"><pre><span class="line">VETH_PEER=veth0</span></pre></td></tr><tr><td class="code"><pre><span class="line">ONBOOT=yes</span></pre></td></tr><tr><td class="code"><pre><span class="line">BOOTPROTO=static</span></pre></td></tr><tr><td class="code"><pre><span class="line">IPADDR=192.168.180.211</span></pre></td></tr><tr><td class="code"><pre><span class="line">MTU=1500</span></pre></td></tr><tr><td class="code"><pre><span class="line">NETMASK=255.255.255.0</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># cat /etc/sysconfig/network-scripts/ifcfg-veth2</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">DEVICE=veth2</span></pre></td></tr><tr><td class="code"><pre><span class="line">DEVICETYPE=veth</span></pre></td></tr><tr><td class="code"><pre><span class="line">VETH_PEER=veth3</span></pre></td></tr><tr><td class="code"><pre><span class="line">BRIDGE=br0</span></pre></td></tr><tr><td class="code"><pre><span class="line">ONBOOT=yes</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># cat /etc/sysconfig/network-scripts/ifcfg-veth3</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">DEVICE=veth3</span></pre></td></tr><tr><td class="code"><pre><span class="line">DEVICETYPE=veth</span></pre></td></tr><tr><td class="code"><pre><span class="line">VETH_PEER=veth2</span></pre></td></tr><tr><td class="code"><pre><span class="line">ONBOOT=yes</span></pre></td></tr></table></figure>

<p>现在，就算重启系统虚拟网卡也会被自动重建了。</p>
<ul>
<li>自动加载内核模块</li>
</ul>
<p>以下示例加载 ipvs 内核模块:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ cat /etc/modules-load.d/ipvs.conf</span></pre></td></tr><tr><td class="code"><pre><span class="line">ip_vs</span></pre></td></tr><tr><td class="code"><pre><span class="line">ip_vs_lc</span></pre></td></tr><tr><td class="code"><pre><span class="line">ip_vs_wlc</span></pre></td></tr><tr><td class="code"><pre><span class="line">ip_vs_rr</span></pre></td></tr><tr><td class="code"><pre><span class="line">ip_vs_wrr</span></pre></td></tr><tr><td class="code"><pre><span class="line">ip_vs_lblc</span></pre></td></tr><tr><td class="code"><pre><span class="line">ip_vs_lblcr</span></pre></td></tr><tr><td class="code"><pre><span class="line">ip_vs_dh</span></pre></td></tr><tr><td class="code"><pre><span class="line">ip_vs_sh</span></pre></td></tr><tr><td class="code"><pre><span class="line">ip_vs_nq</span></pre></td></tr><tr><td class="code"><pre><span class="line">ip_vs_sed</span></pre></td></tr><tr><td class="code"><pre><span class="line">ip_vs_ftp</span></pre></td></tr><tr><td class="code"><pre><span class="line">nf_conntrack</span></pre></td></tr></table></figure>

<ul>
<li>自动设置内核参数<br>以下示例启用 ipv4 转发功能：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ cat /etc/sysctl.conf</span></pre></td></tr><tr><td class="code"><pre><span class="line">net.bridge.bridge-nf-call-iptables=1</span></pre></td></tr><tr><td class="code"><pre><span class="line">net.bridge.bridge-nf-call-ip6tables=1</span></pre></td></tr><tr><td class="code"><pre><span class="line">vm.max_map_count=262144</span></pre></td></tr><tr><td class="code"><pre><span class="line">vm.swappiness=0</span></pre></td></tr><tr><td class="code"><pre><span class="line">net.core.somaxconn=32768</span></pre></td></tr><tr><td class="code"><pre><span class="line">net.ipv4.tcp_syncookies=0</span></pre></td></tr><tr><td class="code"><pre><span class="line">net.ipv4.conf.all.rp_filter=1</span></pre></td></tr><tr><td class="code"><pre><span class="line">net.ipv4.ip_forward=1</span></pre></td></tr></table></figure>

<ul>
<li>磁盘性能测试</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install epel-release</span></pre></td></tr><tr><td class="code"><pre><span class="line">yum install fio</span></pre></td></tr><tr><td class="code"><pre><span class="line">fio --randrepeat=1 --ioengine=libaio --direct=1 --gtod_reduce=1 --name=<span class="built_in">test</span> --filename=<span class="built_in">test</span> --bs=4k --iodepth=64 --size=4G --readwrite=randrw --rwmixread=75</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">//latnecy</span></pre></td></tr><tr><td class="code"><pre><span class="line">yum install epel-release</span></pre></td></tr><tr><td class="code"><pre><span class="line">yum install ioping</span></pre></td></tr><tr><td class="code"><pre><span class="line">ioping -c 10 .</span></pre></td></tr></table></figure>

<ul>
<li>安装 MariaDB</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 添加 MariaDB 仓库</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">cat /etc/yum.repos.d/MariaDB.repo</span></pre></td></tr><tr><td class="code"><pre><span class="line">[mariadb]</span></pre></td></tr><tr><td class="code"><pre><span class="line">name = MariaDB</span></pre></td></tr><tr><td class="code"><pre><span class="line">baseurl = http://yum.mariadb.org/10.4/centos7-amd64</span></pre></td></tr><tr><td class="code"><pre><span class="line">gpgkey=https://yum.mariadb.org/RPM-GPG-KEY-MariaDB</span></pre></td></tr><tr><td class="code"><pre><span class="line">gpgcheck=1</span></pre></td></tr><tr><td class="code"><pre><span class="line">  </span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 执行安装</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">yum -y install MariaDB-server MariaDB-client</span></pre></td></tr><tr><td class="code"><pre><span class="line">systemctl <span class="built_in">enable</span> --now mariadb</span></pre></td></tr></table></figure>

<ul>
<li><p>在 grub 引导界面临时编辑内核启动参数</p>
<p>   首先，选中要编辑的内核项，按 <strong>e</strong> 进入编辑页面，编辑完成后按 <strong>Ctrl + x</strong>  启动系统。下图为编辑内核参数直接进入救援模式。</p>
</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2019/png/182657/1570848156874-4feb1fc6-38d3-4dc2-a3f9-ff076f94291e.png#align=left&display=inline&height=230&name=image.png&originHeight=230&originWidth=716&size=13999&status=done&style=none&width=716" alt="image.png"><br></p>
<ul>
<li>在操作系统中编辑内核启动参数并重新生成 grub 引导</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 修改 /etc/default/grub 中的参数设置</span></pre></td></tr><tr><td class="code"><pre><span class="line">[root@umstor03 ~]<span class="comment"># cat /etc/default/grub </span></span></pre></td></tr><tr><td class="code"><pre><span class="line">GRUB_TIMEOUT=5</span></pre></td></tr><tr><td class="code"><pre><span class="line">GRUB_DISTRIBUTOR=<span class="string">"<span class="variable">$(sed 's, release .*$,,g' /etc/system-release)</span>"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">GRUB_DEFAULT=saved</span></pre></td></tr><tr><td class="code"><pre><span class="line">GRUB_DISABLE_SUBMENU=<span class="literal">true</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">GRUB_TERMINAL_OUTPUT=<span class="string">"console"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">GRUB_CMDLINE_LINUX=<span class="string">"crashkernel=auto rd.lvm.lv=centos_umstor03/root video=640x480 nomodeset"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">GRUB_DISABLE_RECOVERY=<span class="string">"true"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">// 执行以下命令生成新的 grub 引导文件</span></pre></td></tr><tr><td class="code"><pre><span class="line">grub2-mkconfig -o /boot/grub2/grub.cfg</span></pre></td></tr><tr><td class="code"><pre><span class="line">// 重启系统时参数生效</span></pre></td></tr></table></figure>

<ul>
<li>netinstall  centos 1804 可用如下镜像源</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 不要遗漏最后的反斜线</span></pre></td></tr><tr><td class="code"><pre><span class="line">https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;centos-vault&#x2F;7.5.1804&#x2F;os&#x2F;x86_64&#x2F;</span></pre></td></tr></table></figure>

<ul>
<li>包版本降级</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum downgrade httpd-2.2.3-22.el5</span></pre></td></tr></table></figure>

<p><a name="3HTPv"></a></p>
<h4 id="VIM"><a href="#VIM" class="headerlink" title="VIM"></a>VIM</h4><ul>
<li>替换空格为换行</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2019/png/182657/1559296752599-dea00714-5a9b-40e4-9f26-b2aff1323c3c.png#align=left&display=inline&height=25&name=image.png&originHeight=25&originWidth=160&size=2640&status=done&style=none&width=160" alt="image.png"></p>
<p><a name="FfBcn"></a></p>
<h4 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h4><ul>
<li><p>修改历史 commit 信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git rebase -i HEAD~2</span></pre></td></tr><tr><td class="code"><pre><span class="line">pick -&gt; edit</span></pre></td></tr><tr><td class="code"><pre><span class="line">git commit --amend</span></pre></td></tr><tr><td class="code"><pre><span class="line">git rebase --continue</span></pre></td></tr></table></figure>
</li>
<li><p>修改 commit 时间</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 设置为当前时间</span></pre></td></tr><tr><td class="code"><pre><span class="line">GIT_COMMITTER_DATE&#x3D;&quot;$(date &#39;+%Y-%m-%d %H:%M:%S&#39;)&quot; git commit --amend --no-edit --date &quot;$(date)&quot;</span></pre></td></tr><tr><td class="code"><pre><span class="line"># 设置为指定时间</span></pre></td></tr><tr><td class="code"><pre><span class="line">GIT_COMMITTER_DATE&#x3D;&quot;Mon 20 Aug 2018 20:19:19 BST&quot; git commit --amend --no-edit --date &quot;Mon 20 Aug 2018 20:19:19 BST&quot;</span></pre></td></tr></table></figure>
</li>
<li><p>比较两个分支的不同</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git diff branch_1..branch_2</span></pre></td></tr></table></figure>
</li>
<li><p>merge 时使用指定方代码解决冲突</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">git merge -X theirs origin/dev</span></pre></td></tr><tr><td class="code"><pre><span class="line">git merge -X ours origin/dev</span></pre></td></tr></table></figure>
</li>
<li><p>查看一个文件完整的修改历史</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git log --follow -p -- _config.yml</span></pre></td></tr></table></figure>
</li>
<li><p>将当前分支下子目录内容提交至另一个分支</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git subtree push --prefix dist origin gh-pages</span></pre></td></tr></table></figure>
</li>
<li><p>删除 submodule</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git submodule deinit &lt;path_to_submodule&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">git rm &lt;path_to_submodule&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">git commit -m &quot;Removed submodule &quot;</span></pre></td></tr></table></figure>
</li>
<li><p>合并所有 commit 为一个</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git rebase --root -i</span></pre></td></tr></table></figure>
</li>
<li><p>删除所有没有远程分支的本地分支</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git fetch -p &amp;&amp; git branch -vv | awk &#39;&#x2F;: gone]&#x2F;&#123;print $1&#125;&#39; | xargs git branch -d</span></pre></td></tr></table></figure>

</li>
</ul>
<p><a name="Qgmi6"></a></p>
<h4 id="Ansible"><a href="#Ansible" class="headerlink" title="Ansible"></a>Ansible</h4><ul>
<li>打印 Ansible 所有的变量 </li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- name: Print some debug information </span></pre></td></tr><tr><td class="code"><pre><span class="line">  vars: </span></pre></td></tr><tr><td class="code"><pre><span class="line">    msg: |</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Module Variables (&quot;vars&quot;):</span></pre></td></tr><tr><td class="code"><pre><span class="line">        --------------------------------</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#123;&#123; vars | to_nice_json &#125;&#125; </span></pre></td></tr><tr><td class="code"><pre><span class="line"> </span></pre></td></tr><tr><td class="code"><pre><span class="line">        Environment Variables (&quot;environment&quot;):</span></pre></td></tr><tr><td class="code"><pre><span class="line">        --------------------------------</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#123;&#123; environment | to_nice_json &#125;&#125; </span></pre></td></tr><tr><td class="code"><pre><span class="line"> </span></pre></td></tr><tr><td class="code"><pre><span class="line">        GROUP NAMES Variables (&quot;group_names&quot;):</span></pre></td></tr><tr><td class="code"><pre><span class="line">        --------------------------------</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#123;&#123; group_names | to_nice_json &#125;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"> </span></pre></td></tr><tr><td class="code"><pre><span class="line">        GROUPS Variables (&quot;groups&quot;):</span></pre></td></tr><tr><td class="code"><pre><span class="line">        --------------------------------</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#123;&#123; groups | to_nice_json &#125;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"> </span></pre></td></tr><tr><td class="code"><pre><span class="line">        HOST Variables (&quot;hostvars&quot;):</span></pre></td></tr><tr><td class="code"><pre><span class="line">        --------------------------------</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#123;&#123; hostvars | to_nice_json &#125;&#125; </span></pre></td></tr><tr><td class="code"><pre><span class="line"> </span></pre></td></tr><tr><td class="code"><pre><span class="line">  debug: </span></pre></td></tr><tr><td class="code"><pre><span class="line">    msg: &quot;&#123;&#123; msg.split(&#39;\n&#39;) &#125;&#125;&quot;       </span></pre></td></tr><tr><td class="code"><pre><span class="line">  tags: debug_info</span></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- name: Display all variables&#x2F;facts known for a host</span></pre></td></tr><tr><td class="code"><pre><span class="line">  debug:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    var: hostvars[inventory_hostname]</span></pre></td></tr><tr><td class="code"><pre><span class="line">  tags: debug_info</span></pre></td></tr></table></figure>

<p><a name="gzyiV"></a></p>
<h4 id="tcpdump-捕获-http-包"><a href="#tcpdump-捕获-http-包" class="headerlink" title="tcpdump 捕获 http 包"></a>tcpdump 捕获 http 包</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tcpdump -s 0 -A <span class="string">'tcp[((tcp[12:1] &amp; 0xf0) &gt;&gt; 2):4] = 0x47455420'</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">tcpdump -ni ens5f0 -A -s 10240 <span class="string">'tcp port 8056 and (((ip[2:2] - ((ip[0]&amp;0xf)&lt;&lt;2)) - ((tcp[12]&amp;0xf0)&gt;&gt;2)) != 0)'</span> | egrep --line-buffered <span class="string">"^........(GET |HTTP\/|POST |HEAD )|^[A-Za-z0-9-]+: "</span> | sed -r <span class="string">'s/^........(GET |HTTP\/|POST |HEAD )/\n\1/g'</span></span></pre></td></tr></table></figure>

<p><a name="WZCnh"></a></p>
<h4 id="mount-查看目录或分区挂载情况"><a href="#mount-查看目录或分区挂载情况" class="headerlink" title="mount 查看目录或分区挂载情况"></a>mount 查看目录或分区挂载情况</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat /proc/mounts</span></pre></td></tr><tr><td class="code"><pre><span class="line">// or</span></pre></td></tr><tr><td class="code"><pre><span class="line">cat /proc/self/mountinfo</span></pre></td></tr><tr><td class="code"><pre><span class="line">// or</span></pre></td></tr><tr><td class="code"><pre><span class="line">mount -l</span></pre></td></tr><tr><td class="code"><pre><span class="line">// or</span></pre></td></tr><tr><td class="code"><pre><span class="line">findmnt</span></pre></td></tr><tr><td class="code"><pre><span class="line">// or</span></pre></td></tr><tr><td class="code"><pre><span class="line">df -aTh</span></pre></td></tr></table></figure>

<p><a name="1rSZC"></a></p>
<h4 id="pgrep-进程检索与杀死"><a href="#pgrep-进程检索与杀死" class="headerlink" title="pgrep 进程检索与杀死"></a>pgrep 进程检索与杀死</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 按名称列出进程 ID</span></pre></td></tr><tr><td class="code"><pre><span class="line">pgrep chrome</span></pre></td></tr><tr><td class="code"><pre><span class="line">// 按名称杀死进程</span></pre></td></tr><tr><td class="code"><pre><span class="line">pkill -9 fish</span></pre></td></tr><tr><td class="code"><pre><span class="line">killall -9 fish</span></pre></td></tr><tr><td class="code"><pre><span class="line">// 杀死指定 ID 的进程</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">kill</span> -9 3049</span></pre></td></tr><tr><td class="code"><pre><span class="line">// 列出进程树</span></pre></td></tr><tr><td class="code"><pre><span class="line">pstree -p</span></pre></td></tr></table></figure>

<p><a name="e1tG9"></a></p>
<h4 id="fuser-找到正在使用某个文件的进程"><a href="#fuser-找到正在使用某个文件的进程" class="headerlink" title="fuser 找到正在使用某个文件的进程"></a>fuser 找到正在使用某个文件的进程</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// fuser 是 file user 的缩写</span></pre></td></tr><tr><td class="code"><pre><span class="line">fuser -uv &lt;filename&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">fuser -uvm /folder</span></pre></td></tr><tr><td class="code"><pre><span class="line">// 查看哪个程序在占用 8000 端口</span></pre></td></tr><tr><td class="code"><pre><span class="line">fuser -v -n tcp 8000</span></pre></td></tr></table></figure>

<p><a name="lw5hk"></a></p>
<h4 id="lsof-列出所有打开的文件"><a href="#lsof-列出所有打开的文件" class="headerlink" title="lsof 列出所有打开的文件"></a>lsof 列出所有打开的文件</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// lsof 是 list open files 的缩写</span></pre></td></tr><tr><td class="code"><pre><span class="line">// -i 代表列出正在打开的 IPV4[6] 文件； -n 表示不进行 DNS 反解； -P 表示不进行端口反解</span></pre></td></tr><tr><td class="code"><pre><span class="line">lsof -i -n -P</span></pre></td></tr><tr><td class="code"><pre><span class="line">// 查看当前目录下打开的文件</span></pre></td></tr><tr><td class="code"><pre><span class="line">lsof .</span></pre></td></tr></table></figure>

<p><a name="70PLT"></a></p>
<h4 id="strace-跟踪系统调用"><a href="#strace-跟踪系统调用" class="headerlink" title="strace 跟踪系统调用"></a>strace 跟踪系统调用</h4><p>strace 用法参考： <a href="https://www.howtoforge.com/linux-strace-command/" target="_blank" rel="external nofollow noopener noreferrer">https://www.howtoforge.com/linux-strace-command/</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">strace -i ls</span></pre></td></tr></table></figure>

<p><a name="6F4YX"></a></p>
<h4 id="getent-获取系统用户信息"><a href="#getent-获取系统用户信息" class="headerlink" title="getent 获取系统用户信息"></a>getent 获取系统用户信息</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">getent passwd</span></pre></td></tr></table></figure>

<p><a name="zdvyH"></a></p>
<h4 id="sed-删除所有以-开头的行"><a href="#sed-删除所有以-开头的行" class="headerlink" title="sed 删除所有以 # 开头的行"></a>sed 删除所有以 # 开头的行</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sed <span class="string">'/^#/ d'</span></span></pre></td></tr></table></figure>
<p>更多使用方法参考：<a href="https://www.folkstalk.com/2013/03/sed-remove-lines-file-unix-examples.html" target="_blank" rel="external nofollow noopener noreferrer">https://www.folkstalk.com/2013/03/sed-remove-lines-file-unix-examples.html</a></p>
<p><a name="tZDa5"></a></p>
<h4 id="生成-Linux-用户密码的哈希值"><a href="#生成-Linux-用户密码的哈希值" class="headerlink" title="生成 Linux 用户密码的哈希值"></a>生成 Linux 用户密码的哈希值</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python -c &quot;import crypt, getpass, pwd; print(crypt.crypt(&#39;password&#39;, &#39;\$6\$saltsalt\$&#39;))&quot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 或者使用 go</span></pre></td></tr><tr><td class="code"><pre><span class="line">package main                                                </span></pre></td></tr><tr><td class="code"><pre><span class="line">import (</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &quot;fmt&quot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &quot;github.com&#x2F;tredoe&#x2F;osutil&#x2F;user&#x2F;crypt&#x2F;sha512_crypt&quot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">)</span></pre></td></tr><tr><td class="code"><pre><span class="line">func main() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    c :&#x3D; sha512_crypt.New()</span></pre></td></tr><tr><td class="code"><pre><span class="line">    hash, err :&#x3D; c.Generate([]byte(&quot;rasmuslerdorf&quot;), []byte(&quot;$6$usesomesillystringforsalt&quot;))</span></pre></td></tr><tr><td class="code"><pre><span class="line">    if err !&#x3D; nil &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        panic(err)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    fmt.Println(hash)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p><a name="uvsm2"></a></p>
<h4 id="允许使用-root-用户-ssh-登录"><a href="#允许使用-root-用户-ssh-登录" class="headerlink" title="允许使用 root 用户 ssh 登录"></a>允许使用 root 用户 ssh 登录</h4><p>先删除 <code>/root/.ssh/authorized_keys</code> 中的多余限制信息，之后在 <code>/etc/ssh/sshd_config</code> 中添加 <code>PermitRootLogin yes</code> 后重启 sshd 服务。</p>
<p><a name="vwUdA"></a></p>
<h4 id="解决”rtnetlink-answers-file-exists”"><a href="#解决”rtnetlink-answers-file-exists”" class="headerlink" title="解决”rtnetlink answers file exists”"></a>解决”rtnetlink answers file exists”</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ip a flush dev eth0</span></pre></td></tr></table></figure>

<p><a name="HPtZj"></a></p>
<h4 id="ssh-取消-StrictHostKeyChecking-并从环境变量读取-ssh-key-到本地"><a href="#ssh-取消-StrictHostKeyChecking-并从环境变量读取-ssh-key-到本地" class="headerlink" title="ssh 取消 StrictHostKeyChecking 并从环境变量读取 ssh key 到本地"></a>ssh 取消 StrictHostKeyChecking 并从环境变量读取 ssh key 到本地</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"Host *"</span> &gt; /etc/ssh/ssh_config</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"  StrictHostKeyChecking=no"</span> &gt;&gt; /etc/ssh/ssh_config</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"  UserKnownHostsFile=/dev/null"</span> &gt;&gt; /etc/ssh/ssh_config</span></pre></td></tr><tr><td class="code"><pre><span class="line">mkdir -p ~/.ssh</span></pre></td></tr><tr><td class="code"><pre><span class="line">chmod 700 ~/.ssh</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"<span class="variable">$SSH_PRIVATE_KEY</span>"</span> | tr -d <span class="string">'\r'</span> &gt; ~/.ssh/id_rsa</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"<span class="variable">$SSH_PUBLIC_KEY</span>"</span> &gt; ~/.ssh/id_rsa.pub</span></pre></td></tr><tr><td class="code"><pre><span class="line">chmod 600 ~/.ssh/id_rsa</span></pre></td></tr><tr><td class="code"><pre><span class="line">chmod 644 ~/.ssh/id_rsa.pub</span></pre></td></tr></table></figure>

<p><a name="Ey88A"></a></p>
<h4 id="查看登录记录"><a href="#查看登录记录" class="headerlink" title="查看登录记录"></a>查看登录记录</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看当前登录用户</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">who</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 查看最近登录记录</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">last -F</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 查看最近90天所有用户的最后登录时间</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">lastlog --time 90</span></pre></td></tr></table></figure>

<p><a name="g7NoE"></a></p>
<h4 id="rsync-同步时需要-root-权限"><a href="#rsync-同步时需要-root-权限" class="headerlink" title="rsync 同步时需要 root 权限"></a>rsync 同步时需要 root 权限</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rsync -aru -e <span class="string">"ssh"</span> --rsync-path=<span class="string">"sudo rsync"</span> 172.16.110.215:~/ ~/  --progress --exclude=.cache</span></pre></td></tr></table></figure>

<p><a name="hU4cE"></a></p>
<h4 id="expr-比较字符串大小"><a href="#expr-比较字符串大小" class="headerlink" title="expr 比较字符串大小"></a>expr 比较字符串大小</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">str3=<span class="string">'v1.13'</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">str2=<span class="string">'v1.14'</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> [ $(expr <span class="variable">$&#123;str3&#125;</span> \&lt;= <span class="variable">$&#123;str2&#125;</span>) -eq 1 ]; <span class="keyword">then</span>    <span class="built_in">echo</span> <span class="string">"[<span class="variable">$&#123;str3&#125;</span>] &lt;= [<span class="variable">$&#123;str2&#125;</span>]"</span>; <span class="keyword">else</span>    <span class="built_in">echo</span> <span class="string">"[<span class="variable">$&#123;str3&#125;</span>] &gt; [<span class="variable">$&#123;str2&#125;</span>]"</span>; <span class="keyword">fi</span></span></pre></td></tr></table></figure>

<p><a name="bjtsD"></a></p>
<h4 id="tr-移除所有空格"><a href="#tr-移除所有空格" class="headerlink" title="tr 移除所有空格"></a>tr 移除所有空格</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 获取 kubernetes 版本</span></pre></td></tr><tr><td class="code"><pre><span class="line">kubectl version --short | tail -1 | cut -d<span class="string">':'</span> -f2 | tr -d <span class="string">'[:space:]'</span></span></pre></td></tr></table></figure>

<p><a name="NBOFH"></a></p>
<h4 id="vegeta-对-HTTP-服务进行性能测试"><a href="#vegeta-对-HTTP-服务进行性能测试" class="headerlink" title="vegeta 对 HTTP 服务进行性能测试"></a>vegeta 对 HTTP 服务进行性能测试</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">echo <span class="string">"GET http://localhost:8080/cephcsi"</span> | vegeta attack -rate=<span class="number">20000</span> -duration=<span class="number">60</span>s &gt; result.bin</span></pre></td></tr><tr><td class="code"><pre><span class="line">vegeta report result.bin</span></pre></td></tr></table></figure>
<p>更多内容参考：<a href="https://www.scaleway.com/en/docs/vegeta-load-testing/" target="_blank" rel="external nofollow noopener noreferrer">https://www.scaleway.com/en/docs/vegeta-load-testing/</a></p>
<p><a name="DNQzt"></a></p>
<h4 id="zip-压缩文件不带顶级目录"><a href="#zip-压缩文件不带顶级目录" class="headerlink" title="zip 压缩文件不带顶级目录"></a>zip 压缩文件不带顶级目录</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pushd &#x2F;Users&#x2F;me&#x2F;development&#x2F;something</span></pre></td></tr><tr><td class="code"><pre><span class="line">cd path&#x2F;to&#x2F;parent&#x2F;dir&#x2F;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">zip -r complete&#x2F;path&#x2F;to&#x2F;name.zip .&#x2F;*</span></pre></td></tr><tr><td class="code"><pre><span class="line">popd</span></pre></td></tr></table></figure>

<p><a name="KWEjv"></a></p>
<h4 id="MySQL-执行单行命令"><a href="#MySQL-执行单行命令" class="headerlink" title="MySQL 执行单行命令"></a>MySQL 执行单行命令</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql --user&#x3D;&quot;$user&quot; --password&#x3D;&quot;$password&quot; --database&#x3D;&quot;$database&quot; --execute&#x3D;&quot;DROP DATABASE $user; CREATE DATABASE $database;&quot;</span></pre></td></tr></table></figure>

<p><a name="bIf97"></a></p>
<h4 id="MySQL-导出数据库"><a href="#MySQL-导出数据库" class="headerlink" title="MySQL 导出数据库"></a>MySQL 导出数据库</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 导出</span></pre></td></tr><tr><td class="code"><pre><span class="line">mysqldump -P 3306 -u root --password&#x3D;password -h 172.30.100.43  keycloak &gt; keycloak-3.sql</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 导入</span></pre></td></tr><tr><td class="code"><pre><span class="line">mysql -P 3306 -u root --password&#x3D;password -h 172.30.100.43  keycloak &lt; keycloak.sql</span></pre></td></tr></table></figure>

<p><a name="csvsg"></a></p>
<h4 id="ss-列出所有处于监听状态的-socket"><a href="#ss-列出所有处于监听状态的-socket" class="headerlink" title="ss 列出所有处于监听状态的 socket"></a>ss 列出所有处于监听状态的 socket</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">ss -lntu</span></pre></td></tr><tr><td class="code"><pre><span class="line">-l = only services which are listening on some port</span></pre></td></tr><tr><td class="code"><pre><span class="line">-n = show port number, don<span class="string">'t try to resolve the service name</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">-t = tcp ports</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">-u = udp ports</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">-p = name of the program</span></span></pre></td></tr></table></figure>

<p><a name="fL7Yx"></a></p>
<h4 id="实用工具"><a href="#实用工具" class="headerlink" title="实用工具"></a>实用工具</h4><ul>
<li>一个在线渲染代码为图片的网站：<a href="https://carbon.now.sh/" target="_blank" rel="external nofollow noopener noreferrer">https://carbon.now.sh/</a> ， 可以通过设置修改边框等信息。</li>
<li>pandoc 可以借助第三方引擎实现各种文档格式之间的转换：<a href="https://pandoc.org/" target="_blank" rel="external nofollow noopener noreferrer">https://pandoc.org/</a>。</li>
<li>MOBI 转 PDF 的在线网站：<a href="https://ebook2pdf.com/" target="_blank" rel="external nofollow noopener noreferrer">https://ebook2pdf.com/</a></li>
<li>Github dispatch 使用示例：<a href="https://alejandroandr.eu/posts/manual-trigger-github-workflows/" target="_blank" rel="external nofollow noopener noreferrer">https://alejandroandr.eu/posts/manual-trigger-github-workflows/</a></li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag> 云计算</tag>
      </tags>
  </entry>
  <entry>
    <title>基础网络知识</title>
    <url>/post/cf4d6f51.html</url>
    <content><![CDATA[<p><a name="GeX1f"></a></p><h4 id="NO-CARRIER-网卡故障"><a href="#NO-CARRIER-网卡故障" class="headerlink" title="NO-CARRIER 网卡故障"></a>NO-CARRIER 网卡故障</h4><p>NO-CARRIER 表示网络接口未检测到线路上的信号。通常是因为网络电缆已拔出或断开。在极少数情况下，也可能是硬件故障或驱动程序错误。</p><p><a name="5CFzE"></a></p><h4 id="WebSocket-和-Socket的区别"><a href="#WebSocket-和-Socket的区别" class="headerlink" title="WebSocket 和 Socket的区别"></a>WebSocket 和 Socket的区别</h4><p>WebSocket 一般用于浏览器与应用服务器之间的交互，它是类似于 HTTP 的应用层协议，建立在 TCP/IP 之上。它主要应用于浏览器端需要和服务段建立固定连接的场景。而纯粹的 Socket 比 WebSocket 更加强大和通用。Socket 也基于 TCP/IP 但不局限于浏览器应用场景，使用 Socket 可以实现各种各样的通信过程。</p><a id="more"></a>



<p><a name="ru5Ve"></a></p>
<h4 id="WebSocket-通信建立过程"><a href="#WebSocket-通信建立过程" class="headerlink" title="WebSocket 通信建立过程"></a>WebSocket 通信建立过程</h4><p>所有客户端与 WebSocket Server 建立进行通信时，都需要先发送 Http Get 请求完成握手过程，该 Http 请求头中包含 Upgrade: websocket 等必要字段，WebSocket Server 端必须能够处理该 Http 请求并在接受建立 WebSocket 连接时返回一个状态码为 101 的 Http 响应告诉客户端从现在开始把协议切换为 WebSocket。这样设计的一个好处时可以让 WebSocket 服务与已经存在的 Http 服务复用同一个端口，只需要一个后端进程处理两种通信协议。当然，也可以搭建一个纯粹的 WebSocket Server，只是依然需要能够响应握手时客户端发出的用以协议升级的 Http 请求，只不过对于其它的 Http 请求不会响应，亦即纯粹的 WebSocket Server 处理且仅处理用以协议升级 Http Get 的请求，之后的通信过程将全部使用 WebSocket 协议。更多解释参考：<a href="https://stackoverflow.com/questions/47085281/do-websocket-implementations-use-http-protocol-internally" target="_blank" rel="external nofollow noopener noreferrer">https://stackoverflow.com/questions/47085281/do-websocket-implementations-use-http-protocol-internally</a></p>
<p><a name="rSFAH"></a></p>
<h4 id="TCP-连接建立与断开"><a href="#TCP-连接建立与断开" class="headerlink" title="TCP 连接建立与断开"></a>TCP 连接建立与断开</h4><ol>
<li>TCP Server 端初始处于 LISTEN 状态；TCP Client 端新建一个 TCP Socket （端口号由操作系统分配）并主动发起 SYNC 请求，其过程是向 Server 端发送一个标志位为 SYN=1 及 ACK=0 ，序列号为随机生成的 x，数据部分为空的 TCP 报文，其结果是 Client 端进入 SYN_SENT 状态；Server 端接收到 Client 端的报文，根据 SYN=1 及 ACK=0 确定这是发起连接请求的报文并据此进行响应，其过程是向 Client 端发送一个标志位为 SYN=1 及 ACK=1（确认与同步二合一），序列号为随机生成的 y，确认号为 x+1，数据部分为空的 TCP 报文，其结果是服务端进入 SYN_RECV 状态；Client 端接收到 Server 回复的报文，确认可以和服务端建立通信，因此进入 ESTABLISHED 状态，作为对服务端 SYNC 报文的回应，客户端向服务端发送一个标志位为 ACK=1，序列号为 x+1，确认号为 y+1，数据部分为空的 TCP 报文；服务端收到确认报文后才会进入 ESTABLISHED 状态。</li>
<li>TCP 连接建立过程中，最后一次客户端向服务端发送的确认报文除了作为对服务端同步报文的回应，也基于以下原因：在客户端刚开始发起连接时发出的 SYNC 请求报文如果迟迟没有收到服务端的确认报文，客户端会放弃该连接，重新发出 SYNC 请求报文；此时服务端有可能会收到两条 SYNC 报文（超时的报文和新的报文），如果没有最后一次客户端发送的确认报文，服务端直接进入 ESTABLISHED 状态，会建立起两条连接，从而会浪费一条连接开销。</li>
<li>当 TCP 连接建立完成后，两方的角色将变成对称的，任何一端都无法识别自己为客户端还是服务端，因此任何一端都可以先发送 FIN 报文用以关闭连接。由于一旦 FIN 报文从某一端发出，则该端将无法向对端发送数据（接收不受影响），因此往往是由先确知自己无需再发送数据的一端首先发起关闭连接的请求，而对端无需在收到 FIN 报文后立即开始 FIN 过程，可以继续向发起端发送数据直到数据发送完毕后再开始 FIN 过程，因此 TCP 的关闭过程也被称为是半关闭过程，所谓的四次挥手也源于此。</li>
<li>FIN 开始之前两方都处于 ESTABLISHED 状态，直到有一方的应用层确认数据发送完毕，主动发起了关闭连接的过程，此时会向另一方（后称为被动方）发送 FIN 请求，其过程是发送一个标志位 FIN=1，序列号为 u ，数据部分为空（也可能不为空，稍后讨论）的 TCP 报文，其结果是主动方进入了 FIN_WAIT 状态；被动方接收到主动方发出的报文，会返回一个标志位为 ACK=1，序列号为 v，确认号为 u+1 ，数据部分为空的报文，结果是被动方进入 CLOSE_WAIT 状态；此后被动方可以继续发送数据直到数据发送完成；被动方完成数据发送，向主动方发送标志位为 FIN=1 及 ACK=1 ，序列号为 w ，确认号依然为 u+1 的，数据部分为空（也可能不为空，稍后讨论）的 TCP 报文，之后被动方进入 LAST_ACK 状态；主动方收到被动方的 FIN 报文后，返回一个标志位为 ACK=1 ，序列号为 u+1 ，确认号为 w+1，数据部分为空的报文，此后主动方进入 TIME_WAIT 状态进行超时等待；被动方收到主动方的确认报文后进入 CLOSED 状态，此时被动方已经先完成了关闭连接的过程。</li>
<li>FIN 主动方进入 TIME_WAIT 状态后，会等待 2 倍的最大报文生存时间即 2MSL，等待的原因主要有两个： ① 为了保证主动方发送的最后一个 ACK 报文段能够到达被动方。即如果最后这个确认报文丢失，被动方会超时重传 FIN 报文，然后主动方再一次确认，同时启动 2MSL 计时器，如此下去。如果主动方没有等待时间，发送完确认报文就立即释放连接的话，即使被动方重传了 FIN 报文，也会因主动方已关闭而使被动方无法收到确认报文，被动方就无法正常进入 CLOSE状态。 ② 防止已失效的连接请求报文出现在新的连接中。经过 2MSL，和该连接的相关的报文要么已经到达目的地，要么会被丢弃掉，不会滞留在网络中。这样的话，在下一个连接中就不会出现上一个连接遗留下来的请求报文了。</li>
<li>RFC 793 中规定 MSL 为 2 分钟，实际应用中常用的是 30 秒，1 分钟和 2 分钟等。Linux 系统下可通过以下命令查看：<code>cat /proc/sys/net/ipv4/tcp_fin_timeout</code> ，在我的 Deepin 和 Manjaro 系统中分别是 40s 和 60s。</li>
<li>FIN 报文中是可以携带数据的，携带数据时的连接关闭过程与不携带数据时并无本质区别，只不过与 FIN 报文对应的 ACK 报文中的确认号值需要加上 FIN 报文发来的数据长度 d ，如果 FIN 报文不携带数据时对应的 ACK 报文的确认号为 u+1，则 FIN 携带数据时确认号还要加上 d 用以表示被动方收到了长度为 d 的数据内容，此时确认号为 u+1+d 。 FIN 包携带数据往往是为了提高通信效率，因为这样做相当于将最后一个数据报文和 FIN 报文合二为一，节省了一个报文的发送过程。</li>
<li>FIN 谁先关闭的问题可以通过一个简单的抓包实验进行观察：通过启动一个 <code>python3 -mhttp.server</code> Http 服务器，使用 WireShark 进行抓包，执行 <code>curl 127.0.0.1:8000</code> 后观察抓取的数据包，可以发现服务端在发送 Http 响应的同时主动发起了关闭连接的过程，即最后一个数据报文和 FIN 报文合二为一。</li>
<li>通过抓包观察，在数据传输过程中某一方应答报文的确认号为总是等于另一方发送的报文的序列号和报文数据长度之和，而这个和值也会变成发送方下一次发送报文时的序列号。序列号和确认号的初始值来源于建立连接时客户端和服务端分别获取的随机序列号值 x， y，在连接建立后，第一个数据报文的序列号和确认号分别是 x+1,y+1（客户端发送第一份数据）或者 y+1, x+1（服务端发送第一份数据）。</li>
<li>TCP 连接参考文档：<a href="https://blog.csdn.net/guyuealian/article/details/52535294" target="_blank" rel="external nofollow noopener noreferrer">https://blog.csdn.net/guyuealian/article/details/52535294</a> ，<a href="https://stackoverflow.com/questions/289194/what-is-maximum-segment-lifetime/35000966" target="_blank" rel="external nofollow noopener noreferrer">https://stackoverflow.com/questions/289194/what-is-maximum-segment-lifetime/35000966</a>， <a href="https://www.wikiwand.com/en/Transmission_Control_Protocol" target="_blank" rel="external nofollow noopener noreferrer">https://www.wikiwand.com/en/Transmission_Control_Protocol</a>，<a href="https://stackoverflow.com/questions/4677925/who-first-sets-tcp-fin-flag-in-client-server-connection" target="_blank" rel="external nofollow noopener noreferrer">https://stackoverflow.com/questions/4677925/who-first-sets-tcp-fin-flag-in-client-server-connection</a></li>
<li>一张助于理解的图：</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2019/png/182657/1571478423292-36b18cb8-3312-42ed-940e-40b15315d38d.png#align=left&display=inline&height=793&name=image.png&originHeight=793&originWidth=796&size=62072&status=done&style=none&width=796" alt="image.png"></p>
<p><a name="ishW2"></a></p>
<h4 id="Linux-内核网络相关函数调用关系图"><a href="#Linux-内核网络相关函数调用关系图" class="headerlink" title="Linux 内核网络相关函数调用关系图"></a>Linux 内核网络相关函数调用关系图</h4><p><img src="https://cdn.nlark.com/yuque/0/2019/jpeg/182657/1571896927566-028e0063-6be9-4472-a446-66ac67ca17f5.jpeg#align=left&display=inline&height=1952&name=linux-net.jpeg&originHeight=1952&originWidth=3489&size=1016557&status=done&style=none&width=3489" alt="linux-net.jpeg"></p>
<p><a name="edV2o"></a></p>
<h4 id="Qdisc-在-Linux-网络栈中的位置"><a href="#Qdisc-在-Linux-网络栈中的位置" class="headerlink" title="Qdisc 在 Linux 网络栈中的位置"></a>Qdisc 在 Linux 网络栈中的位置</h4><p><img src="https://cdn.nlark.com/yuque/0/2019/png/182657/1571898730049-ed53082d-e336-42cd-aa59-7233ebb6d57c.png#align=left&display=inline&height=913&name=image.png&originHeight=1475&originWidth=1205&size=325485&status=done&style=none&width=746" alt="image.png"></p>
<p><a name="DJVOW"></a></p>
<h4 id="网络路由过程"><a href="#网络路由过程" class="headerlink" title="网络路由过程"></a>网络路由过程</h4><ul>
<li>路由器与 NAT：</li>
</ul>
<p>纯粹的路由过程并不会修改 IP 地址，路由过程会修改 MAC 地址，而家用路由器往往并不是纯粹的路由器，而是包含了 NAT 单元，所以家用路由器会修改 IP 从而实现一个局域网内的多个计算机同时连接外网。</p>
<ul>
<li><p>一个关于路由过程的说明：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">The source and destination MAC address will change as the frame traverses the </span></pre></td></tr><tr><td class="code"><pre><span class="line">network to that of the next hop device and sending device port MAC, respectively.</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">EXAMPLE:</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">Three routers, A, B, C. They are connected in line (A connects to B, B connects to </span></pre></td></tr><tr><td class="code"><pre><span class="line">A and C and C only connects to B like this: A — B — C ) with Host 1 on router A and</span></pre></td></tr><tr><td class="code"><pre><span class="line">Host 2 on Router C.</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">( 1 — A — B — C — 2 )</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">Host connected to router A wants to talk to host connected to router C. Host A</span></pre></td></tr><tr><td class="code"><pre><span class="line">determines the IP address of the host and does an ARP lookup to see if it is local.</span></pre></td></tr><tr><td class="code"><pre><span class="line">The host on A determines that it is not local so it looks for a default gateway IP</span></pre></td></tr><tr><td class="code"><pre><span class="line">address. Once found, the IP of the default gateway is checked for an ARP entry and,</span></pre></td></tr><tr><td class="code"><pre><span class="line">if not, broadcasts and ARP to determine the MAC address. Now that all this has been</span></pre></td></tr><tr><td class="code"><pre><span class="line">done, Host 1 on Router A will forward the packet with the Source IP and MAC of its </span></pre></td></tr><tr><td class="code"><pre><span class="line">machine, Host 1. The Destination IP will be that of Host 2 on Router C and the </span></pre></td></tr><tr><td class="code"><pre><span class="line">Destination MAC will be the MAC address of the default gateway, which in this case,</span></pre></td></tr><tr><td class="code"><pre><span class="line">if the network is setup properly, will be the interface on Router A connecting to </span></pre></td></tr><tr><td class="code"><pre><span class="line">the local LAN segment where Host 1 resides. Once Router A receives the frame, </span></pre></td></tr><tr><td class="code"><pre><span class="line">it will check the destination IP address to see if the IP Address is connected to </span></pre></td></tr><tr><td class="code"><pre><span class="line">a local LAN segment or not. In this case, we need to go through Router C to get</span></pre></td></tr><tr><td class="code"><pre><span class="line">to Host 2, the router determines that the destination IP is NOT local and looks </span></pre></td></tr><tr><td class="code"><pre><span class="line">at the routing table for the next steps. This step will check for the BEST route </span></pre></td></tr><tr><td class="code"><pre><span class="line">available to the Destination IP address. If no route is found, it will check for </span></pre></td></tr><tr><td class="code"><pre><span class="line">a quad route (0.0.0.0 a.k.a. Default Route). Once the interface is determined based</span></pre></td></tr><tr><td class="code"><pre><span class="line">on the route selection process, it will check for an ARP entry for the IP address </span></pre></td></tr><tr><td class="code"><pre><span class="line">of the next hop, in this case, Router B interface facing Router A. Router A will </span></pre></td></tr><tr><td class="code"><pre><span class="line">send the frame up to the CPU and have the source and dest MAC addresses updated to </span></pre></td></tr><tr><td class="code"><pre><span class="line">reflect the following. Router A egress interface will be the new Source MAC and</span></pre></td></tr><tr><td class="code"><pre><span class="line">Router B interface facing toward router A will be the Destination MAC address. </span></pre></td></tr><tr><td class="code"><pre><span class="line">Once Router B gets the frame, it will do the same thing and forward the frame out </span></pre></td></tr><tr><td class="code"><pre><span class="line">toward router C with the Source MAC being the Router B interface facing Router C </span></pre></td></tr><tr><td class="code"><pre><span class="line">and the Destination MAC address being the interface of Router C. All the while, </span></pre></td></tr><tr><td class="code"><pre><span class="line">the Source and Destination IP addresses are the same. Since Host 2 would most </span></pre></td></tr><tr><td class="code"><pre><span class="line">likely be sent to a switch that connects all the users up, Router C will check </span></pre></td></tr><tr><td class="code"><pre><span class="line">its route table and see that the Destination IP address is locally connected via </span></pre></td></tr><tr><td class="code"><pre><span class="line">one of its interfaces. At that point,a final ARP check is done to find the MAC </span></pre></td></tr><tr><td class="code"><pre><span class="line">address of Host 2. The switch will respond with this information and report it </span></pre></td></tr><tr><td class="code"><pre><span class="line">back to Router C. Router C then replaces the Destination MAC to that of Host 2</span></pre></td></tr><tr><td class="code"><pre><span class="line">(learned via ARP) and replaces the Source MAC as the interface of Router C </span></pre></td></tr><tr><td class="code"><pre><span class="line">connected to the LAN Segment&#x2F;Switch. The switch, assuming it’s layer 2 only, </span></pre></td></tr><tr><td class="code"><pre><span class="line">will see the Destination MAC as that of Host 2 and forward the packet out the port</span></pre></td></tr><tr><td class="code"><pre><span class="line">that Host 2 is connected. Host 2 then receives the frame and the initial journey </span></pre></td></tr><tr><td class="code"><pre><span class="line">is completed. All the while, these ARP entries are being cached and stored for the</span></pre></td></tr><tr><td class="code"><pre><span class="line">return path as well.</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">In summary, ARP is used to map the IP to MAC addresses in a network for non-local</span></pre></td></tr><tr><td class="code"><pre><span class="line">forwarding. This is done to prevent broadcasts from flooding the network. Imagine </span></pre></td></tr><tr><td class="code"><pre><span class="line">if you will, the Internet being one big flat network. All of the hosts on the </span></pre></td></tr><tr><td class="code"><pre><span class="line">Internet would be ARP-ing for the MAC address of the device it wants to talk to and,</span></pre></td></tr><tr><td class="code"><pre><span class="line">we would never be able to load http:&#x2F;&#x2F;Quora.com as the Internet would be flooded </span></pre></td></tr><tr><td class="code"><pre><span class="line">with Broadcasts. The purpose of a router is just that, break up the broadcast</span></pre></td></tr><tr><td class="code"><pre><span class="line">domains to prevent this from occuring. Back in the day, we had to design networks </span></pre></td></tr><tr><td class="code"><pre><span class="line">with this in mind as switching hadn’t been fully realized yet.</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">Last thing to note that is important. All communication happens at Layer 2, </span></pre></td></tr><tr><td class="code"><pre><span class="line">Layer 3 is just a way for us humans to organize the network in a way that makes </span></pre></td></tr><tr><td class="code"><pre><span class="line">logical sense using IP addressing.</span></pre></td></tr></table></figure>
</li>
<li><p>一个路由选择的例子：</p>
</li>
</ul>
<p><a href="https://community.cisco.com/t5/networking-blogs/what-happens-when-router-receives-packet/ba-p/3105996" target="_blank" rel="external nofollow noopener noreferrer">https://community.cisco.com/t5/networking-blogs/what-happens-when-router-receives-packet/ba-p/3105996</a></p>
<p><a name="HBxo2"></a></p>
<h4 id="端口与套接字的区别与联系"><a href="#端口与套接字的区别与联系" class="headerlink" title="端口与套接字的区别与联系"></a>端口与套接字的区别与联系</h4><p>原文地址：<a href="https://stackoverflow.com/questions/152457/what-is-the-difference-between-a-port-and-a-socket?page=1&tab=votes#tab-top" target="_blank" rel="external nofollow noopener noreferrer">https://stackoverflow.com/questions/152457/what-is-the-difference-between-a-port-and-a-socket?page=1&amp;tab=votes#tab-top</a><br><strong>总结</strong><br>一个 TCP 套接字是一个端点（endpoint）实例：由特定 TCP 连接或处于监听状态的 TCP server 的上下文环境中的一个 IP 地址和一个端口定义。<br>一个端口是一个虚拟的 ID 定义了一个服务端点（有别于服务实例端点又称 session ID）。<br>TCP 套接字不是连接，而是特定连接的一个端点。<br>同一个服务端点可以存在多个并发连接，因为一个连接是由本地和远端端点共同标识的，所以能够允许不同连接的流量根据该连接的信息被路由到不同的服务实例去处理。<br>对于给定的一个地址与端口组合，只能有一个处于监听状态的套接字。<br><strong>说明</strong><br>这是一个有趣的问题，迫使我重新审视许多我以为自己彻底了解的事情。你可能认为像 “socket” 这样的名字是不言自明的：它的选择显然是为了让人联想起插入网络电缆的端点，因为它们具有很强的功能相似性。然而，在网络编程术语中来说，“插座” 这个词背负着太多的包袱，因此有必要对它进行仔细的重新检查。<br>在广泛的意义上来理解，一个端口就是一个进口或出口点。尽管 porte 这个法语单词没有被用在网络术语中，但它的字面意思门或门户进一步强调了这样一个事实：无论你是运输数据还是大型钢制集装箱，端口都是运输的端点。<br>基于本次讨论的需要，这里仅仅考虑 TCP-IP 网络的情况。OSI 模型是一个非常好的网络模型，但它从来没有被完整实现过，在高流量高压力的网络环境中也很少有部署实施。<br>IP 地址和端口的组合严格地来讲被称为端点，有时也称为套接字。这种用法起源于 RFC793，它是最初的 TCP 规范文档。<br>一个 TCP 连接由两个端点 (又称为套接字) 定义。<br>一个端点 (套接字) 由网络地址和端口 ID 组合定义。需要注意的是，地址与端口的组合并不能确切标识一个套接字 (稍后将详细介绍)。<br>端口的作用是区分给定网络地址上的多个服务端点。也可以说一个端口是一个虚拟的端点。 这种虚拟化使单个网络接口上的多个并发连接成为可能。</p>
<blockquote>
<p>套接字对 (由客户端 IP 地址、客户端端口号、服务器 IP 地址和服务器端口号组成的 4 元组) 描述的两个端点唯一标识了一个网络中的每个 TCP 连接。 (<em>TCP-IP Illustrated Volume 1</em>, W. Richard Stevens)</p>
</blockquote>
<p>在大多数派生自 C 的编程语言中，TCP 连接的建立和操作都是通过调用 Socket 类的实例的一系列方法完成的。虽然常见的是在更高的抽象层次上去操作连接，例如通过 NetworkStream 类的实例，但这些高层次类一般也是通过暴露底层套接字对象的引用来实现的。对于编程人员来说，这个套接字对象似乎代表连接，因为连接是使用套接字对象的方法创建和操作的。<br>在 C# 中，建立一个 TCP 连接（与已经存在的一个监听服务）的第一步是创建一个 TcpClient 对象。如果你没有为 TcpClient 构造函数指定端点，它将使用默认值：某种方法定义的本地端点。然后在已创建的实例上调用 Connect 方法，Connect 方法需要对方端点信息作为参数。<br>所有这些都有点令人困惑，让你相信套接字是一种连接，这是不正确的。 我一直在这种误解之下苦苦思索，直到到 Richard Dorman 问了这个问题。<br>经过大量的阅读和思考，我现在确信，拥有一个带有两个参数 LocalEndpoint 和 RemoteEndpoint 的构造函数的类 TcpConnection 更有具体意义。 当本地端点可以接受缺省值时，可以支持传入单个参数 RemoteEndpoint。 在具有多个网络接口的计算机上使用默认的本地端点会产生不确定性，但是可以使用路由表来选择能够到达远程端点的最短路径的接口来消除这种不确定性。<br>在其它方面的一些明确性也能有提升。套接字不能被 IP 地址和端口的组合确切地标识：</p>
<blockquote>
<p>[…]TCP 会用到组成本地和外部地址的所有四个值对传入的多路数据段进行解析：目的 IP 地址、目的端口、源 IP 地址和源端口。 TCP 无法仅通过目的端口来确定将到达的数据段传递给哪个进程。 此外，[给定端口号] 上的 [多个] 端点中唯有处于监听状态的端点才会收到建立连接的请求。 (p255, <em>TCP-IP Illustrated Volume 1</em>, W. Richard Stevens)</p>
</blockquote>
<p>如你所见，对于一个网络服务来说，在同一地址 / 端口上存在多个套接字不仅是可能的，而且这种可能性还很大，只不过在一个特定的地址 / 端口组合上只能有一个处于监听状态的套接字。 典型的库实现提供一个套接字类，开发人员使用这个类的实例创建和管理连接。这是极其不幸的，因为它造成了混淆，并导致了对套接字和连接两个概念大范围的混用。<br>Hagrawal 不相信我的观点（见评论），因此在此给出一个示例。我通过浏览器访问了 <a href="http://dilbert.com" target="_blank" rel="external nofollow noopener noreferrer">http://dilbert.com</a> 然后执行了 <code>netstat -an -p tcp</code> 命令。命令输出内容的最后六行包含了两个例子可以说明仅靠地址和端口是不足以唯一标识一个套接字的事实。可以看到在 192.168.1.3 (我的本地工作站) 和 54.252.94.236:80 (远端 HTTP 服务器) 之间有两个不同的 TCP 连接。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">TCP    192.168.1.3:63240      54.252.94.236:80       SYN_SENT</span></pre></td></tr><tr><td class="code"><pre><span class="line">TCP    192.168.1.3:63241      54.252.94.236:80       SYN_SENT</span></pre></td></tr><tr><td class="code"><pre><span class="line">TCP    192.168.1.3:63242      207.38.110.62:80       SYN_SENT</span></pre></td></tr><tr><td class="code"><pre><span class="line">TCP    192.168.1.3:63243      207.38.110.62:80       SYN_SENT</span></pre></td></tr><tr><td class="code"><pre><span class="line">TCP    192.168.1.3:64161      65.54.225.168:443      ESTABLISHED</span></pre></td></tr></table></figure>
<p>由于套接字是一个连接的一个端点，所以地址／端口组合 <code>207.38.110.62:80</code> 和<code>54.252.94.236:80</code> 分别都有两个套接字。<br>我想 Hagrawal 的误解来自于我对 “identifies” 一词的极其谨慎地使用。 我提到 “identifies” 一词指的是 “完全、明确和唯一地识别”。 在上面的示例中，地址 / 端口组合 54.252.94.236:80 有两个端点。 如果只有地址和端口信息，则无法区分这些套接字，即没有足够的信息来标识一个套接字。<br> RFC793 文档 2.7 章节第二段说到：</p>
<blockquote>
<p>一个连接由通信两端的一对套接字完整描述。一个本地套接字可以参与到与多个外部套接字建立的多个连接中。</p>
</blockquote>
<p>从编程的角度来讲这个关于套接字的说法毫无意义，因为它和作为特定连接端点的套接字对象并不相同。对于一个编程人员来说（这个问题的大多数受众应该是程序员），这是非常关键的实用性的区别。<br>端口是用在 TCP/IP 协议栈中指代通信端点。而套接字是在各种协议栈的实现中通用的对通信端点的软件抽象（socket API）。例如不同于 TCP/IP 的另一种协议实现是 XTI/TLI API。</p>
]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>Go 知识点汇总</title>
    <url>/post/defe85e8.html</url>
    <content><![CDATA[<p><a name="YEnn3"></a></p><h3 id="基本理解"><a href="#基本理解" class="headerlink" title="基本理解"></a>基本理解</h3><p><a name="szYLf"></a></p><h4 id="关于-slice-的初始化"><a href="#关于-slice-的初始化" class="headerlink" title="关于 slice 的初始化"></a>关于 slice 的初始化</h4><p>执行代码：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="string">"fmt"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">var</span> tmpSlice []<span class="keyword">int</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	fmt.Printf(<span class="string">"value: %[1]v   type: %[1]T    len: %d    cap: %d    underlay: %p\n"</span>, tmpSlice, <span class="built_in">len</span>(tmpSlice), <span class="built_in">cap</span>(tmpSlice), tmpSlice)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	tmpSlice = <span class="built_in">append</span>(tmpSlice, <span class="number">1</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	fmt.Printf(<span class="string">"value: %[1]v   type: %[1]T    len: %d    cap: %d    underlay: %p\n"</span>, tmpSlice, <span class="built_in">len</span>(tmpSlice), <span class="built_in">cap</span>(tmpSlice), tmpSlice)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><a id="more"></a>



<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">value: []   type: []int    len: 0    cap: 0    underlay: 0x0</span></pre></td></tr><tr><td class="code"><pre><span class="line">value: [1]   type: []int    len: 1    cap: 2    underlay: 0x414028</span></pre></td></tr></table></figure>
<p>上述示例说明 slice 可以不进行初始化，在 append 调用中会自动创建底层数组分配空间，即所谓懒初始化。一般情况下， slice 可通过以下方式产生：<br>输入：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="string">"fmt"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	slice1 := []<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	printSlice(slice1)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	</span></pre></td></tr><tr><td class="code"><pre><span class="line">	slice2 := []<span class="keyword">int</span>&#123;<span class="number">6</span>:<span class="number">1</span>&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	printSlice(slice2)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	</span></pre></td></tr><tr><td class="code"><pre><span class="line">	underlayArr :=[...]<span class="keyword">int</span>&#123;<span class="number">15</span>:<span class="number">1</span>&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	slice3 := underlayArr[<span class="number">12</span>:]</span></pre></td></tr><tr><td class="code"><pre><span class="line">	printSlice(slice3)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	</span></pre></td></tr><tr><td class="code"><pre><span class="line">	slice4 := <span class="built_in">make</span>([]<span class="keyword">int</span>,<span class="number">3</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	printSlice(slice4)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	</span></pre></td></tr><tr><td class="code"><pre><span class="line">	slice5 := <span class="built_in">make</span>([]<span class="keyword">int</span>,<span class="number">3</span>,<span class="number">8</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	printSlice(slice5)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printSlice</span><span class="params">(s []<span class="keyword">int</span>)</span></span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	fmt.Printf(<span class="string">"value: %[1]v   type: %[1]T    len: %d    cap: %d    underlay: %p\n"</span>, s, <span class="built_in">len</span>(s), <span class="built_in">cap</span>(s), s)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">value: [1 2 3]   type: []int    len: 3    cap: 3    underlay: 0x414020</span></pre></td></tr><tr><td class="code"><pre><span class="line">value: [0 0 0 0 0 0 1]   type: []int    len: 7    cap: 7    underlay: 0x45e020</span></pre></td></tr><tr><td class="code"><pre><span class="line">value: [0 0 0 1]   type: []int    len: 4    cap: 4    underlay: 0x4300f0</span></pre></td></tr><tr><td class="code"><pre><span class="line">value: [0 0 0]   type: []int    len: 3    cap: 3    underlay: 0x4140a0</span></pre></td></tr><tr><td class="code"><pre><span class="line">value: [0 0 0]   type: []int    len: 3    cap: 8    underlay: 0x45e040</span></pre></td></tr></table></figure>

<p><a name="J5JDU"></a></p>
<h4 id="切片拷贝"><a href="#切片拷贝" class="headerlink" title="切片拷贝"></a>切片拷贝</h4><p>以下代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="string">"fmt"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	arr := [<span class="number">20</span>]<span class="keyword">int</span>&#123;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	slice1 := arr[<span class="number">2</span>:<span class="number">5</span>]</span></pre></td></tr><tr><td class="code"><pre><span class="line">	fmt.Printf(<span class="string">"%+v\n"</span>, slice1)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	slice2 := slice1</span></pre></td></tr><tr><td class="code"><pre><span class="line">	slice2[<span class="number">1</span>] = <span class="number">3</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	slice2 = <span class="built_in">append</span>(slice2, []<span class="keyword">int</span>&#123;<span class="number">1</span>&#125;...)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	fmt.Printf(<span class="string">"%+v\n"</span>, slice1)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	fmt.Printf(<span class="string">"%+v\n"</span>, slice2)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	slice2[<span class="number">2</span>] = <span class="number">5</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	fmt.Printf(<span class="string">"%+v\n"</span>, slice1)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	fmt.Printf(<span class="string">"%+v\n"</span>, slice2)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[0 0 0]</span></pre></td></tr><tr><td class="code"><pre><span class="line">[0 3 0]</span></pre></td></tr><tr><td class="code"><pre><span class="line">[0 3 0 1]</span></pre></td></tr><tr><td class="code"><pre><span class="line">[0 3 5]</span></pre></td></tr><tr><td class="code"><pre><span class="line">[0 3 5 1]</span></pre></td></tr></table></figure>
<p>以上输出说明，整个过程中两个切片的底层数组仍然是同一个，这是因为切片复制完成的瞬间新切片和原切片的底层数组一定是同一个，之后随着 append 操作有可能会造成切片各自的底层数组发生变化，而这种变化并不是一定会出现，只有底层数组的容量不足以容纳新的元素时才会发生，而上面的输出结果表明，由于底层数组的容量仍然足以容纳新的元素，所以切片 append 操作后底层数组仍未变化，也就是说原切片和新切片之间仍然有可能相互影响。<br>下面的例子恰好是由于新切片 append 元素时底层数组不足以容纳新的元素造成底层数组的变化，之后两个切片再无关系：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="string">"fmt"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	slice1 := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">10</span>: <span class="number">0</span>&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	fmt.Printf(<span class="string">"%+v\n"</span>, slice1)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	slice2 := slice1</span></pre></td></tr><tr><td class="code"><pre><span class="line">	slice2[<span class="number">1</span>] = <span class="number">3</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	slice2 = <span class="built_in">append</span>(slice2, []<span class="keyword">int</span>&#123;<span class="number">1</span>&#125;...)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	fmt.Printf(<span class="string">"%+v\n"</span>, slice1)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	fmt.Printf(<span class="string">"%+v\n"</span>, slice2)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	slice2[<span class="number">3</span>]=<span class="number">5</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	fmt.Printf(<span class="string">"%+v\n"</span>, slice1)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	fmt.Printf(<span class="string">"%+v\n"</span>, slice2)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="number">1</span> <span class="number">3</span> <span class="number">3</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="number">1</span> <span class="number">3</span> <span class="number">3</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span>]</span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="number">1</span> <span class="number">3</span> <span class="number">3</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</span></pre></td></tr><tr><td class="code"><pre><span class="line">[<span class="number">1</span> <span class="number">3</span> <span class="number">3</span> <span class="number">5</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span>]</span></pre></td></tr></table></figure>
<p>综上，我们不能依靠拷贝切片之间的联系来获取排序后的元素值（除非是原地排序，不需要增加切片大小），即不能像 C 语言使用指针一样，而应当每次返回一个新的切片存储排好序的值。</p>
<p><a name="IWVp8"></a></p>
<h4 id="包导入过程"><a href="#包导入过程" class="headerlink" title="包导入过程"></a>包导入过程</h4><p><img src="https://cdn.nlark.com/yuque/0/2019/png/182657/1572858912878-86d89e2a-168b-43ad-9e9b-70068b16e723.png#align=left&display=inline&height=424&name=image.png&originHeight=424&originWidth=953&size=146883&status=done&width=953" alt="image.png"><br><a name="ifRex"></a></p>
<h4 id="godoc-与-go-doc"><a href="#godoc-与-go-doc" class="headerlink" title="godoc 与 go doc"></a>godoc 与 go doc</h4><p>从 go 1.12 开始， godoc 不再提供各种子命令，仅作为一个 http server 提供 GOPATH 和 GOROOT 下 pkg 的在线文档，而 go doc 命令可以用来查看本地程序的文档。</p>
<p><a name="EA3XH"></a></p>
<h3 id="编程方法"><a href="#编程方法" class="headerlink" title="编程方法"></a>编程方法</h3><p><a name="2qLn1"></a></p>
<h4 id="获取变量类型"><a href="#获取变量类型" class="headerlink" title="获取变量类型"></a>获取变量类型</h4><ul>
<li><p>fmt</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    v := <span class="string">"hello world"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    fmt.Println(typeof(v))</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">typeof</span><span class="params">(v <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">string</span></span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> fmt.Sprintf(<span class="string">"%T"</span>, v)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
</li>
<li><p>reflect</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="string">"reflect"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="string">"fmt"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">)</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    v := <span class="string">"hello world"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    fmt.Println(typeof(v))</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">typeof</span><span class="params">(v <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">string</span></span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> reflect.TypeOf(v).String()</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
</li>
<li><p><a href="https://golang.org/ref/spec#Type_assertions" target="_blank" rel="external nofollow noopener noreferrer">类型断言</a></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    v := <span class="string">"hello world"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    fmt.Println(typeof(v))</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">typeof</span><span class="params">(v <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">string</span></span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">switch</span> t := v.(<span class="keyword">type</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">case</span> <span class="keyword">int</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="string">"int"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">case</span> <span class="keyword">float64</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="string">"float64"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//... etc</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">default</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">        _ = t</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="string">"unknown"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>其实前两个都是用了反射，fmt.Printf (“% T”) 里最终调用的还是 <code>reflect.TypeOf()</code>。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *pp)</span> <span class="title">printArg</span><span class="params">(arg <span class="keyword">interface</span>&#123;&#125;, verb <span class="keyword">rune</span>)</span></span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ...</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">// Special processing considerations.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">// %T (the value's type) and %p (its address) are special; we always do them first.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">switch</span> verb &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">case</span> <span class="string">'T'</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">		p.fmt.fmt_s(reflect.TypeOf(arg).String())</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">return</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">case</span> <span class="string">'p'</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">		p.fmtPointer(reflect.ValueOf(arg), <span class="string">'p'</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">return</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr></table></figure>
<p>reflect.TypeOf () 的参数是 <code>v interface{}</code>，golang 的反射是怎么做到的呢？在 golang 中，interface 也是一个结构体，记录了 2 个指针：</p>
</li>
<li><p>指针 1，指向该变量的类型</p>
</li>
<li><p>指针 2，指向该变量的 value<br><a name="fCmPq"></a></p>
<h4 id="获取变量地址"><a href="#获取变量地址" class="headerlink" title="获取变量地址"></a>获取变量地址</h4><p>输入：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="string">"fmt"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="string">"reflect"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="string">"unsafe"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	intarr := [<span class="number">5</span>]<span class="keyword">int</span>&#123;<span class="number">12</span>, <span class="number">34</span>, <span class="number">55</span>, <span class="number">66</span>, <span class="number">43</span>&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	slice := intarr[:]</span></pre></td></tr><tr><td class="code"><pre><span class="line">	fmt.Printf(<span class="string">"the len is %d and cap is %d \n"</span>, <span class="built_in">len</span>(slice), <span class="built_in">cap</span>(slice))</span></pre></td></tr><tr><td class="code"><pre><span class="line">	fmt.Printf(<span class="string">"%p   %p   %p   %p\n"</span>, &amp;slice[<span class="number">0</span>], &amp;intarr, slice, &amp;slice)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	fmt.Printf(<span class="string">"underlay: %#x\n"</span>, (*reflect.SliceHeader)(unsafe.Pointer(&amp;slice)).Data)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">the len is 5 and cap is 5 </span></pre></td></tr><tr><td class="code"><pre><span class="line">0x456000   0x456000   0x456000   0x40a0e0</span></pre></td></tr><tr><td class="code"><pre><span class="line">underlay: 0x456000</span></pre></td></tr></table></figure>

</li>
</ul>
<p><a name="XLO09"></a></p>
<h4 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h4><p>在 Go 语言中可以很方便地构建反向代理服务器：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Serve a reverse proxy for a given url</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">serveReverseProxy</span><span class="params">(target <span class="keyword">string</span>, res http.ResponseWriter, req *http.Request)</span></span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">// parse the url</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	url, _ := url.Parse(target)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">// create the reverse proxy</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	proxy := httputil.NewSingleHostReverseProxy(url)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">// Update the headers to allow for SSL redirection</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	req.URL.Host = url.Host</span></pre></td></tr><tr><td class="code"><pre><span class="line">	req.URL.Scheme = url.Scheme</span></pre></td></tr><tr><td class="code"><pre><span class="line">	req.Header.Set(<span class="string">"X-Forwarded-Host"</span>, req.Header.Get(<span class="string">"Host"</span>))</span></pre></td></tr><tr><td class="code"><pre><span class="line">	req.Host = url.Host</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">// Note that ServeHttp is non blocking and uses a go routine under the hood</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	proxy.ServeHTTP(res, req)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p><a name="yfmQE"></a></p>
<h4 id="从静态文件生成-go-code-并-serve"><a href="#从静态文件生成-go-code-并-serve" class="headerlink" title="从静态文件生成 go code 并 serve"></a>从静态文件生成 go code 并 serve</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 使用两个开源库</span></pre></td></tr><tr><td class="code"><pre><span class="line">go get github.com/jteeuwen/go-bindata</span></pre></td></tr><tr><td class="code"><pre><span class="line">go get github.com/elazarl/go-bindata-assetfs</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">// 从本地目录生成 go code</span></pre></td></tr><tr><td class="code"><pre><span class="line">// 会在当前目录生成 bindata.go</span></pre></td></tr><tr><td class="code"><pre><span class="line">go-bindata-assetfs swagger-ui/</span></pre></td></tr></table></figure>
<p>之后就可以使用该文件创建一个 http 静态站点：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这里以 swagger-ui 编译之后的文件为例</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 假设生成的 go 代码所属包名为 swagger</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="string">"log"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="string">"net/http"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="string">"github.com/elazarl/go-bindata-assetfs"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  	<span class="string">"fake.local.com/test/swagger"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// FileServer 会自动尝试获取目录下的 index.html 文件返回给用户</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 从而使得一个静态站点能够正常工作</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">// Use binary asset FileServer</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	http.Handle(<span class="string">"/"</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">		http.FileServer(&amp;assetfs.AssetFS&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		Asset:    swagger.Asset,</span></pre></td></tr><tr><td class="code"><pre><span class="line">		AssetDir: swagger.AssetDir,</span></pre></td></tr><tr><td class="code"><pre><span class="line">		Prefix:   <span class="string">"swagger-ui"</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;))</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	log.Println(<span class="string">"http server started on :8000"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	err := http.ListenAndServe(<span class="string">":8000"</span>, <span class="literal">nil</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		log.Fatal(<span class="string">"ListenAndServe: "</span>, err)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p><a name="q6Eoo"></a></p>
<h4 id="HTTP-Response-Status"><a href="#HTTP-Response-Status" class="headerlink" title="HTTP Response Status"></a>HTTP Response Status</h4><p>有两种标准写法可用：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// WriteHeader 用以返回指定状态码的 http 响应。如果在调用 Write 方法前没有显式指定状态码，</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 则第一次调用 Write 时会触发一个隐式的设定状态码操作 WriteHeader(http.StatusOK)。因此，</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 一般不需要显式去设置状态码，大多数情况下只是在出现错误时显式调用 WriteHeader 用以返回错误</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 状态。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ServeHTTP</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    w.WriteHeader(http.StatusInternalServerError)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    w.Write([]<span class="keyword">byte</span>(<span class="string">"500 - Something bad happened!"</span>))</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 另一种写法,其实也是调用了 WriteHeader 方法</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">yourFuncHandler</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    http.Error(w, <span class="string">"my own error message"</span>, http.StatusForbidden)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// or using the default message error</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    http.Error(w, http.StatusText(http.StatusNotFound), http.StatusNotFound)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p><a name="RkIX9"></a></p>
<h4 id="写入文件"><a href="#写入文件" class="headerlink" title="写入文件"></a>写入文件</h4><p>当待写入的文件已经存在时，应该以可写模式打开它进行写入；当待写入文件不存在时，应该创建该文件并进行写入。直觉上，我们应当首先判断文件是否存在，可以使用如下代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> _, err := os.Stat(<span class="string">"/path/to/whatever"</span>); os.IsNotExist(err) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// path/to/whatever does not exist</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>通过跟踪 <code>os.IsNotExist</code> 函数的实现可以发现，它主要处理两类错误： <code>os.ErrNotExist</code> 和 <code>syscall.ENOENT</code> ，也就是只有这两种错误才会使得 <code>os.IsNotExist(err)</code> 返回 <code>true</code>。实际上，仅仅这两种错误是无法确定文件是不存在的，有时 <code>os.Stat</code> 返回 <code>ENOTDIR</code> 而不是 <code>ENOENT</code> ，例如，如果 <code>/etc/bashrc</code> 文件存在，则使用 <code>os.Stat</code> 检查 <code>/etc/bashrc/foobar</code> 是否存在时会返回 <code>ENOTDIR</code> 错误表明 <code>/etc/bashrc</code> 不是一个目录，因此上述写法是有问题的。实际上使用 <code>os.Stat</code> 的可能结果如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> _, err := os.Stat(<span class="string">"/path/to/whatever"</span>); err == <span class="literal">nil</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// path/to/whatever exists</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> os.IsNotExist(err) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// path/to/whatever does *not* exist</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125; <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// Schrodinger: file may or may not exist. See err for details.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// Therefore, do *NOT* use !os.IsNotExist(err) to test for file existence</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>也就是说使用 <code>os.Stat</code> 无法确定文件是否存在，因此写入文件时先使用 <code>os.Stat</code> 判断文件是否存在，不存在时则使用 <code>os.Create</code> 创建文件的写法是错误的（尽管大多数时候能够成功写入）。正确的写入文件的方法是 <code>os.OpenFile(path, os.O_RDWR|os.O_CREATE, 0666)</code> ，这个函数通过 sys_openat 系统调用依据传入的 Flag 打开文件，如果文件不存在则创建，如果文件存在则直接打开，使用这个函数的另一个好处是不会产生竞争条件（即使另外一个操作正在创建该文件？），参见 <a href="https://stackoverflow.com/questions/12518876/how-to-check-if-a-file-exists-in-go" target="_blank" rel="external nofollow noopener noreferrer">https://stackoverflow.com/questions/12518876/how-to-check-if-a-file-exists-in-go</a> 中的一系列回答和讨论。<br>另一种选择是使用 <code>ioutil.WriteFile()</code> ，其内部同样是调用了 <code>os.OpenFile</code>，只不过只适用于一次性全量写入。</p>
<p><a name="ZC8Wn"></a></p>
<h4 id="Template-中判断-range-最后一个元素"><a href="#Template-中判断-range-最后一个元素" class="headerlink" title="Template 中判断 range 最后一个元素"></a>Template 中判断 range 最后一个元素</h4><p>template 中可以使用 if 判断值是否为 0 ，不像在 Go 语法只能对 bool 值执行 if 操作，因此判断是否为第一个元素相对容易一些，使用 <code>{\{if $index\}\},\{\{end\}\}</code> 即可，而且 <code>index</code> 不需要专门声明。判断是否为最后一个元素则需要自定义函数如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="string">"os"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="string">"reflect"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="string">"text/template"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fns = template.FuncMap&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="string">"last"</span>: <span class="function"><span class="keyword">func</span><span class="params">(x <span class="keyword">int</span>, a <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">bool</span></span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> x == reflect.ValueOf(a).Len() - <span class="number">1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    t := template.Must(template.New(<span class="string">"abc"</span>).Funcs(fns).Parse(<span class="string">`\&#123;\&#123;range  $i, $e := .\&#125;\&#125;\&#123;\&#123;if $i\&#125;\&#125;, \&#123;\&#123;end\&#125;\&#125;\&#123;\&#123;if last $i $\&#125;\&#125;and \&#123;\&#123;end\&#125;\&#125;\&#123;\&#123;$e\&#125;\&#125;\&#123;\&#123;end\&#125;\&#125;.`</span>))</span></pre></td></tr><tr><td class="code"><pre><span class="line">    a := []<span class="keyword">string</span>&#123;<span class="string">"one"</span>, <span class="string">"two"</span>, <span class="string">"three"</span>&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    t.Execute(os.Stdout, a)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>关于 Template 的使用可以参考：<a href="https://github.com/grpc-ecosystem/grpc-gateway/blob/master/protoc-gen-grpc-gateway/gengateway/template.go" target="_blank" rel="external nofollow noopener noreferrer">https://github.com/grpc-ecosystem/grpc-gateway/blob/master/protoc-gen-grpc-gateway/gengateway/template.go</a></p>
<p><a name="0UUJH"></a></p>
<h4 id="生成-zip-文件并返回给-http-response"><a href="#生成-zip-文件并返回给-http-response" class="headerlink" title="生成 zip 文件并返回给 http response"></a>生成 zip 文件并返回给 http response</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">zipHandler</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    filename := <span class="string">"randomfile.jpg"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// var buf bytes.Buffer </span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 直接声明一个 buffer 即可用，buffer 开箱即用是因为当调用 Write 写入内容时会自动判断</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 底层切片是否为 nil，如果为 nil 则会分配一个容量为 smallBufferSize = 64 ,长度</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 为待写入切片的长度 n （如果满足 n &lt; smallBufferSize，否则转入其它处理逻辑）</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    buf := <span class="built_in">new</span>(bytes.Buffer)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 其实没有必要使用 Buffer ，可以直接使用 w，如下：</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// writer := zip.NewWriter(w)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 因为 net/http 内部类型 *response 实现了 http.ResponseWriter ，而 reponse 内部</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 使用的 bufferio.Writer 本身就已经有缓冲区</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    writer := zip.NewWriter(buf)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    data, err := ioutil.ReadFile(filename)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        log.Fatal(err)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    f, err := writer.Create(filename)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        log.Fatal(err)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    _, err = f.Write([]<span class="keyword">byte</span>(data))</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        log.Fatal(err)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    err = writer.Close()</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        log.Fatal(err)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 实测可以使用 w.Header().Set("Content-Type", "application/octet-stream")</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    w.Header().Set(<span class="string">"Content-Type"</span>, <span class="string">"application/zip"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    w.Header().Set(<span class="string">"Content-Disposition"</span>, fmt.Sprintf(<span class="string">"attachment; filename=\"%s.zip\""</span>, filename))</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//io.Copy(w, buf)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    w.Write(buf.Bytes())</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>另一种简单的写法：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handleZip</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    f, err := os.Open(<span class="string">"main.go"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        log.Fatal(err)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> err := f.Close(); err != <span class="literal">nil</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            log.Fatal(err)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;()</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// write straight to the http.ResponseWriter</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    zw := zip.NewWriter(w)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    cf, err := zw.Create(f.Name())</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        log.Fatal(err)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    w.Header().Set(<span class="string">"Content-Type"</span>, <span class="string">"application/zip"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    w.Header().Set(<span class="string">"Content-Disposition"</span>, fmt.Sprintf(<span class="string">"attachment; filename=\"%s.zip\""</span>, f.Name()))</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// copy the file contents to the zip Writer</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    _, err = io.Copy(cf, f)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        log.Fatal(err)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// close the zip Writer to flush the contents to the ResponseWriter</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    err = zw.Close()</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        log.Fatal(err)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p><a name="vNzvG"></a></p>
<h4 id="从-http-request-body-中解析出-go-对象"><a href="#从-http-request-body-中解析出-go-对象" class="headerlink" title="从 http request body 中解析出 go 对象"></a>从 http request body 中解析出 go 对象</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> info MyLocalType</span></pre></td></tr><tr><td class="code"><pre><span class="line">data, err := ioutil.ReadAll(req.Body)</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    w.WriteHeader(http.StatusBadRequest)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    w.Write([]<span class="keyword">byte</span>(<span class="string">"read data from request body failed!"</span>))</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> err = json.Unmarshal(data, &amp;info); err != <span class="literal">nil</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    w.WriteHeader(http.StatusBadRequest)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    w.Write([]<span class="keyword">byte</span>(<span class="string">"parse info from request body failed!"</span>))</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 简单点的</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> err := json.NewDecoder(req.Body).Decode(&amp;info); err != <span class="literal">nil</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    w.WriteHeader(http.StatusBadRequest)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    w.Write([]<span class="keyword">byte</span>(<span class="string">"parse info from request body failed!"</span>))</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p><a name="CtPsq"></a></p>
<h4 id="按行读取文本"><a href="#按行读取文本" class="headerlink" title="按行读取文本"></a>按行读取文本</h4><p>如果是对一个多行的字符串按行读取，则可以：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> _, line := <span class="keyword">range</span> strings.Split(strings.TrimSuffix(x, <span class="string">"\n"</span>), <span class="string">"\n"</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    fmt.Println(line)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>如果是从文件或者流式管道中按行读取，则可以：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">scanner := bufio.NewScanner(f) <span class="comment">// f is the *os.File</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> scanner.Scan() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    fmt.Println(scanner.Text()) <span class="comment">// Println will add back the final '\n'</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> err := scanner.Err(); err != <span class="literal">nil</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="comment">// handle error</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 另一个例子</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">args := <span class="string">"-E -eNEW,DESTROY -ptcp --any-nat --buffer-size 1024000 --dport "</span> + fmt.Sprintf(<span class="string">"%d"</span>, serviceNodePort)</span></pre></td></tr><tr><td class="code"><pre><span class="line">cmd := exec.Command(<span class="string">"conntrack"</span>, strings.Split(args, <span class="string">" "</span>)...)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">stdout, _ := cmd.StdoutPipe()</span></pre></td></tr><tr><td class="code"><pre><span class="line">err := cmd.Start()</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    common.ZapClient.Fatalf(<span class="string">"start conntrack failed: %s"</span>, err.Error())</span></pre></td></tr><tr><td class="code"><pre><span class="line">    errChan &lt;- err</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">scanner := bufio.NewScanner(stdout)</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> scanner.Scan() &#123;&#125;</span></pre></td></tr></table></figure>

<p><a name="utDk1"></a></p>
<h3 id="WebAssembly"><a href="#WebAssembly" class="headerlink" title="WebAssembly"></a>WebAssembly</h3><ol>
<li>作者通过一系列 hack 过程成功实现了将一个 go 语言写的工具 <a href="https://github.com/pdfcpu/pdfcpu" target="_blank" rel="external nofollow noopener noreferrer">pdfcpu</a> 编译为 wasm 文件并运行在浏览器中，其中有使用到一个浏览器端基于内存的文件系统 <a href="https://github.com/jvilk/BrowserFS" target="_blank" rel="external nofollow noopener noreferrer">BrowserFS</a> （实现了 Node JS 的 fs 库的 API）对 pdf 文件进行操作，很有意思。博客地址：<a href="https://dev.to/wcchoi/browser-side-pdf-processing-with-go-and-webassembly-13hn" target="_blank" rel="external nofollow noopener noreferrer">https://dev.to/wcchoi/browser-side-pdf-processing-with-go-and-webassembly-13hn</a>，代码地址：<a href="https://github.com/wcchoi/go-wasm-pdfcpu" target="_blank" rel="external nofollow noopener noreferrer">https://github.com/wcchoi/go-wasm-pdfcpu</a>。</li>
<li>vugu 使用 go 实现的类似于 vue 的前端框架，用 go 替代 JavaScript 写逻辑：<a href="https://github.com/vugu/vugu" target="_blank" rel="external nofollow noopener noreferrer">https://github.com/vugu/vugu</a>。</li>
</ol>
<p><a name="ttykc"></a></p>
<h3 id="开源库"><a href="#开源库" class="headerlink" title="开源库"></a>开源库</h3><ol>
<li>Linux 操作系统功能调用 <a href="https://github.com/tredoe/osutil" target="_blank" rel="external nofollow noopener noreferrer">osutil</a>， 可以用以生成 Linux 用户密码的 Hash。</li>
<li>一个强大的请求限速库 <a href="https://github.com/didip/tollbooth" target="_blank" rel="external nofollow noopener noreferrer">https://github.com/didip/tollbooth</a>，可以根据请求头或者源 IP 限速。</li>
<li>Go 社区提供的实现了令牌桶算法的限速包 <a href="https://godoc.org/golang.org/x/time/rate" target="_blank" rel="external nofollow noopener noreferrer">https://godoc.org/golang.org/x/time/rate</a>，一个简单的例子 <a href="https://pliutau.com/rate-limit-http-requests/" target="_blank" rel="external nofollow noopener noreferrer">https://pliutau.com/rate-limit-http-requests/</a> 。</li>
<li>一个创建和解压 zip 文件的库，在调用标准库 <code>archive/zip</code> 基础上做了些友好封装：<a href="https://github.com/pierrre/archivefile" target="_blank" rel="external nofollow noopener noreferrer">https://github.com/pierrre/archivefile</a>。</li>
<li>一个 Markdown 转 PDF 的库，只是不支持中文字符：<a href="https://github.com/mandolyte/mdtopdf" target="_blank" rel="external nofollow noopener noreferrer">https://github.com/mandolyte/mdtopdf</a>。</li>
</ol>
<p><a name="ymvvh"></a></p>
<h3 id="书籍"><a href="#书籍" class="headerlink" title="书籍"></a>书籍</h3><ol>
<li>《Go 语言从入门到进阶实战》名字俗了点，但是内容还是值得一读，作者对 Go 语言的使用还是很熟练的。</li>
<li>《Go 语言高级编程》 <a href="https://github.com/chai2010/advanced-go-programming-book" target="_blank" rel="external nofollow noopener noreferrer">https://github.com/chai2010/advanced-go-programming-book</a> rpc 相关的内容可以一读。</li>
<li>Concurrency in Go</li>
</ol>
]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>Go 语言流式 IO</title>
    <url>/post/d2033f7a.html</url>
    <content><![CDATA[<p><a name="2PGKt"></a></p><h3 id="原文"><a href="#原文" class="headerlink" title="原文"></a>原文</h3><p><a href="https://medium.com/learning-the-go-programming-language/streaming-io-in-go-d93507931185" target="_blank" rel="external nofollow noopener noreferrer">Streaming IO in Go</a></p><p>在 Go 语言中，实现输入输出操作有专门的原语，这些原语将数据构建为可读写的字节流。Go 语言标准库中 io 包提供了 <code>io.Reader</code> 和 <code>io.Write</code>r 接口，分别用于数据输入和输出操作，如下图所示：</p><p><img src="https://cdn.nlark.com/yuque/0/2019/png/182657/1574581234981-aab516f1-5c45-4c94-a275-5291faa2e23b.png#align=left&display=inline&height=186&name=image.png&originHeight=372&originWidth=2772&size=89243&status=done&width=1386" alt="image.png"></p><p>Go 提供了许多 api，支持来自于内存、文件、网络连接等资源的流式 IO。本文主要讲解如何使用 <code>io.Reader</code> 和 <code>io. Writer</code> 接口创建能够处理流式数据的 Go 程序，分别提供了基于标准库和自定义类型的实现。</p><a id="more"></a>




<p><a name="D5k3q"></a></p>
<h3 id="io-Reader-接口"><a href="#io-Reader-接口" class="headerlink" title="io.Reader 接口"></a>io.Reader 接口</h3><p>reader 由 io.Reader 接口定义，可以从数据源读取数据到传输缓冲区，缓冲区中的数据可以继续被流式处理或者直接消费，如下图所示：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2019/png/182657/1574582203043-67900870-30e2-4c99-bd30-da4717c937b5.png#align=left&display=inline&height=206&name=image.png&originHeight=412&originWidth=1858&size=60329&status=done&width=929" alt="image.png"><br>如果要把一个 Go 语言类型作为 reader 来使用，这个类型必须实现 <code>io.Reader</code> 所定义的 <code>Read(p []byte)</code> 方法，如下所示：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Reader <span class="keyword">interface</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Read(p []<span class="keyword">byte</span>) (n <span class="keyword">int</span>, err error)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p><code>Read()</code> 方法需要返回读取的字节数，如果发生错误则同时返回 error ，如果数据源的所有内容已被读取完毕，则 <code>Read()</code> 方法应当返回 <code>io.EOF</code> 错误。</p>
<p><a name="Oj4Mx"></a></p>
<h3 id="读取规则（新增）"><a href="#读取规则（新增）" class="headerlink" title="读取规则（新增）"></a>读取规则（新增）</h3><p>根据 Reddit 上的反馈，我决定新增这部分内容帮助理解读取操作。一个 reader 的行为取决于它的具体实现，但是 <code>io.Reader</code> 的文档中定义了一些基本的规则，在使用 reader 的时候你应当首先阅读这些说明文档：</p>
<ol>
<li><code>Read()</code> 方法会尽可能但最多读取 len(p) 个字节到 p 中。</li>
<li>调用 <code>Read()</code> 方法读取的字节数 n 可能小于 len(p)。</li>
<li>在发生读取错误的时候，<code>Read()</code> 仍然有可能已经成功读取了 n 个字节的数据到缓冲区 p 中。例如，正在从一个 TCP 套接字中读取数据时套接字突然关闭。根据使用场景的不同，你可以保留这些成功读取的数据或者丢掉它们重新尝试读取。</li>
<li>当数据源中的可用数据被读完时，<code>Read()</code> 方法有可能返回一个非零的 n 和 <code>err = io.EOF</code>。但是，根据具体的实现，reader 也可以选择在读取结束时返回一个非零的 n 和 <code>err = nil</code>。在这种情况下，所有后续的读取操作必须返回 <code>n = 0</code> 和 <code>err = io.EOF</code>。</li>
<li>最后，<code>Read()</code> 调用返回 <code>n = 0</code> 和 <code>err = nil</code> 并不意味着 EOF 因为下一次调用 <code>Read()</code> 方法可能会返回数据。</li>
</ol>
<p>正如你所看到的，有时候直接从 reader 中读取数据有些棘手。但幸运的是，标准库中实现的 reader 都遵循符合常理的方法使得可以比较容易地实现流式操作。尽管如此，在使用一个 reader 之前仍然应当仔细查阅它的文档。</p>
<p><a name="Y6TMJ"></a></p>
<h3 id="流式读取数据"><a href="#流式读取数据" class="headerlink" title="流式读取数据"></a>流式读取数据</h3><p>从一个 reader 中流式读取数据很容易。<code>Read()</code> 方法被设计为在循环中调用，在每一次迭代中，<code>Read()</code> 方法会从数据源读取一个数据 chunk 并将其放入到缓冲区 p 中。循环过程一直进行直到 <code>Read()</code> 方法返回 <code>io.EOF</code> 错误。<br>下面是一个简单的例子：使用 strings.NewReader(string) 创建了一个字符串 reader，对一个源字符串中的字节进行流式处理：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	reader := strings.NewReader(<span class="string">"Clear is better than clever"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	p := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">4</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">for</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		n, err := reader.Read(p)</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		    <span class="keyword">if</span> err == io.EOF &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			fmt.Println(<span class="keyword">string</span>(p[:n])) <span class="comment">//should handle any remainding bytes.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">			<span class="keyword">break</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">		    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		    fmt.Println(err)</span></pre></td></tr><tr><td class="code"><pre><span class="line">		    os.Exit(<span class="number">1</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		fmt.Println(<span class="keyword">string</span>(p[:n]))</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>上述代码使用 <code>make([]byte, 4)</code> 创建了一个容量和长度均为 4 个字节的字节切片作为缓冲区 p。这个缓冲区长度被故意设置为小于源字符串的长度，用来演示如何流式处理长度大于缓冲区长度的数据源。</p>
<p><a name="5SCFw"></a></p>
<h3 id="实现自定义-io-Reader"><a href="#实现自定义-io-Reader" class="headerlink" title="实现自定义 io.Reader"></a>实现自定义 io.Reader</h3><p>上面的例子使用了标准库的 reader ，现在我们尝试自定义实现一个 reader。下面的代码定义了一个 rader 类型实现了 io.Reader 接口，作用是过滤掉数据源中所有的非字母字符。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> alphaReader <span class="keyword">struct</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	src <span class="keyword">string</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	cur <span class="keyword">int</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newAlphaReader</span><span class="params">(src <span class="keyword">string</span>)</span> *<span class="title">alphaReader</span></span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">return</span> &amp;alphaReader&#123;src: src&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">alpha</span><span class="params">(r <span class="keyword">byte</span>)</span> <span class="title">byte</span></span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">if</span> (r &gt;= <span class="string">'A'</span> &amp;&amp; r &lt;= <span class="string">'Z'</span>) || (r &gt;= <span class="string">'a'</span> &amp;&amp; r &lt;= <span class="string">'z'</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">return</span> r</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">return</span> <span class="number">0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *alphaReader)</span> <span class="title">Read</span><span class="params">(p []<span class="keyword">byte</span>)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">if</span> a.cur &gt;= <span class="built_in">len</span>(a.src) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">return</span> <span class="number">0</span>, io.EOF</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	x := <span class="built_in">len</span>(a.src) - a.cur</span></pre></td></tr><tr><td class="code"><pre><span class="line">	n, bound := <span class="number">0</span>, <span class="number">0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">if</span> x &gt;= <span class="built_in">len</span>(p) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		bound = <span class="built_in">len</span>(p)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> x &lt;= <span class="built_in">len</span>(p) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		bound = x</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//译者注</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//下面的代码改成这个样子比较合适</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//这段代码可以保证每次都读到 4 个字母再返回</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//所以返回的序列是： Hell oIts amwh erei sthe sun</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//而下面的代码返回的序列是：Hell oI ts am ...</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//之所以能正常工作是因为 byte 零值打印出来为空字符串</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//buf := make([]byte, bound)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">//for n &lt; bound &amp;&amp; a.cur &lt; len(a.src) &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">//	if char := alpha(a.src[a.cur]); char != 0 &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">//		buf[n] = char</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">//		n++</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">//	&#125;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">//	a.cur++</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">//&#125;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	buf := <span class="built_in">make</span>([]<span class="keyword">byte</span>, bound)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">for</span> n &lt; bound &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">if</span> char := alpha(a.src[a.cur]); char != <span class="number">0</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			buf[n] = char</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		n++</span></pre></td></tr><tr><td class="code"><pre><span class="line">		a.cur++</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="built_in">copy</span>(p, buf)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">return</span> n, <span class="literal">nil</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	reader := newAlphaReader(<span class="string">"Hello! It's 9am, where is the sun?"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	p := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">4</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">for</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		n, err := reader.Read(p)</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">if</span> err == io.EOF &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			<span class="keyword">break</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">		&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		fmt.Print(<span class="keyword">string</span>(p[:n]))</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	fmt.Println()</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>当程序执行时会输出：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">$&gt; <span class="keyword">go</span> run alpha_reader.<span class="keyword">go</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">HelloItsamwhereisthesun</span></pre></td></tr></table></figure>

<p><a name="9cKOP"></a></p>
<h3 id="链式读取"><a href="#链式读取" class="headerlink" title="链式读取"></a>链式读取</h3><p>标准库中有很多 reader 已经实现了链式读取。使用一个 reader 作为另一个 reader 的数据源是一种常见的做法。reader 的链式组合使得一个 reader 可以复用另一个 reader 已经实现的逻辑，就像下面代码的做法：更新了 <code>alphaReader</code> 的实现使其可以接受一个 <code>io.Reader</code> 作为数据源。这样的做法通过复用已有 reader 的工作来降低代码的复杂性。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> alphaReader <span class="keyword">struct</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	reader io.Reader</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newAlphaReader</span><span class="params">(reader io.Reader)</span> *<span class="title">alphaReader</span></span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">return</span> &amp;alphaReader&#123;reader: reader&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">alpha</span><span class="params">(r <span class="keyword">byte</span>)</span> <span class="title">byte</span></span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">if</span> (r &gt;= <span class="string">'A'</span> &amp;&amp; r &lt;= <span class="string">'Z'</span>) || (r &gt;= <span class="string">'a'</span> &amp;&amp; r &lt;= <span class="string">'z'</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">return</span> r</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">return</span> <span class="number">0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *alphaReader)</span> <span class="title">Read</span><span class="params">(p []<span class="keyword">byte</span>)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	n, err := a.reader.Read(p)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">return</span> n, err</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	buf := <span class="built_in">make</span>([]<span class="keyword">byte</span>, n)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">if</span> char := alpha(p[i]); char != <span class="number">0</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			buf[i] = char</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="built_in">copy</span>(p, buf)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">return</span> n, <span class="literal">nil</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">// use an io.Reader as source for alphaReader</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	reader := newAlphaReader(strings.NewReader(<span class="string">"Hello! It's 9am, where is the sun?"</span>))</span></pre></td></tr><tr><td class="code"><pre><span class="line">	p := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">4</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">for</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		n, err := reader.Read(p)</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">if</span> err == io.EOF &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			<span class="keyword">break</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">		&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		fmt.Print(<span class="keyword">string</span>(p[:n]))</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	fmt.Println()</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p><a name="laIBP"></a></p>
<h3 id="io-Writer-接口"><a href="#io-Writer-接口" class="headerlink" title="io.Writer 接口"></a>io.Writer 接口</h3><p>writer 由 <code>io.Writer</code> 接口定义，实现流式地将数据从缓冲区写入到目标资源中，如下图所示：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2019/png/182657/1574586722093-9d4d9479-da59-446d-a748-e38a16b37d77.png#align=left&display=inline&height=213&name=image.png&originHeight=426&originWidth=1902&size=62060&status=done&width=951" alt="image.png"><br>writer 必须实现 <code>io.Write</code>r 接口的 <code>Write(p []byte)</code> 方法。<code>Wirte()</code>)方法被设计为从缓冲区 p 中读取数据并将其写入到指定的目标资源中。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Writer <span class="keyword">interface</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Write(p []<span class="keyword">byte</span>) (n <span class="keyword">int</span>, err error)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p><code>Write()</code> 方法的实现应该返回写入的字节数，发生错误时返回 <code>error</code>。</p>
<p><a name="VWQLr"></a></p>
<h3 id="使用-writers"><a href="#使用-writers" class="headerlink" title="使用 writers"></a>使用 writers</h3><p>标准库中有很多预先实现了 <code>io.Writer</code> 的类型。使用 writers 也是比较简单的，下面的代码演示了使用 <code>bytes.Buffer</code> 作为一个 writer 向内存中写入数据。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	proverbs := []<span class="keyword">string</span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="string">"Channels orchestrate mutexes serialize"</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="string">"Cgo is not Go"</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="string">"Errors are values"</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="string">"Don't panic"</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">var</span> writer bytes.Buffer</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">for</span> _, p := <span class="keyword">range</span> proverbs &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		n, err := writer.Write([]<span class="keyword">byte</span>(p))</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			fmt.Println(err)</span></pre></td></tr><tr><td class="code"><pre><span class="line">			os.Exit(<span class="number">1</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">if</span> n != <span class="built_in">len</span>(p) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			fmt.Println(<span class="string">"failed to write data"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">			os.Exit(<span class="number">1</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	fmt.Println(writer.String())</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p><a name="NeU92"></a></p>
<h3 id="实现自定义-io-Writer"><a href="#实现自定义-io-Writer" class="headerlink" title="实现自定义 io.Writer"></a>实现自定义 io.Writer</h3><p>下面的代码展示了如何实现一个名为 chanWriter 的自定义<code>io.Writer</code> 用来将缓冲区中的内容作为字节序列写入到一个 Go channel 中。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> chanWriter <span class="keyword">struct</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	ch <span class="keyword">chan</span> <span class="keyword">byte</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newChanWriter</span><span class="params">()</span> *<span class="title">chanWriter</span></span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">return</span> &amp;chanWriter&#123;<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">byte</span>, <span class="number">1024</span>)&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *chanWriter)</span> <span class="title">Chan</span><span class="params">()</span> &lt;-<span class="title">chan</span> <span class="title">byte</span></span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">return</span> w.ch</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *chanWriter)</span> <span class="title">Write</span><span class="params">(p []<span class="keyword">byte</span>)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	n := <span class="number">0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">for</span> _, b := <span class="keyword">range</span> p &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		w.ch &lt;- b</span></pre></td></tr><tr><td class="code"><pre><span class="line">		n++</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">return</span> n, <span class="literal">nil</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *chanWriter)</span> <span class="title">Close</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="built_in">close</span>(w.ch)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	writer := newChanWriter()</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">defer</span> writer.Close()</span></pre></td></tr><tr><td class="code"><pre><span class="line">		writer.Write([]<span class="keyword">byte</span>(<span class="string">"Stream "</span>))</span></pre></td></tr><tr><td class="code"><pre><span class="line">		writer.Write([]<span class="keyword">byte</span>(<span class="string">"me!"</span>))</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;()</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">for</span> c := <span class="keyword">range</span> writer.Chan() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		fmt.Printf(<span class="string">"%c"</span>, c)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	fmt.Println()</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>使用 writer 也非常简单，在 main() 函数中调用（在一个单独的 goroutine 中） <code>writer.Write()</code> 方法即可。 chanWriter 也实现了 <code>io.Closer</code> 接口，写入完成后调用 <code>writer.Close()</code> 方法关闭 channel 防止访问 channel 陷入死锁。</p>
<p><a name="4ZHls"></a></p>
<h3 id="IO-操作常用的类型和包"><a href="#IO-操作常用的类型和包" class="headerlink" title="IO 操作常用的类型和包"></a>IO 操作常用的类型和包</h3><p>之前提到，Go 语言标准库中提供了很多有用的函数和类型使得操作流式 IO 变得非常简单。<br><a name="yvVNl"></a></p>
<h4 id="os-File"><a href="#os-File" class="headerlink" title="os.File"></a>os.File</h4><p>os.File 类型表示本地系统的一个文件。它同时实现了 <code>io.Reader</code> 和 <code>io.Writer</code> 接口，所以可以被用在任何流式 IO 操作的场景。例如，下面的代码展示了如何将字符串切片直接写入到文件中：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	proverbs := []<span class="keyword">string</span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="string">"Channels orchestrate mutexes serialize\n"</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="string">"Cgo is not Go\n"</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="string">"Errors are values\n"</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="string">"Don't panic\n"</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	file, err := os.Create(<span class="string">"./proverbs.txt"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		fmt.Println(err)</span></pre></td></tr><tr><td class="code"><pre><span class="line">		os.Exit(<span class="number">1</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">defer</span> file.Close()</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">for</span> _, p := <span class="keyword">range</span> proverbs &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		n, err := file.Write([]<span class="keyword">byte</span>(p))</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			fmt.Println(err)</span></pre></td></tr><tr><td class="code"><pre><span class="line">			os.Exit(<span class="number">1</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">if</span> n != <span class="built_in">len</span>(p) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			fmt.Println(<span class="string">"failed to write data"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">			os.Exit(<span class="number">1</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	fmt.Println(<span class="string">"file write done"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>另外， <code>io.File</code> 也可以作为 reader 使用实现流式读取本地文件中的内容。例如，下面的代码演示了读取一个文件并将其内容打印出来：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	file, err := os.Open(<span class="string">"./proverbs.txt"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		fmt.Println(err)</span></pre></td></tr><tr><td class="code"><pre><span class="line">		os.Exit(<span class="number">1</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">defer</span> file.Close()</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	p := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">4</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">for</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		n, err := file.Read(p)</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">if</span> err == io.EOF &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			<span class="keyword">break</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">		&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		fmt.Print(<span class="keyword">string</span>(p[:n]))</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p><a name="YvfN0"></a></p>
<h4 id="标准输出、输入和错误"><a href="#标准输出、输入和错误" class="headerlink" title="标准输出、输入和错误"></a>标准输出、输入和错误</h4><p>os 包提供了三个变量：<code>os.Stdout</code>、<code>os.Stdin</code> 和 <code>os.Stderr</code> 。它们都是 <code>*os.File</code> 类型，分别表示操作系统的标准输出、输入和错误的文件句柄。例如，下面的代码展示直接向标准输出写入内容：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	proverbs := []<span class="keyword">string</span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="string">"Channels orchestrate mutexes serialize\n"</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="string">"Cgo is not Go\n"</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="string">"Errors are values\n"</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="string">"Don't panic\n"</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">for</span> _, p := <span class="keyword">range</span> proverbs &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		n, err := os.Stdout.Write([]<span class="keyword">byte</span>(p))</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			fmt.Println(err)</span></pre></td></tr><tr><td class="code"><pre><span class="line">			os.Exit(<span class="number">1</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">if</span> n != <span class="built_in">len</span>(p) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			fmt.Println(<span class="string">"failed to write data"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">			os.Exit(<span class="number">1</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p><a name="dPq5R"></a></p>
<h4 id="io-Copy"><a href="#io-Copy" class="headerlink" title="io.Copy()"></a>io.Copy()</h4><p>使用 <code>io.Copy()</code> 函数可以很容易地流式地从源 reader 向目标 writer 拷贝数据。它抽象了 <code>for-loop</code> 模式和正确处理 <code>io.EOF</code> 及字节数的过程。<br>下面的代码展示了一个之前代码的简化版本，拷贝 proverbs 中的内容到 file 文件中：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	proverbs := <span class="built_in">new</span>(bytes.Buffer)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	proverbs.WriteString(<span class="string">"Channels orchestrate mutexes serialize\n"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	proverbs.WriteString(<span class="string">"Cgo is not Go\n"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	proverbs.WriteString(<span class="string">"Errors are values\n"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	proverbs.WriteString(<span class="string">"Don't panic\n"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	file, err := os.Create(<span class="string">"./proverbs.txt"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		fmt.Println(err)</span></pre></td></tr><tr><td class="code"><pre><span class="line">		os.Exit(<span class="number">1</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">defer</span> file.Close()</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">// copy from reader data into writer file</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">if</span> _, err := io.Copy(file, proverbs); err != <span class="literal">nil</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		fmt.Println(err)</span></pre></td></tr><tr><td class="code"><pre><span class="line">		os.Exit(<span class="number">1</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	fmt.Println(<span class="string">"file created"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>类似地，我们可以重写之前的程序使用 <code>io.Copy()</code> 将本地文件中的内容流式地写入到标准输出：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	file, err := os.Open(<span class="string">"./proverbs.txt"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		fmt.Println(err)</span></pre></td></tr><tr><td class="code"><pre><span class="line">		os.Exit(<span class="number">1</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">defer</span> file.Close()</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">if</span> _, err := io.Copy(os.Stdout, file); err != <span class="literal">nil</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		fmt.Println(err)</span></pre></td></tr><tr><td class="code"><pre><span class="line">		os.Exit(<span class="number">1</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p><a name="Vkzoy"></a></p>
<h4 id="io-WriteString"><a href="#io-WriteString" class="headerlink" title="io.WriteString()"></a>io.WriteString()</h4><p><code>io.WriteString()</code> 为写入字符串到指定 writer 提供了便利：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	file, err := os.Create(<span class="string">"./magic_msg.txt"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		fmt.Println(err)</span></pre></td></tr><tr><td class="code"><pre><span class="line">		os.Exit(<span class="number">1</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">defer</span> file.Close()</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">if</span> _, err := io.WriteString(file, <span class="string">"Go is fun!"</span>); err != <span class="literal">nil</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		fmt.Println(err)</span></pre></td></tr><tr><td class="code"><pre><span class="line">		os.Exit(<span class="number">1</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p><a name="t0SE7"></a></p>
<h4 id="管道-writers-and-readers"><a href="#管道-writers-and-readers" class="headerlink" title="管道 writers and readers"></a>管道 writers and readers</h4><p><code>io.PipeWrite</code>r 和 <code>io.PipeReade</code>r 将 IO 操作建模为基于内存的管道。数据被写入到管道的写端并在另外一个 goroutine 中从读端读出。下面的代码使用 <code>io.Pipe()</code> 创建了一个管道 reader/writer 对用来从 proverbs 缓冲区中拷贝数据到 <code>io.Stdout</code>：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	proverbs := <span class="built_in">new</span>(bytes.Buffer)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	proverbs.WriteString(<span class="string">"Channels orchestrate mutexes serialize\n"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	proverbs.WriteString(<span class="string">"Cgo is not Go\n"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	proverbs.WriteString(<span class="string">"Errors are values\n"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	proverbs.WriteString(<span class="string">"Don't panic\n"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	piper, pipew := io.Pipe()</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">// write in writer end of pipe</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">defer</span> pipew.Close()</span></pre></td></tr><tr><td class="code"><pre><span class="line">		io.Copy(pipew, proverbs)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;()</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">// read from reader end of pipe.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	io.Copy(os.Stdout, piper)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	piper.Close()</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p><a name="PagHc"></a></p>
<h4 id="Buffered-IO"><a href="#Buffered-IO" class="headerlink" title="Buffered IO"></a>Buffered IO</h4><p>Go 通过 <code>bufio</code> 包支持 Buffered IO 使得操作文本内容更加方便。例如，下面的代码使用 <code>&#39;\n&#39;</code> 作为分隔符一行一行地读取文件的内容：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	file, err := os.Open(<span class="string">"./planets.txt"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		fmt.Println(err)</span></pre></td></tr><tr><td class="code"><pre><span class="line">		os.Exit(<span class="number">1</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">defer</span> file.Close()</span></pre></td></tr><tr><td class="code"><pre><span class="line">	reader := bufio.NewReader(file)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">for</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		line, err := reader.ReadString(<span class="string">'\n'</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			<span class="keyword">if</span> err == io.EOF &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">				<span class="keyword">break</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">			&#125; <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">				fmt.Println(err)</span></pre></td></tr><tr><td class="code"><pre><span class="line">				os.Exit(<span class="number">1</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">			&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		fmt.Print(line)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p><a name="HYmux"></a></p>
<h4 id="Util-包"><a href="#Util-包" class="headerlink" title="Util 包"></a>Util 包</h4><p>ioutil 包是 io 包的一个子包，它提供了几个方便的函数用于执行 IO 操作。例如，下面的代码使用 <code>ReadFile</code> 函数读取文件的所有内容到一个 <code>[]byte</code> 中:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="string">"io/ioutil"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">   ...</span></pre></td></tr><tr><td class="code"><pre><span class="line">)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	bytes, err := ioutil.ReadFile(<span class="string">"./planets.txt"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		fmt.Println(err)</span></pre></td></tr><tr><td class="code"><pre><span class="line">		os.Exit(<span class="number">1</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	fmt.Printf(<span class="string">"%s"</span>, bytes)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p><a name="qy15o"></a></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这篇文章展示了如何使用 <code>io.Reader</code> 和 <code>io.Writer</code> 接口实现流式 IO 操作。读过这篇文章后你应该理解了如何使用 io 包写程序处理流式 IO。<br>这里只对支持流式 IO 的包进行了简单的讨论，并没有深入探讨文件 IO 、缓冲 IO、网络 IO 和格式化 IO 等。我希望这篇文章能给你一些关于 Go 语言流式 IO 编程范式的启发。</p>
]]></content>
      <categories>
        <category>译文</category>
      </categories>
      <tags>
        <tag>译文</tag>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>gRPC snippets</title>
    <url>/post/ab759786.html</url>
    <content><![CDATA[<p><a name="d3l9E"></a></p><h4 id="使用-gRPC-错误类型"><a href="#使用-gRPC-错误类型" class="headerlink" title="使用 gRPC 错误类型"></a>使用 gRPC 错误类型</h4><p>服务端返回 <code>codes.PermissionDenined</code> 错误：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span></pre></td></tr><tr><td class="code"><pre><span class="line">	...</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="string">"google.golang.org/grpc/codes"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="string">"google.golang.org/grpc/status"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">)</span></pre></td></tr><tr><td class="code"><pre><span class="line">...</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, status.Error(codes.PermissionDenied, <span class="string">"PERMISSION_DENIED_TEXT"</span>)</span></pre></td></tr></table></figure><a id="more"></a>


<p>客户端使用 <code>status</code> 库的 <code>FromError</code> 函数解析错误，使用<code>swicth</code> 语句判断错误类型并进行对应操作:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; client</span></pre></td></tr><tr><td class="code"><pre><span class="line">    assignvar, err :&#x3D; s.MyFunctionCall(ctx, ...)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    if err !&#x3D; nil &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        if e, ok :&#x3D; status.FromError(err); ok &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            switch e.Code() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            case codes.PermissionDenied:</span></pre></td></tr><tr><td class="code"><pre><span class="line">                fmt.Println(e.Message()) &#x2F;&#x2F; this will print PERMISSION_DENIED_TEST</span></pre></td></tr><tr><td class="code"><pre><span class="line">            case codes.Internal:</span></pre></td></tr><tr><td class="code"><pre><span class="line">                fmt.Println(&quot;Has Internal Error&quot;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            case codes.Aborted:</span></pre></td></tr><tr><td class="code"><pre><span class="line">                fmt.Println(&quot;gRPC Aborted the call&quot;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            default:</span></pre></td></tr><tr><td class="code"><pre><span class="line">                fmt.Println(e.Code(), e.Message())</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        else &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            fmt.Printf(&quot;not able to parse error returned %v&quot;, err)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr></table></figure>

<p><a name="82jnK"></a></p>
<h4 id="使用-metadata-进行用户认证"><a href="#使用-metadata-进行用户认证" class="headerlink" title="使用 metadata 进行用户认证"></a>使用 metadata 进行用户认证</h4><p>参考：<a href="https://github.com/grpc/grpc-go/issues/106" target="_blank" rel="external nofollow noopener noreferrer">https://github.com/grpc/grpc-go/issues/106</a>，通过添加拦截器的方式</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// client</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">grpc.Dial(target,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    grpc.WithInsecure(),</span></pre></td></tr><tr><td class="code"><pre><span class="line">    grpc.WithPerRPCCredentials(&amp;loginCreds&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Username: <span class="string">"admin"</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Password: <span class="string">"admin123"</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;))</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> loginCreds <span class="keyword">struct</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Username, Password <span class="keyword">string</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *loginCreds)</span> <span class="title">GetRequestMetadata</span><span class="params">(context.Context, ...<span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>, error)</span></span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="string">"username"</span>: c.Username,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="string">"password"</span>: c.Password,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;, <span class="literal">nil</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *loginCreds)</span> <span class="title">RequireTransportSecurity</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// server</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">grpc.NewServer(</span></pre></td></tr><tr><td class="code"><pre><span class="line">    grpc.StreamInterceptor(streamInterceptor), </span></pre></td></tr><tr><td class="code"><pre><span class="line">    grpc.UnaryInterceptor(unaryInterceptor)</span></pre></td></tr><tr><td class="code"><pre><span class="line">)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">streamInterceptor</span><span class="params">(srv <span class="keyword">interface</span>&#123;&#125;, stream grpc.ServerStream, info *grpc.StreamServerInfo, handler grpc.StreamHandler)</span> <span class="title">error</span></span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> err := authorize(stream.Context()); err != <span class="literal">nil</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> err</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> handler(srv, stream)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">unaryInterceptor</span><span class="params">(ctx context.Context, req <span class="keyword">interface</span>&#123;&#125;, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler)</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span></span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> err := authorize(ctx); err != <span class="literal">nil</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> err</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> handler(ctx, req)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">authorize</span><span class="params">(ctx context.Context)</span> <span class="title">error</span></span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> md, ok := metadata.FromContext(ctx); ok &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(md[<span class="string">"username"</span>]) &gt; <span class="number">0</span> &amp;&amp; md[<span class="string">"username"</span>][<span class="number">0</span>] == <span class="string">"admin"</span> &amp;&amp;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="built_in">len</span>(md[<span class="string">"password"</span>]) &gt; <span class="number">0</span> &amp;&amp; md[<span class="string">"password"</span>][<span class="number">0</span>] == <span class="string">"admin123"</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> AccessDeniedErr</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> EmptyMetadataErr</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<ul>
<li>官方文档关于认证的内容：<a href="https://grpc.io/docs/guides/auth/" target="_blank" rel="external nofollow noopener noreferrer">https://grpc.io/docs/guides/auth/</a>，支持基于 TLS 证书的认证过程，使用参考：<a href="https://mycodesmells.com/post/authentication-in-grpc" target="_blank" rel="external nofollow noopener noreferrer">https://mycodesmells.com/post/authentication-in-grpc</a>，这篇文章也说明 contextWithValue 的值无法通过 gRPC 通信传递，需要通过 metadata 传输用户信息。</li>
<li>使用 metadata：可以使用 metadata 传输一些用户认证或者业务无关的信息，类似于 Http 请求中的 Header。使用方法参考： <a href="http://ralphbupt.github.io/2017/05/27/gRPC%E4%B9%8Bmetadata/" target="_blank" rel="external nofollow noopener noreferrer">http://ralphbupt.github.io/2017/05/27/gRPC之metadata/</a> 以及原文 <a href="https://github.com/grpc/grpc-go/blob/master/Documentation/grpc-metadata.md#sending-metadata-1" target="_blank" rel="external nofollow noopener noreferrer">https://github.com/grpc/grpc-go/blob/master/Documentation/grpc-metadata.md#sending-metadata-1</a>。</li>
</ul>
<p><a name="fbI01"></a></p>
<h4 id="grpc-gateway-实现-gRPC-server-提供-RESTful"><a href="#grpc-gateway-实现-gRPC-server-提供-RESTful" class="headerlink" title="grpc-gateway 实现 gRPC server 提供 RESTful"></a>grpc-gateway 实现 gRPC server 提供 RESTful</h4><p>实现在同一服务端的同一端口同时提供 gRPC 和 RESTful 服务，用于向后兼容及技术栈的平滑迁移。其基本原理是创建一个HTTP 反向代理服务，将客户端的 HTTP 请求转换为 gRPC 客户端请求并向 gRPC 服务端发起调用。辅助命令工具的部署安装参考：<a href="https://grpc-ecosystem.github.io/grpc-gateway/docs/usage.html" target="_blank" rel="external nofollow noopener noreferrer">https://grpc-ecosystem.github.io/grpc-gateway/docs/usage.html</a>。<br><img src="https://cdn.nlark.com/yuque/0/2019/png/182657/1573718382911-c19287bb-bfb6-4d82-8970-00489693b8ad.png#align=left&display=inline&height=369&name=image.png&originHeight=369&originWidth=749&size=52841&status=done&style=none&width=749" alt="image.png"><br>会使用到以下命令：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 基于 proto 生成 go 代码，使用到 protoc-gen-go 可执行文件</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// -I 参数用于指定 proto 文件中导入的外部 proto 文件的搜索路径</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">protoc -I/usr/local/include -I. -I$GOPATH/src -I$GOPATH/src/github.com/grpc-ecosystem/grpc-gateway/third_party/googleapis --go_out=plugins=grpc:. service.proto</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 生成 grpc-web 的 js 代码，非必须，仅当欲使用 grpc-web，使用到 protoc-gen-grpc-web 可执行文件</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">protoc service.proto --grpc-web_out=import_style=typescript,mode=grpcwebtext:./ --js_out=import_style=commonjs:.</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 生成 grpc-gateway 相关的 go 代码，使用到 protoc-gen-grpc-gateway 可执行文件</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">protoc -I/usr/local/include -I. -I$GOPATH/src -I$GOPATH/src/github.com/grpc-ecosystem/grpc-gateway/third_party/googleapis  --grpc-gateway_out=logtostderr=<span class="literal">true</span>:. service.proto</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 生成 swagger 格式的 API 文档，使用到 protoc-gen-swagger 可执行文件</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">protoc -I/usr/local/include -I. -I$GOPATH/src -I$GOPATH/src/github.com/grpc-ecosystem/grpc-gateway/third_party/googleapis --swagger_out=logtostderr=<span class="literal">true</span>:. service.proto</span></pre></td></tr></table></figure>
<p>使用 gRPC 错误类型的另一个好处是 grpc-gateway 会自动将其转换为对应的 HTTP 状态码而不是每次出错都返回 500，参见 grpc-gateway <a href="https://github.com/grpc-ecosystem/grpc-gateway/blob/master/runtime/errors.go" target="_blank" rel="external nofollow noopener noreferrer">源码</a>。<br>可参考的实例：</p>
<ul>
<li><a href="https://medium.com/swlh/rest-over-grpc-with-grpc-gateway-for-go-9584bfcbb835" target="_blank" rel="external nofollow noopener noreferrer">https://medium.com/swlh/rest-over-grpc-with-grpc-gateway-for-go-9584bfcbb835</a></li>
<li><a href="https://forum.golangbridge.org/t/go-rest-grpc-api/13072/5" target="_blank" rel="external nofollow noopener noreferrer">https://forum.golangbridge.org/t/go-rest-grpc-api/13072/5</a></li>
</ul>
<p><a name="5XZZz"></a></p>
<h4 id="使用-Empty-类型"><a href="#使用-Empty-类型" class="headerlink" title="使用 Empty 类型"></a>使用 Empty 类型</h4><p>在 gRPC 中要求每个函数调用都有返回值，如果确实不需要返回值，则为了统一规范与重用，我们可以使用 google  提供的 Empty 类型，Empty 类型的对象在序列化和反序列化时会被视为空对象，其 JSON 形式表示为 <code>{}</code> ，使用方法：</p>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"google/protobuf/empty.proto"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">service</span> <span class="title">Foo</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">rpc</span> Bar(google.protobuf.Empty) <span class="keyword">returns</span> (google.protobuf.Empty)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p><a name="CgG5k"></a></p>
<h4 id="传输文件"><a href="#传输文件" class="headerlink" title="传输文件"></a>传输文件</h4><p><a href="https://ops.tips/blog/sending-files-via-grpc/" target="_blank" rel="external nofollow noopener noreferrer">https://ops.tips/blog/sending-files-via-grpc/</a></p>
]]></content>
      <categories>
        <category>gRPC</category>
      </categories>
      <tags>
        <tag>Go</tag>
        <tag>gRPC</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构-绪论</title>
    <url>/post/75bf7760.html</url>
    <content><![CDATA[<p><a name="baPCt"></a></p><h3 id="计算与计算机"><a href="#计算与计算机" class="headerlink" title="计算与计算机"></a>计算与计算机</h3><p>绳索计算机与尺规计算机举例，重点是想说明算法是由一系列基本操作组合而成的。</p><p><a name="TkNuM"></a></p><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p>计算机超过四分之一的时间都是在进行排序操作。所谓排序是按照某种给定的次序将给定的一组元素顺序排列，例如将 n 个整数按通常的大小次序排成一个非降序列（包含小于等于之意）。序列中相邻元素满足小于等于的关系则称之为顺序的，否则成为逆序，逆序对在随后的一些排序算法中将起到辅助算法设计与分析的功能。局部有序不能保证整体有序，整体有序则必局部有序。冒泡排序算法的实现如下：</p><a id="more"></a>



<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BubbleSort</span><span class="params">(input []<span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">// sorted 标志位引入是为了提早结束扫描</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	sorted := <span class="literal">false</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	count := <span class="built_in">len</span>(input)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	times := <span class="number">0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">for</span> !sorted &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		sorted = <span class="literal">true</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">for</span> i := <span class="number">1</span>; i &lt; count; i++ &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			<span class="keyword">if</span> input[i<span class="number">-1</span>] &gt; input[i] &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">				input[i<span class="number">-1</span>], input[i] = input[i], input[i<span class="number">-1</span>]</span></pre></td></tr><tr><td class="code"><pre><span class="line">				sorted = <span class="literal">false</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">			&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		times++</span></pre></td></tr><tr><td class="code"><pre><span class="line">		fmt.Printf(<span class="string">"this is %d scan\n"</span>, times)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">return</span> input</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>冒泡排序属于原地排序，所以可以直接返回原切片作为排好序的序列。</p>
<p><a name="x0qwr"></a></p>
<h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p>算法是指基于特定的计算模型，旨在解决某一信息处理问题而设计的一个指令序列。算法必须要具有确定性（由若干语义明确的基本操作组成的指令序列）、可行性（每一个基本操作均可兑现）、有穷性（有限次操作后终止并输出）、正确性（输出符合预设条件），考虑到具体实现还应当有较高的效率和鲁棒性。<br>证明算法有穷性和正确性的一个技巧是从适当的角度审视整个计算过程，找出算法所具有的某种不变性和单调性。冒泡排序的不变性和单调性可概括为：经过 k 趟扫描交换之后，最大的前 k 个元素必然就位（不再参与运算且满足预设条件）；经过 k 趟扫描之后，待求解问题的有效规模将会缩减至 n-k 。<br><a name="j26KP"></a></p>
<h4 id="算法复杂度"><a href="#算法复杂度" class="headerlink" title="算法复杂度"></a>算法复杂度</h4><p>为了超脱于硬件平台和软件环境客观评价算法复杂度，可将算法执行时间定义为算法所执行的基本操作的总次数。大 O 标记法表示的算法复杂度界定了算法执行时间的上界，对应于最坏情况；大 Ω 标记界定算法的下界，对应于最好情况；大 θ 标记表明对于规模为 n 的任意输入，算法运行时间同阶，不存在所谓最坏或最好情况。多数情况下，更关注算法执行的最坏情况，所以大 O 标记最为常用。<br>空间复杂度往往关注较小是因为就渐进复杂度而言，在任一算法的任何一次运行过程中所消耗的存储空间都不会多于其间所执行的基本操作的总和。因为每次基本操作所涉及的存储空间都不会超过常数规模，就算每次基本操作设计的空间都是新开辟的，则整个算法所需的空间总量也不过与基本操作的次数同阶，因此可以说时间复杂度本身就是空间复杂度的一个天然上界。<br>除了输入数据之外，仅需常数规模辅助空间的算法称为就地算法。<br>在算法复杂度理论中，多项式时间复杂度被视为一个具有特殊意义的复杂度级别。多项式级别的运行时间成本，在实际应用中一般认为是可接受或可忍受的。某问题若存在一个复杂度在多项式范围内的算法，则称该问题为可求解的或易解的。相应地不存在多项式复杂度算法的问题称作难解的问题。</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>Go</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>使用语雀、GitHub 和阿里云函数计算构建博客</title>
    <url>/post/b2362878.html</url>
    <content><![CDATA[<p><a name="e6cefb85"></a></p><h3 id="使用语雀撰写博客"><a href="#使用语雀撰写博客" class="headerlink" title="使用语雀撰写博客"></a>使用语雀撰写博客</h3><p>最开始搭建自己的博客系统时，我会先写好 Markdown 文件，然后借助 Hexo 生成静态页面，之后部署到云主机上，配置好域名解析后就可以访问了。<br>虽然 Markdown 已经足够简明便捷，但语雀为我们提供了更友好的 Markdown 编辑器，使得撰写技术文档的体验有了质的提升，因此强烈推荐给大家使用。<br>语雀的使用也比较简单，首先登陆到<a href="https://yuque.com" target="_blank" rel="external nofollow noopener noreferrer">官网</a>使用手机号注册一个账号，然后创建一个知识库，在知识库就可以新建文档开始写文章了。撰写文档时，在快捷键 “/” 的帮助下可以快速插入代码、图片、视频、思维导图等，使用非常方便，更多的内容可以参考语雀官方的<a href="https://www.yuque.com/yuque/help" target="_blank" rel="external nofollow noopener noreferrer">使用文档</a>。<br>实际上，语雀本身也是一个文章发布平台，写好的文章只要被设置为可公开访问，别人就可以在语雀上订阅你的文章，但由于不能自定义域名等原因，目前仍然只是把它作为文档撰写工具，博客站点仍然借助其它平台实现。</p><a id="more"></a>

<p><a name="729de1d0"></a></p>
<h3 id="Hexo-与语雀同步"><a href="#Hexo-与语雀同步" class="headerlink" title="Hexo 与语雀同步"></a>Hexo 与语雀同步</h3><p><a href="https://hexo.io/" target="_blank" rel="external nofollow noopener noreferrer">Hexo</a> 是一款开源的静态站点生成工具，虽然 <a href="https://gohugo.io/" target="_blank" rel="external nofollow noopener noreferrer">Hugo</a> 使用起来可能更加方便，但由于个人十分喜欢 Hexo 的<a href="https://github.com/theme-next/hexo-theme-next" target="_blank" rel="external nofollow noopener noreferrer">这款</a>名为 Next 的博客主题，所以一直没有更换为 Hugo。<br>之前都是直接写好 Markdown 文件放在 Hexo 项目指定目录，然后从 Markdown 生成静态页面，换用了语雀之后则需要借助工具将语雀上的内容导出为 Markdown。语雀支持将文章导出为 Markdown 的操作，你可以在 Web 端简单点击后获取到所有文章的 Markdown 导出，更幸运的是我们可以利用开源工具<a href="https://github.com/x-cold/yuque-hexo" target="_blank" rel="external nofollow noopener noreferrer"> yuque-hexo</a> 将导出过程程序化。只需要安装好 yuque-hexo 插件并配置好语雀相关的参数即可。<br>具体的参数配置可以参考各个开源项目的文档，也可以参考<a href="https://github.com/XiaYinchang/xiayinchang.github.io" target="_blank" rel="external nofollow noopener noreferrer">我的 Hexo 项目</a>配置。我将同步操作和 Hexo 的生成静态文件命令合并成了一个 npm 脚本，只需要执行 <code>npm run generate</code>  即可完成同步以及静态文件的生成，生成的静态文件在当前目录 <code>pulic</code> 路径下。</p>
<p><a name="gDYO8"></a></p>
<h3 id="使用-GitHub-托管博客"><a href="#使用-GitHub-托管博客" class="headerlink" title="使用 GitHub 托管博客"></a>使用 GitHub 托管博客</h3><p>使用 Hexo 生成的静态页面必须通过网络服务器 Serve 起来才能被别人访问，之前我是使用廉价版的阿里云主机通过 Nginx 启动了 Http 服务器，使用下来发现访问速度比 GitHub 托管还慢，后续也使用过 coding.net 提供的 Pages 服务，访问速度很快，但是服务不太稳定，多次出现未知原因导致博客无法访问，最后决定还是用回 GitHub。<br>首先在 GitHub 上新建一个名称为 username.github.io 的代码仓库，我建的是 xiayinchang.github.io，根据官方文档的说法， username 需要和你的 GitHub 账户名称保持一致。然后将 Hexo 生成的静态文件（即 public 路径下的文件）添加到该代码仓库，push 到 GitHub 上即可。现在，就可以通过 username.github.io 这个地址访问到博客站点的内容。</p>
<p><a name="L1I0z"></a></p>
<h3 id="借助-GitHub-Action-实现静态文件的自动生成"><a href="#借助-GitHub-Action-实现静态文件的自动生成" class="headerlink" title="借助 GitHub Action 实现静态文件的自动生成"></a>借助 GitHub Action 实现静态文件的自动生成</h3><p>GitHub Action 是 GitHub 最新推出的 CICD 工具（完全可以取代第三方的 Travis CI 等工具），和 GitHub 的各项服务无缝集成，开源仓库可以免费使用，虽然有额度限制，但就博客静态文件的生成来说免费额度已经足够用了。GitHub Action 的概念还是很多的，有兴趣的话可以参阅<a href="https://help.github.com/en/actions/automating-your-workflow-with-github-actions" target="_blank" rel="external nofollow noopener noreferrer">这篇官方文档</a>。<br>简单说明一下使用方法，首先需要在 Hexo 项目中新建一个 .github 目录，然后在该目录下再新建 workflows 目录，在 workflows 中新建一个 yml 格式的文件用来定义工作流，如下，我建了两个 yml 文件定义了两种工作流，文件名称可以随便取，这里命名成 nodejs.yml 是因为生成静态文件需要使用 Nodejs，只要按照这种路径定义了工作流，就能被 GitHub Action 系统自动读取并解析，这是一种约定：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">➜  xiayinchang.github.io git:(src) tree -L <span class="number">3</span> .github</span></pre></td></tr><tr><td class="code"><pre><span class="line">.github</span></pre></td></tr><tr><td class="code"><pre><span class="line">└── workflows</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ├── cron.yml</span></pre></td></tr><tr><td class="code"><pre><span class="line">    └── nodejs.yml</span></pre></td></tr></table></figure>
<p>简单介绍一下 nodejs.yml 这个文件定义的工作流，on 这行用来指定在发生什么事件（这里响应 push 和 repository_dispatch 两种事件，push 即为向该分支推送代码的事件， repository_dispatch 为自定义外部事件，稍后详说）时执行该工作流，jobs 可以定义多个 job 分别执行不同的工作，不同的 job 可以并行执行，不同 job 的执行环境（操作系统）可以不一样，这里只定义了一个名为 build 的 job，指定的运行环境是 Ubuntu，这个 job 又可以拆分成几个步骤，步骤按序执行，首先通过使用第三方定义好的 actions/checkout@master （这是 GitHub Action 的另一个强大之处，允许直接复用别人定义好的各种操作即 Action）可以实现从 GitHub 仓库（这里指定从当前仓库 xiayinchang.github.io 的 src 分支）拉取代码，然后借助 actions/setup-node@master 这个第三方 Action 实现 Nodejs 环境的配置，这里指定使用 Nodejs 13 版本，接着开始执行 Hexo 的构建，分为安装依赖包和生成静态文件两个命令，最后一步是借助 peaceiris/actions-gh-pages@v2.5.0 这个第三方 Action 将生成的静态文件 push 到指定仓库的指定分支（这里是 xiayinchang.github.io 仓库的 master 分支）。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">name: Node CI</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">on: [push, repository_dispatch]</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">jobs:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  build:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    runs-on: ubuntu-latest</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    strategy:</span></pre></td></tr><tr><td class="code"><pre><span class="line">      matrix:</span></pre></td></tr><tr><td class="code"><pre><span class="line">        node-version: [<span class="number">13.</span>x]</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    steps:</span></pre></td></tr><tr><td class="code"><pre><span class="line">      - uses: actions/checkout@master</span></pre></td></tr><tr><td class="code"><pre><span class="line">        with:</span></pre></td></tr><tr><td class="code"><pre><span class="line">          ref: src</span></pre></td></tr><tr><td class="code"><pre><span class="line">      - name: Use Node.js $&#123;&#123; matrix.node-version &#125;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        uses: actions/setup-node@master</span></pre></td></tr><tr><td class="code"><pre><span class="line">        with:</span></pre></td></tr><tr><td class="code"><pre><span class="line">          node-version: $&#123;&#123; matrix.node-version &#125;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      - name: npm install, build</span></pre></td></tr><tr><td class="code"><pre><span class="line">        run: |</span></pre></td></tr><tr><td class="code"><pre><span class="line">          npm install</span></pre></td></tr><tr><td class="code"><pre><span class="line">          npm run generate</span></pre></td></tr><tr><td class="code"><pre><span class="line">        env:</span></pre></td></tr><tr><td class="code"><pre><span class="line">          CI: <span class="literal">true</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">          HEXO_ALGOLIA_INDEXING_KEY: $&#123;&#123; secrets.HEXO_ALGOLIA_INDEXING_KEY &#125;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">          YUQUE_TOKEN: $&#123;&#123; secrets.YUQUE_TOKEN &#125;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      - name: Deploy</span></pre></td></tr><tr><td class="code"><pre><span class="line">        uses: peaceiris/actions-gh-pages@v2<span class="number">.5</span><span class="number">.0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        env:</span></pre></td></tr><tr><td class="code"><pre><span class="line">          PERSONAL_TOKEN: $&#123;&#123; secrets.PERSONAL_TOKEN &#125;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">          PUBLISH_BRANCH: master</span></pre></td></tr><tr><td class="code"><pre><span class="line">          PUBLISH_DIR: ./public</span></pre></td></tr></table></figure>
<p>回过头查看上述工作流，涉及到了 xiayinchang.github.io 仓库的两个分支，一个是 src 分支，一个是 master 分支， src 分支保存的是 Hexo 项目的代码，用来生成静态文件，master 分支保存的是生成的静态文件，也是 GitHub Pages 服务的数据源，src 分支生成的静态文件要 push 到 master 分支才能被 GitHub Pages 使用，这是因为：根据 GitHub Pages 的说明，静态文件必须要放在 master 分支。<br>现在，只要修改了部分文章内容后，push 到 xiayinchang.github.io 仓库的 src 分支即会触发该工作流，完成从 Markdown 格式的源文件到博客静态文件的自动生成，并自动推送到 master 分支从而触发 GitHub Pages 的自动更新，进而完成博客站点的自动更新，此时再打开 xiayinchang.github.io 这个站点就能看到更新的文章内容已经显示在网页端了。</p>
<p><a name="BCs47"></a></p>
<h3 id="语雀更新触发-GitHub-Action-自动构建"><a href="#语雀更新触发-GitHub-Action-自动构建" class="headerlink" title="语雀更新触发 GitHub Action 自动构建"></a>语雀更新触发 GitHub Action 自动构建</h3><p><a name="Vwaex"></a></p>
<h4 id="初步方案设计"><a href="#初步方案设计" class="headerlink" title="初步方案设计"></a>初步方案设计</h4><p>在上一步中虽然已经实现了自动生成静态文件，但是事件本身仍然需要我们手动生成，即手动 push 后触发自动构建，在这一步我们要实现的是在语雀上更新文章后就能触发 GitHub 的自动构建。语雀提供了 webhook 机制使得更新文章时能够触发外部事件，而 GitHub Action 能够通过我们之前提到过的 repository_dispatch 机制接收外部事件，如果能够将两者对接起来，也就实现了我们的目标，但这个过程并没有那么简单。<br>语雀支持的 webhook 是一个简单的 http url ，无法添加请求头和请求体，如下图所示:<br><img src="https://cdn.nlark.com/yuque/0/2019/png/182657/1574345326347-21a088e7-b99e-48ab-b4d4-03da8cd43dd5.png#align=left&display=inline&height=281&name=image.png&originHeight=562&originWidth=1454&size=81111&status=done&width=727" alt="image.png"><br>GitHub repository_dispatch 支持的外部事件必须具有以下请求头（包括认证信息）：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">curl -X POST \</span></pre></td></tr><tr><td class="code"><pre><span class="line">    -H <span class="string">"Authorization: token $&#123;GITHUB_TOKEN&#125;"</span> \</span></pre></td></tr><tr><td class="code"><pre><span class="line">    -H <span class="string">'Accept: application/vnd.github.everest-preview+json'</span> \</span></pre></td></tr><tr><td class="code"><pre><span class="line">    -d <span class="string">'&#123;"event_type":"rollback"&#125;'</span> \</span></pre></td></tr><tr><td class="code"><pre><span class="line">    https:<span class="comment">//api.github.com/repos/$&#123;GITHUB_REPO_OWNER&#125;/$&#123;GITHUB_REPO&#125;/dispatches</span></span></pre></td></tr></table></figure>
<p>所以直接在语雀 webhook 中添加 GitHub 事件的触发地址是不行的，因为无法添加必须的请求头信息，因此我们需要一个中间层把两者适配起来，示意图如下：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2019/svg/182657/1574346796484-cd1f3d51-6d05-4e95-a457-68f02556072e.svg#align=left&display=inline&height=53&name=yuque-github.svg&originHeight=53&originWidth=531&size=9035&status=done&width=531" alt="yuque-github.svg"></p>
<p><a name="Rxpuo"></a></p>
<h4 id="基于虚拟机的中间层实现"><a href="#基于虚拟机的中间层实现" class="headerlink" title="基于虚拟机的中间层实现"></a>基于虚拟机的中间层实现</h4><p>最初，我在购买的阿里云主机上使用 Nodejs 创建了一个简单的 HTTP 服务来实现这个中间层，其代码如下，其基本逻辑和上图一致，首先是在 8888 端口上响应来自语雀的 hook 调用，然后再拼装出一个带有认证信息的 https 请求生成 GitHub 外部事件。这段代码虽然写的比较简陋，但是完全可以满足我们的需求实现语雀更新触发 GitHub 的自动构建和部署。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">"http"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> https = <span class="built_in">require</span>(<span class="string">'https'</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> url = <span class="built_in">require</span>(<span class="string">"url"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> process = <span class="built_in">require</span>(<span class="string">"process"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">http</span></pre></td></tr><tr><td class="code"><pre><span class="line">  .createServer(<span class="function"><span class="keyword">function</span>(<span class="params">request, response</span>) </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    response.writeHead(<span class="number">200</span>, &#123; <span class="string">"Content-type"</span>: <span class="string">"text/plan"</span> &#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    response.end(<span class="string">"ok"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    pathName = url.parse(request.url).pathname;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (pathName === <span class="string">"/sync"</span> &amp;&amp; request.method === <span class="string">"POST"</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">          <span class="keyword">const</span> data = <span class="built_in">JSON</span>.stringify(&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            event_type: <span class="string">'run-it'</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">          &#125;)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">          <span class="keyword">const</span> options = &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            hostname: <span class="string">'api.github.com'</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">            port: <span class="number">443</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">            path: <span class="string">'/repos/XiaYinchang/xiayinchang.github.io/dispatches'</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">            method: <span class="string">'POST'</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">            headers: &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">              <span class="string">'User-Agent'</span>: <span class="string">'curl/7.52.1'</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">              <span class="string">'Content-Type'</span>: <span class="string">'application/json'</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">              <span class="string">'Accept'</span>: <span class="string">'application/vnd.github.everest-preview+json'</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">              <span class="string">'Authorization'</span>: <span class="string">'token $GITHUB_TOKEN'</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">          &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">          <span class="keyword">const</span> req = https.request(options, res =&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="built_in">console</span>.log(<span class="string">`statusCode: <span class="subst">$&#123;res.statusCode&#125;</span>`</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">            res.on(<span class="string">'data'</span>, d =&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">              process.stdout.write(d)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">          &#125;)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">          req.on(<span class="string">'error'</span>, error =&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="built_in">console</span>.error(error)</span></pre></td></tr><tr><td class="code"><pre><span class="line">          &#125;)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">          req.write(data)</span></pre></td></tr><tr><td class="code"><pre><span class="line">          req.end()</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  )</span></pre></td></tr><tr><td class="code"><pre><span class="line">  .listen(<span class="number">8888</span>);</span></pre></td></tr></table></figure>

<p><a name="W6wLo"></a></p>
<h4 id="基于阿里云函数计算的中间层实现"><a href="#基于阿里云函数计算的中间层实现" class="headerlink" title="基于阿里云函数计算的中间层实现"></a>基于阿里云函数计算的中间层实现</h4><p>后来发现阿里云函数计算有免费的额度可以使用，完全可以将我的虚拟机释放出来做其他事情，而且虚拟机两年后就到期了，这个函数计算至少坚挺几年问题不大，以下是阿里云官方文档关于函数计算的免费额度说明，前 100 万次调用免费，财大气粗的阿里云：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2019/png/182657/1574348003304-00176e01-df5f-452f-8a3e-d2b42ccbb19f.png#align=left&display=inline&height=159&name=image.png&originHeight=318&originWidth=1550&size=73916&status=done&width=775" alt="image.png"></p>
<p>根据我们的使用场景，需要部署一个函数能够处理语雀的 http post 请求，参考阿里云函数计算的<a href="https://help.aliyun.com/document_detail/74768.html?spm=a2c4g.11186623.6.604.233e68f4qM1FYl" target="_blank" rel="external nofollow noopener noreferrer">官方文档</a>，我创建了一个名为 sync_yuque 的函数，运行环境选择 Python 是因为使用 Nodejs 时发现阿里云的函数计算貌似只支持 Express 的一套 api，我之前写的 Nodejs 的代码都不好用了，然后发现根本不支持 Go 的环境，所以只好用 Python 的：<br><img src="https://cdn.nlark.com/yuque/0/2019/png/182657/1574348393403-568dcfe8-4c88-4cd5-9067-3fd4f9b098fe.png#align=left&display=inline&height=382&name=image.png&originHeight=764&originWidth=1648&size=99272&status=done&width=824" alt="image.png"><br>这个函数计算是可以在线编辑代码的，这个函数计算要求函数的命名有一定的规范，最后写的 Python 代码如下：<br><img src="https://cdn.nlark.com/yuque/0/2019/png/182657/1574348796118-0f1724a9-181f-4d26-8d47-417aa64642d0.png#align=left&display=inline&height=685&name=image.png&originHeight=1370&originWidth=1678&size=258218&status=done&width=839" alt="image.png"><br>还可以在线调试，点击执行手动触发了一波，看到 GitHub 那边果然被触发了，注意下图中的 Http 触发器有个点击复制的按钮，点击后复制的就是触发 Python 代码调用的 URL 地址，随后会将这个地址添加到语雀的 webhook 中：<br><img src="https://cdn.nlark.com/yuque/0/2019/png/182657/1574348964801-b5f5e678-23bd-4af9-b3ad-2a8fdb3eb129.png#align=left&display=inline&height=365&name=image.png&originHeight=1104&originWidth=2256&size=191252&status=done&width=746" alt="image.png"><br>GitHub Action 触发自动构建如下，可以看到触发的事件源确实是 repository_dispatch ：<br><img src="https://cdn.nlark.com/yuque/0/2019/png/182657/1574349095187-c0ee05f1-2140-4664-b999-fb46b18e5b1d.png#align=left&display=inline&height=319&name=image.png&originHeight=638&originWidth=2408&size=127346&status=done&width=1204" alt="image.png"><br>最后，将获取的 Http 函数调用地址添加到语雀的 webhook 中，如下：<br><img src="https://cdn.nlark.com/yuque/0/2019/png/182657/1574349534969-cee1fcaf-2bbc-4eff-9c8a-dc44fa6363b8.png#align=left&display=inline&height=522&name=image.png&originHeight=1044&originWidth=2132&size=157428&status=done&width=1066" alt="image.png"><br>现在，在语雀上对应知识库中更新任何一篇文章或者发布新的文章都会触发 GitHub 自动构建和部署，实现博客站点与语雀文章的同步更新，整个过程已经被自动化衔接起来，而你只需要关注写作本身。</p>
]]></content>
      <categories>
        <category>云计算</category>
      </categories>
      <tags>
        <tag>语雀</tag>
        <tag>GitHub</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 文件系统基础知识</title>
    <url>/post/c957e495.html</url>
    <content><![CDATA[<p><a name="d3l9E"></a></p><h4 id="软链接和硬链接的区别"><a href="#软链接和硬链接的区别" class="headerlink" title="软链接和硬链接的区别"></a>软链接和硬链接的区别</h4><p><img src="https://cdn.nlark.com/yuque/0/2019/png/182657/1573195363300-6e1b32b6-8636-48a9-a84c-def0811985fb.png#align=left&display=inline&height=255&name=image.png&originHeight=255&originWidth=514&size=34517&status=done&width=514" alt="image.png"></p><ul>
<li><p>参考：<a href="https://stackoverflow.com/questions/185899/what-is-the-difference-between-a-symbolic-link-and-a-hard-link" target="_blank" rel="external nofollow noopener noreferrer">https://stackoverflow.com/questions/185899/what-is-the-difference-between-a-symbolic-link-and-a-hard-link</a></p>
</li>
<li><p>硬链接是对 inode 的引用，只有所有引用都删除后 inode 才会被删除，删除源文件，通过硬链接创建的文件仍然能够访问之前保存的数据；软链接指向源文件，源文件被删除后，访问软链接会提示文件不存在， inode 一般在源文件删除后即被删除（除非有硬链接指向该 inode）。</p>
</li>
<li><p>创建硬链接时源文件必须存在；而软链接可以指向不存在的对象以及不同文件系统的对象（目录或文件）。</p>
</li>
<li><p>创建硬链接改变文件系统结构，创建软链接不改变文件系统结构（或许是增加了一个应用层存储软链接对象）。</p>
</li>
<li><p>关于为什么不允许对目录创建硬链接的个人理解：硬链接创建的是和源文件同样类型的文件系统对象，在硬链接创建完成后，文件系统已经无法区分新建出来的文件系统对象是否是通过硬链接创建出来的，因此在执行目录遍历时便会将其作为普通的文件对象对待，因此一旦允许硬链接指向目录，则在出现环路时会永不停止的遍历下去，造成文件系统无法正常工作；而对目录创建软链接可以工作是因为，软链接创建出来的文件系统对象和普通的文件系统对象类型是不一样的，因此文件系统可以区分出软链接创建出来的文件系统对象并在进行目录遍历时获取到软链接指向的最短路径（readlink -f soft-link）后就终止对其进行遍历，从而能够正常工作；其关键在于是否可识别，如果能够识别就可以区别对待。<br><a name="KiJyy"></a></p>
<h4 id="chroot"><a href="#chroot" class="headerlink" title="chroot"></a>chroot</h4><p>chroot 改变了进程及其子进程能够访问的文件系统的入口点，使得该应用只能访问新的根目录下的文件内容而无法访问根目录以外的文件，将应用置于沙盒中从而限制其能够访问的文件和设备等资源，实现对应用的安全隔离。<br><a name="Hy6Xv"></a></p>
<h4 id="软链接和-bind-mount-的比较"><a href="#软链接和-bind-mount-的比较" class="headerlink" title="软链接和 bind mount 的比较"></a>软链接和 bind mount 的比较</h4></li>
<li><p>其相同之处是都可以实现对源目录进行跨文件系统的定位和访问。</p>
</li>
<li><p>其主要的不同点在于它们的控制主体和表现形式，软链接由文件系统负责管理，是文件系统中的对象；bind mount 由内核直接控制，是内核中的实体，比文件系统层级更低（因此 bind mount 需要 root 权限，创建软链接并不需要 root 权限），它可以更改文件系统的底层拓扑结构而使得文件系统毫无察觉（因此 bind mount 过程不会持久化保存，系统重启时必须重新进行 bind mount，一般将其写入到 /etc/fstab）。</p>
</li>
<li><p>软链接的创建可以使用相对路径或绝对路径，表示对象中保存的源路径与输入路径完全一致，因此有可能使得软链接在某些情况无法访问（例如，在由软链接建立的循环路径中相对路径可能失效）；bind mount 在使用相对路径作为源路径时会将其解析为绝对路径后保存并挂载。</p>
</li>
<li><p>在使用 chroot 的情况下，软链接的范围仅限于当前新的根目录下（源目录与目的目录均在当前 chroot 下），而 bind mount 可以将 chroot 外的文件挂载到当前 chroot 中使用（过程是怎样的？）</p>
</li>
<li><p>容器文件系统的挂载过程借助了 bind mount。</p>
</li>
<li><p>参考：<a href="https://www.quora.com/What-are-the-differences-between-bind-mounts-and-symlink-on-Unix" target="_blank" rel="external nofollow noopener noreferrer">https://www.quora.com/What-are-the-differences-between-bind-mounts-and-symlink-on-Unix</a></p>
</li>
<li><p>参考：<a href="https://unix.stackexchange.com/questions/198590/what-is-a-bind-mount" target="_blank" rel="external nofollow noopener noreferrer">https://unix.stackexchange.com/questions/198590/what-is-a-bind-mount</a><br><a name="XJ56q"></a></p>
<h4 id="mount-namespace"><a href="#mount-namespace" class="headerlink" title="mount namespace"></a>mount namespace</h4></li>
<li><p><a href="https://lwn.net/Articles/689856/" target="_blank" rel="external nofollow noopener noreferrer">https://lwn.net/Articles/689856/</a></p>
</li>
<li><p>新的 mount namespace 会继承原 mount namespace 的挂载点（因为是 clone），之后挂载点会各自变化。</p>
</li>
<li><p>Creating a mount namespace is similar to a recursive bind mount of / followed by chroot into the bind mount. Chroot creating is simular to creating a mount namespace followed by pivot_root.</p>
</li>
<li><p><a href="https://unix.stackexchange.com/questions/456620/how-to-perform-chroot-with-linux-namespaces" target="_blank" rel="external nofollow noopener noreferrer">https://unix.stackexchange.com/questions/456620/how-to-perform-chroot-with-linux-namespaces</a></p>
</li>
</ul>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>VSCode 使用技巧</title>
    <url>/post/16a650d7.html</url>
    <content><![CDATA[<p><a name="XdU7U"></a></p><h4 id="Linux-下默认快捷键"><a href="#Linux-下默认快捷键" class="headerlink" title="Linux 下默认快捷键"></a>Linux 下默认快捷键</h4><ul>
<li><code>Ctrl+Alt+-</code> 返回上一个位置</li>
<li><code>Ctrl+Shift+-</code> 转到下一个位置<br><a name="nFG3l"></a><h4 id="将-n-字符替换为换行符"><a href="#将-n-字符替换为换行符" class="headerlink" title="将 /n 字符替换为换行符"></a>将 /n 字符替换为换行符</h4>在替换为一栏中输入 <code>Ctrl+Enter</code> 可以输入换行符。</li>
</ul>]]></content>
      <categories>
        <category>VSCode</category>
      </categories>
      <tags>
        <tag>VSCode</tag>
      </tags>
  </entry>
  <entry>
    <title>Envoy 知识汇总</title>
    <url>/post/111604be.html</url>
    <content><![CDATA[<p><a name="YEnn3"></a></p><h3 id="基本理解"><a href="#基本理解" class="headerlink" title="基本理解"></a>基本理解</h3><p><a name="SWRZB"></a></p><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><p><a name="2qLn1"></a></p><h4 id="编写-Lua-脚本"><a href="#编写-Lua-脚本" class="headerlink" title="编写 Lua 脚本"></a>编写 Lua 脚本</h4><ul>
<li>一个简单的案例，使用 Lua 脚本为 Http 请求添加了 Authorization 请求头：<a href="https://segmentfault.com/a/1190000020650955" target="_blank" rel="external nofollow noopener noreferrer">https://segmentfault.com/a/1190000020650955</a></li>
</ul>]]></content>
      <categories>
        <category>Envoy</category>
      </categories>
      <tags>
        <tag>Envoy</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker 卷和文件系统权限</title>
    <url>/post/86bd2460.html</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th align="center">Date</th>
<th align="center">Log</th>
</tr>
</thead>
<tbody><tr>
<td align="center">17/10/2019</td>
<td align="center">初始版本.</td>
</tr>
</tbody></table><p><a name="e5729e94"></a></p><h3 id="原文"><a href="#原文" class="headerlink" title="原文"></a>原文</h3><p><a href="https://medium.com/@nielssj/docker-volumes-and-file-system-permissions-772c1aee23ca" target="_blank" rel="external nofollow noopener noreferrer">Docker volumes and file system permissions</a><br>Docker 卷和文件系统权限</p><p><a name="wdhwT"></a></p><h3 id="译文"><a href="#译文" class="headerlink" title="译文"></a>译文</h3><p>Docker 容器的文件系统是临时存在的（不要在运行期间持久化数据到容器内的文件目录）。但是很多容器存在持久化数据的需求。Docker 的卷挂载功能提供了一种满足数据持久化需求的能力，但是使用时往往存在一些有关文件系统权限的陷阱。</p><a id="more"></a>




<p>在生产环境中你一般会使用一些公有云提供商的容器编排工具和持久化存储，提供商已经帮助解决了文件权限的设置问题。在大多数已部署的设置中，您将使用容器编排机制，并且某些公共云产品提供了永久性存储，它们可能具有自己配置权限的方式。但是，在本地开发期间或在产品的早期迭代中，最简单的方法是将宿主机目录挂载为 Docker 卷的形式暴露给容器内服务使用。</p>
<p>将主机目录配置为 Docker 卷时需要注意以下内容：</p>
<ul>
<li>对卷中的内容设置的文件权限在容器和宿主机看来是一样的。</li>
<li>仅 UID（用户 ID）和 GID（组 ID）会影响文件权限。例如，用户和组的名称和密码不需要匹配，甚至不需要在主机和容器中真实存在。</li>
<li>容器 OS 根据其自身的配置对容器内的文件进行操作。例如，如果在主机和容器中都存在用户 A，如果仅在宿主机上将用户 A 添加到组 B，则在容器内用户 A 仍将无法拥有读写归属于组 B 的文件的权限，除非在容器内也创建了组 B 并将用户 A 添加到其中。</li>
<li>默认情况下，容器的命令以 root 身份运行</li>
<li>可以（在基于 unix 的系统上）将文件 / 目录所有权设置为不属于任何实际存在的组的 GID</li>
</ul>
<p>如果你牢记上述事实，则应该能够正确配置容器和卷，并不会对文件读写权限的各种情况感到意外。如果你不熟悉 UNIX 文件权限，可以阅读该<a href="https://help.ubuntu.com/community/FilePermissions" target="_blank" rel="external nofollow noopener noreferrer">页面</a>关于文件权限的描述。</p>
<p>下面举例说明本地开发时如何快速配置文件权限：</p>
<p>在宿主机上将要用作卷的目录的归属组设置为未被任何已存在的组使用的 GID（此例中设置为 1024）</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">chown :<span class="number">1024</span> /data/myvolume</span></pre></td></tr></table></figure>

<p>更改目录权限以授予组成员完全访问权限（读 + 写 + 执行）</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">chmod <span class="number">775</span> /data/myvolume</span></pre></td></tr></table></figure>

<p>确保文件夹中所有新建内容都将继承归属组</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">chmod g+s /data/myvolume</span></pre></td></tr></table></figure>

<p>在 Dockerfile 中创建一个用户，该用户是 1024 组的成员</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">RUN addgroup --gid <span class="number">1024</span> mygroup</span></pre></td></tr><tr><td class="code"><pre><span class="line">RUN adduser --disabled-password --gecos <span class="string">""</span> --force-badname --ingroup <span class="number">1024</span> myuser </span></pre></td></tr><tr><td class="code"><pre><span class="line">USER myuser</span></pre></td></tr></table></figure>

<p>（可选）在宿主机将当前用户添加到 1024 组中，从而可以方便地在宿主机上操作挂载为容器卷的目录的内容</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">adduser ubuntu <span class="number">1024</span></span></pre></td></tr></table></figure>

<p>上面的示例是一个很简单的配置，可以使得不需要使用 root 用户在容器内运行程序，也可以在主机上操作挂载为容器卷的目录的内容而无需使用主机 root 用户。这些设置过程硬编码到 Docker 镜像打包过程中使得无法在容器运行时调整 GID。如果调整，则需将 GID 作为环境变量传递到容器内，并编写一个通用的初始化脚本在容器启动时进行权限配置。DeniBertović 的这篇博客 <a href="https://denibertovic.com/posts/handling-permissions-with-docker-volumes/" target="_blank" rel="external nofollow noopener noreferrer">https://denibertovic.com/posts/handling-permissions-with-docker-volumes/</a> 提供了完成此类设置的指南。</p>
]]></content>
      <categories>
        <category>译文</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>译文</tag>
      </tags>
  </entry>
  <entry>
    <title>K8S PVC 在线扩容</title>
    <url>/post/99dfe25e.html</url>
    <content><![CDATA[<ol>
<li><p>创建storageclass 时加入 allowVolumeExpansion: true 参数。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">storage.k8s.io/v1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="attr">kind:</span> <span class="string">StorageClass</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="attr">metadata:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="attr">name:</span> <span class="string">ceph-rbd</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="attr">parameters:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="string">...</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="attr">provisioner:</span> <span class="string">kubernetes.io/rbd</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="attr">allowVolumeExpansion:</span> <span class="literal">true</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="attr">reclaimPolicy:</span> <span class="string">Delete</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="attr">volumeBindingMode:</span> <span class="string">Immediate</span></span></pre></td></tr></table></figure>
</li>
<li><p>在所有 master 节点上安装好 ceph-common 包，并且拷贝 ceph 配置文件到每个 master 节点的 /etc/ceph 目录，确保 <code>ceph -s</code> 能够输出正常的结果。</p>
</li>
<li><p>执行以下命令从某一 kube-controller-manager 容器中拷贝出 kube-controller-manager 可执行文件以备后用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl -n kube-system cp kube-controller-manager-节点名:usr&#x2F;local&#x2F;bin&#x2F;kube-controller-manager .</span></pre></td></tr></table></figure>
</li>
<li><p>基于 ceph 基础镜像重新打包一个包含有 rbd 命令的 kube-controller-manager 容器镜像。ceph 基础镜像的版本要和部署好的 ceph 集群的版本一致，通过 <code>ceph -v</code> 查看版本，例如 ceph 版本是 12.2.4 ，则通过 dockerhub 可以获取到 ceph 12.2.4 的基础镜像：<a href="https://hub.docker.com/r/ceph/ceph-amd64/tags" target="_blank" rel="external nofollow noopener noreferrer">https://hub.docker.com/r/ceph/ceph-amd64/tags</a>, 然后使用以下 Dockerfile 文件重新打包镜像：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FROM ceph&#x2F;ceph-amd64:v12.2.4-20190828</span></pre></td></tr><tr><td class="code"><pre><span class="line"># 将上一步获取的 kube-controller-manager 与此 Dockerfile 置于同一目录</span></pre></td></tr><tr><td class="code"><pre><span class="line">ADD kube-controller-manager &#x2F;usr&#x2F;local&#x2F;bin&#x2F;kube-controller-manager</span></pre></td></tr></table></figure>
</li>
<li><p>使用上述 Dockerfile 执行以下命令打包，镜像名称和标签可以自定义，标签最好和原始的 kube-controller-manager 保持一致：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker build -t kube-controller-manager-ceph-v12.2.4:v1.13.3 .</span></pre></td></tr></table></figure>
</li>
<li><p>执行以下命令导出镜像并上传至所有 master 节点后倒入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 导出镜像</span></pre></td></tr><tr><td class="code"><pre><span class="line">docker save kube-controller-manager-ceph-v12.2.4:v1.13.3 | gzip -c &gt; kube-controller-manager.tar.gz</span></pre></td></tr><tr><td class="code"><pre><span class="line"># 上传至 master 节点</span></pre></td></tr><tr><td class="code"><pre><span class="line">scp kube-controller-manager.tar.gz root@master1:.</span></pre></td></tr><tr><td class="code"><pre><span class="line"># 登录至 master 节点并执行以下命令倒入镜像</span></pre></td></tr><tr><td class="code"><pre><span class="line">docker load &lt; kube-controller-manager.tar.gz</span></pre></td></tr><tr><td class="code"><pre><span class="line"># 以上步骤需要在所有 master 节点执行</span></pre></td></tr></table></figure>
</li>
<li><p>修改 kube-api-server / kube-controller-manager / kubelet 配置以启用 ExpandInUsePersistentVolumes:<br><br>/etc/kubernetes/manifests/kube-apiserver.yaml 中添加 feature-gates 参数：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">...</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="attr">spec:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="attr">containers:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="bullet">-</span> <span class="attr">command:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="bullet">-</span> <span class="string">kube-apiserver</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="string">...</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="bullet">-</span> <span class="string">--feature-gates=ExpandInUsePersistentVolumes=true</span></span></pre></td></tr></table></figure>
<p>/etc/kubernetes/manifests/kube-controller-manager.yaml 中添加 feature-gates 参数并替换镜像为之前重新制作的镜像，另外需要将宿主机上的 ceph 配置目录挂载到 kube-controller-manager 容器中：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">...</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="attr">spec:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="attr">containers:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="bullet">-</span> <span class="attr">command:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="bullet">-</span> <span class="string">kube-controller-manager</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="string">...</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="bullet">-</span> <span class="string">--feature-gates=ExpandInUsePersistentVolumes=true</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="attr">image:</span> <span class="string">kube-controller-manager-ceph-v12.2.4:v1.13.3</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="string">...</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="attr">volumeMounts:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="string">...</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="bullet">-</span> <span class="attr">mountPath:</span> <span class="string">/etc/ceph</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="attr">name:</span> <span class="string">ceph-config</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="attr">readOnly:</span> <span class="literal">true</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="string">...</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="attr">volumes:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="string">...</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="bullet">-</span> <span class="attr">hostPath:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="attr">path:</span> <span class="string">/etc/ceph</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="attr">type:</span> <span class="string">Directory</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="attr">name:</span> <span class="string">ceph-config</span></span></pre></td></tr></table></figure>
<p>以上关于 kube-apiserver 和 kube-controller-manager 的操作需要在所有 master 节点上执行，kubelet 会监听到相关文件的变化并自动应用这些更新。<br><br>/etc/systemd/system/kubelet.service.d/10-kubeadm.conf 中更改 ExecStart 项增加 feature-gates 参数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ExecStart&#x3D;&#x2F;usr&#x2F;bin&#x2F;kubelet --feature-gates&#x3D;ExpandInUsePersistentVolumes&#x3D;true ...</span></pre></td></tr></table></figure>
<p>修改后需要执行以下命令使更改生效：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl daemon-reload</span></pre></td></tr><tr><td class="code"><pre><span class="line">systemctl restart kubelet</span></pre></td></tr></table></figure>
<p>以上关于 kubelet 的修改需要再所有计算节点上执行。</p>
</li>
<li><p>执行完所有以上操作后即可对使用该 storgeclass 的 PVC 进行动态在线扩容。</p>
</li>
</ol>]]></content>
      <categories>
        <category>Kubernetes</category>
      </categories>
      <tags>
        <tag>Ceph</tag>
        <tag>Kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>限制单位时间请求次数</title>
    <url>/post/cb6f39ed.html</url>
    <content><![CDATA[<p><a name="z0hPi"></a></p><h4 id="Rate-Limit"><a href="#Rate-Limit" class="headerlink" title="Rate Limit"></a>Rate Limit</h4><p>在众多的反向代理服务器中，实现请求次数限制的功能往往称作 rate-limit。   Rate-limit 在公网环境下实际上主要是为了防止 DoS 攻击。Rate-limit 实现了对每个客户端单位时间内请求次数的限制，例如 5 r/s，就是限制每个客户端 1s 之内针对该服务端只能发起 5 个 Http 请求。其原理往往是基于客户端请求中的某些标志性信息（一般是 IP）使用某种限流算法在服务端做出相应处理：如果该客户端的单位时间请求次数超出限制，服务端直接返回状态码为 429 的响应，在 Http 规范中，状态码 429 含义为“请求次数过多”。<br><a name="38NLy"></a></p><a id="more"></a>

<h4 id="限流算法"><a href="#限流算法" class="headerlink" title="限流算法"></a>限流算法</h4><p>常用的限流算法有两种：漏桶和令牌桶。<br>漏桶算法：请求先进入到漏桶中，漏桶以一定的速率将请求转给后端处理, 当请求速率过大会直接溢出即返回状态码为 429 的响应。漏桶对以不规则速率进入的请求进行了整形，使其以固定的速率被处理，往往被反向代理服务器用于保护真正的后端服务。<br>令牌桶算法：系统会按固定时间向桶中放入令牌, 如果桶已经满了就不再加了。新请求来临时，会各自拿走一个令牌并被转给后端服务处理, 如果没有令牌可拿就拒绝服务即返回状态码为 429 的响应。<br>假设漏桶和令牌桶均处于最佳状态（漏桶为空，令牌桶已满），当出现突发大流量时，对于漏桶，一部分请求被置于桶中，超出桶容量的请求被拒绝服务，而桶中的请求会以固定速率转给后端处理，因此必然存在排队情况，也就意味着请求可能存在较大的响应延时，这对后端服务来说是友好的，因为大流量经过漏桶已经被整形为平滑的请求序列，对后端压力较小，只不过压力较小可能意味着资源利用不充分；对于令牌桶来说，一部分请求立即获得令牌并且被立即转给服务后端处理，超出桶容量的请求一样被拒绝服务，转给后端服务的请求会被立即处理，因此响应延时会小很多，但是后端服务器会直接受到大流量的冲击，因此对后端服务不是很友好，不过这个问题并不严重，后端服务器的处理能力往往是很强的，只要设定的桶容量适宜，这些流量冲击一般不构成威胁，反而能够更充分的利用服务端资源。<br>除了应对突发流量时的较大差别，漏桶和令牌桶对于一般情况下的请求限速效果是类似的。<br>Nginx 的 Http 限速模块 <a href="http://nginx.org/en/docs/http/ngx_http_limit_req_module.html" target="_blank" rel="external nofollow noopener noreferrer">ngx_http_limit_req_module</a> 使用的是漏桶算法。OpenResty 的限速模块 <a href="https://github.com/openresty/lua-resty-limit-traffic" target="_blank" rel="external nofollow noopener noreferrer">lua-resty-limit-traffic</a> 支持配置使用漏桶或者令牌桶，配置方法可参考<a href="https://developpaper.com/gateway-rate-limit-network-rate-limitation-scheme/" target="_blank" rel="external nofollow noopener noreferrer">这篇文章</a>。<br><a name="j2z6C"></a></p>
<h4 id="针对-S3-请求的限速方案"><a href="#针对-S3-请求的限速方案" class="headerlink" title="针对 S3 请求的限速方案"></a>针对 S3 请求的限速方案</h4><p>进行限速的第一步是要确定使用什么信息来区分不同的客户端，一般来讲客户端 IP 使用的较为广泛，在 Nginx 和 OpenResty 的限速模块中都有现成的可获取客户端 IP 的变量 ，分别是 $binary_remote_addr 和 ngx.var.binary_remote_addr。当然还有一些其它的信息也可以用以区分客户端从而分别进行限速，例如 Http 请求头中的 Authorization 信息等。这里需要对 S3 进行限速，区分不同客户端使用的是 s3 的 accesskey。 根据 s3 协议<a href="https://docs.aws.amazon.com/zh_cn/AmazonS3/latest/API/sigv4-auth-using-authorization-header.html" target="_blank" rel="external nofollow noopener noreferrer">文档</a>，这个 accesskey 包含在请求信息的 Authorization 请求头中，但需要去提取出来才能用，因此需要对限速的逻辑进行定制以实现从 Authorization 中提取 accesskey 并基于此实现限速。无论对 Nginx 还是 OpenResty 的限速模块进行定制开发都是可以实现这个功能，但最终选择使用另外一个反向代理服务器 Envoy 来进行定制开发，这是因为：Envoy 对扩展开发原生就有非常友好的支持，扩展模块和 Envoy 本身的核心模块是完全解耦的，它们通过 grpc 进行通信，使用 grpc 的另一个好处就是可以使用任何开发语言实现扩展模块而不用关心 Envoy 本身使用的开发语言，因此完全可以采用一种开发人员最熟悉的语言去实现扩展模块逻辑，相比之下， Nginx 或者 OpenResty 的扩展开发只能使用 C 语言或者 Lua 。由于这种扩展模块的解耦，对扩展模块的更改并不需要重新编译打包 Envoy 本身的镜像，而 OpenResty 就必须重新打包整个镜像。因此，最终决定采用 Envoy 实现对 S3 的请求限速，其基本原理如下图所示，所有的客户端请求都要经过 envoy 的处理，针对每个请求 envoy 将其请求头中的 Authorization 信息作为参数向 rate-limiter 发起 rpc 调用以确定该请求是否应该被接受，如果是则将该请求转发给后端 rgw 服务进一步处理，如果否则直接返回状态码为 429 的响应。rate-limiter（采用令牌桶算法） 从 Authorization 信息中提取出 accesskey 并以此为 key 去检索出相应的桶中是否有令牌存在，进而决定是否应该接受该请求。<br>Envoy 的限速服务 gRPC 接口定义：<br><a href="https://github.com/envoyproxy/envoy/blob/master/api/envoy/service/ratelimit/v2/rls.proto" target="_blank" rel="external nofollow noopener noreferrer">https://github.com/envoyproxy/envoy/blob/master/api/envoy/service/ratelimit/v2/rls.proto</a><br>Envoy go 版本控制平面生成的代码：<br><a href="https://github.com/envoyproxy/go-control-plane/blob/master/envoy/service/ratelimit/v2/rls.pb.go" target="_blank" rel="external nofollow noopener noreferrer">https://github.com/envoyproxy/go-control-plane/blob/master/envoy/service/ratelimit/v2/rls.pb.go</a><br><img src="https://cdn.nlark.com/yuque/0/2019/png/182657/1570516385891-e3718bb2-93bc-46d8-ad5e-d5514de1a882.png#align=left&display=inline&height=201&name=rate%20limit%20using%20envoy.png&originHeight=201&originWidth=541&size=11509&status=done&width=541" alt="rate limit using envoy.png"><br></p>
<p><a name="6rvwm"></a></p>
<h4 id="Rate-limiter"><a href="#Rate-limiter" class="headerlink" title="Rate-limiter"></a>Rate-limiter</h4><p>这里采用 Go 语言实现 Rate-limiter 扩展模块。为每个 accesskey 维护一个令牌桶，令牌发放速率可调节，accesskey 和令牌桶的对应关系通过 map 结构维护。accesskey 和其限速值均存于数据库中，Rate-limiter 定期从数据库中同步限速信息并依次调节令牌桶发放速率，存储数据库中的限速值可通过控制平面 API 进行调整。添加一个全局限速值，存于数据库中，Rate-limiter 服务启动时从数据库中读取，该值可以通过控制平面 API 进行设置，值为 0 时涵义是不进行全局限速，当有携带新的 accesskey 的请求到来时，只记录下该 accesskey 的存在，不自动进行限速处理，除非用户指定要对其限速，非零值则意味着对新接入的 accesskey 自动添加限速规则，创建令牌桶进行限速。<br>初始状态下每个令牌桶中令牌数量为 0 ，随着时间推移，令牌数量逐渐增加，直到令牌桶满，令牌数量保存在内存中，一旦 Rate-limiter 重启则令牌数量重新初始化为 0. 若需要在分布式环境下保存令牌数量，则最好使用 Redis 作为存储后端。<br><a name="d4L4e"></a></p>
<h4 id="Envoy-限流方案的实现参考"><a href="#Envoy-限流方案的实现参考" class="headerlink" title="Envoy 限流方案的实现参考"></a>Envoy 限流方案的实现参考</h4><ul>
<li>一个较为完整的实现案例：<a href="https://venilnoronha.io/envoy-grpc-and-rate-limiting" target="_blank" rel="external nofollow noopener noreferrer">https://venilnoronha.io/envoy-grpc-and-rate-limiting</a></li>
<li>Lyft 贡献了一个开源项目，同样是实现了一个 gRPC Server 供 Envoy 调用，使用 Redis 存储数据，可对数据库、消息队列等多种后端应用进行限速：<a href="https://github.com/lyft/ratelimit" target="_blank" rel="external nofollow noopener noreferrer">https://github.com/lyft/ratelimit</a><br><a name="cimY6"></a><h4 id="不使用-Envoy-的方案"><a href="#不使用-Envoy-的方案" class="headerlink" title="不使用 Envoy 的方案"></a>不使用 Envoy 的方案</h4>由于 Go 社区官方提供了一种可以创建简单反向代理服务器的工具包，也可以通过直接编写一个反向代理工具进行简单的 Http 限速，从而避免使用 Envoy 限速要引入 Envoy 本身和一个 rate-limiter grpc server 两个容器的问题，其基本的结构如下：<br><img src="https://cdn.nlark.com/yuque/0/2019/png/182657/1571380553625-7cd700cf-3ff5-488c-96e3-3a15b7e07953.png#align=left&display=inline&height=81&name=image.png&originHeight=81&originWidth=541&size=6154&status=done&width=541" alt="image.png"><br>其中 rate-limiter 不再是一个 grpc server ， 而是一个 http 反向代理服务器，直接接收来自客户端的请求，并通过限流算法决定是否应该接受该请求，对于接受的请求转给后端 rgw 进行处理，对于不接受的请求直接返回状态码为 429 的 Http 响应。<br>rate-limiter 和 rgw 作为两个容器部署于 K8S 同一个 Pod 中，同时还可以实现带宽限制和请求数限制同时使用。<br><a name="sMQRp"></a><h4 id="控制平面-API"><a href="#控制平面-API" class="headerlink" title="控制平面 API"></a>控制平面 API</h4>这里控制平面也使用 grpc 协议，主要实现添加 accesskey，设置限速值等操作。</li>
</ul>
]]></content>
      <categories>
        <category>Envoy</category>
      </categories>
      <tags>
        <tag>RateLimit</tag>
        <tag>S3</tag>
      </tags>
  </entry>
  <entry>
    <title>从 RESTful 到 gRPC-Web 的平滑切换</title>
    <url>/post/bd5bd15.html</url>
    <content><![CDATA[<p><a name="z0hPi"></a></p><h4 id="gRPC-Web"><a href="#gRPC-Web" class="headerlink" title="gRPC-Web"></a>gRPC-Web</h4><ul>
<li>安装</li>
</ul><p>参考<a href="https://grpc-ecosystem.github.io/grpc-gateway/docs/usage.html" target="_blank" rel="external nofollow noopener noreferrer">官方安装说明</a>，需要指出的是有可能如果出现以下报错：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">protoc: error while loading shared libraries: libprotobuf.so.20: cannot open shared object file: No such file or directory</span></pre></td></tr></table></figure><a id="more"></a>




<p>此时，需要执行以下命令更新环境变量中关于 LIB 的信息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo ldconfig</span></pre></td></tr><tr><td class="code"><pre><span class="line">或者</span></pre></td></tr><tr><td class="code"><pre><span class="line">export LD_LIBRARY_PATH&#x3D;&#x2F;usr&#x2F;local&#x2F;lib</span></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>RESTful</tag>
        <tag>gRPC-Web</tag>
      </tags>
  </entry>
  <entry>
    <title>Ceph 对接 Kubernetes 的两种方式</title>
    <url>/post/466a6051.html</url>
    <content><![CDATA[<p><a name="hguEn"></a></p><h4 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h4><ul>
<li>创建 rbd 存储池</li>
</ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ceph osd pool create rbd 128 128</span></pre></td></tr><tr><td class="code"><pre><span class="line">rbd pool init rbd</span></pre></td></tr></table></figure><ul>
<li>获取 ceph 集群基本信息</li>
</ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 执行 cat 查看 ceph 配置文件</span></pre></td></tr><tr><td class="code"><pre><span class="line">cat &#x2F;etc&#x2F;ceph&#x2F;ceph.conf </span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">[global]</span></pre></td></tr><tr><td class="code"><pre><span class="line">bluestore block db size &#x3D; 10737418240</span></pre></td></tr><tr><td class="code"><pre><span class="line">bluestore block fast create &#x3D; False</span></pre></td></tr><tr><td class="code"><pre><span class="line">bluestore block fast size &#x3D; 10737418240</span></pre></td></tr><tr><td class="code"><pre><span class="line">cluster network &#x3D; 10.10.0.0&#x2F;16</span></pre></td></tr><tr><td class="code"><pre><span class="line">fsid &#x3D; 5db6cfe0-e485-4884-89eb-8f926fd6d677</span></pre></td></tr><tr><td class="code"><pre><span class="line">mon allow pool delete &#x3D; True</span></pre></td></tr><tr><td class="code"><pre><span class="line">mon health preluminous compat warning &#x3D; False</span></pre></td></tr><tr><td class="code"><pre><span class="line">mon host &#x3D; [v2:10.10.46.236:3300,v1:10.10.46.236:6789],[v2:10.10.66.143:3300,v1:10.10.66.143:6789],[v2:10.10.178.231:3300,v1:10.10.178.231:6789]</span></pre></td></tr><tr><td class="code"><pre><span class="line">mon initial members &#x3D; u1,u2,u3</span></pre></td></tr><tr><td class="code"><pre><span class="line">mon_max_pg_per_osd &#x3D; 400</span></pre></td></tr><tr><td class="code"><pre><span class="line">osd pool default crush rule &#x3D; -1</span></pre></td></tr><tr><td class="code"><pre><span class="line">public network &#x3D; 10.10.0.0&#x2F;16</span></pre></td></tr></table></figure><a id="more"></a>






<p>由上述信息可知，ceph 集群 clusterid 为 5db6cfe0-e485-4884-89eb-8f926fd6d677，monitor 节点信息为：10.10.46.236:6789，10.10.66.143:6789，10.10.178.231:6789。</p>
<ul>
<li>获取 client.admin keyring</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">➜  ~ cat &#x2F;etc&#x2F;ceph&#x2F;ceph.client.admin.keyring </span></pre></td></tr><tr><td class="code"><pre><span class="line">[client.admin]</span></pre></td></tr><tr><td class="code"><pre><span class="line">	key &#x3D; AQAheXddCD0xBhAA3KEps1mbPzcJbFVKVpIdMQ&#x3D;&#x3D;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	caps mds &#x3D; &quot;allow *&quot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	caps mgr &#x3D; &quot;allow *&quot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	caps mon &#x3D; &quot;allow *&quot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	caps osd &#x3D; &quot;allow *&quot;</span></pre></td></tr></table></figure>

<p>记录 admin 用户的 key 为 AQAheXddCD0xBhAA3KEps1mbPzcJbFVKVpIdMQ==。</p>
<p><a name="5svKr"></a></p>
<h4 id="In-tree"><a href="#In-tree" class="headerlink" title="In-tree"></a>In-tree</h4><p>In-tree 插件是比较早和成熟的方式，调用不同存后端的代码包含在 Kubernetes 核心代码中，缺乏灵活性，不利于更新迭代，而且使用起来比较麻烦，需要在每个需要 PV 的命名空间都创建 role 和 secret key，不建议使用。如需使用，参见 <a href="https://medium.com/velotio-perspectives/an-innovators-guide-to-kubernetes-storage-using-ceph-a4b919f4e469" target="_blank" rel="external nofollow noopener noreferrer">An Innovator’s Guide to Kubernetes Storage Using Ceph</a> 。</p>
<p><a name="DVykd"></a></p>
<h4 id="Out-tree"><a href="#Out-tree" class="headerlink" title="Out-tree"></a>Out-tree</h4><p>Out-tree 存储插件主要是 CSI ，Kubernetes 核心代码定义了调用接口，具体的实现由第三方插件开发商自行维护，是未来主流的使用方式，目前 Ceph-CSI rbd 相关功能已经 GA。</p>
<ul>
<li><p>下载最新的 ceph-csi 代码，地址：<a href="https://github.com/ceph/ceph-csi/archive/v1.2.0.tar.gz" target="_blank" rel="external nofollow noopener noreferrer">https://github.com/ceph/ceph-csi/archive/v1.2.0.tar.gz</a></p>
</li>
<li><p>解压后目录结构如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">➜  ceph-csi-1.2.0 tree -L 1</span></pre></td></tr><tr><td class="code"><pre><span class="line">.</span></pre></td></tr><tr><td class="code"><pre><span class="line">├── assets</span></pre></td></tr><tr><td class="code"><pre><span class="line">├── cmd</span></pre></td></tr><tr><td class="code"><pre><span class="line">├── deploy</span></pre></td></tr><tr><td class="code"><pre><span class="line">├── deploy.sh</span></pre></td></tr><tr><td class="code"><pre><span class="line">├── docs</span></pre></td></tr><tr><td class="code"><pre><span class="line">├── e2e</span></pre></td></tr><tr><td class="code"><pre><span class="line">├── examples</span></pre></td></tr><tr><td class="code"><pre><span class="line">├── Gopkg.lock</span></pre></td></tr><tr><td class="code"><pre><span class="line">├── Gopkg.toml</span></pre></td></tr><tr><td class="code"><pre><span class="line">├── LICENSE</span></pre></td></tr><tr><td class="code"><pre><span class="line">├── Makefile</span></pre></td></tr><tr><td class="code"><pre><span class="line">├── pkg</span></pre></td></tr><tr><td class="code"><pre><span class="line">├── README.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">├── scripts</span></pre></td></tr><tr><td class="code"><pre><span class="line">├── troubleshooting</span></pre></td></tr><tr><td class="code"><pre><span class="line">└── vendor</span></pre></td></tr></table></figure>
</li>
<li><p>以 rbd 配置为例，先修改 deploy/rbd/kubernetes/v1.14+/csi-config-map.yaml 文件内容，将 ceph 集群信息填写进去：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span></pre></td></tr><tr><td class="code"><pre><span class="line">kind: ConfigMap</span></pre></td></tr><tr><td class="code"><pre><span class="line">data:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  config.json: |-</span></pre></td></tr><tr><td class="code"><pre><span class="line">    [</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &quot;clusterID&quot;: &quot;5db6cfe0-e485-4884-89eb-8f926fd6d677&quot;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &quot;monitors&quot;: [</span></pre></td></tr><tr><td class="code"><pre><span class="line">          &quot;10.10.46.236&quot;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">          &quot;10.10.66.143&quot;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">          &quot;10.10.178.231&quot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ]</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ]</span></pre></td></tr><tr><td class="code"><pre><span class="line">metadata:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  name: ceph-csi-config</span></pre></td></tr></table></figure>
</li>
<li><p>执行以下脚本进行部署</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;examples&#x2F;rbd&#x2F;plugin-deploy.sh</span></pre></td></tr></table></figure>
</li>
<li><p>创建 rbd-secret</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl create secret generic csi-rbd-secret --from-literal&#x3D;adminID&#x3D;&quot;admin&quot; --from-literal&#x3D;adminKey&#x3D;&quot;AQAheXddCD0xBhAA3KEps1mbPzcJbFVKVpIdMQ&#x3D;&#x3D;&quot; --from-literal&#x3D;userID&#x3D;&quot;admin&quot; --from-literal&#x3D;userKey&#x3D;&quot;AQAheXddCD0xBhAA3KEps1mbPzcJbFVKVpIdMQ&#x3D;&#x3D;&quot;</span></pre></td></tr></table></figure>
</li>
<li><p>修改 examples/rbd/storageclass.yaml 文件，主要是填上 clusterID</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apiVersion: storage.k8s.io&#x2F;v1</span></pre></td></tr><tr><td class="code"><pre><span class="line">kind: StorageClass</span></pre></td></tr><tr><td class="code"><pre><span class="line">metadata:</span></pre></td></tr><tr><td class="code"><pre><span class="line">   name: csi-rbd-sc</span></pre></td></tr><tr><td class="code"><pre><span class="line">provisioner: rbd.csi.ceph.com</span></pre></td></tr><tr><td class="code"><pre><span class="line">parameters:</span></pre></td></tr><tr><td class="code"><pre><span class="line">   # String representing a Ceph cluster to provision storage from.</span></pre></td></tr><tr><td class="code"><pre><span class="line">   # Should be unique across all Ceph clusters in use for provisioning,</span></pre></td></tr><tr><td class="code"><pre><span class="line">   # cannot be greater than 36 bytes in length, and should remain immutable for</span></pre></td></tr><tr><td class="code"><pre><span class="line">   # the lifetime of the StorageClass in use.</span></pre></td></tr><tr><td class="code"><pre><span class="line">   # Ensure to create an entry in the config map named ceph-csi-config, based on</span></pre></td></tr><tr><td class="code"><pre><span class="line">   # csi-config-map-sample.yaml, to accompany the string chosen to</span></pre></td></tr><tr><td class="code"><pre><span class="line">   # represent the Ceph cluster in clusterID below</span></pre></td></tr><tr><td class="code"><pre><span class="line">   clusterID: 5db6cfe0-e485-4884-89eb-8f926fd6d677</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">   # Ceph pool into which the RBD image shall be created</span></pre></td></tr><tr><td class="code"><pre><span class="line">   pool: rbd</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">   # RBD image format. Defaults to &quot;2&quot;.</span></pre></td></tr><tr><td class="code"><pre><span class="line">   imageFormat: &quot;2&quot;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">   # RBD image features. Available for imageFormat: &quot;2&quot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">   # CSI RBD currently supports only &#96;layering&#96; feature.</span></pre></td></tr><tr><td class="code"><pre><span class="line">   imageFeatures: layering</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">   # The secrets have to contain Ceph credentials with required access</span></pre></td></tr><tr><td class="code"><pre><span class="line">   # to the &#39;pool&#39;.</span></pre></td></tr><tr><td class="code"><pre><span class="line">   csi.storage.k8s.io&#x2F;provisioner-secret-name: csi-rbd-secret</span></pre></td></tr><tr><td class="code"><pre><span class="line">   csi.storage.k8s.io&#x2F;provisioner-secret-namespace: default</span></pre></td></tr><tr><td class="code"><pre><span class="line">   csi.storage.k8s.io&#x2F;node-stage-secret-name: csi-rbd-secret</span></pre></td></tr><tr><td class="code"><pre><span class="line">   csi.storage.k8s.io&#x2F;node-stage-secret-namespace: default</span></pre></td></tr><tr><td class="code"><pre><span class="line">   # Specify the filesystem type of the volume. If not specified,</span></pre></td></tr><tr><td class="code"><pre><span class="line">   # csi-provisioner will set default as &#96;ext4&#96;.</span></pre></td></tr><tr><td class="code"><pre><span class="line">   csi.storage.k8s.io&#x2F;fstype: xfs</span></pre></td></tr><tr><td class="code"><pre><span class="line">   # uncomment the following to use rbd-nbd as mounter on supported nodes</span></pre></td></tr><tr><td class="code"><pre><span class="line">   # mounter: rbd-nbd</span></pre></td></tr><tr><td class="code"><pre><span class="line">reclaimPolicy: Delete</span></pre></td></tr><tr><td class="code"><pre><span class="line">mountOptions:</span></pre></td></tr><tr><td class="code"><pre><span class="line">   - discard</span></pre></td></tr></table></figure>
</li>
<li><p>创建 storage-class</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl apply -f examples&#x2F;rbd&#x2F;storageclass.yaml</span></pre></td></tr></table></figure>
</li>
<li><p>设置该 storage-class 为默认</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl patch storageclass csi-rbd-sc -p &#39;&#123;&quot;metadata&quot;: &#123;&quot;annotations&quot;:&#123;&quot;storageclass.kubernetes.io&#x2F;is-default-class&quot;:&quot;true&quot;&#125;&#125;&#125;&#39;</span></pre></td></tr></table></figure>
</li>
<li><p>以上部署主要使用了默认值，相关插件都部署在 default 命名空间，可以根据需要进行调整。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Kubernetes</category>
      </categories>
      <tags>
        <tag>Ceph</tag>
        <tag>Kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>统一认证中心方案调研</title>
    <url>/post/c851306f.html</url>
    <content><![CDATA[<p><a name="QW5Ia"></a></p><h4 id="为什么需要认证中心"><a href="#为什么需要认证中心" class="headerlink" title="为什么需要认证中心"></a>为什么需要认证中心</h4><p>认证（Authentication）和授权（Athorization）是企业级服务的基本功能，企业级应用的开发必须考虑到如何使提供的产品与用户已有的认证和授权体系结合起来，更进一步能够基于该体系提供开发接口给其它应用调用。如下图所示，不同的用户可能已经有不同的认证体系，有的用户可能用的是<br> LDAP，这是种比较老的认证方式，SAML 新一些，最新的是<br>OpenID，这些不同的认证后端都应当可以接入到统一认证中心，从而能够更好地管理用户和进行授权。</p><a id="more"></a>

<p><img src="https://cdn.nlark.com/yuque/0/2019/png/182657/1568099807740-b6f23b9f-79f7-4f1e-8c5b-e7e6dcc812c7.png#align=left&display=inline&height=121&name=image.png&originHeight=121&originWidth=531&size=9511&status=done&style=none&width=531" alt="image.png"><br></p>
<p><a name="lMJ8j"></a></p>
<h4 id="OpenID"><a href="#OpenID" class="headerlink" title="OpenID"></a>OpenID</h4><p>如上图所示，不论用户已有的认证体系是基于什么协议的，通过认证中心我们将其统一转换为 OpenID 协议从而方便应用服务的开发，协议的转换可以交由 Keystone 和 Keycloak 等开源方案来解决， 而 OpenID 是我们开发环节必须要涉及到的内容，因此需要搞清楚其原理。<br>OpenID 是 OAuth 2.0 协议的扩展，主要增强了认证功能，因此认识 OpenID 需要从 OAuth 2.0 开始。OAuth 2.0 协议的应用实际上已经相当广泛，现在很多网站都允许使用微信扫码登录，这个登录过程其实就是 OAuth 2.0 协议的一种实现。下面以<a href="https://www.ituring.com.cn" target="_blank" rel="external nofollow noopener noreferrer">图灵社区</a>使用微信账号登录为例说明整个过程：</p>
<ol>
<li>第一步：打开图灵社区登录页面<a href="https://account.ituring.com.cn/log-in" target="_blank" rel="external nofollow noopener noreferrer">https://account.ituring.com.cn/log-in</a>，点击微信登录图标</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2019/png/182657/1568101991767-538e6965-086f-4f6a-bc9e-ddaad3dd6acc.png#align=left&display=inline&height=301&name=image.png&originHeight=416&originWidth=466&size=22980&status=done&style=none&width=337" alt="image.png"></p>
<ol start="2">
<li>第二步：页面跳转至微信认证中心</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https:&#x2F;&#x2F;open.weixin.qq.com&#x2F;connect&#x2F;qrconnect?appid&#x3D;wx3a6700225b70af1f&amp;redirect_uri&#x3D;https%3A%2F%2Faccount.ituring.com.cn%2Fsignin-wechat&amp;response_type&#x3D;code&amp;scope&#x3D;snsapi_login&amp;state&#x3D;7nh23BdGirIHwjyH79bzV6YjF-55Vn7AzzZIjFZZnKrFxCmAsisTRfSCD7ikv_PMx7uFjsdQPUA8A94MzuZxPOAAvqd1P-0-oo2HGw0yatvKc4hZFU0-ZpEBHt2gqkXqXHAI-0wpyATNbXv14mDzcJSPR-OST90-XwoHpwD0fCXlM3sGdzYHHHPb74bW4dMHSeOThBkhpJvD6oE_k0TFAwQd4cIFV9-gj5tYRelAawc</span></pre></td></tr></table></figure>
<p><img src="https://cdn.nlark.com/yuque/0/2019/png/182657/1568102224149-f1424311-b431-4989-b589-b89f2fe08d2c.png#align=left&display=inline&height=337&name=image.png&originHeight=422&originWidth=347&size=54611&status=done&style=none&width=277" alt="image.png"></p>
<ol start="3">
<li>第三步：用户微信扫码进行授权确认</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2019/png/182657/1568102587868-68ff5b22-2254-47f9-86a7-109ad9a01934.png#align=left&display=inline&height=377&name=%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20190910155905.png&originHeight=1508&originWidth=1077&size=105137&status=done&style=none&width=269" alt="微信图片_20190910155905.png"></p>
<ol start="4">
<li>第四步: 登录成功，返回图灵社区主页。</li>
</ol>
<p>这里的四步是我们能够直观看到的步骤，实际上背后的交互逻辑如下：<br><br><br><img src="https://cdn.nlark.com/yuque/0/2019/png/182657/1568106057222-f82dd3f8-d2ac-427a-ab9f-05d3fd651fe1.png#align=left&display=inline&height=514&name=auth-center-02.png&originHeight=514&originWidth=733&size=66359&status=done&style=none&width=733" alt="auth-center-02.png"></p>
<p>交互过程中涉及到的 OAuth 术语有：</p>
<ul>
<li>Resource owner:： 用户</li>
<li>Client：需要授权的应用，这里指图灵社区</li>
<li>Authorization server：认证中心，这里指微信开发中心</li>
<li>Resource server： 拥有 Client 所需资源的服务端，这里指存储有用户基本信息的微信 API 服务端</li>
<li>Access token：Client 与 Resource Server 交互时的凭证</li>
<li>Scope： 通常指一个可用 api 资源的集合，这里的 scope 值为 snsapi_login 意味着 client 请求的这个集合只包含登录用的基本操作 API ，如查询用户基本信息，而不能去操作用户，如更改用户名</li>
<li>Consent： 同意，这里指用户同意授权图灵社区获取自己的基本信息</li>
</ul>
<p>更具体的交互过程参考：</p>
<ul>
<li><a href="https://mp.weixin.qq.com/wiki?action=doc&id=mp1421140842" target="_blank" rel="external nofollow noopener noreferrer">微信官方文档</a></li>
<li><a href="https://www.cnblogs.com/0201zcr/p/5131602.html" target="_blank" rel="external nofollow noopener noreferrer">cnblog-微信公众平台开发 —— 微信授权登录（OAuth2.0）</a></li>
</ul>
<p><a name="RW3b5"></a></p>
<h4 id="Keystone-与-Keycloak"><a href="#Keystone-与-Keycloak" class="headerlink" title="Keystone 与 Keycloak"></a>Keystone 与 Keycloak</h4><p>Keystone 是 OpenStack 社区的统一认证项目，主要是作为 OpenStack 多租户管理的基础组件 ，由于 OpenStack 所有项目的设计都具有松耦合的特点， Keystone 项目完全可以单独拿出来使用，另外 Keystone 也充当了 OpenStack 项目的服务注册中心。<br>Keycloak 是 RedHat 维护的统一认证项目，是其商业产品 RH-SSO 的上游项目。<br>下面对两个项目做对比说明。</p>
<ul>
<li>基本信息</li>
</ul>
<p>下表显示的基本信息为 2019 年 09 月 15 日的情况：<br></p>
<table>
<thead>
<tr>
<th align="center">比较项<br></th>
<th align="center"><strong>Keystone</strong></th>
<th align="center"><strong>Keycloak</strong><br></th>
</tr>
</thead>
<tbody><tr>
<td align="center">开发语言</td>
<td align="center">Python<br></td>
<td align="center">Java</td>
</tr>
<tr>
<td align="center">开源<br></td>
<td align="center">是</td>
<td align="center">是，有商业版</td>
</tr>
<tr>
<td align="center">维护方<br></td>
<td align="center">OpenStack 社区<br></td>
<td align="center">RedHat 及社区<br></td>
</tr>
<tr>
<td align="center">贡献者数量<br></td>
<td align="center">433</td>
<td align="center">328</td>
</tr>
<tr>
<td align="center">提交数</td>
<td align="center">14250<br></td>
<td align="center">11665</td>
</tr>
<tr>
<td align="center">最近一年的提交数</td>
<td align="center"><img src="https://cdn.nlark.com/yuque/0/2019/png/182657/1568554312502-222a3c04-cfb8-44a0-b25d-428c7c56684e.png#align=left&display=inline&height=132&name=image.png&originHeight=132&originWidth=721&size=5838&status=done&width=721" alt="image.png"></td>
<td align="center"><img src="https://cdn.nlark.com/yuque/0/2019/png/182657/1568554290207-8a67772f-52fc-4d4b-9778-7a934ed22ac6.png#align=left&display=inline&height=140&name=image.png&originHeight=140&originWidth=726&size=5728&status=done&width=726" alt="image.png"></td>
</tr>
<tr>
<td align="center">LDAP 集成<br></td>
<td align="center">支持<br></td>
<td align="center">支持<br></td>
</tr>
<tr>
<td align="center">支持的数据库<br></td>
<td align="center">MySQL</td>
<td align="center">h2，MySQL，Postgres</td>
</tr>
<tr>
<td align="center">UI<br></td>
<td align="center">无独立 UI，界面集成在 Horizon 中<br></td>
<td align="center">有独立 UI，可以定制主题以适应需要<br></td>
</tr>
<tr>
<td align="center">SDK<br></td>
<td align="center">不区分 Admin 和 普通用户 SDK ，<a href="https://github.com/openstack/js-openstack-lib" target="_blank" rel="external nofollow noopener noreferrer">js SDK  </a>有但不完善，<a href="https://github.com/openstack/python-keystoneclient" target="_blank" rel="external nofollow noopener noreferrer"> Python SDK </a>最完善，<a href="https://github.com/gophercloud/gophercloud" target="_blank" rel="external nofollow noopener noreferrer">Go SDK </a>相对完善。</td>
<td align="center">区分 Admin 和 普通用户 SDK ，Admin SDK 提供了管理用户、角色和应用认证等的功能，普用户SDK主要实现认证和授权功能， Admin SDK Java 版本最完善， Node 版次之， <a href="https://github.com/Nerzal/gocloak" target="_blank" rel="external nofollow noopener noreferrer">Go</a> 版为非官方维护，较为完善。普通用户 SDK 同样是 Java最为完善，其次是 JavaScript 、Node、Python等，由于其遵循标准的 OpenID 认证流程，故各种语言已有的 OpenID Client 都可以直接使用。<br><br></td>
</tr>
<tr>
<td align="center">Rest API <br></td>
<td align="center"><a href="https://docs.openstack.org/api-ref/identity/v3/" target="_blank" rel="external nofollow noopener noreferrer">v3 </a>版本文档：<a href="https://docs.openstack.org/api-ref/identity/v3/" target="_blank" rel="external nofollow noopener noreferrer">https://docs.openstack.org/api-ref/identity/v3/</a></td>
<td align="center">7.0 版本的 <a href="https://www.keycloak.org/docs-api/7.0/rest-api/index.html" target="_blank" rel="external nofollow noopener noreferrer">Admin API</a> 文档<br>：<a href="https://www.keycloak.org/docs-api/7.0/rest-api/index.html" target="_blank" rel="external nofollow noopener noreferrer">https://www.keycloak.org/docs-api/7.0/rest-api/index.html</a></td>
</tr>
<tr>
<td align="center">基于 Kubernetes 部署<br></td>
<td align="center">官方有使用 <a href="https://github.com/openstack/openstack-helm" target="_blank" rel="external nofollow noopener noreferrer">Helm charts </a>部署整个 OpenStack 集群的方案，没有专门的使用 Kubernetes 部署Keystone 的方案，可从  OpenStack helm charts 中抽离，但有一定的工作量。<br></td>
<td align="center">有非官方的 <a href="https://github.com/codecentric/helm-charts" target="_blank" rel="external nofollow noopener noreferrer">Helm charts </a>用于部署高可用 Keycloak 集群，经试用满足需求。另外最近官方新开了 <a href="https://github.com/keycloak/keycloak-operator" target="_blank" rel="external nofollow noopener noreferrer">keycloak-operator</a> 仓库，下一步有可能提供基于 CRD 的部署支持。<br></td>
</tr>
<tr>
<td align="center">非侵入式认证</td>
<td align="center">未见官方支持方案<br></td>
<td align="center">官方提供 <a href="https://github.com/keycloak/keycloak-gatekeeper" target="_blank" rel="external nofollow noopener noreferrer">keycloak-gatekeeper</a> 项目通过 proxy 方式代理前端请求，认证过程由代理完成，业务代码中不需要加入认证处理的内容，方便现有业务的无侵入接入认证。可以结合 Nginx-Ingress 等 API Gateway 使用。<br></td>
</tr>
</tbody></table>
<ul>
<li>基本概念</li>
</ul>
<p>Keystone 和 Keycloak 有一部分概念是相同的，有一部分是相似的（即涵义基本相同，名称不同），还有一部分是各自独有的，下表对照说明：<br></p>
<table>
<thead>
<tr>
<th align="center">比较项<br></th>
<th align="center"><strong>Keystone</strong></th>
<th align="center"><strong>Keycloak</strong><br></th>
</tr>
</thead>
<tbody><tr>
<td align="center">用户</td>
<td align="center">Users：用户必须属于某一个域（domain），用户名非全局唯一，而是域内唯一。</td>
<td align="center">Users：概念一致。</td>
</tr>
<tr>
<td align="center">用户组</td>
<td align="center">Groups：用户组包含一组用户，用户组必须属于某一个域（domain）。</td>
<td align="center">Groups：概念一致。</td>
</tr>
<tr>
<td align="center">项目</td>
<td align="center">Projects： OpenStack 中为方便多租户管理的概念。OpenStack 中的虚拟机、虚拟盘等资源必须是属于某一个项目，而项目本身必须是属于某一个域（domain）。<br></td>
<td align="center">无</td>
</tr>
<tr>
<td align="center">域</td>
<td align="center">Domains： 域是项目、用户组、用户的容器，Keystone 提供默认域（Default）。对所有用户、项目和用户组的操作都必须提供域信息。域名全局唯一。<br></td>
<td align="center">Realms：和 Domains 概念一致，Keycloak 提供默认域（Master）。<br></td>
</tr>
<tr>
<td align="center">角色</td>
<td align="center">Roles：用于约束用户在某种资源上可以进行的操作，从而实现基于角色的授权（RBAC）。可以对单个用户或某组用户授予操作某个项目或某个域的某种角色。角色名域内唯一。</td>
<td align="center">Roles： 概念一致。<br></td>
</tr>
<tr>
<td align="center">Token</td>
<td align="center">Token：用于在向资源服务器请求资源时标示自身身份。根据用途的不同和有效范围可分为多种 token。</td>
<td align="center">Token：用途一致，实现 token 使用的算法有所区别</td>
</tr>
<tr>
<td align="center">服务目录</td>
<td align="center">Catalog：服务目录，用于集中注册和管理 OpenStack 各种服务，方便松耦合的各项服务之间互相发现和调用。<br></td>
<td align="center">无</td>
</tr>
<tr>
<td align="center">客户端认证<br></td>
<td align="center">Application Credentials：应用凭证，与用户绑定的一种凭证，拥有与用户一致的权限（Role），也可以在创建时指定，专门给 client 端在无需使用用户和密码进行登录时使用。<br>Credentials：与用户名和密码基本等同的凭证，只不过是以 EC2 方式提供的凭证，包括 accekey 和 secret key。<br></td>
<td align="center">Clients： 和 OAuth 术语基本一致，只能由管理员用户创建，和普通用户并无绑定关系。使用标准认证协议 OpenID（OAuth 2.0）或者 SAML2 。可以配置成需要用户登录认证或者直接访问。</td>
</tr>
<tr>
<td align="center">认证提供方</td>
<td align="center">Identity Provider：第三方认证提供方，用于替代 Keystone 的认证功能， 例如 Github、微信等，只要是支持的标准协议就可以接入， Keystone 支持 SAML2 和 OpenID<br>。Keystone 既可以接入第三方认证提供方，其本身也可以作为认证提供方供其它服务调用。当作为认证提供方时支持 SAML2 和 OAuth1.0a 对外服务，不支持 OpenID。<br></td>
<td align="center">Identity Provider：概念一致，但是作为认证提供方时支持 SAML2 和 OpenID。<br></td>
</tr>
</tbody></table>
<ul>
<li>结论</li>
</ul>
<p>通过对比，可以知道 Keystone 更多是为 OpenStack 专门设计的，虽然也支持标准协议的接入，但这并不是其核心和重点功能，而 Keycloak 一开始就是作为独立的认证中心进行设计的，完全建立在标准认证协议之上，并为此提供了完善的周边工具，因此选择使用 Keycloak 作为基础进行认证中心的实现更合适。<br><a name="tlhNK"></a></p>
<h4 id="引入-Keycloak-后的架构"><a href="#引入-Keycloak-后的架构" class="headerlink" title="引入 Keycloak 后的架构"></a>引入 Keycloak 后的架构</h4><ul>
<li>引入 Keycloak 之前的架构</li>
</ul>
<p>这是最初的架构，客户端请求经过 API 网关分发到不同的服务，而服务在业务代码中维护用户的认证和授权过程，并且用户的管理包括用户、角色以及用户角色的绑定都由后端服务自己进行。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2019/png/182657/1568620339129-62544ce7-0f22-40be-9ac3-e8479f90b590.png#align=left&display=inline&height=231&name=image.png&originHeight=231&originWidth=476&size=12341&status=done&style=none&width=476" alt="image.png"></p>
<ul>
<li>引入 Keycloak 之后</li>
</ul>
<p>由于我们的服务都是基于 Kubernetes 部署的，我们使用了 ingress-nginx 作为 API 网关， ingress-nginx 可以视为 nginx 为 Kubernetes 定制的版本，功能受到 Kubernetes Ingress 定义的限制，虽然支持使用 OAuth 2.0 对接外部认证服务，但本身并不支持对接外部授权服务。如果使用 ingress-nginx 对接 Keycloak 认证，则总体架构变为下图所示，Ingress 负责进行认证，各个后端服务仍然需要自行去处理授权。<br><img src="https://cdn.nlark.com/yuque/0/2019/png/182657/1568621100341-781dba8e-5d5d-4349-80d4-50449397caff.png#align=left&display=inline&height=341&name=image.png&originHeight=341&originWidth=569&size=16799&status=done&style=none&width=569" alt="image.png"><br>更进一步，使用 keycloak-gatekeeper 进行认证和授权，这样后端服务将完全和认证与授权解耦，只关注业务逻辑，这样解耦的一个好处是，更换认证提供方对于后端服务是无感的，更加灵活。<br><img src="https://cdn.nlark.com/yuque/0/2019/png/182657/1568622013241-ade99ea1-a5b4-4da8-8c98-0c07cefd3044.png#align=left&display=inline&height=281&name=image.png&originHeight=281&originWidth=637&size=13836&status=done&style=none&width=637" alt="image.png"></p>
<ul>
<li>keycloak-gatekeeper</li>
</ul>
<p>keycloak-gatekeeper 是 Keycloak 官方使用 Go 语言开发的请求代理转发组件，集成了认证和授权功能，对服务的请求只有经过了 gatekeeper 的验证才会被转发到下一环节，否则将直接返回未授权响应。一个示例 keycloak-gatekeeper 如下， 对于 /admin 路径下资源的请求必须具有相应的角色才能继续进行。 <br></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># is the url for retrieve the OpenID configuration - normally the &lt;server&gt;&#x2F;auth&#x2F;realm&#x2F;&lt;realm_name&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">discovery-url: https:&#x2F;&#x2F;keycloak.example.com&#x2F;auth&#x2F;realms&#x2F;&lt;REALM_NAME&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"># the client id for the &#39;client&#39; application</span></pre></td></tr><tr><td class="code"><pre><span class="line">client-id: &lt;CLIENT_ID&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"># the secret associated to the &#39;client&#39; application</span></pre></td></tr><tr><td class="code"><pre><span class="line">client-secret: &lt;CLIENT_SECRET&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"># the interface definition you wish the proxy to listen, all interfaces is specified as &#39;:&lt;port&gt;&#39;, unix sockets as unix:&#x2F;&#x2F;&lt;REL_PATH&gt;|&lt;&#x2F;ABS PATH&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">listen: 127.0.0.1:3000</span></pre></td></tr><tr><td class="code"><pre><span class="line"># whether to enable refresh tokens</span></pre></td></tr><tr><td class="code"><pre><span class="line">enable-refresh-tokens: true</span></pre></td></tr><tr><td class="code"><pre><span class="line"># the location of a certificate you wish the proxy to use for TLS support</span></pre></td></tr><tr><td class="code"><pre><span class="line">tls-cert:</span></pre></td></tr><tr><td class="code"><pre><span class="line"># the location of a private key for TLS</span></pre></td></tr><tr><td class="code"><pre><span class="line">tls-private-key:</span></pre></td></tr><tr><td class="code"><pre><span class="line"># the redirection url, essentially the site url, note: &#x2F;oauth&#x2F;callback is added at the end</span></pre></td></tr><tr><td class="code"><pre><span class="line">redirection-url: http:&#x2F;&#x2F;127.0.0.1:3000</span></pre></td></tr><tr><td class="code"><pre><span class="line"># the encryption key used to encode the session state</span></pre></td></tr><tr><td class="code"><pre><span class="line">encryption-key: &lt;ENCRYPTION_KEY&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"># the upstream endpoint which we should proxy request</span></pre></td></tr><tr><td class="code"><pre><span class="line">upstream-url: http:&#x2F;&#x2F;127.0.0.1:80</span></pre></td></tr><tr><td class="code"><pre><span class="line"># additional scopes to add to add to the default (openid+email+profile)</span></pre></td></tr><tr><td class="code"><pre><span class="line">scopes:</span></pre></td></tr><tr><td class="code"><pre><span class="line">- vpn-user</span></pre></td></tr><tr><td class="code"><pre><span class="line"># a collection of resource i.e. urls that you wish to protect</span></pre></td></tr><tr><td class="code"><pre><span class="line">resources:</span></pre></td></tr><tr><td class="code"><pre><span class="line">- uri: &#x2F;admin&#x2F;test</span></pre></td></tr><tr><td class="code"><pre><span class="line">  # the methods on this url that should be protected, if missing, we assuming all</span></pre></td></tr><tr><td class="code"><pre><span class="line">  methods:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  - GET</span></pre></td></tr><tr><td class="code"><pre><span class="line">  # a list of roles the user must have in order to access urls under the above</span></pre></td></tr><tr><td class="code"><pre><span class="line">  # If all you want is authentication ONLY, simply remove the roles array - the user must be authenticated but</span></pre></td></tr><tr><td class="code"><pre><span class="line">  # no roles are required</span></pre></td></tr><tr><td class="code"><pre><span class="line">  roles:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  - openvpn:vpn-user</span></pre></td></tr><tr><td class="code"><pre><span class="line">  - openvpn:prod-vpn</span></pre></td></tr><tr><td class="code"><pre><span class="line">  - test</span></pre></td></tr><tr><td class="code"><pre><span class="line">- uri: &#x2F;admin&#x2F;*</span></pre></td></tr><tr><td class="code"><pre><span class="line">  methods:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  - GET</span></pre></td></tr><tr><td class="code"><pre><span class="line">  roles:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  - openvpn:vpn-user</span></pre></td></tr><tr><td class="code"><pre><span class="line">  - openvpn:commons-prod-vpn</span></pre></td></tr></table></figure>

<p><a name="crKdK"></a></p>
<h4 id="扩展阅读资料"><a href="#扩展阅读资料" class="headerlink" title="扩展阅读资料"></a>扩展阅读资料</h4><p><a href="https://www.infoq.cn/article/identity-authentication-of-architecture-in-micro-service" target="_blank" rel="external nofollow noopener noreferrer">深入聊聊微服务架构的身份认证问题</a></p>
]]></content>
      <categories>
        <category>Kubernetes</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>LVM 基本概念</title>
    <url>/post/31e91381.html</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th align="center">Date</th>
<th align="center">Log</th>
</tr>
</thead>
<tbody><tr>
<td align="center">2019/05/28</td>
<td align="center">初始版本.</td>
</tr>
<tr>
<td align="center">2019/09/08</td>
<td align="center">添加逻辑卷扩容.</td>
</tr>
</tbody></table><p><a name="e5729e94"></a></p><h3 id="原文"><a href="#原文" class="headerlink" title="原文"></a>原文</h3><p><a href="https://www.thegeekdiary.com/redhat-centos-a-beginners-guide-to-lvm-logical-volume-manager/" target="_blank" rel="external nofollow noopener noreferrer">RedHat / CentOS : A beginners guide to LVM</a><br></p><p><a name="df368884"></a></p><h3 id="什么是LVM"><a href="#什么是LVM" class="headerlink" title="什么是LVM"></a>什么是LVM</h3><p>逻辑卷管理（LVM）在物理磁盘和文件系统之间引入了额外的一层从而使得文件系统具有了如下特性：</p><a id="more"></a>




<ul>
<li>方便地在线扩容和移动，不需要系统范围的中断</li>
<li>利用磁盘不连续的空间</li>
<li>有含义的卷名取代通常的晦涩的设备名</li>
<li>跨多个物理磁盘</li>
</ul>
<p>Linux LVM 和 HP-UX LVM非常相似，但是提供了更多诸如磁盘快照、集群支持（GFS2、OCFS 和 Lustre）等高级功能。</p>
<p><a name="mLNqS"></a></p>
<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>LVM 包含几项概念上的分层：物理卷（PV）、逻辑卷（LV）和文件系统。<br><img src="https://cdn.nlark.com/yuque/0/2019/png/182657/1559006793676-717ab08e-f951-4f4c-b181-9167f797adb9.png#align=left&display=inline&height=316&name=image.png&originHeight=316&originWidth=260&size=21399&status=done&width=260" alt="image.png"><br>这些分层又由较小的单元组成，例如物理卷由一组PE（Physical Extents）组成、逻辑卷由一组LE（Logical Extents）组成。Extent 在这里指的是组成卷的最小逻辑单元。Extent 在磁盘管理中指的是一些连续的 block，一个 extent 由起始的 block 加上长度进行定义。 Extent 是 btrfs 管理磁盘空间的最小单位，由 extent tree 管理。 Btrfs 分配 data 或 metadata 都需要查询 extent tree 以便获得空闲空间的信息。<br><img src="https://cdn.nlark.com/yuque/0/2019/png/182657/1559008329932-64cc00c4-b926-40f1-be09-d0ab8e0f90d9.png#align=left&display=inline&height=179&name=image.png&originHeight=179&originWidth=563&size=39153&status=done&width=563" alt="image.png"><br><br><br><img src="https://cdn.nlark.com/yuque/0/2019/png/182657/1559007427978-1c2c017c-ab1a-4b34-a21a-55b313d17ac5.png#align=left&display=inline&height=258&name=image.png&originHeight=258&originWidth=671&size=23025&status=done&width=671" alt="image.png"><br></p>
<p><a name="BfIJI"></a></p>
<h4 id="物理卷（PV）"><a href="#物理卷（PV）" class="headerlink" title="物理卷（PV）"></a>物理卷（PV）</h4><p>每个物理卷可以是磁盘分区，整个磁盘，元设备或回环文件。 使用命令 pvcreate 初始化存储空间以供 LVM 使用。 将块设备初始化为物理卷会在设备的开头放置标签。<br><a name="m0nfw"></a></p>
<h4 id="卷组（VG）"><a href="#卷组（VG）" class="headerlink" title="卷组（VG）"></a>卷组（VG）</h4><p>一个卷组将一组逻辑卷和物理卷纳入到一个管理单元。卷组被切分成一组大小固定的 PE。vgcreate 命令使用先前 pvcreate 为 LVM 配置的物理卷路径创建一个卷组。</p>
<ul>
<li>卷组由物理卷构成，物理卷由 PE 构成。不同卷组包含的 PE 大小可以不同，具体是在创建卷组时指定。</li>
<li>PE 的默认大小是 4MB，但是可以在创建 VG 的时候指定不同的值。</li>
<li>一般来讲，PE 大小越大性能越好，逻辑卷的控制粒度也会降低。<br><a name="JvUDh"></a><h4 id="逻辑卷（LV）"><a href="#逻辑卷（LV）" class="headerlink" title="逻辑卷（LV）"></a>逻辑卷（LV）</h4>逻辑卷在概念上和非 LVM 系统中的硬盘分区等价。逻辑卷就是一些在从属于同一卷组的 PE 的基础上创建的块设备。可以使用 lvcreate 命令在某个卷组里创建逻辑卷。<br><a name="9YWaY"></a><h4 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h4>文件系统构建在逻辑卷之上。使用 mkfs 命令可以在基于逻辑卷创建文件系统。文件系统创建完成后就可以根据需要挂载使用。<br><a name="6E788"></a><h3 id="实操"><a href="#实操" class="headerlink" title="实操"></a>实操</h3><a name="Rvesv"></a><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4>接下来的操作中我们将会：</li>
</ul>
<ol>
<li>基于三个物理磁盘（/dev/sdb,/dev/sdc,/dev/sdd）创建三个物理卷。</li>
<li>基于三个物理卷创建一个卷组（/dev/vg01）。</li>
<li>在卷组中创建一个逻辑卷。</li>
<li>在逻辑卷上创建文件系统并且挂载（/data01）。<br><a name="tNiMj"></a><h4 id="创建物理卷"><a href="#创建物理卷" class="headerlink" title="创建物理卷"></a>创建物理卷</h4>使用 pvcreate 命令初始化 LVM 使用的物理卷。在创建物理卷之前需要确保目标磁盘在操作系统中可见。使用 lvmdiskscan 扫描可用于创建物理卷的块设备。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># lvmdiskscan</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">.......</span></pre></td></tr><tr><td class="code"><pre><span class="line">  /dev/sdb   [       2.00 GiB]</span></pre></td></tr><tr><td class="code"><pre><span class="line">  /dev/sdc   [       2.00 GiB]</span></pre></td></tr><tr><td class="code"><pre><span class="line">  /dev/sdd   [       2.00 GiB]</span></pre></td></tr><tr><td class="code"><pre><span class="line">  3 disks</span></pre></td></tr><tr><td class="code"><pre><span class="line">  19 partitions</span></pre></td></tr><tr><td class="code"><pre><span class="line">  0 LVM physical volume whole disks</span></pre></td></tr><tr><td class="code"><pre><span class="line">  0 LVM physical volumes</span></pre></td></tr></table></figure>

<p>初始化块设备：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># pvcreate /dev/sdb /dev/sdc /dev/sdd</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Physical volume <span class="string">"/dev/sdb"</span> successfully created</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Physical volume <span class="string">"/dev/sdc"</span> successfully created</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Physical volume <span class="string">"/dev/sdd"</span> successfully created</span></pre></td></tr></table></figure>

<p>查看物理卷：<br>可以使用 pvdisplay、pvs 和 pvscan 查看刚刚创建的物理卷。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># pvdisplay</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="string">"/dev/sdb"</span> is a new physical volume of <span class="string">"2.00 GiB"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  --- NEW Physical volume ---</span></pre></td></tr><tr><td class="code"><pre><span class="line">  PV Name               /dev/sdb</span></pre></td></tr><tr><td class="code"><pre><span class="line">  VG Name</span></pre></td></tr><tr><td class="code"><pre><span class="line">  PV Size               2.00 GiB</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Allocatable           NO</span></pre></td></tr><tr><td class="code"><pre><span class="line">  PE Size               0</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Total PE              0</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Free PE               0</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Allocated PE          0</span></pre></td></tr><tr><td class="code"><pre><span class="line">  PV UUID               Mt3F7z-a2AV-28Vn-uXe2-QejE-Z6tP-UMlQGM</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="string">"/dev/sdc"</span> is a new physical volume of <span class="string">"2.00 GiB"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  --- NEW Physical volume ---</span></pre></td></tr><tr><td class="code"><pre><span class="line">  PV Name               /dev/sdc</span></pre></td></tr><tr><td class="code"><pre><span class="line">  VG Name</span></pre></td></tr><tr><td class="code"><pre><span class="line">  PV Size               2.00 GiB</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Allocatable           NO</span></pre></td></tr><tr><td class="code"><pre><span class="line">  PE Size               0</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Total PE              0</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Free PE               0</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Allocated PE          0</span></pre></td></tr><tr><td class="code"><pre><span class="line">  PV UUID               5m1Fuc-yTRn-I2vG-bMfU-6SE7-53EA-s8VQjt</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="string">"/dev/sdd"</span> is a new physical volume of <span class="string">"2.00 GiB"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  --- NEW Physical volume ---</span></pre></td></tr><tr><td class="code"><pre><span class="line">  PV Name               /dev/sdd</span></pre></td></tr><tr><td class="code"><pre><span class="line">  VG Name</span></pre></td></tr><tr><td class="code"><pre><span class="line">  PV Size               2.00 GiB</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Allocatable           NO</span></pre></td></tr><tr><td class="code"><pre><span class="line">  PE Size               0</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Total PE              0</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Free PE               0</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Allocated PE          0</span></pre></td></tr><tr><td class="code"><pre><span class="line">  PV UUID               1x3e2A-C0Lt-DrUA-tPSM-lsMu-sn70-qg1j8p</span></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># pvscan</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  PV /dev/sdb                      lvm2 [2.00 GiB]</span></pre></td></tr><tr><td class="code"><pre><span class="line">  PV /dev/sdc                      lvm2 [2.00 GiB]</span></pre></td></tr><tr><td class="code"><pre><span class="line">  PV /dev/sdd                      lvm2 [2.00 GiB]</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Total: 3 [6.00 GiB] / <span class="keyword">in</span> use: 0 [0   ] / <span class="keyword">in</span> no VG: 3 [6.00 GiB]</span></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># pvs</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  PV         VG   Fmt  Attr PSize PFree</span></pre></td></tr><tr><td class="code"><pre><span class="line">  /dev/sdb        lvm2 a--  2.00g 2.00g</span></pre></td></tr><tr><td class="code"><pre><span class="line">  /dev/sdc        lvm2 a--  2.00g 2.00g</span></pre></td></tr><tr><td class="code"><pre><span class="line">  /dev/sdd        lvm2 a--  2.00g 2.00g</span></pre></td></tr></table></figure>

<p><a name="UUsml"></a></p>
<h4 id="创建卷组"><a href="#创建卷组" class="headerlink" title="创建卷组"></a>创建卷组</h4><p>使用 vgcreate 命令创建新的卷组 vg01，卷组用到了刚刚创建的三个PV。使用通过传入 -s 参数指定 PE 的大小、传入 -p 指定 PV 的最大数量、传入 -I 指定 LV 的最大数量。这些参数都是可选项。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># vgcreate vg01 /dev/sdb /dev/sdc /dev/sdd</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Volume group <span class="string">"vg01"</span> successfully created</span></pre></td></tr></table></figure>

<p>pvcreate 命令可选参数列表如下：</p>
<table>
<thead>
<tr>
<th align="left">Option</th>
<th align="left">Meaning</th>
</tr>
</thead>
<tbody><tr>
<td align="left">-s</td>
<td align="left">Physical extent size</td>
</tr>
<tr>
<td align="left">-p</td>
<td align="left">Max number of PVs</td>
</tr>
<tr>
<td align="left">-l</td>
<td align="left">Max number of LVs</td>
</tr>
<tr>
<td align="left">–alloc</td>
<td align="left">allocation policy (either contiguous, anywhere, or cling)</td>
</tr>
</tbody></table>
<p>使用 vgs 和 vgdisplay 命令可以查看卷组信息：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># vgs vg01</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  VG   <span class="comment">#PV #LV #SN Attr   VSize VFree</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  vg01   3   0   0 wz--n- 5.99g 5.99g</span></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># vgdisplay vg01</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  --- Volume group ---</span></pre></td></tr><tr><td class="code"><pre><span class="line">  VG Name               vg01</span></pre></td></tr><tr><td class="code"><pre><span class="line">  System ID</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Format                lvm2</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Metadata Areas        3</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Metadata Sequence No  1</span></pre></td></tr><tr><td class="code"><pre><span class="line">  VG Access             <span class="built_in">read</span>/write</span></pre></td></tr><tr><td class="code"><pre><span class="line">  VG Status             resizable</span></pre></td></tr><tr><td class="code"><pre><span class="line">  MAX LV                0</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Cur LV                0</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Open LV               0</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Max PV                0</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Cur PV                3</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Act PV                3</span></pre></td></tr><tr><td class="code"><pre><span class="line">  VG Size               5.99 GiB</span></pre></td></tr><tr><td class="code"><pre><span class="line">  PE Size               4.00 MiB</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Total PE              1533</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Alloc PE / Size       0 / 0</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Free  PE / Size       1533 / 5.99 GiB</span></pre></td></tr><tr><td class="code"><pre><span class="line">  VG UUID               Cw7GGz-NH3o-Sax2-5jPv-buZS-938T-tmNKFa</span></pre></td></tr></table></figure>

<p>使用 vgchange 命令可以 activate/deactivate 卷组。<br>激活卷组：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># vgchange -a n vg01</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  0 logical volume(s) <span class="keyword">in</span> volume group <span class="string">"vg01"</span> now active</span></pre></td></tr></table></figure>

<p>停用卷组：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># vgchange -a y vg01</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  1 logical volume(s) <span class="keyword">in</span> volume group <span class="string">"vg01"</span> now active</span></pre></td></tr></table></figure>

<p><a name="F4bvs"></a></p>
<h4 id="创建逻辑卷"><a href="#创建逻辑卷" class="headerlink" title="创建逻辑卷"></a>创建逻辑卷</h4><p>使用 lvcreate 命令在卷组中创建逻辑卷。</p>
<ul>
<li>如果在创建逻辑卷时未指定卷名，默认卷名是 lvol#，#代表逻辑卷序号。</li>
<li>一般来讲，如果在创建逻辑卷时不指定所用物理卷，逻辑卷会在紧邻当前位置的下一个可用 PV 上创建。</li>
</ul>
<p>创建一个 5GB 大小的名称为 lvol01 的逻辑卷：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># lvcreate -L 5G -n lvol01 vg01</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Logical volume <span class="string">"lvol01"</span> created</span></pre></td></tr></table></figure>

<p>创建一个 stripped 卷，通过以下命令创建一个跨越三个物理卷的 stripped 逻辑卷：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># lvcreate -L 5G -I 4096 -i 3 -n lvol01 vg01</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Rounding size (1280 extents) up to stripe boundary size (1281 extents)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Logical volume <span class="string">"lvol01"</span> created</span></pre></td></tr></table></figure>

<p>lvcreate 命令的部分参数说明如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">I - PVs to span <span class="keyword">while</span> creating striped volume</span></pre></td></tr><tr><td class="code"><pre><span class="line">i - stripe unit</span></pre></td></tr></table></figure>

<p>创建 mirrored 卷，使用如下命令创建一个跨越三个物理卷的含有三路镜像的卷：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># lvcreate -L 1G -m 2 -n lvol01 vg01</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Logical volume <span class="string">"lvol01"</span> created</span></pre></td></tr></table></figure>
<p>在创建镜像逻辑卷时可以指定使用哪些物理卷，这里卷组中只有三个物理卷，所以默认逻辑卷默认在这三个物理卷上创建。</p>
<p>查看逻辑卷<br>可以使用 lvdisplay、lvs 和 lvscan 命令查看创建的逻辑卷：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># lvs /dev/vg01/lvol01</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  LV     VG   Attr      LSize Pool Origin Data%  Move Log         Cpy%Sync Convert</span></pre></td></tr><tr><td class="code"><pre><span class="line">  lvol01 vg01 mwi<span class="_">-a</span>-m-- 1.00g                         lvol01_mlog   100.00</span></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># lvdisplay /dev/vg01/lvol01</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  --- Logical volume ---</span></pre></td></tr><tr><td class="code"><pre><span class="line">  LV Path                /dev/vg01/lvol01</span></pre></td></tr><tr><td class="code"><pre><span class="line">  LV Name                lvol01</span></pre></td></tr><tr><td class="code"><pre><span class="line">  VG Name                vg01</span></pre></td></tr><tr><td class="code"><pre><span class="line">  LV UUID                ptlmAV-mO42-fWiJ-e2Ml-r9kj-PFcC-MOexxw</span></pre></td></tr><tr><td class="code"><pre><span class="line">  LV Write Access        <span class="built_in">read</span>/write</span></pre></td></tr><tr><td class="code"><pre><span class="line">  LV Creation host, time localhost.localdomain, 2014-10-22 09:04:25 -0700</span></pre></td></tr><tr><td class="code"><pre><span class="line">  LV Status              available</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment"># open                 0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  LV Size                1.00 GiB</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Current LE             256</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Mirrored volumes       3</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Segments               1</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Allocation             inherit</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Read ahead sectors     auto</span></pre></td></tr><tr><td class="code"><pre><span class="line">  - currently <span class="built_in">set</span> to     256</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Block device           253:4</span></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># lvscan</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  ACTIVE            <span class="string">'/dev/vg01/lvol01'</span> [1.00 GiB] inherit</span></pre></td></tr></table></figure>

<p><a name="MLjmc"></a></p>
<h4 id="创建文件系统"><a href="#创建文件系统" class="headerlink" title="创建文件系统"></a>创建文件系统</h4><p>最后一步是在刚刚创建好的逻辑卷上创建文件系统并将其挂载到系统目录从而能够访问它并且存储数据。使用 mkfs 命令在逻辑卷上创建文件系统。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># mkfs.ext4 /dev/vg01/lvol01</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">mke2fs 1.41.12 (17-May-2010)</span></pre></td></tr><tr><td class="code"><pre><span class="line">Filesystem label=</span></pre></td></tr><tr><td class="code"><pre><span class="line">OS <span class="built_in">type</span>: Linux</span></pre></td></tr><tr><td class="code"><pre><span class="line">Block size=4096 (<span class="built_in">log</span>=2)</span></pre></td></tr><tr><td class="code"><pre><span class="line">Fragment size=4096 (<span class="built_in">log</span>=2)</span></pre></td></tr><tr><td class="code"><pre><span class="line">Stride=0 blocks, Stripe width=0 blocks</span></pre></td></tr><tr><td class="code"><pre><span class="line">65536 inodes, 262144 blocks</span></pre></td></tr><tr><td class="code"><pre><span class="line">13107 blocks (5.00%) reserved <span class="keyword">for</span> the super user</span></pre></td></tr><tr><td class="code"><pre><span class="line">First data block=0</span></pre></td></tr><tr><td class="code"><pre><span class="line">Maximum filesystem blocks=268435456</span></pre></td></tr><tr><td class="code"><pre><span class="line">8 block groups</span></pre></td></tr><tr><td class="code"><pre><span class="line">32768 blocks per group, 32768 fragments per group</span></pre></td></tr><tr><td class="code"><pre><span class="line">8192 inodes per group</span></pre></td></tr><tr><td class="code"><pre><span class="line">Superblock backups stored on blocks:</span></pre></td></tr><tr><td class="code"><pre><span class="line">	32768, 98304, 163840, 229376</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">Writing inode tables: <span class="keyword">done</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Creating journal (8192 blocks): <span class="keyword">done</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Writing superblocks and filesystem accounting information: <span class="keyword">done</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">This filesystem will be automatically checked every 37 mounts or</span></pre></td></tr><tr><td class="code"><pre><span class="line">180 days, whichever comes first.  Use tune2fs -c or -i to override.</span></pre></td></tr></table></figure>

<p>文件系统创建完成后，相应的逻辑卷就可以用来挂载了。请确保在 /etc/fstab 文件中添加相应的条目，然后在系统启动时就可以自动挂载逻辑卷到相应的目录了。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># mkdir /data01</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># mount /dev/vg01/lvol01 /data01</span></span></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># vi /etc/fstab</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">/dev/vg01/lvol01	/data01			ext4	defaults	0 0</span></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># df -h /data01</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Filesystem                   Size  Used  Avail  Use%  Mounted on</span></pre></td></tr><tr><td class="code"><pre><span class="line">/dev/mapper/vg01-lvol01     1008M   34M  924M   4%    /data01</span></pre></td></tr></table></figure>

<p>使用带 GUI 的工具管理 LVM<br>如果你想使用图形化界面管理 LVM，推荐 system-config-lvm。 使用以下命令进行安装：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># yum install system-config-lvm</span></span></pre></td></tr></table></figure>

<p>执行以下命令启动：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">system-config-lvm</span></pre></td></tr></table></figure>

<p><img src="https://cdn.nlark.com/yuque/0/2019/png/182657/1559628183097-f4e684b1-2ab3-432d-b062-075ed84278f4.png#align=left&display=inline&height=568&name=image.png&originHeight=568&originWidth=970&size=83085&status=done&width=970" alt="image.png"><br></p>
<ul>
<li>逻辑卷扩容</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 扩容到 12G</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">lvextend -L12G /dev/vg01/lvol01</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 容量增加 1G</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">lvextend -L+1G /dev/vg01/lvol01</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 占用 vg 所有剩余空间</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">lvextend -l +100%FREE /dev/vg01/lvol01</span></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>译文</category>
      </categories>
      <tags>
        <tag>译文</tag>
        <tag>LVM</tag>
      </tags>
  </entry>
  <entry>
    <title>Proxmox 使用拾遗</title>
    <url>/post/399a617a.html</url>
    <content><![CDATA[<p><a name="BdT88"></a></p><h4 id="zfs-destroy-提示-dataset-is-busy"><a href="#zfs-destroy-提示-dataset-is-busy" class="headerlink" title="zfs destroy 提示 dataset is busy"></a>zfs destroy 提示 dataset is busy</h4><p>报错如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@umstor22:~<span class="comment"># zfs destroy -r umstor22-zfs</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">cannot destroy <span class="string">'umstor22-zfs/vm-109-disk-0'</span>: dataset is busy</span></pre></td></tr><tr><td class="code"><pre><span class="line">cannot destroy <span class="string">'umstor22-zfs/vm-109-disk-2'</span>: dataset is busy</span></pre></td></tr><tr><td class="code"><pre><span class="line">cannot destroy <span class="string">'umstor22-zfs/vm-109-disk-1'</span>: dataset is busy</span></pre></td></tr></table></figure><a id="more"></a>



<p>首先使用 fuser 查看挂载了相关虚拟设备的进程：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@umstor22:~<span class="comment"># fuser -am /dev/umstor22-zfs/vm-109-disk-0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">/dev/zd0:            2133532</span></pre></td></tr><tr><td class="code"><pre><span class="line">root@umstor22:~<span class="comment"># fuser -am /dev/umstor22-zfs/vm-109-disk-1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">/dev/zd16:           2133532</span></pre></td></tr><tr><td class="code"><pre><span class="line">root@umstor22:~<span class="comment"># fuser -am /dev/umstor22-zfs/vm-109-disk-2</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">/dev/zd32:           2133532</span></pre></td></tr></table></figure>

<p>然后查看进程号为 2133532 的进程信息：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@umstor22:~<span class="comment"># ps aux | grep 2133532</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">root     1832619  0.0  0.0   6072   892 pts/0    S+   11:41   0:00 grep 2133532</span></pre></td></tr><tr><td class="code"><pre><span class="line">root     2133532  3.2  0.1 9705992 105132 ?      Sl   Sep02  42:19 /usr/bin/kvm -id 109 -name yf01 -chardev socket,id=qmp,path=/var/run/qemu-server/109.qmp,server,nowait -mon chardev=qmp,mode=control -chardev socket,id=qmp-event,path=/var/run/qmeventd.sock,reconnect=5 -mon chardev=qmp-event,mode=control -pidfile /var/run/qemu-server/109.pid -daemonize -smbios <span class="built_in">type</span>=1,uuid=3969d5bf-1597-4834-ac82-bc89de18495a -smp 8,sockets=2,cores=4,maxcpus=8 -nodefaults -boot menu=on,strict=on,reboot-timeout=1000,splash=/usr/share/qemu-server/bootsplash.jpg -vnc unix:/var/run/qemu-server/109.vnc,password -cpu kvm64,+lahf_lm,+sep,+kvm_pv_unhalt,+kvm_pv_eoi,enforce -m 8192 -device pci-bridge,id=pci.1,chassis_nr=1,bus=pci.0,addr=0x1e -device pci-bridge,id=pci.2,chassis_nr=2,bus=pci.0,addr=0x1f -device vmgenid,guid=b917480a-d4f1-4d4d-869e-632b6a9d7769 -device piix3-usb-uhci,id=uhci,bus=pci.0,addr=0x1.0x2 -device usb-tablet,id=tablet,bus=uhci.0,port=1 -device VGA,id=vga,bus=pci.0,addr=0x2 -chardev socket,path=/var/run/qemu-server/109.qga,server,nowait,id=qga0 -device virtio-serial,id=qga0,bus=pci.0,addr=0x8 -device virtserialport,chardev=qga0,name=org.qemu.guest_agent.0 -device virtio-balloon-pci,id=balloon0,bus=pci.0,addr=0x3 -iscsi initiator-name=iqn.1993-08.org.debian:01:c024a4d1a487 -drive file=rbd:cloud-disk/vm-109-cloudinit:conf=/etc/pve/ceph.conf:id=admin:keyring=/etc/pve/priv/ceph/ceph.keyring,<span class="keyword">if</span>=none,id=drive-ide0,media=cdrom,aio=threads -device ide-cd,bus=ide.0,unit=0,drive=drive-ide0,id=ide0,bootindex=200 -device virtio-scsi-pci,id=scsihw0,bus=pci.0,addr=0x5 -drive file=/dev/zvol/umstor22-zfs/vm-109-disk-0,<span class="keyword">if</span>=none,id=drive-scsi0,format=raw,cache=none,aio=native,detect-zeroes=on -device scsi-hd,bus=scsihw0.0,channel=0,scsi-id=0,lun=0,drive=drive-scsi0,id=scsi0,bootindex=100 -drive file=/dev/zvol/umstor22-zfs/vm-109-disk-1,<span class="keyword">if</span>=none,id=drive-scsi1,format=raw,cache=none,aio=native,detect-zeroes=on -device scsi-hd,bus=scsihw0.0,channel=0,scsi-id=0,lun=1,drive=drive-scsi1,id=scsi1 -drive file=/dev/zvol/umstor22-zfs/vm-109-disk-2,<span class="keyword">if</span>=none,id=drive-scsi2,format=raw,cache=none,aio=native,detect-zeroes=on -device scsi-hd,bus=scsihw0.0,channel=0,scsi-id=0,lun=2,drive=drive-scsi2,id=scsi2 -drive file=rbd:cloud-disk/vm-109-disk-0:conf=/etc/pve/ceph.conf:id=admin:keyring=/etc/pve/priv/ceph/ceph.keyring,<span class="keyword">if</span>=none,id=drive-scsi3,format=raw,cache=none,aio=native,detect-zeroes=on -device scsi-hd,bus=scsihw0.0,channel=0,scsi-id=0,lun=3,drive=drive-scsi3,id=scsi3 -drive file=rbd:cloud-disk/vm-109-disk-2:conf=/etc/pve/ceph.conf:id=admin:keyring=/etc/pve/priv/ceph/ceph.keyring,<span class="keyword">if</span>=none,id=drive-scsi4,format=raw,cache=none,aio=native,detect-zeroes=on -device scsi-hd,bus=scsihw0.0,channel=0,scsi-id=0,lun=4,drive=drive-scsi4,id=scsi4 -drive file=rbd:cloud-disk/vm-109-disk-5:conf=/etc/pve/ceph.conf:id=admin:keyring=/etc/pve/priv/ceph/ceph.keyring,<span class="keyword">if</span>=none,id=drive-scsi5,format=raw,cache=none,aio=native,detect-zeroes=on -device scsi-hd,bus=scsihw0.0,channel=0,scsi-id=0,lun=5,drive=drive-scsi5,id=scsi5 -netdev <span class="built_in">type</span>=tap,id=net0,ifname=tap109i0,script=/var/lib/qemu-server/pve-bridge,downscript=/var/lib/qemu-server/pve-bridgedown,vhost=on -device virtio-net-pci,mac=1A:D3:33:5C:92:DF,netdev=net0,bus=pci.0,addr=0x12,id=net0,bootindex=300 -machine <span class="built_in">type</span>=pc-i440fx-4.0 -incoming unix:/run/qemu-server/109.migrate -S</span></pre></td></tr></table></figure>

<p>可知，该进程为一个 kvm 虚拟机的进程，杀掉进程后重新执行 destroy 即可：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">kill</span> -9 2133532</span></pre></td></tr><tr><td class="code"><pre><span class="line">zfs destroy -r umstor22-zfs</span></pre></td></tr><tr><td class="code"><pre><span class="line">zpool destroy umstor22-zfs</span></pre></td></tr></table></figure>

<ul>
<li>vm is locked</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">qm unlock 101</span></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>Proxmox</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Proxmox</tag>
      </tags>
  </entry>
  <entry>
    <title>基于 CentOS Minimal 镜像制作 Docker Base Image</title>
    <url>/post/8a546874.html</url>
    <content><![CDATA[<p><a name="BdT88"></a></p><h4 id="使用镜像安装-centos-虚拟机"><a href="#使用镜像安装-centos-虚拟机" class="headerlink" title="使用镜像安装 centos 虚拟机"></a>使用镜像安装 centos 虚拟机</h4><p>使用 VirtualBox、VMware workstation 或者 Proxmox 等虚拟机管理平台创建虚拟机，在这里我使用 Proxmox 创建虚拟机。由于我们只是为了制作 Docker Base Image，虚拟机用完即删，给虚拟机分配的资源可随意配置。下图是我创建的虚拟机基本配置： </p><a id="more"></a>

<p><img src="https://cdn.nlark.com/yuque/0/2019/png/182657/1567131557233-c3e8da2b-10a6-495a-9805-fcb2f3683b77.png#align=left&display=inline&height=710&name=WX20190830-101825%402x.png&originHeight=710&originWidth=1438&size=138442&status=done&width=1438" alt="WX20190830-101825@2x.png"></p>
<p>这里使用 CentOS 7 1804 的 ISO 镜像安装虚拟机操作系统，安装系统的过程不再赘述，按照正常安装步骤操作即可。这里使用这个版本的操作系统镜像是因为我们自己的软件包都是基于这个版本的 centos 制作的，我需要这个版本的基础镜像通过安装这些软件包制作最后的工作镜像。读者可以根据自己的需要选择不同操作系统不同的版本。<br><a name="r33Tf"></a></p>
<h4 id="制作基础镜像"><a href="#制作基础镜像" class="headerlink" title="制作基础镜像"></a>制作基础镜像</h4><ul>
<li>配置网络（按需）</li>
</ul>
<p>如果你的网络是通过DHCP配置的这一步不需要，只需要检查一下能否联网并正常解析域名即可。否则，可能需要手动配置网络，具体 IP 地址根据自己的网络情况选择：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ip a add 192.168.180.150/24 dev eth0</span></pre></td></tr><tr><td class="code"><pre><span class="line">ip r default via 192.168.180.254 dev eth0</span></pre></td></tr></table></figure>

<p>另外设置一下 dns nameserver：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat /etc/resolv.conf</span></pre></td></tr><tr><td class="code"><pre><span class="line">nameserver 192.168.180.42</span></pre></td></tr></table></figure>

<ul>
<li>安装 docker-ce</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install -y yum-utils device-mapper-persistent-data lvm2</span></pre></td></tr><tr><td class="code"><pre><span class="line">yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo</span></pre></td></tr><tr><td class="code"><pre><span class="line">yum install -y docker-ce docker-ce-cli containerd.io</span></pre></td></tr><tr><td class="code"><pre><span class="line">systemctl <span class="built_in">enable</span> --now docker</span></pre></td></tr></table></figure>

<ul>
<li>获取制作脚本</li>
</ul>
<p>制作脚本从Moby项目获取，具体地址： <a href="https://github.com/moby/moby/tree/master/contrib" target="_blank" rel="external nofollow noopener noreferrer">https://github.com/moby/moby/tree/master/contrib</a>，读者可根据自己的需要下载针对不同操作系统的制作脚本，这里使用 mkimage-yum.sh。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install -y wget</span></pre></td></tr><tr><td class="code"><pre><span class="line">wget https://raw.githubusercontent.com/moby/moby/master/contrib/mkimage-yum.sh</span></pre></td></tr><tr><td class="code"><pre><span class="line">chmod +x mkimage-yum.sh</span></pre></td></tr></table></figure>

<ul>
<li>制作基础镜像</li>
</ul>
<p>执行以下脚本进行制作：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./mkimage-yum.sh centos</span></pre></td></tr></table></figure>

<p>制作完成后：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2019/png/182657/1567133343307-c8b7d86e-9a50-48ac-bfa8-d21c79e26c8c.png#align=left&display=inline&height=108&name=WX20190830-101825%402x.png&originHeight=108&originWidth=1662&size=30100&status=done&width=1662" alt="WX20190830-101825@2x.png"></p>
<p>然后就可以推送到内部镜像仓库中，并作为基础镜像来使用。</p>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>为 Proxmox 制作包含 cloud-init 的虚拟机模板</title>
    <url>/post/6c44975c.html</url>
    <content><![CDATA[<p><a name="WsMUi"></a></p><h4 id="安装-Centos"><a href="#安装-Centos" class="headerlink" title="安装 Centos"></a>安装 Centos</h4><p>在我搭建的 Proxmox 平台中使用了 Ceph 作为虚拟机的后端存储，为了提高虚拟机磁盘性能，在安装虚拟机的时候使用 LVM raid0 逻辑分区挂载根目录。</p><ul>
<li>在 install destination 中选中三块盘并勾选自行分区选项</li>
</ul><p><img src="https://cdn.nlark.com/yuque/0/2019/png/182657/1565763386484-e5ca7b70-8be9-4748-a45b-729056006387.png#align=left&display=inline&height=690&name=image.png&originHeight=690&originWidth=1038&size=159786&status=done&width=1038" alt="image.png"></p><ul>
<li>点击 automatically create lvm partition 自动创建分区，删除其它分区只保留 /boot 分区</li>
</ul><a id="more"></a>




<p><img src="https://cdn.nlark.com/yuque/0/2019/png/182657/1565763580611-942dc4e2-6db4-4dc3-8f80-8c34786c5b08.png#align=left&display=inline&height=751&name=image.png&originHeight=751&originWidth=1043&size=125930&status=done&width=1043" alt="image.png"></p>
<ul>
<li>点击 + 按钮添加新的分区，挂载点为根路径，容量超过磁盘最大容量，安装程序会自动校正到真实的最大可用容量。</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2019/png/182657/1565763613900-3375e62f-af48-4a23-a3c2-75d5883a1ce2.png#align=left&display=inline&height=769&name=image.png&originHeight=769&originWidth=1026&size=121666&status=done&width=1026" alt="image.png"></p>
<ul>
<li>点击 Modify 按钮修改新建分区的 RAID Level 为 RAID0。</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2019/png/182657/1565763651682-d3ed9a9e-6388-4d4f-802a-09929eaab7af.png#align=left&display=inline&height=769&name=image.png&originHeight=769&originWidth=1041&size=165004&status=done&width=1041" alt="image.png"></p>
<ul>
<li>以下是创建完成的分区，保存后按照常规步骤继续安装操作系统。</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2019/png/182657/1565763668133-da5c4ce4-c19a-493c-b20d-fa91ac1c38f9.png#align=left&display=inline&height=733&name=image.png&originHeight=733&originWidth=1020&size=132613&status=done&width=1020" alt="image.png"></p>
<p><a name="0dMBI"></a></p>
<h4 id="调整安装好的操作系统"><a href="#调整安装好的操作系统" class="headerlink" title="调整安装好的操作系统"></a>调整安装好的操作系统</h4><ul>
<li>进入操作系统，首先关闭 selinux、firewalld 和 NetworkManager。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl <span class="built_in">disable</span> --now firewalld NetworkManager</span></pre></td></tr><tr><td class="code"><pre><span class="line">setenforce 0</span></pre></td></tr><tr><td class="code"><pre><span class="line">sed -ri <span class="string">'/^[^#]*SELINUX=/s#=.+$#=disabled#'</span> /etc/selinux/config</span></pre></td></tr></table></figure>

<ul>
<li>安装acpid cloud-init cloud-utils-growpart</li>
</ul>
<p>apcid 是为了可以使 kvm 可以关闭和重启虚拟机，qemu-guest-agent 使得 Proxmox 可以获取虚拟机的 IP 等信息。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install -y acpid cloud-init cloud-utils-growpart qemu-guest-agent</span></pre></td></tr><tr><td class="code"><pre><span class="line">systemctl <span class="built_in">enable</span> acpid </span></pre></td></tr><tr><td class="code"><pre><span class="line">systemctl <span class="built_in">enable</span> qemu-guest-agent</span></pre></td></tr></table></figure>


<ul>
<li>禁用默认zeroconf路线</li>
</ul>
<p>当系统无法连接DHCP server的时候，就会尝试通过ZEROCONF来获取IP,并添加一条169.254.0.0/16的路由条目。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"NOZEROCONF=yes"</span> &gt;&gt; /etc/sysconfig/network</span></pre></td></tr></table></figure>

<ul>
<li>修改sshd不使用dns防止ssh连接慢</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sed -ri <span class="string">'/UseDNS/&#123;s@#@@;s@\s+.+@ no@&#125;'</span> /etc/ssh/sshd_config</span></pre></td></tr><tr><td class="code"><pre><span class="line">systemctl restart sshd</span></pre></td></tr></table></figure>

<ul>
<li>修改 cloud-init 配置</li>
</ul>
<p>分别是允许 root 登录，允许使用 password 登录，禁止第一次开机自动更新系统。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sed -ri <span class="string">'/disable_root/&#123;s#\S$#0#&#125;'</span> /etc/cloud/cloud.cfg</span></pre></td></tr><tr><td class="code"><pre><span class="line">sed -ri <span class="string">'/ssh_pwauth/&#123;s#\S$#1#&#125;'</span> /etc/cloud/cloud.cfg</span></pre></td></tr><tr><td class="code"><pre><span class="line">sed -ri <span class="string">'/package-update/s@^@#@'</span> /etc/cloud/cloud.cfg</span></pre></td></tr></table></figure>

<ul>
<li>如有需要可以自行添加一些额外的配置</li>
</ul>
<p>我在 /sbin/ifup-local 中添加了如下配置用于配置特殊的路由以适应办公室网络环境。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">touch /sbin/ifup-local</span></pre></td></tr><tr><td class="code"><pre><span class="line">chmod +x /sbin/ifup-local</span></pre></td></tr><tr><td class="code"><pre><span class="line">cat /sbin/ifup-local</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">ip r add 192.168.76.0/24 via 192.168.180.254</span></pre></td></tr><tr><td class="code"><pre><span class="line">ip r add 192.168.77.0/24 via 192.168.180.254</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">exit</span> 0</span></pre></td></tr></table></figure>


<ul>
<li>关机，并在 Proxmox 中为之添加 CloudInit Drive。</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2019/png/182657/1565765481819-2158abbc-ff3a-4f5e-870f-40f545b0acd1.png#align=left&display=inline&height=633&name=image.png&originHeight=633&originWidth=719&size=92450&status=done&width=719" alt="image.png"></p>
<ul>
<li>填写相关 init 参数并 regenerate image。</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2019/png/182657/1565765613783-81f32306-e298-4d18-a553-128415466232.png#align=left&display=inline&height=388&name=image.png&originHeight=388&originWidth=533&size=35717&status=done&width=533" alt="image.png"></p>
<ul>
<li>启用 qemu-agent</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2019/png/182657/1565768472227-62c14d9c-88ec-47dd-b030-841d773cef94.png#align=left&display=inline&height=645&name=image.png&originHeight=645&originWidth=720&size=68736&status=done&width=720" alt="image.png"></p>
<ul>
<li>将虚拟机转为模板，之后就可以以此为基础创建新的虚拟机。<br><a name="btgSa"></a><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><a href="https://zhangguanzhang.github.io/2019/01/22/proxmox-cloud-init/" target="_blank" rel="external nofollow noopener noreferrer">proxmox里使用cloud-init和一些笔记</a></li>
</ul>
]]></content>
      <categories>
        <category>Proxmox</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag> 云计算</tag>
        <tag>Proxmox</tag>
        <tag>虚拟机</tag>
      </tags>
  </entry>
  <entry>
    <title>IPVS 模式下 NodePort 的工作过程浅析</title>
    <url>/post/4c49613e.html</url>
    <content><![CDATA[<p><a name="lfAlR"></a></p><h3 id><a href="#" class="headerlink" title></a></h3>]]></content>
      <categories>
        <category>Kubernetes</category>
      </categories>
      <tags>
        <tag>kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>Centos 编译安装 zfs</title>
    <url>/post/dc552b49.html</url>
    <content><![CDATA[<ul>
<li><p>安装依赖</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum groupinstall <span class="string">"Development Tools"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">yum install zlib-devel libuuid-devel libattr-devel libblkid-devel libselinux-devel libudev-devel</span></pre></td></tr><tr><td class="code"><pre><span class="line">yum install parted lsscsi ksh openssl-devel elfutils-libelf-devel</span></pre></td></tr><tr><td class="code"><pre><span class="line">yum install kernel-devel-$(uname -r)</span></pre></td></tr></table></figure>
</li>
<li><p>从<a href="https://github.com/zfsonlinux/zfs/releases" target="_blank" rel="external nofollow noopener noreferrer">这里</a>下载源代码并解压</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://github.com/zfsonlinux/zfs/releases/download/zfs-0.8.1/zfs-0.8.1.tar.gz &amp;&amp; tar zxf zfs-0.8.1.tar.gz</span></pre></td></tr></table></figure>
</li>
<li><p>编译安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ../zfs-0.8.1</span></pre></td></tr><tr><td class="code"><pre><span class="line">sh autogen.sh</span></pre></td></tr><tr><td class="code"><pre><span class="line">./configure</span></pre></td></tr><tr><td class="code"><pre><span class="line">make -s -j$(nproc)</span></pre></td></tr><tr><td class="code"><pre><span class="line">make install</span></pre></td></tr></table></figure>
</li>
<li><p>重启系统</p>
</li>
</ul>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Centos</tag>
        <tag>存储</tag>
      </tags>
  </entry>
  <entry>
    <title>树莓派 3B 编译安装 zfs</title>
    <url>/post/6adad945.html</url>
    <content><![CDATA[<ul>
<li><p>安装依赖</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt remove 3.6-trunk-rpi</span></pre></td></tr><tr><td class="code"><pre><span class="line">sudo apt update</span></pre></td></tr><tr><td class="code"><pre><span class="line">sudo apt install build-essential autoconf libtool gawk alien fakeroot</span></pre></td></tr><tr><td class="code"><pre><span class="line">sudo apt install dkms zlib1g-dev uuid-dev libattr1-dev libblkid-dev libselinux-dev libudev-dev libssl-dev parted lsscsi wget ksh</span></pre></td></tr><tr><td class="code"><pre><span class="line">sudo apt install python3-dev python3-setuptools python3-cffi</span></pre></td></tr></table></figure>
</li>
<li><p>安装内核头文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt upgrade raspberrypi-kernel raspberrypi-kernel-headers</span></pre></td></tr></table></figure>
</li>
<li><p>从<a href="https://github.com/zfsonlinux/zfs/releases" target="_blank" rel="external nofollow noopener noreferrer">这里</a>下载源代码并解压</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://github.com/zfsonlinux/zfs/releases/download/zfs-0.8.1/zfs-0.8.1.tar.gz &amp;&amp; tar zxf zfs-0.8.1.tar.gz</span></pre></td></tr></table></figure>
</li>
<li><p>编译安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ../zfs-0.8.1</span></pre></td></tr><tr><td class="code"><pre><span class="line">autoreconf --install --force</span></pre></td></tr><tr><td class="code"><pre><span class="line">./configure --with-config=srpm</span></pre></td></tr><tr><td class="code"><pre><span class="line">sed -E <span class="string">'s/(^RPMBUILD = rpmbuild.*)/\1 --target=armhf/'</span> -i Makefile</span></pre></td></tr><tr><td class="code"><pre><span class="line">make pkg-utils deb-dkms</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> deb <span class="keyword">in</span> *.deb; <span class="keyword">do</span> sudo dpkg -i <span class="string">"<span class="variable">$deb</span>"</span>; <span class="keyword">done</span></span></pre></td></tr></table></figure>
</li>
<li><p>重启系统</p>
</li>
</ul>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>存储</tag>
        <tag>树莓派</tag>
      </tags>
  </entry>
  <entry>
    <title>Keepalived 和 Kubeadm 部署高可用 Kubernetes</title>
    <url>/post/c9063311.html</url>
    <content><![CDATA[<p><a name="df368884"></a></p><h3 id="准备-k8s-离线安装包"><a href="#准备-k8s-离线安装包" class="headerlink" title="准备 k8s 离线安装包"></a>准备 k8s 离线安装包</h3><p>在 k8s Github 仓库的 <a href="https://github.com/kubernetes/kubernetes/releases" target="_blank" rel="external nofollow noopener noreferrer">Release 页面</a> 找到最新稳定版本，点击对应的如  <a href="https://github.com/kubernetes/kubernetes/blob/master/CHANGELOG-1.14.md#downloads-for-v1142" target="_blank" rel="external nofollow noopener noreferrer">CHANGELOG-1.14.md</a> 链接进入该版本的安装包下载页面。分别下载 AMD64 版本的 Server 和 Node 安装包 <a href="https://dl.k8s.io/v1.14.2/kubernetes-server-linux-amd64.tar.gz" target="_blank" rel="external nofollow noopener noreferrer">kubernetes-server-linux-amd64.tar.gz</a> 与 <a href="https://dl.k8s.io/v1.14.2/kubernetes-node-linux-amd64.tar.gz" target="_blank" rel="external nofollow noopener noreferrer">kubernetes-node-linux-amd64.tar.gz</a>。然后使用 tar 命令解压缩并将所有文件汇总到一个集中的目录，如下，其中 coredns、etcd 和 pause 的镜像不包含在上述两个压缩包中，需要自行下载：</p><a id="more"></a>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#tree -L 2 kubernetes-1.14.2</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">kubernetes-1.14.2</span></pre></td></tr><tr><td class="code"><pre><span class="line">├── apiextensions-apiserver</span></pre></td></tr><tr><td class="code"><pre><span class="line">├── cloud-controller-manager</span></pre></td></tr><tr><td class="code"><pre><span class="line">├── hyperkube</span></pre></td></tr><tr><td class="code"><pre><span class="line">├── images</span></pre></td></tr><tr><td class="code"><pre><span class="line">│   ├── cloud-controller-manager.tar</span></pre></td></tr><tr><td class="code"><pre><span class="line">│   ├── coredns.tar</span></pre></td></tr><tr><td class="code"><pre><span class="line">│   ├── etcd.tar</span></pre></td></tr><tr><td class="code"><pre><span class="line">│   ├── kube-apiserver.tar</span></pre></td></tr><tr><td class="code"><pre><span class="line">│   ├── kube-controller-manager.tar</span></pre></td></tr><tr><td class="code"><pre><span class="line">│   ├── kube-proxy.tar</span></pre></td></tr><tr><td class="code"><pre><span class="line">│   ├── kube-scheduler.tar</span></pre></td></tr><tr><td class="code"><pre><span class="line">│   └── pause.tar</span></pre></td></tr><tr><td class="code"><pre><span class="line">├── kubeadm</span></pre></td></tr><tr><td class="code"><pre><span class="line">├── kube-apiserver</span></pre></td></tr><tr><td class="code"><pre><span class="line">├── kube-controller-manager</span></pre></td></tr><tr><td class="code"><pre><span class="line">├── kubectl</span></pre></td></tr><tr><td class="code"><pre><span class="line">├── kubelet</span></pre></td></tr><tr><td class="code"><pre><span class="line">├── kube-proxy</span></pre></td></tr><tr><td class="code"><pre><span class="line">├── kube-scheduler</span></pre></td></tr><tr><td class="code"><pre><span class="line">└── mounter</span></pre></td></tr></table></figure>

<p><a name="0laqA"></a></p>
<h3 id="准备ansible-环境和脚本"><a href="#准备ansible-环境和脚本" class="headerlink" title="准备ansible 环境和脚本"></a>准备ansible 环境和脚本</h3>]]></content>
      <categories>
        <category>kubernetes</category>
      </categories>
      <tags>
        <tag>kubernetes</tag>
        <tag>云计算</tag>
      </tags>
  </entry>
  <entry>
    <title>VMware Workstation 虚拟机 root 分区扩容</title>
    <url>/post/eca5e5f3.html</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th align="center">Date</th>
<th align="center">Log</th>
</tr>
</thead>
<tbody><tr>
<td align="center">26/05/2019</td>
<td align="center">初始版本.</td>
</tr>
</tbody></table><p><a name="b072c805"></a></p><h3 id="解决什么问题"><a href="#解决什么问题" class="headerlink" title="解决什么问题"></a>解决什么问题</h3><p>本文尝试解决的问题：</p><ul>
<li>在使用 VMware Workstation 安装 Centos 虚拟机后，发现根分区大小不够用，在不进行系统重装的前提下对根分区进行扩容。</li>
</ul><p><a name="fb370aed"></a></p><h3 id="具体步骤"><a href="#具体步骤" class="headerlink" title="具体步骤"></a>具体步骤</h3><p>基本过程是先通过 VMware Workstations 对虚拟物理磁盘设备进行扩容，然后进入系统后新建 LVM 分区，新建 PV，分配 PV 给 VG，扩容 LV，最后扩容文件系统。<br><br><a name="bb27f7bd"></a></p><a id="more"></a>





<h4 id="物理磁盘扩容"><a href="#物理磁盘扩容" class="headerlink" title="物理磁盘扩容"></a>物理磁盘扩容</h4><p>在 VMware Workstation 虚拟机详情中，对虚拟物理盘扩容，如图：<br><img src="https://cdn.nlark.com/yuque/0/2019/png/182657/1558855276765-9429af86-29d5-4e67-9dd1-2b5901f41d76.png#align=left&display=inline&height=521&name=image.png&originHeight=623&originWidth=892&size=90730&status=done&width=746" alt="image.png"></p>
<p>此时进入操作系统查看块设备详情，目标是增加 centos-root 容量：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># lsblk</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">NAME            MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT</span></pre></td></tr><tr><td class="code"><pre><span class="line">sda               8:0    0  300G  0 disk </span></pre></td></tr><tr><td class="code"><pre><span class="line">├─sda1            8:1    0    1G  0 part /boot</span></pre></td></tr><tr><td class="code"><pre><span class="line">└─sda2            8:2    0   39G  0 part </span></pre></td></tr><tr><td class="code"><pre><span class="line">  ├─centos-root 253:0    0 35.1G  0 lvm  /</span></pre></td></tr><tr><td class="code"><pre><span class="line">  └─centos-swap 253:1    0  3.9G  0 lvm  [SWAP]</span></pre></td></tr><tr><td class="code"><pre><span class="line">sr0              11:0    1 1024M  0 rom</span></pre></td></tr></table></figure>

<p><a name="9NJvT"></a></p>
<h4 id="新建-LVM-分区"><a href="#新建-LVM-分区" class="headerlink" title="新建 LVM 分区"></a>新建 LVM 分区</h4><p>使用 fsdik 在 /dev/sda 上新建分区。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># fdisk /dev/sda</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Welcome to fdisk (util-linux 2.23.2).</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">Changes will remain <span class="keyword">in</span> memory only, until you decide to write them.</span></pre></td></tr><tr><td class="code"><pre><span class="line">Be careful before using the write <span class="built_in">command</span>.</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">Command (m <span class="keyword">for</span> <span class="built_in">help</span>): n</span></pre></td></tr></table></figure>

<p>根据提示， 一直 Enter 采用默认设置即可，直到出现类似以下输出：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Partition 3 of <span class="built_in">type</span> Linux and of size 260 GiB is <span class="built_in">set</span></span></pre></td></tr></table></figure>

<p>之后，键入 t 进行分区类型设置，依次输入 3、8e 设置 LVM 分区：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Command (m <span class="keyword">for</span> <span class="built_in">help</span>): t</span></pre></td></tr><tr><td class="code"><pre><span class="line">Partition number (1-3, default 3): 3</span></pre></td></tr><tr><td class="code"><pre><span class="line">Hex code (<span class="built_in">type</span> L to list all codes): 8e</span></pre></td></tr><tr><td class="code"><pre><span class="line">Changed <span class="built_in">type</span> of partition <span class="string">'Linux'</span> to <span class="string">'Linux LVM'</span></span></pre></td></tr></table></figure>

<p>然后，键入 w 保存分区。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Command (m <span class="keyword">for</span> <span class="built_in">help</span>): w</span></pre></td></tr><tr><td class="code"><pre><span class="line">The partition table has been altered!</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">Calling ioctl() to re-read partition table.</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">WARNING: Re-reading the partition table failed with error 16: Device or resource busy.</span></pre></td></tr><tr><td class="code"><pre><span class="line">The kernel still uses the old table. The new table will be used at</span></pre></td></tr><tr><td class="code"><pre><span class="line">the next reboot or after you run partprobe(8) or kpartx(8)</span></pre></td></tr><tr><td class="code"><pre><span class="line">Syncing disks.</span></pre></td></tr></table></figure>

<p>使用以下命令扫描出新创建的分区：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># partprobe -s</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">/dev/sda: msdos partitions 1 2 3</span></pre></td></tr></table></figure>

<p>或者如下命令扫描：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># partx -v -a /dev/sda</span></span></pre></td></tr></table></figure>

<p>此时，查看块设备详情可以看到新建的 /dev/sda3 分区：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># lsblk</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">NAME            MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT</span></pre></td></tr><tr><td class="code"><pre><span class="line">sda               8:0    0  300G  0 disk </span></pre></td></tr><tr><td class="code"><pre><span class="line">├─sda1            8:1    0    1G  0 part /boot</span></pre></td></tr><tr><td class="code"><pre><span class="line">├─sda2            8:2    0   39G  0 part </span></pre></td></tr><tr><td class="code"><pre><span class="line">│ ├─centos-root 253:0    0 35.1G  0 lvm  /</span></pre></td></tr><tr><td class="code"><pre><span class="line">│ └─centos-swap 253:1    0  3.9G  0 lvm  [SWAP]</span></pre></td></tr><tr><td class="code"><pre><span class="line">└─sda3            8:3    0  260G  0 part </span></pre></td></tr><tr><td class="code"><pre><span class="line">sr0              11:0    1 1024M  0 rom</span></pre></td></tr></table></figure>

<p><a name="6kVFX"></a></p>
<h4 id="使用新分区扩容-LV"><a href="#使用新分区扩容-LV" class="headerlink" title="使用新分区扩容 LV"></a>使用新分区扩容 LV</h4><p>在磁盘分区的基础上创建物理卷：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># pvcreate /dev/sda3</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Physical volume <span class="string">"/dev/sda3"</span> successfully created</span></pre></td></tr></table></figure>

<p>使用新建的物理卷扩展卷组：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># vgextend centos /dev/sda3</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Volume group <span class="string">"centos"</span> successfully extended</span></pre></td></tr></table></figure>

<p>扩容逻辑卷：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#  lvextend /dev/centos/root /dev/sda3</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  Size of logical volume centos/root changed from 35.12 GiB (8991 extents) to &lt;295.12 GiB (75550 extents).</span></pre></td></tr><tr><td class="code"><pre><span class="line">  Logical volume centos/root successfully resized.</span></pre></td></tr></table></figure>

<p>扩容文件系统：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># xfs_growfs /dev/mapper/centos-root</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">meta-data=/dev/mapper/centos-root isize=512    agcount=4, agsize=2301440 blks</span></pre></td></tr><tr><td class="code"><pre><span class="line">         =                       sectsz=512   attr=2, projid32bit=1</span></pre></td></tr><tr><td class="code"><pre><span class="line">         =                       crc=1        finobt=0 spinodes=0</span></pre></td></tr><tr><td class="code"><pre><span class="line">data     =                       bsize=4096   blocks=9205760, imaxpct=25</span></pre></td></tr><tr><td class="code"><pre><span class="line">         =                       sunit=0      swidth=0 blks</span></pre></td></tr><tr><td class="code"><pre><span class="line">naming   =version 2              bsize=4096   ascii-ci=0 ftype=1</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">log</span>      =internal               bsize=4096   blocks=4495, version=2</span></pre></td></tr><tr><td class="code"><pre><span class="line">         =                       sectsz=512   sunit=0 blks, lazy-count=1</span></pre></td></tr><tr><td class="code"><pre><span class="line">realtime =none                   extsz=4096   blocks=0, rtextents=0</span></pre></td></tr><tr><td class="code"><pre><span class="line">data blocks changed from 9205760 to 77363200</span></pre></td></tr></table></figure>

<p>最后查看块设备详情，扩容成功：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># lsblk</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">NAME            MAJ:MIN RM   SIZE RO TYPE MOUNTPOINT</span></pre></td></tr><tr><td class="code"><pre><span class="line">sda               8:0    0   300G  0 disk </span></pre></td></tr><tr><td class="code"><pre><span class="line">├─sda1            8:1    0     1G  0 part /boot</span></pre></td></tr><tr><td class="code"><pre><span class="line">├─sda2            8:2    0    39G  0 part </span></pre></td></tr><tr><td class="code"><pre><span class="line">│ ├─centos-root 253:0    0 295.1G  0 lvm  /</span></pre></td></tr><tr><td class="code"><pre><span class="line">│ └─centos-swap 253:1    0   3.9G  0 lvm  [SWAP]</span></pre></td></tr><tr><td class="code"><pre><span class="line">└─sda3            8:3    0   260G  0 part </span></pre></td></tr><tr><td class="code"><pre><span class="line">  └─centos-root 253:0    0 295.1G  0 lvm  /</span></pre></td></tr><tr><td class="code"><pre><span class="line">sr0              11:0    1  1024M  0 rom</span></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>Virtualization</category>
      </categories>
      <tags>
        <tag>云计算</tag>
        <tag>Virtaulization</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 kolla-ansible 部署 OpenStack</title>
    <url>/post/43354256.html</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th align="center">Date</th>
<th align="center">Log</th>
</tr>
</thead>
<tbody><tr>
<td align="center">26/05/2019</td>
<td align="center">初始版本.</td>
</tr>
</tbody></table><p><a name="b072c805"></a></p><h3 id="解决什么问题"><a href="#解决什么问题" class="headerlink" title="解决什么问题"></a>解决什么问题</h3><p>本文尝试解决的问题：</p><ul>
<li>使用个人开发电脑搭建一套 OpenStack 开发环境。</li>
</ul><p>本文所有操作的前提是个人电脑搭建 Linux 操作系统且具有 16G 以上的内存资源和 足够大的硬盘空间。要完成整个系统的搭建，需要进行：</p><ul>
<li>准备三个控制节点和两个计算节点的虚拟机环境；</li>
<li>使用 kolla-ansible 部署 OpenStack。</li>
</ul><a id="more"></a>





<p><a name="fb370aed"></a></p>
<h3 id="准备虚拟机"><a href="#准备虚拟机" class="headerlink" title="准备虚拟机"></a>准备虚拟机</h3><p>首先，新建 /infra 目录用于存放本次部署产生所有的数据信息，包括安装文件和虚拟机磁盘文件。基于 VMware Workstation 创建虚拟机， VMware Workstation 安装过程不再赘述。使用 CentOS 7.6 最小系统镜像安装操作系统，镜像地址：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">https://mirrors.tuna.tsinghua.edu.cn/centos/7.6.1810/isos/x86_64/CentOS-7-x86_64-Minimal-1810.iso</span></pre></td></tr></table></figure>

<p>三个控制节点配置相同，可以在创建完成一个虚拟机后使用 VMware 提供的 clone 功能直接复制出其余的（复制得到的虚拟机需要重新生成 MAC 地址，否则会造成地址冲突），配置详情如下：<br><img src="https://cdn.nlark.com/yuque/0/2019/png/182657/1558868599415-e0c7d40e-0869-4bdb-b9cd-c03d2ca01291.png#align=left&display=inline&height=702&name=image.png&originHeight=702&originWidth=891&size=68225&status=done&width=891" alt="image.png"><br>两个计算节点在上图配置的基础上提升了内存、处理器和硬盘配置，这里硬盘容量设置较大是为了后续在 OpenStack 环境中部署 Kubernetes 等其它系统做准备，可根据个人需要缩减：<br><img src="https://cdn.nlark.com/yuque/0/2019/png/182657/1558868727583-2c08f21e-a5cd-4226-9050-fe9a3a935143.png#align=left&display=inline&height=696&name=image.png&originHeight=696&originWidth=885&size=68338&status=done&width=885" alt="image.png"><br>所有节点配置两张网卡：一张用于 OpenStack 管理网，通过 NAT 连接外网；一张用于 Neutron 网络，直接桥接到外部网络。可根据个人需求调整连接外部网络的方式，VMware 虚拟网络信息如下：<br><img src="https://cdn.nlark.com/yuque/0/2019/png/182657/1558869217104-6d5aa106-722c-4a3a-a398-6aec413ea9c2.png#align=left&display=inline&height=614&name=image.png&originHeight=614&originWidth=617&size=55558&status=done&width=617" alt="image.png"><br>虚拟机创建完成后进入操作系统检查 IP 地址获取情况：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@controller_03 ~]<span class="comment"># ip a</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000</span></pre></td></tr><tr><td class="code"><pre><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span></pre></td></tr><tr><td class="code"><pre><span class="line">    inet 127.0.0.1/8 scope host lo</span></pre></td></tr><tr><td class="code"><pre><span class="line">       valid_lft forever preferred_lft forever</span></pre></td></tr><tr><td class="code"><pre><span class="line">    inet6 ::1/128 scope host </span></pre></td></tr><tr><td class="code"><pre><span class="line">       valid_lft forever preferred_lft forever</span></pre></td></tr><tr><td class="code"><pre><span class="line">2: ens33: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000</span></pre></td></tr><tr><td class="code"><pre><span class="line">    link/ether 00:50:56:32:8a:b7 brd ff:ff:ff:ff:ff:ff</span></pre></td></tr><tr><td class="code"><pre><span class="line">    inet 172.16.192.131/24 brd 172.16.192.255 scope global noprefixroute ens33</span></pre></td></tr><tr><td class="code"><pre><span class="line">       valid_lft forever preferred_lft forever</span></pre></td></tr><tr><td class="code"><pre><span class="line">    inet6 fe80::250:56ff:fe32:8ab7/64 scope link </span></pre></td></tr><tr><td class="code"><pre><span class="line">       valid_lft forever preferred_lft forever</span></pre></td></tr><tr><td class="code"><pre><span class="line">3: ens36: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000</span></pre></td></tr><tr><td class="code"><pre><span class="line">    link/ether 00:50:56:34:89:62 brd ff:ff:ff:ff:ff:ff</span></pre></td></tr><tr><td class="code"><pre><span class="line">    inet 192.168.1.10/24 brd 192.168.1.255 scope global noprefixroute dynamic ens36</span></pre></td></tr><tr><td class="code"><pre><span class="line">       valid_lft 82858sec preferred_lft 82858sec</span></pre></td></tr><tr><td class="code"><pre><span class="line">    inet6 fe80::91ef:7089:dc2e:d7f1/64 scope link noprefixroute </span></pre></td></tr><tr><td class="code"><pre><span class="line">       valid_lft forever preferred_lft forever</span></pre></td></tr></table></figure>

<p>如果没有获取到 IP 可执行 dhclient 命令尝试获取 IP 地址，动态分配的 IP 地址只是为系统提供了临时连接外部网络的途径。为了后续的自动化部署，我们需要将每个节点连接管理网的网卡 IP 地址固定下来，并使用管理网网关为默认路由网关（一定要确认好网关地址），如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@controller_03 ~]<span class="comment"># cat /etc/sysconfig/network-scripts/ifcfg-ens33 </span></span></pre></td></tr><tr><td class="code"><pre><span class="line">TYPE=Ethernet</span></pre></td></tr><tr><td class="code"><pre><span class="line">PROXY_METHOD=none</span></pre></td></tr><tr><td class="code"><pre><span class="line">BROWSER_ONLY=no</span></pre></td></tr><tr><td class="code"><pre><span class="line">BOOTPROTO=static</span></pre></td></tr><tr><td class="code"><pre><span class="line">DEFROUTE=yes</span></pre></td></tr><tr><td class="code"><pre><span class="line">NAME=ens33</span></pre></td></tr><tr><td class="code"><pre><span class="line">UUID=f7c0ccd3-10d2-4bd9-bc47-c6429cbc28a0</span></pre></td></tr><tr><td class="code"><pre><span class="line">DEVICE=ens33</span></pre></td></tr><tr><td class="code"><pre><span class="line">ONBOOT=yes</span></pre></td></tr><tr><td class="code"><pre><span class="line">IPADDR=172.16.192.131</span></pre></td></tr><tr><td class="code"><pre><span class="line">GATEWAY=172.16.192.2</span></pre></td></tr><tr><td class="code"><pre><span class="line">NETMASK=255.255.255.0</span></pre></td></tr><tr><td class="code"><pre><span class="line">DNS1=114.114.114.114</span></pre></td></tr><tr><td class="code"><pre><span class="line">DNS2=1.1.1.1</span></pre></td></tr><tr><td class="code"><pre><span class="line">DNS3=8.8.4.4</span></pre></td></tr></table></figure>

<p>给 Neutron 使用的网卡配置如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># cat /etc/sysconfig/network-scripts/ifcfg-ens36</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">TYPE=Ethernet</span></pre></td></tr><tr><td class="code"><pre><span class="line">PROXY_METHOD=none</span></pre></td></tr><tr><td class="code"><pre><span class="line">BROWSER_ONLY=no</span></pre></td></tr><tr><td class="code"><pre><span class="line">BOOTPROTO=dhcp</span></pre></td></tr><tr><td class="code"><pre><span class="line">DEFROUTE=no</span></pre></td></tr><tr><td class="code"><pre><span class="line">NAME=ens36</span></pre></td></tr><tr><td class="code"><pre><span class="line">DEVICE=ens36</span></pre></td></tr><tr><td class="code"><pre><span class="line">ONBOOT=yes</span></pre></td></tr></table></figure>


<p>为了管理方便，我们将三个控制节点和两个计算节点的 hostname 分别设置为（主机名不能带下划线，否则部署 OpenStack 时报错）:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">controller-01</span></pre></td></tr><tr><td class="code"><pre><span class="line">controller-02</span></pre></td></tr><tr><td class="code"><pre><span class="line">controller-03</span></pre></td></tr><tr><td class="code"><pre><span class="line">compute-01</span></pre></td></tr><tr><td class="code"><pre><span class="line">compute-02</span></pre></td></tr></table></figure>

<p>为了方便命令行登录节点，可通过 ssh-copy-id 将宿主机 ssh public-key 拷贝到各虚拟节点，之后在 ssh 登录时无需再输入密码。<br>为了方便在所有虚拟机和宿主机之间共享文件，我们可以使用 VMware 的文件共享机制将宿主机目录挂载到虚拟机中。首先，在虚拟机的属性配置中添加要共享的文件夹，如下是将宿主机上的 /infra/vmshare 目录共享给虚拟机：<br><img src="https://cdn.nlark.com/yuque/0/2019/png/182657/1558870518738-a48e46b4-d616-4a1b-9c17-f11fc2595b76.png#align=left&display=inline&height=590&name=image.png&originHeight=701&originWidth=886&size=70490&status=done&width=746" alt="image.png"></p>
<p>只有上图的设置还不够，我们需要进入到虚拟机内部将共享的文件夹挂载到本地目录才能使用，如下，该命令的涵义是将名称为 vmshare 的共享挂载到本地 /vmshare 目录：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vmhgfs-fuse .host:/vmshare /vmshare</span></pre></td></tr></table></figure>

<p>另外也可以将挂载信息写入到 /etc/fstab 使系统在启动时自动挂载：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">.host:/vmshare /vmshare fuse.vmhgfs-fuse allow_other 0 0</span></pre></td></tr></table></figure>

<p>部署 OpenStack 的时候需要使用到网卡的混杂模式，而在 Linux 下虚拟机没有权限完成该操作，可通过以下设置开放权限给虚拟机：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo chmod a+rw /dev/vmnet0</span></pre></td></tr><tr><td class="code"><pre><span class="line">sudo chmod a+rw /dev/vmnet8</span></pre></td></tr></table></figure>

<p>在使用图形化界面完成以上操作和配置后，我们将脱离 GUI 运行虚拟机，这样可以节省一些资源开支。执行以下命令以命令行形式运行虚拟机：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vmrun start /infra/openstack_controller_02/openstack_controller_02.vmx nogui</span></pre></td></tr></table></figure>

<p>现在，将所有节点都以 nogui 形式启动起来，vmrun list 可以看到它们：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(kolla) ➜  kolla vmrun list                                                                  </span></pre></td></tr><tr><td class="code"><pre><span class="line">Total running VMs: 5</span></pre></td></tr><tr><td class="code"><pre><span class="line">/infra/openstack_controller_02/openstack_controller_02.vmx</span></pre></td></tr><tr><td class="code"><pre><span class="line">/infra/openstack_controller_03/openstack_controller_03.vmx</span></pre></td></tr><tr><td class="code"><pre><span class="line">/infra/openstack_controller_01/openstack_controller_01.vmx</span></pre></td></tr><tr><td class="code"><pre><span class="line">/infra/openstack_compute_01/openstack_compute_01.vmx</span></pre></td></tr><tr><td class="code"><pre><span class="line">/infra/openstack_compute_02/openstack_compute_02.vmx</span></pre></td></tr></table></figure>

<p>我们的虚拟机环境准备好了，开始使用 kolla-ansible 进行部署。</p>
<p><a name="9jAVQ"></a></p>
<h3 id="使用-kolla-ansible-部署-OpenStack"><a href="#使用-kolla-ansible-部署-OpenStack" class="headerlink" title="使用 kolla-ansible 部署 OpenStack"></a>使用 kolla-ansible 部署 OpenStack</h3><p>参考 kolla-ansible <a href="https://docs.openstack.org/kolla-ansible/latest/user/quickstart.html" target="_blank" rel="external nofollow noopener noreferrer">官方文档</a> 进行部署。<br>创建一份虚拟 Python 环境用于本次部署，需要先安装 virtualenv ，我的宿主机环境是 ArchLinux，执行以下命令安装，其它 Linux 环境请自行 Google 安装方法：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yay -S python-virtualenv</span></pre></td></tr></table></figure>

<p>然后执行以下命令创建 kolla 虚拟环境：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">virtualenv -p python2 /infra/kolla</span></pre></td></tr></table></figure>

<p>使用以下命令激活虚拟 Python 环境 :</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">source</span> /infra/kolla/bin/activate</span></pre></td></tr></table></figure>

<p>安装 Ansible:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install ansible</span></pre></td></tr></table></figure>

<p>为了方便对所有节点执行一些共性的操作，我们临时创建一份 hosts 文件，如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(kolla) ➜  kolla cat /infra/hosts            </span></pre></td></tr><tr><td class="code"><pre><span class="line">[OpenstackGroup:children]</span></pre></td></tr><tr><td class="code"><pre><span class="line"> nodes</span></pre></td></tr><tr><td class="code"><pre><span class="line"> controllers</span></pre></td></tr><tr><td class="code"><pre><span class="line"> computes</span></pre></td></tr><tr><td class="code"><pre><span class="line">[OpenstackGroup:vars]</span></pre></td></tr><tr><td class="code"><pre><span class="line"> ansible_ssh_user=root</span></pre></td></tr><tr><td class="code"><pre><span class="line"> ansible_ssh_pass=r00tme</span></pre></td></tr><tr><td class="code"><pre><span class="line"> ansible_port=22</span></pre></td></tr><tr><td class="code"><pre><span class="line">[nodes]</span></pre></td></tr><tr><td class="code"><pre><span class="line"> openstack_controller_01 ansible_host=172.16.192.129</span></pre></td></tr><tr><td class="code"><pre><span class="line"> openstack_controller_02 ansible_host=172.16.192.130</span></pre></td></tr><tr><td class="code"><pre><span class="line"> openstack_controller_03 ansible_host=172.16.192.131</span></pre></td></tr><tr><td class="code"><pre><span class="line"> openstack_compute_01 ansible_host=172.16.192.132</span></pre></td></tr><tr><td class="code"><pre><span class="line"> openstack_compute_02 ansible_host=172.16.192.133</span></pre></td></tr><tr><td class="code"><pre><span class="line">[contorllers]</span></pre></td></tr><tr><td class="code"><pre><span class="line"> openstack_controller_01 ansible_host=172.16.192.129</span></pre></td></tr><tr><td class="code"><pre><span class="line"> openstack_controller_02 ansible_host=172.16.192.130</span></pre></td></tr><tr><td class="code"><pre><span class="line"> openstack_controller_03 ansible_host=172.16.192.131</span></pre></td></tr><tr><td class="code"><pre><span class="line">[computes]</span></pre></td></tr><tr><td class="code"><pre><span class="line"> openstack_compute_01 ansible_host=172.16.192.132</span></pre></td></tr><tr><td class="code"><pre><span class="line"> openstack_compute_02 ansible_host=172.16.192.133</span></pre></td></tr></table></figure>

<p>启用 SELinux 会带来一些麻烦，影响 kolla 安装部署，因此我们使用 ansible 关闭所有节点的 SELinux 并重启系统使之生效：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ansible nodes -i /infra/hosts -m shell -a <span class="string">'sed -i "s#SELINUX=enforcing#SELINUX=disabled#g" /etc/selinux/config'</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">ansible nodes -i /infra/hosts -m shell -a <span class="string">'reboot'</span></span></pre></td></tr></table></figure>

<p>另外，我们使用清华开源镜像替代 Pypi 官方仓库：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ansible nodes -i /infra/hosts -m shell -a <span class="string">'yum install -y wget'</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">ansible nodes -i /infra/hosts -m shell -a <span class="string">'wget https://tuna.moe/oh-my-tuna/oh-my-tuna.py'</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">ansible nodes -i /infra/hosts -m shell -a <span class="string">'python /root/oh-my-tuna.py'</span></span></pre></td></tr></table></figure>

<p>接下来，继续按照 kolla 文档安装 kolla-ansible：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install kolla-ansible</span></pre></td></tr><tr><td class="code"><pre><span class="line">sudo mkdir -p /etc/kolla</span></pre></td></tr><tr><td class="code"><pre><span class="line">sudo chown <span class="variable">$USER</span>:<span class="variable">$USER</span> /etc/kolla</span></pre></td></tr><tr><td class="code"><pre><span class="line">cp -r /infra/kolla/share/kolla-ansible/etc_examples/kolla/* /etc/kolla</span></pre></td></tr><tr><td class="code"><pre><span class="line">cp /infra/kolla/share/kolla-ansible/ansible/inventory/multinode /infra/kolla</span></pre></td></tr></table></figure>

<p>然后，配置 multinode inventory 文件，根据文档中的说明来进行配置即可：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(kolla) ➜  kolla cat multinode </span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># These initial groups are the only groups required to be modified. The</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># additional groups are for more control of the environment.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">[control]</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 这里的配置和我们宿主机 hosts 配置要对应起来</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">openstack_controller_01</span></pre></td></tr><tr><td class="code"><pre><span class="line">openstack_controller_02</span></pre></td></tr><tr><td class="code"><pre><span class="line">openstack_controller_03</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># The above can also be specified as follows:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">#control[01:03]     ansible_user=kolla</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 网路节点和控制节点对应</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">[network]</span></pre></td></tr><tr><td class="code"><pre><span class="line">openstack_controller_01</span></pre></td></tr><tr><td class="code"><pre><span class="line">openstack_controller_02</span></pre></td></tr><tr><td class="code"><pre><span class="line">openstack_controller_03</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># inner-compute is the groups of compute nodes which do not have</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># external reachability.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># DEPRECATED, the group will be removed in S release of OpenStack,</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># use variable neutron_compute_dvr_mode instead.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">[inner-compute]</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 我们的两个计算节点都可以联通外网</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># DEPRECATED, the group will be removed in S release of OpenStack,</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># use variable neutron_compute_dvr_mode instead.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">[external-compute]</span></pre></td></tr><tr><td class="code"><pre><span class="line">openstack_compute_01</span></pre></td></tr><tr><td class="code"><pre><span class="line">openstack_compute_02</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">[compute:children]</span></pre></td></tr><tr><td class="code"><pre><span class="line">inner-compute</span></pre></td></tr><tr><td class="code"><pre><span class="line">external-compute</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 监控节点可以选择控制节点中的任意一个</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">[monitoring]</span></pre></td></tr><tr><td class="code"><pre><span class="line">openstack_controller_01</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># When compute nodes and control nodes use different interfaces,</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># you need to comment out "api_interface" and other interfaces from the globals.yml</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># and specify like below:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">#compute01 neutron_external_interface=eth0 api_interface=em1 storage_interface=em1 tunnel_interface=em1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 存储节点和计算节点复用</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">[storage]</span></pre></td></tr><tr><td class="code"><pre><span class="line">openstack_compute_01</span></pre></td></tr><tr><td class="code"><pre><span class="line">openstack_compute_02</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">[deployment]</span></pre></td></tr><tr><td class="code"><pre><span class="line">localhost       ansible_connection=<span class="built_in">local</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">[baremetal:children]</span></pre></td></tr><tr><td class="code"><pre><span class="line">control</span></pre></td></tr><tr><td class="code"><pre><span class="line">network</span></pre></td></tr><tr><td class="code"><pre><span class="line">compute</span></pre></td></tr><tr><td class="code"><pre><span class="line">storage</span></pre></td></tr><tr><td class="code"><pre><span class="line">monitoring</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 添加了一项变量配置，指明登录虚拟机节点所需要的用户名和密码</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">[baremetal:vars]</span></pre></td></tr><tr><td class="code"><pre><span class="line">ansible_ssh_user=root</span></pre></td></tr><tr><td class="code"><pre><span class="line">ansible_ssh_pass=r00tme</span></pre></td></tr><tr><td class="code"><pre><span class="line">ansible_port=22</span></pre></td></tr></table></figure>

<p>注意上述文件中的虚拟机名称应当可以在宿主机解析到其对应的 IP 地址，为此 宿主机 hosts 增加如下配置：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(kolla) ➜  kolla tail -n 5 /etc/hosts</span></pre></td></tr><tr><td class="code"><pre><span class="line">172.16.192.129 openstack_controller_01</span></pre></td></tr><tr><td class="code"><pre><span class="line">172.16.192.130 openstack_controller_02</span></pre></td></tr><tr><td class="code"><pre><span class="line">172.16.192.131 openstack_controller_03</span></pre></td></tr><tr><td class="code"><pre><span class="line">172.16.192.132 openstack_compute_01</span></pre></td></tr><tr><td class="code"><pre><span class="line">172.16.192.133 openstack_compute_02</span></pre></td></tr></table></figure>

<p>执行以下命令生成安装过程所需的数据库等各项基础设施密码：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kolla-genpwd</span></pre></td></tr></table></figure>

<p>然后修改 kolla 的全局配置文件 /etc/kolla/globals.yml :</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 所有OpenStack组件的基础镜像使用 centos</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">kolla_base_distro: <span class="string">"centos"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 选择社区编译好的安装源文件进行安装</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">kolla_install_type: <span class="string">"binary"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 选择安装 R 版 OpenStack</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">openstack_release: <span class="string">"rocky"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 设置管理网使用的网卡，即为我们为每个虚拟机添加的网卡之一</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">network_interface: <span class="string">"ens33"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 设置 Neutron 使用的网卡，即为我们为虚拟机添加的另外一块网卡</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">neutron_external_interface: <span class="string">"ens36"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 设置管理平台 VIP，该 IP 漂移在三个控制节点的管理网卡上，因此应是一个未被占用的和管理网段一致的 IP 地址</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">kolla_internal_vip_address: <span class="string">"172.16.192.134"</span></span></pre></td></tr></table></figure>

<p>接下来，开始真正部署的第一步，在所有节点上安装部署依赖的基础软件包，安装过程可能有报错，可针对具体问题解决后重复执行安装命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kolla-ansible -i /infra/kolla/multinode bootstrap-servers</span></pre></td></tr></table></figure>

<p>第二步，检查环境是否已经准备好，配置是否有错漏，检查过程可能会抛出一些错误，不要惊慌，一般都有提示信息，按照提示去修改即可：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kolla-ansible -i /infra/kolla/multinode prechecks</span></pre></td></tr></table></figure>

<p>第三步，正式开始安装：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kolla-ansible -i /infra/kolla/multinode deploy</span></pre></td></tr></table></figure>

<p>如果在安装中出错，可以先找到错误原因并修复后，先清理上次安装后再重装：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kolla-ansible -i ./multinode destroy --yes-i-really-really-mean-it</span></pre></td></tr><tr><td class="code"><pre><span class="line">kolla-ansible -i /infra/kolla/multinode deploy</span></pre></td></tr></table></figure>

<p><a name="9AVli"></a></p>
<h3 id="常见错误"><a href="#常见错误" class="headerlink" title="常见错误"></a>常见错误</h3><ul>
<li>在 bootstrap-servers 阶段遇到 Python uninstall request 包错误，可尝试如下方式解决：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install -I requests==2.9</span></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>OpenStack</category>
      </categories>
      <tags>
        <tag> 云计算</tag>
        <tag>OpenStack</tag>
      </tags>
  </entry>
  <entry>
    <title>K8S集成Keystone认证</title>
    <url>/post/699b195d.html</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th align="center">Date</th>
<th align="center">Log</th>
</tr>
</thead>
<tbody><tr>
<td align="center">12/02/2019</td>
<td align="center">初始版本.</td>
</tr>
</tbody></table><p><a name="b072c805"></a></p><h3 id="解决什么问题"><a href="#解决什么问题" class="headerlink" title="解决什么问题"></a>解决什么问题</h3><p>本文尝试解决的问题有两个：</p><ul>
<li>K8S 中虽然有用户的概念，但 K8S 本身并不管理用户以及认证过程，而是提供了多种方式来接入外部用户管理系统。</li>
<li>K8S 并不能提供物理隔离的多租户能力，但软多租户的实现仍然是有意义的，在一定程度上可以解决每个用户独占一个集群的问题。</li>
</ul><a id="more"></a>



<p>上述问题的解决方案其实是很多的，也可以自己开发相应的功能组件，这里选择 Keystone 来解决该问题的原因主要有：</p>
<ul>
<li>Keystone 本身是一个非常完备的认证系统，具有完整的域、项目、用户、角色等概念体系和文档完善的 Restful API，可以省去大量的开发工作，尤其适合规模比较小的开发团队拿来即用。</li>
<li>大量私有云用户已经使用了 OpenStack 作为基础设施管理平台，在该平台基础上引入 K8S 时可以直接使用 OpenStack中部署好的 Keystone。</li>
<li>社区为 K8S 开发了 cloud-provider-openstack，其中就包括对 Keystone 的大量支持性工作，大大降低了用户自行对接使用的难度。</li>
<li>我曾经从事过一段时间的基于 OpenStack 的云管平台的开发，对 Keystone 有一定使用经验。</li>
</ul>
<p>当然，使用 Keystone 的问题也不少，主要有以下几个方面：</p>
<ul>
<li>Keystone 本身具有一定的复杂性，有一定的学习成本，一些功能用不到。</li>
<li>Keystone 的部署也相对麻烦。整个 OpenStack 项目都有着部署麻烦的问题。</li>
<li>Keystone 在 R 版本之后只支持基于 Fernet 标准的 Token 生成方式。 Fernet token 虽然和 Json Web Token 类似也是一种非持久化 Token，但是其受众群体显然不如 JWT 广，不利于和集群中其它功能模块的集成。一个例子就是，目前 Istio 的认证过程只支持 JWT，这使得无法直接使用 Keystone 作为 Istio 的认证服务器。</li>
</ul>
<p>要完成整个系统的搭建，显然我们需要进行以下几个步骤：</p>
<ul>
<li>部署一个 K8S 集群；</li>
<li>部署 Keystone；</li>
<li>部署支撑 Keystone 与 K8S 集成的插件。</li>
</ul>
<p>在以上步骤中，部署 K8S 相对资料比较齐全，不再赘述，下面主要介绍剩余步骤。</p>
<p><a name="fb370aed"></a></p>
<h3 id="部署-Keystone"><a href="#部署-Keystone" class="headerlink" title="部署 Keystone"></a>部署 Keystone</h3><p>部署 Keystone 是假设用户本身并不具有处于可用状态的 Keystone 服务。</p>
<p>部署 Keystone 可以有多种形式，包括：</p>
<ul>
<li>直接在虚拟机或物理机中部署；</li>
<li>使用 Docker 进行容器化部署；</li>
<li>在 K8S 集群中部署。</li>
</ul>
<p>这里在 K8S 集群中部署 Keystone 服务。</p>
<p><a name="6b097826"></a></p>
<h4 id="Keystone-镜像的构建"><a href="#Keystone-镜像的构建" class="headerlink" title="Keystone 镜像的构建"></a>Keystone 镜像的构建</h4><p>OpenStack 容器化部署一直是社区想要解决的问题，Kolla 项目就是为此而生并已经生产可用，但是由于 OpenStack 部署牵涉到的配置选项太多，使用 Kolla 部署仍然没有达到令人欢欣的简单。</p>
<p>我尝试通过 Kolla 生成 Keystone 项目的部署镜像，但是由于国内网络的种种问题以及 OpenStack 的庞大的 Python 依赖体系以及漏洞百出的官方部署文档，该过程并没有顺利完成。</p>
<p>基督徒无奈时应会求助于上帝，程序员无助时多会逛一逛 Github 撞撞运气。</p>
<p>幸运的是我真的找到了一个容器化部署 Keystone 的开源项目，地址<a href="https://github.com/dixudx/keystone-docker" target="_blank" rel="external nofollow noopener noreferrer">在此</a>，加上我刚点的星星，总共只有十颗星星，最近更新是18年9月，但文档写的很是详细，决定一试。</p>
<p>把文档读了一遍，开始动手，看到可以设置 Keystone 版本信息，本着不用最新版的程序员不是一个好极客的理念，果断使用 Keystone 最新发布版本 14.0.1。</p>
<p>另外数据库决定使用已经部署在集群中的 TiDB 分布式数据库，因为默认端口是 4000 这个莫名其妙的数字，所以需要改一下该项目中使用到数据库的代码，并在数据库中创建 keystone 用户。之后开始打包镜像，过程很顺利，打包好的镜像上传到了 dockerhub 上 xyc11223344/keystone.</p>
<p><a name="bb27f7bd"></a></p>
<h4 id="Keystone-部署"><a href="#Keystone-部署" class="headerlink" title="Keystone 部署"></a>Keystone 部署</h4><p>部署所用 yaml 文件如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="attr">kind:</span> <span class="string">Namespace</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="attr">metadata:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="attr">name:</span> <span class="string">keystone</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="attr">metadata:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="attr">name:</span> <span class="string">keystone</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="attr">namespace:</span> <span class="string">keystone</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="attr">labels:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="attr">app:</span> <span class="string">keystone</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="attr">spec:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="attr">ports:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">35357</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="attr">name:</span> <span class="string">internal</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">5000</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="attr">nodePort:</span> <span class="number">31221</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="attr">name:</span> <span class="string">public</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="attr">selector:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="attr">app:</span> <span class="string">keystone</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="attr">type:</span> <span class="string">NodePort</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="attr">metadata:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="attr">name:</span> <span class="string">keystone</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="attr">namespace:</span> <span class="string">keystone</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="attr">labels:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="attr">app:</span> <span class="string">keystone</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="attr">spec:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="attr">selector:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="attr">matchLabels:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="attr">app:</span> <span class="string">keystone</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="attr">strategy:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="attr">type:</span> <span class="string">Recreate</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="attr">template:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="attr">metadata:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="attr">namespace:</span> <span class="string">keystone</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="attr">labels:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="attr">app:</span> <span class="string">keystone</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="attr">spec:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="attr">containers:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">xyc11223344/keystone</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="attr">name:</span> <span class="string">keystone</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="attr">imagePullPolicy:</span> <span class="string">Always</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="attr">ports:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">35357</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">5000</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="attr">env:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">KEYSTONE_DB_HOST</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">          <span class="attr">value:</span> <span class="string">"test-tidb.test-tidb"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">KEYSTONE_DB_ROOT_PASSWD_IF_REMOTED</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">          <span class="attr">value:</span> <span class="string">"test"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="attr">volumeMounts:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">tz-config</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">          <span class="attr">mountPath:</span> <span class="string">/etc/localtime</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">          <span class="attr">readOnly:</span> <span class="literal">true</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="attr">volumes:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">tz-config</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">          <span class="attr">hostPath:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="attr">path:</span> <span class="string">/etc/localtime</span></span></pre></td></tr></table></figure>

<p>首次部署后，Pod 一直起不来，kubectl logs 查看 Pod 日志，发现是初始化 Keystone 数据库时报错，提示 Alter database keystone charset 不支持，根据报错信息，发现相关操作在 TiDB 中不兼容，因为 Keystone 本来支持的是 MySQL 数据库，TiDB 虽然号称兼容 MySQL，但是仍然有一些不常用的 DML 操作不支持。</p>
<p>我尝试直接在 Keystone Python 代码中删除掉了该操作，但是再次部署时又出现了其它数据库操作兼容性问题。Keystone 数据库初始化是通过 keystone-manage db_sync 命令执行的，具体的代码我没有去分析，不过从 log 来看，它首先创建了一个空的数据库，然后生成老版本的各个 table ，之后再根据安装的目标版本一步一步升级到最新的，所以出现了大量的数据库变更 ALTER 操作，而不是直接初始化到目标版本完事儿。鉴于此，直接改 Python 代码貌似不可行，转念一想，决定重新部署一个 MySQL 数据库，然后使用该数据库完成初始化工作，获取到最终形态的数据库之后，dump 整个数据库到一个 sql 文件，再导入到 TiDB 数据库中，由于是最终形态，应当不会有 ALTER 操作出现。之后的尝试过程成功进行，获取到了最新版本的数据库 dump 文件，以后部署需要手动导入该文件而不能通过 Keystone 容器启动脚本中的 db_sync 命令完成，虽然解决了兼容性问题，显然该数据库只适应于当前 14.0.1 版本的 Keystone，以后每次更换版本仍然需要重新生成数据库 dump 文件。</p>
<p>解决了数据库问题之后，再次部署，又出现了新的问题，查看 keystone pod log 问题大概是找不到名为 uuid 的 token provider，猜测大概是 OpenStack 升级后配置也发生了一些变化，先到上述开源项目中找到 keystone 配置文件果然找到一段配置，如下：</p>
<figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="section">[token]</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="attr">expiration</span> = <span class="number">3600</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="attr">provider</span> = uuid</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="attr">driver</span> = memcache</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="attr">caching</span> = <span class="literal">true</span></span></pre></td></tr></table></figure>

<p>显然，问题出在 provider = uuid 这项配置，Google 一下，根据官方文档的说法，从 R 版本开始不再支持 uuid 作为token provider，目前支持 fernet，应当是基于安全和性能考虑作出的变更。</p>
<p>之后将配置更改为：</p>
<figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="section">[token]</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="attr">expiration</span> = <span class="number">3600</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="attr">provider</span> = fernet</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="attr">driver</span> = memcache</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="attr">caching</span> = <span class="literal">true</span></span></pre></td></tr></table></figure>

<p>重新打包镜像后尝试部署，仍然报错，这次是找不到 fernet 相关的 key 文件，应当是 fernet 需要额外的一些部署操作，查看官方文档后，在镜像启动脚本中添加了以下命令:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">keystone-manage fernet_setup --keystone-user keystone --keystone-group keystone</span></pre></td></tr><tr><td class="code"><pre><span class="line">keystone-manage credential_setup --keystone-user keystone --keystone-group keystone</span></pre></td></tr></table></figure>

<p>再次重新打包镜像，重新部署，部署成功。curl 访问一下，结果如下：<br><img src="https://cdn.nlark.com/yuque/0/2019/png/182657/1575441061446-d961a9d8-bb54-44c9-ab3e-e63b839554bf.png#align=left&display=inline&height=780&name=image.png&originHeight=780&originWidth=1124&size=108671&status=done&style=none&width=1124" alt="image.png"></p>
<p>因为做了一些改动，所以将原来的 keystone 容器化部署开源项目做了一些修改，并提交到了<a href="https://github.com/XiaYinchang/keystone" target="_blank" rel="external nofollow noopener noreferrer">这里</a>.</p>
<p><a name="fb97588f"></a></p>
<h3 id="部署-K8S-与-Keystone-集成的支持插件"><a href="#部署-K8S-与-Keystone-集成的支持插件" class="headerlink" title="部署 K8S 与 Keystone 集成的支持插件"></a>部署 K8S 与 Keystone 集成的支持插件</h3><p>根据<a href="https://github.com/kubernetes/cloud-provider-openstack" target="_blank" rel="external nofollow noopener noreferrer">cloud-provider-openstack</a>的使用说明文档，我们这里主要使用到两个插件：</p>
<ul>
<li>k8s-keystone-auth: 实现了Kubernetes webhook authentication 插件接口，将 Keystone 以 webhook 的形式接入到 K8S 认证过程。</li>
<li>client-keystone-auth: 用于在如 kubectl 等命令行工具端接入 Keystone 认证。</li>
</ul>
<p><a name="9bbac6d4"></a></p>
<h4 id="k8s-keystone-auth-的部署"><a href="#k8s-keystone-auth-的部署" class="headerlink" title="k8s-keystone-auth 的部署"></a>k8s-keystone-auth 的部署</h4><p>从配置项看，k8s-keystone-auth 的核心功能有三项：接入 Keystone 的认证、接入 Keystone 的鉴权和同步 Keystone 中的项目及角色绑定。其中，接入认证是必选项，其它两项可选。</p>
<p>这里，只使用接入 Keystone 认证和同步 Keystone 中项目及角色绑定两项，鉴权使用 K8S 本身的 RBAC。</p>
<p>同步功能的配置均以 configmap 的形式提供，如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="attr">kind:</span> <span class="string">ConfigMap</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="attr">metadata:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="attr">name:</span> <span class="string">k8s-sync-config</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="attr">namespace:</span> <span class="string">kube-system</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="attr">data:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="attr">syncConfig:</span> <span class="string">|</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="string">data_types_to_sync":</span> <span class="string">["projects",</span> <span class="string">"role_assignments"</span><span class="string">]</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="attr">"namespace_format":</span> <span class="string">"%n-%i"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="attr">"projects_black_list":</span> <span class="string">[]</span></span></pre></td></tr></table></figure>

<p>注意，k8s-keystone-auth 必须部署在 kube-system 命名空间中，因为我在查看源代码时发现命名空间被hard coded了。</p>
<p>由于 k8s-keystone-auth 需要使用到命名空间中的默认 serviceaccount 来操作 K8S 集群包括创建命名空间和rolebinding等，所以要为 kube-system:default 服务账户创建 clusterrolebinding，如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl create clusterrolebinding key-auth-cluster-admin --clusterrole=cluster-admin --serviceaccount=kube-system:default</span></pre></td></tr></table></figure>

<p>另外 K8S 使用 https 协议，所以需要提供 tls 认证证书，这里直接使用 master 节点宿主机上的证书创建一个 secret ，然后挂载到k8s-keystone-auth pod 中使用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl create secret generic keystone-auth-certs --from-file&#x3D;cert-file&#x3D;&#x2F;etc&#x2F;kubernetes&#x2F;pki&#x2F;apiserver.crt --from-file&#x3D;key-file&#x3D;&#x2F;etc&#x2F;kubernetes&#x2F;pki&#x2F;apiserver.key -n kube-system</span></pre></td></tr></table></figure>

<p>然后，创建 k8s-keystone-auth 的部署文件如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="attr">metadata:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="attr">name:</span> <span class="string">k8s-keystone-auth</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="attr">namespace:</span> <span class="string">kube-system</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="attr">labels:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="attr">app:</span> <span class="string">k8s-keystone-auth</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="attr">spec:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="attr">replicas:</span> <span class="number">2</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="attr">selector:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="attr">matchLabels:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="attr">app:</span> <span class="string">k8s-keystone-auth</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="attr">template:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="attr">metadata:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="attr">labels:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="attr">app:</span> <span class="string">k8s-keystone-auth</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="attr">spec:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="attr">containers:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">k8s-keystone-auth</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">          <span class="attr">image:</span> <span class="string">xyc11223344/k8s-keystone-auth:v1.0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">          <span class="attr">imagePullPolicy:</span> <span class="string">Always</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">          <span class="attr">args:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="bullet">-</span> <span class="string">/bin/k8s-keystone-auth</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="bullet">-</span> <span class="string">--v=10</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="bullet">-</span> <span class="string">--tls-cert-file</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="bullet">-</span> <span class="string">/etc/kubernetes/pki/cert-file</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="bullet">-</span> <span class="string">--tls-private-key-file</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="bullet">-</span> <span class="string">/etc/kubernetes/pki/key-file</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="bullet">-</span> <span class="string">--sync-configmap-name</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="bullet">-</span> <span class="string">k8s-sync-config</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="bullet">-</span> <span class="string">--keystone-url</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="bullet">-</span> <span class="string">http://keystone.keystone:5000/v3</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">          <span class="attr">env:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">          <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">KEYSTONE_SYNC_CONFIGMAP_NAME</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="attr">value:</span> <span class="string">k8s-sync-config</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">          <span class="attr">volumeMounts:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="bullet">-</span> <span class="attr">mountPath:</span> <span class="string">/etc/kubernetes/pki</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">              <span class="attr">name:</span> <span class="string">k8s-certs</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">              <span class="attr">readOnly:</span> <span class="literal">true</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">          <span class="attr">ports:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">8443</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="attr">volumes:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">k8s-certs</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="attr">secret:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">          <span class="attr">secretName:</span> <span class="string">keystone-auth-certs</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="attr">metadata:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="attr">name:</span> <span class="string">k8s-keystone-auth-service</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="attr">namespace:</span> <span class="string">kube-system</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="attr">spec:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="attr">selector:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="attr">app:</span> <span class="string">k8s-keystone-auth</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="attr">ports:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="bullet">-</span> <span class="attr">nodePort:</span> <span class="number">32189</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="attr">port:</span> <span class="number">8443</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="attr">protocol:</span> <span class="string">TCP</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="attr">targetPort:</span> <span class="number">8443</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="attr">type:</span> <span class="string">NodePort</span></span></pre></td></tr></table></figure>

<p>第一次部署时使用的是社区提供的 k8scloudprovider/k8s-keystone-auth 镜像，结果部署时一堆报错，先是无法识别 sync-configmap-name 传进去的参数，源代码一看有个很明显的错误，赋值时用错了变量。</p>
<p>没办法重新编译了镜像后尝试部署，又出现报错，干脆直接 panic。看了一下社区源码，有个指针声明一下，未赋值就拿来直接用了，再改了后重新编译，并将镜像传至 xyc11223344/k8s-keystone-auth:v1.0。</p>
<p>再次部署，成功运行起来。然后，需要修改 kube-apiserver的配置文件，使用 webhook 来进行认证。首先，需要创建 webhook 的配置文件如下，需要注意的是 kube-apiserver 是以静态容器的形式启动的，无法访问集群内的服务VIP，所以需要使用 NodePort 来访问刚刚部署好的 k8s-keystone-auth 服务：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="attr">kind:</span> <span class="string">Config</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="attr">preferences:</span> <span class="string">&#123;&#125;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="attr">clusters:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="bullet">-</span> <span class="attr">cluster:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="attr">insecure-skip-tls-verify:</span> <span class="literal">true</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="attr">server:</span> <span class="string">https://10.10.144.75:32189/webhook</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="attr">name:</span> <span class="string">webhook</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="attr">users:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">webhook</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="attr">contexts:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="bullet">-</span> <span class="attr">context:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="attr">cluster:</span> <span class="string">webhook</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="attr">user:</span> <span class="string">webhook</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="attr">name:</span> <span class="string">webhook</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="attr">current-context:</span> <span class="string">webhook</span></span></pre></td></tr></table></figure>

<p>之后将 webhook 配置文件拷贝到每一个 master 节点的 /etc/kubernetes/pki/webhookconfig.yaml 路径， 这是因为该配置文件需要被 kube-apiserver 容器访问到，而 /etc/kubernetes 路径已经以 hostPath 的形式挂载到了 kube-apiserver 容器中，所以放到宿主机上该路径下的文件可以直接被容器访问到。</p>
<p>接下来，更改 kube-apiserver 的启动参数，编辑 /etc/kubernetes/manifests/kube-apiserver.yaml 如下，增加了一行内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--authentication-token-webhook-config-file&#x3D;&#x2F;etc&#x2F;kubernetes&#x2F;pki&#x2F;webhookconfig.yaml</span></pre></td></tr></table></figure>

<p><img src="https://cdn.nlark.com/yuque/0/2019/png/182657/1575441117777-1a84f269-f9cb-4f21-b149-f3a9979f981d.png#align=left&display=inline&height=1128&name=image.png&originHeight=1128&originWidth=1268&size=287983&status=done&style=none&width=1268" alt="image.png"></p>
<p><a name="fd1817a9"></a></p>
<h4 id="client-keystone-auth-的部署"><a href="#client-keystone-auth-的部署" class="headerlink" title="client-keystone-auth 的部署"></a>client-keystone-auth 的部署</h4><p>先编译出 client-keystone-aut 可执行文件，并放到 master 任意路径，这里放在 /usr/local/bin/client-keystone-auth。然后，执行以下命令创建一个 user ：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl config set-credentials admin</span></pre></td></tr></table></figure>

<p>执行后，查看 ~/.kube/config，发现，多出一个 user，如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">users:</span></pre></td></tr><tr><td class="code"><pre><span class="line">- name: admin</span></pre></td></tr><tr><td class="code"><pre><span class="line">  user: &#123;&#125;</span></pre></td></tr></table></figure>

<p>修改上述 config 文件如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">users:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">admin</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="attr">user:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="attr">exec:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="attr">apiVersion:</span> <span class="string">client.authentication.k8s.io/v1beta1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="attr">command:</span> <span class="string">/usr/local/bin/client-keystone-auth</span></span></pre></td></tr></table></figure>

<p>接着执行以下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl config set-context --cluster&#x3D;kubernetes --user&#x3D;admin keystone-admin@kubernetes</span></pre></td></tr><tr><td class="code"><pre><span class="line">kubectl config use-context keystone-admin@kubernetes</span></pre></td></tr></table></figure>

<p>此时再执行 kubectl 命令会提示输入 Keystone 相关认证信息。也可以提前设置好如下环境变量：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export OS_DOMAIN_NAME&#x3D;Default</span></pre></td></tr><tr><td class="code"><pre><span class="line">export OS_PROJECT_NAME&#x3D;admin</span></pre></td></tr><tr><td class="code"><pre><span class="line">export OS_USERNAME&#x3D;admin</span></pre></td></tr><tr><td class="code"><pre><span class="line">export OS_PASSWORD&#x3D;test</span></pre></td></tr><tr><td class="code"><pre><span class="line">export OS_AUTH_URL&#x3D;http:&#x2F;&#x2F;10.10.144.75:31221&#x2F;v3</span></pre></td></tr><tr><td class="code"><pre><span class="line">export OS_IDENTITY_API_VERSION&#x3D;3</span></pre></td></tr></table></figure>

<p>设置好环境变量后使用 kubectl 依然会提示 unauthorized，这是因为 admin 用户并没有权限访问集群资源，admin 用户目前只有权限访问从 keystone 同步过来的项目。执行以下命令，切换 kubectl 认证信息为集群初始的管理员：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl config use-context kubernetes-admin@kubernetes</span></pre></td></tr></table></figure>

<p>此时执行 kubectl get ns 可以发现，keystone 中的项目已经同步过来了，列表中第一个命名空间就是从 Keystone 同步过来的项目，命名规则和我们设置的一致，即项目名-项目ID：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2019/png/182657/1575441145645-fc76fed8-5251-442c-897c-ec854e8fbdf8.png#align=left&display=inline&height=204&name=image.png&originHeight=204&originWidth=792&size=37633&status=done&style=none&width=792" alt="image.png"></p>
<p>刚刚我们说到 keystone-admin<a href>@kubernetes </a> context 只有权限访问从 Keystone 同步过来的项目，也就是这个列表中的第一个命名空间，其它命名空间都是无权限访问的。</p>
<p>另外 kubernetes 中默认已经有 admin 、 edit 和 view 三个clusterrole，而 keystone 默认的三种角色是 admin、 member 和 reader， 为了同步时的一致性，这里将 keystone 中的角色改为和 kubernetes 中一致，如下：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2019/png/182657/1575441171154-0092ca7c-9d67-46e0-8d07-752a98a02951.png#align=left&display=inline&height=614&name=image.png&originHeight=614&originWidth=778&size=107346&status=done&style=none&width=778" alt="image.png"></p>
<p>之后，到 admin-b97a1f63205743ce8e33356243774fbc 中查看 rolebinding ：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2019/png/182657/1575441193681-709aa70d-5835-46dc-a67a-57b10339e0da.png#align=left&display=inline&height=172&name=image.png&originHeight=172&originWidth=1316&size=66169&status=done&style=none&width=1316" alt="image.png"></p>
<p><a name="9bf2bca6"></a></p>
<h3 id="如何解决了问题"><a href="#如何解决了问题" class="headerlink" title="如何解决了问题"></a>如何解决了问题</h3><p>针对文章开篇提到的两个问题，一个是认证系统的问题，一个是软多租户的问题。</p>
<p>针对认证系统的问题，k8s-keystone-auth 插件提供了解决方案。</p>
<p>针对软多租户的问题，可以借由 keystone 的租户管理概念来实现。</p>
<p>而对于 kubectl 命令行工具，client-keystone-auth 插件提供了支持，通过对不同用户可访问命名空间的限制来实现命令行端的权限管控。</p>
]]></content>
      <categories>
        <category>Kubernetes</category>
      </categories>
      <tags>
        <tag>Kubernetes</tag>
        <tag>云计算</tag>
        <tag>Keystone</tag>
      </tags>
  </entry>
  <entry>
    <title>关于K8S中Pod带宽限制的问题</title>
    <url>/post/2c3c5a80.html</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th align="center">Date</th>
<th align="center">Log</th>
</tr>
</thead>
<tbody><tr>
<td align="center">13/01/2019</td>
<td align="center">初始版本.</td>
</tr>
</tbody></table><p><a name="e6cefb85"></a></p><h3 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h3><p>因业务需求，需要对 K8S 集群中 Pod 的出入带宽进行限制，可能是因为该需求并不常见，能找到的参考资料不多，只能结合官网的一些简单说明开始了踩坑探索。</p><p><a name="729de1d0"></a></p><h3 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h3><p>根据官网<a href="https://kubernetes.io/docs/concepts/extend-kubernetes/compute-storage-net/" target="_blank" rel="external nofollow noopener noreferrer">该章节</a>的描述，感觉配置过程很简单的样子，总结一下：</p><ul>
<li>需要使用 CNI 网络插件，确保 kubelet 的启动参数中有 –network-plugin=cni</li>
<li>确保 –cni-conf-dir 和 –cni-bin-dir 存在，默认分别是 /etc/cni/net.d 和 /opt/cni/bin</li>
<li>修改 CNI 插件的配置如下：```yaml<br>{<br>“name”: “k8s-pod-network”,<br>“cniVersion”: “0.3.0”,<br>“plugins”:<br>  [<pre><code>{
  &quot;type&quot;: &quot;calico&quot;,
  &quot;log_level&quot;: &quot;info&quot;,
  &quot;datastore_type&quot;: &quot;kubernetes&quot;,
  &quot;nodename&quot;: &quot;127.0.0.1&quot;,
  &quot;ipam&quot;: { &quot;type&quot;: &quot;host-local&quot;, &quot;subnet&quot;: &quot;usePodCidr&quot; },
  &quot;policy&quot;: { &quot;type&quot;: &quot;k8s&quot; },
  &quot;kubernetes&quot;: { &quot;kubeconfig&quot;: &quot;/etc/cni/net.d/calico-kubeconfig&quot; },
},
{ &quot;type&quot;: &quot;bandwidth&quot;, &quot;capabilities&quot;: { &quot;bandwidth&quot;: true } },</code></pre>  ]<br>}<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">- 在 Pod 模板中添加以下注解即可：&#96;&#96;&#96;yaml</span></pre></td></tr><tr><td class="code"><pre><span class="line">apiVersion: v1</span></pre></td></tr><tr><td class="code"><pre><span class="line">  kind: Pod</span></pre></td></tr><tr><td class="code"><pre><span class="line">  metadata:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  annotations:</span></pre></td></tr><tr><td class="code"><pre><span class="line">      kubernetes.io&#x2F;ingress-bandwidth: 1M</span></pre></td></tr><tr><td class="code"><pre><span class="line">      kubernetes.io&#x2F;egress-bandwidth: 1M</span></pre></td></tr><tr><td class="code"><pre><span class="line">  ...</span></pre></td></tr></table></figure>

</li>
</ul><a id="more"></a>





<p>以上几个条件，前两个已经默认满足，我部署的是 Kubernetes 1.13.1 版本，默认启用 CNI。关于第三个，官网没有说哪些 CNI 可以使用带宽限制，直接给出了一个 calico 的配置示例。因为部署 Kubernetes 时网络插件用的 Flannel ，决定直接改下 Flannel 的配置试试。</p>
<p><a name="db06c78d"></a></p>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p><a name="08c8022a"></a></p>
<h4 id="基于-Flannel-的测试"><a href="#基于-Flannel-的测试" class="headerlink" title="基于 Flannel 的测试"></a>基于 Flannel 的测试</h4><p>登录到 master 节点， cd 到 /etc/cni/net.d，果然发现了一个名为 10-flannel.conflist 的配置文件孤零零躺着， cat 一下， 内容如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="attr">"name":</span> <span class="string">"cbr0"</span><span class="string">,</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="attr">"plugins":</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="string">[</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="string">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="attr">"type":</span> <span class="string">"flannel"</span><span class="string">,</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="attr">"delegate":</span> <span class="string">&#123;</span> <span class="attr">"hairpinMode":</span> <span class="literal">true</span><span class="string">,</span> <span class="attr">"isDefaultGateway":</span> <span class="literal">true</span> <span class="string">&#125;,</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="string">&#125;,</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="string">&#123;</span> <span class="attr">"type":</span> <span class="string">"portmap"</span><span class="string">,</span> <span class="attr">"capabilities":</span> <span class="string">&#123;</span> <span class="attr">"portMappings":</span> <span class="literal">true</span> <span class="string">&#125;</span> <span class="string">&#125;,</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="string">],</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">&#125;</span></span></pre></td></tr></table></figure>

<p>本着只增不减的原则，在配置中增加了 bandwidth 的配置，变成如下内容：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="attr">"name":</span> <span class="string">"cbr0"</span><span class="string">,</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="attr">"plugins":</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="string">[</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="string">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="attr">"type":</span> <span class="string">"flannel"</span><span class="string">,</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="attr">"delegate":</span> <span class="string">&#123;</span> <span class="attr">"hairpinMode":</span> <span class="literal">true</span><span class="string">,</span> <span class="attr">"isDefaultGateway":</span> <span class="literal">true</span> <span class="string">&#125;,</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="string">&#125;,</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="string">&#123;</span> <span class="attr">"type":</span> <span class="string">"portmap"</span><span class="string">,</span> <span class="attr">"capabilities":</span> <span class="string">&#123;</span> <span class="attr">"portMappings":</span> <span class="literal">true</span> <span class="string">&#125;</span> <span class="string">&#125;,</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="string">&#123;</span> <span class="attr">"type":</span> <span class="string">"bandwidth"</span><span class="string">,</span> <span class="attr">"capabilities":</span> <span class="string">&#123;</span> <span class="attr">"bandwidth":</span> <span class="literal">true</span> <span class="string">&#125;</span> <span class="string">&#125;,</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="string">],</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">&#125;</span></span></pre></td></tr></table></figure>

<p>然后执行 systemctl restart kubelet 重启了一下 kubelet 。再回头 cat 一下配置文件，发现增加的配置消失了…<br><br>猜测难道是因为 bandwidth 插件和 portmap 插件有冲突，然后强大的 K8S 来了个自动还原？<br><br>只能把 portmap 插件去掉再试试了… 然后重启 kubelet ，发现这次 bandwidth 没有消失。<br><br>配置变为：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="attr">"name":</span> <span class="string">"cbr0"</span><span class="string">,</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="attr">"plugins":</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="string">[</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="string">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="attr">"type":</span> <span class="string">"flannel"</span><span class="string">,</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="attr">"delegate":</span> <span class="string">&#123;</span> <span class="attr">"hairpinMode":</span> <span class="literal">true</span><span class="string">,</span> <span class="attr">"isDefaultGateway":</span> <span class="literal">true</span> <span class="string">&#125;,</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="string">&#125;,</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="string">&#123;</span> <span class="attr">"type":</span> <span class="string">"bandwidth"</span><span class="string">,</span> <span class="attr">"capabilities":</span> <span class="string">&#123;</span> <span class="attr">"bandwidth":</span> <span class="literal">true</span> <span class="string">&#125;</span> <span class="string">&#125;,</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="string">],</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">&#125;</span></span></pre></td></tr></table></figure>

<p>之后创建两个 deployment 测试，分别如下：<br><br>无带宽限制的 deployment：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">piVersion:</span> <span class="string">extensions/v1beta1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="attr">metadata:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="attr">name:</span> <span class="string">centos-deployment</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="attr">labels:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="attr">app:</span> <span class="string">centos</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="attr">spec:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="attr">selector:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="attr">matchLabels:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="attr">app:</span> <span class="string">centos</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="attr">template:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="attr">metadata:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="attr">labels:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="attr">app:</span> <span class="string">centos</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="attr">spec:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="attr">containers:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">centos</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="attr">image:</span> <span class="string">xyc11223344/centos</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="attr">command:</span> <span class="string">["nginx",</span> <span class="string">"-g"</span><span class="string">,</span> <span class="string">"daemon off;"</span><span class="string">]</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="attr">ports:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span></pre></td></tr></table></figure>

<p>有带宽限制的 deployment：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">piVersion:</span> <span class="string">extensions/v1beta1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="attr">metadata:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="attr">name:</span> <span class="string">centos-deployment-01</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="attr">labels:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="attr">app:</span> <span class="string">centos-01</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="attr">spec:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="attr">selector:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="attr">matchLabels:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="attr">app:</span> <span class="string">centos-01</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="attr">template:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="attr">metadata:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="attr">labels:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="attr">app:</span> <span class="string">centos-01</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="attr">annotations:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="attr">kubernetes.io/ingress-bandwidth:</span> <span class="string">10M</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="attr">kubernetes.io/egress-bandwidth:</span> <span class="string">10M</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="attr">spec:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="attr">containers:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">centos-01</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="attr">image:</span> <span class="string">xyc11223344/centos</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="attr">command:</span> <span class="string">["nginx",</span> <span class="string">"-g"</span><span class="string">,</span> <span class="string">"daemon off;"</span><span class="string">]</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="attr">ports:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span></pre></td></tr></table></figure>

<p>部署后发现，又出错，提示 no bandwidth plugin 之类的…<br><br>想了想难道是没有 bandwidth 二进制包， cd 到 /opt/cni/bin 看了下，果然没有任何名为 bandwidth 的东西…<br><br>好吧，去 github 上下吧…<br><br>一通乱搜，找到了插件<a href="https://github.com/containernetworking/plugins" target="_blank" rel="external nofollow noopener noreferrer">项目地址</a>：<br><br>下载了最新 release 的 0.7.4 版本二进制包，解压开一看，无语，还是没有…<br><br>难道是我解压姿势不对？仔细看了看项目说明，明明是有的，好吧，看来要自己动手编译了。<br><br>编译的过程异乎寻常的顺利，前提是你的机子上已经配置好Go的开发环境，只需执行以下命令即可:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/containernetworking/plugins.git</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> plugins</span></pre></td></tr><tr><td class="code"><pre><span class="line">./build_linux.sh</span></pre></td></tr></table></figure>

<p>很快编译完了，在项目目录下出现了 bin 文件夹， ls 查看一下，有了：<br><img src="https://cdn.nlark.com/yuque/0/2019/png/182657/1575442963241-bc70c7cc-1ee4-4fb6-aecb-0507f46d33ad.png#align=left&display=inline&height=38&name=image.png&originHeight=38&originWidth=1166&size=27284&status=done&style=none&width=1166" alt="image.png"><br><br><br><br>scp 到 master 节点，放到/opt/cni/bin 目录下。<br><br>重启 kubelet，又报错…说是 config version is 0.1.0， plugin supports only [0.3.0, 0.3.1, 0.4.0]<br><br>完全摸不着头脑，只能靠猜了…<br><br>看了一下上边的 Flannel 配置，貌似没有版本号的信息，猜测没有版本号就意味采用了默认版本号，而默认版本号应该是 0.1.0 ，所以才会有上述错误。继续修改配置为：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="attr">"name":</span> <span class="string">"cbr0"</span><span class="string">,</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="attr">"cniVersion":</span> <span class="string">"0.3.0"</span><span class="string">,</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="attr">"plugins":</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="string">[</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="string">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="attr">"type":</span> <span class="string">"flannel"</span><span class="string">,</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="attr">"delegate":</span> <span class="string">&#123;</span> <span class="attr">"hairpinMode":</span> <span class="literal">true</span><span class="string">,</span> <span class="attr">"isDefaultGateway":</span> <span class="literal">true</span> <span class="string">&#125;,</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="string">&#125;,</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="string">&#123;</span> <span class="attr">"type":</span> <span class="string">"bandwidth"</span><span class="string">,</span> <span class="attr">"capabilities":</span> <span class="string">&#123;</span> <span class="attr">"bandwidth":</span> <span class="literal">true</span> <span class="string">&#125;</span> <span class="string">&#125;,</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="string">],</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">&#125;</span></span></pre></td></tr></table></figure>

<p>重启 kubelet ， 等了半天 Pod 还是创建不出来，再次 kubetl get events 看看又 TM 咋了…<br><br>报错 no interface 之类的…最后一丝侥幸心理也没了。老老实实换 Calico 吧。</p>
<p><a name="17c18ff8"></a></p>
<h4 id="基于Calico的测试"><a href="#基于Calico的测试" class="headerlink" title="基于Calico的测试"></a>基于Calico的测试</h4><p>网络插件要从 Flannel 换为 Calico ，因为 Kubeadm init 时传进去的是 –pod-network-cidr=10.244.0.0/16 ， 和 Calico 的默认网段不一致，好吧，要替换一下了，执行以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 先卸掉flannel</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">wget https://raw.githubusercontent.com/coreos/flannel/bc79dd1505b0c8681ece4de4c0d86c5cd2643275/Documentation/kube-flannel.yml</span></pre></td></tr><tr><td class="code"><pre><span class="line">kubectl delete -f kube-flannel.yml</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 删掉丫的防干扰</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">rm -f /etc/cni/net.d/10-flannel.conflist</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 再装calico</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">kubectl apply -f https://docs.projectcalico.org/v3.3/getting-started/kubernetes/installation/hosted/rbac-kdd.yaml</span></pre></td></tr><tr><td class="code"><pre><span class="line">wget https://docs.projectcalico.org/v3.3/getting-started/kubernetes/installation/hosted/kubernetes-datastore/calico-networking/1.7/calico.yaml</span></pre></td></tr><tr><td class="code"><pre><span class="line">sed <span class="string">'s/192.168.0.0/10.244.0.0/g'</span> calico.yaml</span></pre></td></tr><tr><td class="code"><pre><span class="line">kubectl apply -f calico.yaml</span></pre></td></tr></table></figure>

<p>再次进入到 /etc/cni/net.d 目录，惊喜的发现多了两个文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /etc/cni/net.d</span></pre></td></tr><tr><td class="code"><pre><span class="line">ls</span></pre></td></tr><tr><td class="code"><pre><span class="line">10-calico.conflist  calico-kubeconfig</span></pre></td></tr></table></figure>

<p>修改 10-calico.conflist 为如下内容，其实就是增加了 bandwidth 的配置项，去掉了 potmap 的配置项：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="attr">"name":</span> <span class="string">"k8s-pod-network"</span><span class="string">,</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="attr">"cniVersion":</span> <span class="string">"0.3.0"</span><span class="string">,</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="attr">"plugins":</span> <span class="string">[</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="string">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="attr">"type":</span> <span class="string">"calico"</span><span class="string">,</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="attr">"log_level":</span> <span class="string">"info"</span><span class="string">,</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="attr">"datastore_type":</span> <span class="string">"kubernetes"</span><span class="string">,</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="attr">"nodename":</span> <span class="string">"10-10-183-55"</span><span class="string">,</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="attr">"mtu":</span> <span class="number">1440</span><span class="string">,</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="attr">"ipam":</span> <span class="string">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="attr">"type":</span> <span class="string">"host-local"</span><span class="string">,</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="attr">"subnet":</span> <span class="string">"usePodCidr"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="string">&#125;,</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="attr">"policy":</span> <span class="string">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="attr">"type":</span> <span class="string">"k8s"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="string">&#125;,</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="attr">"kubernetes":</span> <span class="string">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="attr">"kubeconfig":</span> <span class="string">"/etc/cni/net.d/calico-kubeconfig"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="string">&#125;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="string">&#125;,</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="string">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="attr">"type":</span> <span class="string">"bandwidth"</span><span class="string">,</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="attr">"capabilities":</span> <span class="string">&#123;"bandwidth":</span> <span class="literal">true</span><span class="string">&#125;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="string">&#125;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="string">]</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">&#125;</span></span></pre></td></tr></table></figure>

<p>重启 kubelet， 呵呵。Pod 终于 Running 了。<br><img src="https://cdn.nlark.com/yuque/0/2019/png/182657/1575442988039-9762993b-8113-4dae-b114-b305332405bd.png#align=left&display=inline&height=74&name=image.png&originHeight=74&originWidth=1218&size=63427&status=done&style=none&width=1218" alt="image.png"><br></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 执行以下命令进入Pod</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">kubectl <span class="built_in">exec</span> -it centos-deployment-01-699f7776f-5j6t5 bash</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 执行以下命令开个iperf server，iperf 什么的提前都装好了</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">iperf -s</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 另外再开个窗口，执行以下命令进入另一个Pod</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">kubectl <span class="built_in">exec</span> -it centos-deployment-57948c8598-jwkpr bash</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 执行以下命令进行测试</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">iperf -c iperf -c 10.244.1.6 -t 10</span></pre></td></tr></table></figure>

<p>数据如下:<br><br>限速前：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2019/png/182657/1575443012295-d2bc2306-a82c-4223-95a1-7ca0567eaa11.png#align=left&display=inline&height=127&name=image.png&originHeight=127&originWidth=630&size=45608&status=done&style=none&width=630" alt="image.png"><br><br>限速后：<br><br><img src="https://cdn.nlark.com/yuque/0/2019/png/182657/1575443032242-0bc4e6c4-f824-4821-b254-2d16eee44ce5.png#align=left&display=inline&height=126&name=image.png&originHeight=126&originWidth=660&size=49857&status=done&style=none&width=660" alt="image.png"><br><br>啊！真的限速了呢！可这限的什么鬼…<br><br>明明说好的10M，怎么变成了301K…<br><br>难道又是姿势不对？换了好多姿势，可每次数据都是不一样的吊诡…<br><br>上网搜吧…找到了一个 Github 上的 <a href="https://github.com/kubernetes/kubernetes/issues/70014" target="_blank" rel="external nofollow noopener noreferrer">issue</a> ，和我这个问题的症状相似又不太一样，而且看起来已经关闭了。<br><br>难道是我的 Kubernetes 版本太老了， 1.13.1 不是最新的吗？难道有新版本发布了？到 Github 上看了看还真有， 3天前发布了 1.13.2。<br><br>好吧，开始升级：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 标准的使用kubeadm部署的集群的升级姿势</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">kubeadm upgrade apply 1.13.2</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 提示可以升级，但是要先自己升级kubeadm kubelet kubectl</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">yum install kubeadm</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 提示已经是最新了...看来官方源还没跟上步伐，只能从官网自己下二进制包吧</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 到这里https://github.com/kubernetes/kubernetes/blob/master/CHANGELOG-1.13.md下载最新版的linux-server端二进制包</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 解压后，用新的kubeadm kubectl kubelet 替换旧的</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 注意替换 kubelet 要先执行以下命令停止服务</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">systemctl stop kubelet</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 替换后执行以下命令重启</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">systemctl start kubelet</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 所有节点都替换这三大件</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 之后执行以下命令升级集群</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">kubeadm upgrade plan 1.13.2</span></pre></td></tr></table></figure>

<p>升级完成之后，重新测试。结果真是忧伤，依然吊诡…<br><br>万般无奈之下，找到华为云容器团队的杜大师咨询了一下，大师不愧是大师，秒懂怎么回事儿，并教给我如下命令查看 tc 配置，因为说到底这个带宽限制还是通过Linux TC实现的:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tc qdisc show</span></pre></td></tr></table></figure>

<p><img src="https://cdn.nlark.com/yuque/0/2019/png/182657/1575443051065-4bc1bc1a-0b5a-4591-b3df-f57802fc1ff4.png#align=left&display=inline&height=274&name=image.png&originHeight=274&originWidth=823&size=150326&status=done&style=none&width=823" alt="image.png"><br></p>
<p>仔细看最后几行，10M变成了10K，和上述70014描述的bug一致，不过burst默认是214747b有点吊诡…<br><br>好吧，总结一下，功能是有的，只不过还有bug。<br><br>折腾到这里，突然有点怀念 OpenShift ，那就测一下吧。</p>
<p><a name="6c797bc4"></a></p>
<h4 id="基于OpenShift-SDN的测试"><a href="#基于OpenShift-SDN的测试" class="headerlink" title="基于OpenShift-SDN的测试"></a>基于OpenShift-SDN的测试</h4><p>先看一下openshift的零件，竟然也是标准CNI：<br><img src="https://cdn.nlark.com/yuque/0/2019/png/182657/1575443067485-64bda488-ce15-45e7-9208-97030040af11.png#align=left&display=inline&height=220&name=image.png&originHeight=220&originWidth=586&size=68560&status=done&style=none&width=586" alt="image.png"><br><br>而且据说不用任何额外配置，直接支持带宽限制。所以，把上面的两个deployment直接部署，过了一会儿Pod就起来了。<br><img src="https://cdn.nlark.com/yuque/0/2019/png/182657/1575443083763-bea1fe29-ae77-4322-bf1f-0d955d4780a8.png#align=left&display=inline&height=74&name=image.png&originHeight=74&originWidth=684&size=42546&status=done&style=none&width=684" alt="image.png"><br><br>然后跑一下iperf试试，数据如下：<br><img src="https://cdn.nlark.com/yuque/0/2019/png/182657/1575443097570-ef5d3d03-4755-497c-8bbe-6ee3bbb73d03.png#align=left&display=inline&height=127&name=image.png&originHeight=127&originWidth=666&size=79395&status=done&style=none&width=666" alt="image.png"><br><br>看看这数据，真是相当整齐了，10M就是10M。<br><br>说到底，还是 OpenShift 好用啊。</p>
]]></content>
      <categories>
        <category>Kubernetes</category>
      </categories>
      <tags>
        <tag>Kubernetes</tag>
        <tag>云计算</tag>
      </tags>
  </entry>
  <entry>
    <title>Go整洁架构实践</title>
    <url>/post/35963400.html</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th align="center">Date</th>
<th align="center">Log</th>
</tr>
</thead>
<tbody><tr>
<td align="center">17/09/2018</td>
<td align="center">初始版本.</td>
</tr>
</tbody></table><p><a name="e5729e94"></a></p><h3 id="原文"><a href="#原文" class="headerlink" title="原文"></a>原文</h3><p><a href="https://medium.com/@hatajoe/clean-architecture-in-go-4030f11ec1b1" target="_blank" rel="external nofollow noopener noreferrer">Clean Architecture in Go</a></p><p>本文讲述了一个使用 Go 和 gRPC 实践整洁架构的案例。</p><p><a name="df368884"></a></p><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>整洁架构现在已为人熟知，但是很多人可能并不了解如何去实现。本文尝试使用 Go 和 Grpc 提供一种清晰明了的实现方法。文中案例源码已放在<a href="https://github.com/hatajoe/8am" target="_blank" rel="external nofollow noopener noreferrer">基站</a>，这个小项目演示了用户注册业务的实现，有任何问题可以随时反馈。</p><a id="more"></a>





<p><a name="8a95a6d1"></a></p>
<h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p>8am 基于整洁架构，其目录结构如下:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">%</span><span class="bash"> tree</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">.</span></pre></td></tr><tr><td class="code"><pre><span class="line">├── Makefile</span></pre></td></tr><tr><td class="code"><pre><span class="line">├── README.md</span></pre></td></tr><tr><td class="code"><pre><span class="line">├── app</span></pre></td></tr><tr><td class="code"><pre><span class="line">│   ├── domain</span></pre></td></tr><tr><td class="code"><pre><span class="line">│   │   ├── model</span></pre></td></tr><tr><td class="code"><pre><span class="line">│   │   ├── repository</span></pre></td></tr><tr><td class="code"><pre><span class="line">│   │   └── service</span></pre></td></tr><tr><td class="code"><pre><span class="line">│   ├── interface</span></pre></td></tr><tr><td class="code"><pre><span class="line">│   │   ├── persistence</span></pre></td></tr><tr><td class="code"><pre><span class="line">│   │   └── rpc</span></pre></td></tr><tr><td class="code"><pre><span class="line">│   ├── registry</span></pre></td></tr><tr><td class="code"><pre><span class="line">│   └── usecase</span></pre></td></tr><tr><td class="code"><pre><span class="line">├── cmd</span></pre></td></tr><tr><td class="code"><pre><span class="line">│   └── 8am</span></pre></td></tr><tr><td class="code"><pre><span class="line">│       └── main.go</span></pre></td></tr><tr><td class="code"><pre><span class="line">└── vendor</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ├── vendor packages</span></pre></td></tr><tr><td class="code"><pre><span class="line">    |...</span></pre></td></tr></table></figure>

<p>顶级目录包含了三个子目录，分别是：</p>
<ul>
<li>app ： 应用包根目录</li>
<li>cmd：main 包目录</li>
<li>vendor ：第三方包目录</li>
</ul>
<p>整洁架构的概念分层如下图所示：<br><img src="https://cdn.nlark.com/yuque/0/2019/png/182657/1575442901636-ce111580-647a-485d-adfd-bed678fc98ee.png#align=left&display=inline&height=567&name=image.png&originHeight=567&originWidth=772&size=383132&status=done&style=none&width=772" alt="image.png"><br>整个架构共有四层，从外到内依次为蓝绿红黄层，除了作为应用目录的蓝色层，其余各层分别表示了：</p>
<ul>
<li>interface: 绿色层</li>
<li>usercase: 红色层</li>
<li>domain: 黄色层</li>
</ul>
<p>整洁架构的核心就是在各层之间构建接口。</p>
<p><a name="af7f7ab9"></a></p>
<h3 id="实体层-黄色层"><a href="#实体层-黄色层" class="headerlink" title="实体层-黄色层"></a>实体层-黄色层</h3><p>在作者看来，实体层和领域层在分层架构中的含义是类似的。这里称之为领域层是为了避免和 DDD 中实体的概念混淆。</p>
<p>领域层包含三个包：</p>
<ul>
<li>model: 具有聚合，实体和值对象</li>
<li>repository: 具有聚合的存储库接口</li>
<li>service: 具有依赖于多个模型的应用程序服务</li>
</ul>
<p>下面介绍各个包的实现细节：</p>
<p><a name="model"></a></p>
<h4 id="model"><a href="#model" class="headerlink" title="model"></a>model</h4><p>model 描述的用户聚合如下：</p>
<blockquote>
<p>这实际上还不是一个聚合，在这里视为聚合的前提是未来还会添加更多实体和值对象。</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> model</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	id    <span class="keyword">string</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	email <span class="keyword">string</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewUser</span><span class="params">(id, email <span class="keyword">string</span>)</span> *<span class="title">User</span></span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">return</span> &amp;User&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		id:    id,</span></pre></td></tr><tr><td class="code"><pre><span class="line">		email: email,</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u *User)</span> <span class="title">GetID</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">return</span> u.id</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u *User)</span> <span class="title">GetEmail</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">return</span> u.email</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>聚合是事务的边界，用以保持业务规则的一致性。因此，需要有一个仓储对应一个聚合。</p>
<p><a name="repository"></a></p>
<h4 id="repository"><a href="#repository" class="headerlink" title="repository"></a>repository</h4><p>repository 只负责提供实体集合的操作接口而不必关心持久化的具体实现。其代码实现如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> repository</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"github.com/hatajoe/8am/app/domain/model"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> UserRepository <span class="keyword">interface</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	FindAll() ([]*model.User, error)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        FindByEmail(email <span class="keyword">string</span>) (*model.User, error)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Save(*model.User) error</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>FindAll方法获取所有存储在系统中的用户。Save方法保存用户。再次强调，该层不应该获知对象是怎样被存储或序列化的。</p>
<p><a name="service"></a></p>
<h4 id="service"><a href="#service" class="headerlink" title="service"></a>service</h4><p>service 由各种业务逻辑组成。业务逻辑不应该包含在model中。例如，应用不允许已经存在的邮箱重复进行注册。如果把校验逻辑放在 model 中，会感到很别扭，如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u *User)</span> <span class="title">Duplicated</span><span class="params">(email <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// Find user by email from persistence layer...</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>Duplicated function 实际上和 User 模型是无关的。<br><br>为了解决这个问题，我们可以添加如下的服务层：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> UserService <span class="keyword">struct</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        repo repository.UserRepository</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *UserService)</span> <span class="title">Duplicated</span><span class="params">(email <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        user, err := s.repo.FindByEmail(email)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> user != <span class="literal">nil</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span> fmt.Errorf(<span class="string">"%s already exists"</span>, email)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span> err</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>实体层包含业务逻辑以及与其它层的接口。业务逻辑仅应涉及 model 和 service， 而不应该依赖于其它任何层级。如果需要访问其它层，则应当使用 repository 穿透层级。通过这种依赖倒置的形式，各个包之间会有更好的隔离性，并且更方便测试和维护。</p>
<p><a name="42e9e3dd"></a></p>
<h3 id="用例层-红色层"><a href="#用例层-红色层" class="headerlink" title="用例层-红色层"></a>用例层-红色层</h3><p>用例指的是应用的单一可操作单元。在该项目中， 获取用户列表和注册新用户被定义为用例。这些用例使用如下接口表示：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> UserUsecase <span class="keyword">interface</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ListUser() ([]*User, error)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    RegisterUser(email <span class="keyword">string</span>) error</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>为什么使用接口表示呢？这是因为用例将会被接口层（绿色层）使用。跨越层级的操作应通过定义的接口完成。</p>
<p>UserUsecase 的简单实现如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> userUsecase <span class="keyword">struct</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    repo    repository.UserRepository</span></pre></td></tr><tr><td class="code"><pre><span class="line">    service *service.UserService</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewUserUsecase</span><span class="params">(repo repository.UserRepository, service *service.UserService)</span> *<span class="title">userUsecase</span></span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> &amp;userUsecase &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        repo:    repo,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        service: service,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u *userUsecase)</span> <span class="title">ListUser</span><span class="params">()</span> <span class="params">([]*User, error)</span></span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    users, err := u.repo.FindAll()</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> toUser(users), <span class="literal">nil</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u *userUsecase)</span> <span class="title">RegisterUser</span><span class="params">(email <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    uid, err := uuid.NewRandom()</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> err</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> err := u.service.Duplicated(email); err != <span class="literal">nil</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> err</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    user := model.NewUser(uid.String(), email)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> err := u.repo.Save(user); err != <span class="literal">nil</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> err</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>userUsercase 依赖两个包： repository.UserRepository 接口 和 *service.UserService 结构。这两个包必须在用例初始化的时候由用例使用者进行注入。这些依赖关系通常由依赖注入容器解决，文中后面将会提及。ListUser 会获取所有已注册用户，RegisterUser 会将注册邮箱未重复的用户注册到系统中。</p>
<p>有一点要指出，这里的 User 并不是 model.User。model.User 可能拥有很多商业信息，但是其它层级不应该了解太多。 因此，这里专门为用例中的用户定义了DAO来屏蔽更具体的信息。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ID    <span class="keyword">string</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    Email <span class="keyword">string</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">toUser</span><span class="params">(users []*model.User)</span> []*<span class="title">User</span></span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    res := <span class="built_in">make</span>([]*User, <span class="built_in">len</span>(users))</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> i, user := <span class="keyword">range</span> users &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        res[i] = &amp;User&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            ID:    user.GetID(),</span></pre></td></tr><tr><td class="code"><pre><span class="line">            Email: user.GetEmail(),</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> res</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>你可能会想，为什么这个服务不使用接口而是直接实现呢？这是因为该服务不依赖于任何其它服务。<br><br>相反，当仓储穿透层和具体实现依赖于其它层不应知道太多细节的设备时，就需要定义一个接口来实现。作者认为这是整洁架构中最重要的一点。</p>
<p><a name="4cc3104e"></a></p>
<h3 id="接口层-绿色层"><a href="#接口层-绿色层" class="headerlink" title="接口层-绿色层"></a>接口层-绿色层</h3><p>该层放置具体对象，如API端点的处理程序，RDB的存储库或接口的其他边界。在这个案例中，添加了内存存储访问器和 gRPC 服务两个对象。</p>
<p><a name="4825ab28"></a></p>
<h4 id="内存存储访问器"><a href="#内存存储访问器" class="headerlink" title="内存存储访问器"></a>内存存储访问器</h4><p>作者使用用户存储库作为内存存储访问器。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> userRepository <span class="keyword">struct</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    mu    *sync.Mutex</span></pre></td></tr><tr><td class="code"><pre><span class="line">    users <span class="keyword">map</span>[<span class="keyword">string</span>]*User</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewUserRepository</span><span class="params">()</span> *<span class="title">userRepository</span></span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> &amp;userRepository&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        mu:    &amp;sync.Mutex&#123;&#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        users: <span class="keyword">map</span>[<span class="keyword">string</span>]*User&#123;&#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *userRepository)</span> <span class="title">FindAll</span><span class="params">()</span> <span class="params">([]*model.User, error)</span></span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    r.mu.Lock()</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">defer</span> r.mu.Unlock()</span></pre></td></tr><tr><td class="code"><pre><span class="line">    users := <span class="built_in">make</span>([]*model.User, <span class="built_in">len</span>(r.users))</span></pre></td></tr><tr><td class="code"><pre><span class="line">    i := <span class="number">0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> _, user := <span class="keyword">range</span> r.users &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        users[i] = model.NewUser(user.ID, user.Email)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        i++</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> users, <span class="literal">nil</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *userRepository)</span> <span class="title">FindByEmail</span><span class="params">(email <span class="keyword">string</span>)</span> <span class="params">(*model.User, error)</span></span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    r.mu.Lock()</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">defer</span> r.mu.Unlock()</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> _, user := <span class="keyword">range</span> r.users &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> user.Email == email &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span> model.NewUser(user.ID, user.Email), <span class="literal">nil</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *userRepository)</span> <span class="title">Save</span><span class="params">(user *model.User)</span> <span class="title">error</span></span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    r.mu.Lock()</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">defer</span> r.mu.Unlock()</span></pre></td></tr><tr><td class="code"><pre><span class="line">    r.users[user.GetID()] = &amp;User&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ID:    user.GetID(),</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Email: user.GetEmail(),</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>这是存储库的具体实现。如果我们需要将用户持久保存到RDB或其他，我们将需要另一个实现。但即使在这种情况下，我们也不需要更改模型层。模型层仅依赖于存储库接口，并对实现细节毫不关心。这很鹅妹子嘤。<br><br>这里的 User 仅在当前包中定义，用于实现跨越层级的信息解封。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ID    <span class="keyword">string</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    Email <span class="keyword">string</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p><a name="f04c0c37"></a></p>
<h4 id="gRPC-service"><a href="#gRPC-service" class="headerlink" title="gRPC service"></a>gRPC service</h4><p>作者认为gRPC服务也应当包括在接口层中。gRPC服务的目录结构如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">% tree</span></pre></td></tr><tr><td class="code"><pre><span class="line">.</span></pre></td></tr><tr><td class="code"><pre><span class="line">├── rpc.go</span></pre></td></tr><tr><td class="code"><pre><span class="line">└── v1.0</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ├── protocol</span></pre></td></tr><tr><td class="code"><pre><span class="line">    │   ├── user_service.pb.go</span></pre></td></tr><tr><td class="code"><pre><span class="line">    │   └── user_service.proto</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ├── user_service.go</span></pre></td></tr><tr><td class="code"><pre><span class="line">    └── v1.go</span></pre></td></tr></table></figure>

<p>protocol 目录包含协议缓冲区DSL文件（user_service.proto）和生成的RPC服务代码（user_service.pb.go）。<br><br>user_service.go 是gRPC端点处理程序的包装器：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> userService <span class="keyword">struct</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    userUsecase usecase.UserUsecase</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewUserService</span><span class="params">(userUsecase usecase.UserUsecase)</span> *<span class="title">userService</span></span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> &amp;userService&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        userUsecase: userUsecase,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *userService)</span> <span class="title">ListUser</span><span class="params">(ctx context.Context, in *protocol.ListUserRequestType)</span> <span class="params">(*protocol.ListUserResponseType, error)</span></span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    users, err := s.userUsecase.ListUser()</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    res := &amp;protocol.ListUserResponseType&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Users: toUser(users),</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> res, <span class="literal">nil</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *userService)</span> <span class="title">RegisterUser</span><span class="params">(ctx context.Context, in *protocol.RegisterUserRequestType)</span> <span class="params">(*protocol.RegisterUserResponseType, error)</span></span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> err := s.userUsecase.RegisterUser(in.GetEmail()); err != <span class="literal">nil</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> &amp;protocol.RegisterUserResponseType&#123;&#125;, err</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> &amp;protocol.RegisterUserResponseType&#123;&#125;, <span class="literal">nil</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">toUser</span><span class="params">(users []*usecase.User)</span> []*<span class="title">protocol</span>.<span class="title">User</span></span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"> res := <span class="built_in">make</span>([]*protocol.User, <span class="built_in">len</span>(users))</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> i, user := <span class="keyword">range</span> users &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        res[i] = &amp;protocol.User&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            Id:    user.ID,</span></pre></td></tr><tr><td class="code"><pre><span class="line">            Email: user.Email,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> res</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>userService 仅依赖用例接口。如果你想在其它层级（例如，终端）中使用用例，你可以在接口层中按照需求实现该服务。<br><br>v1.go 使用DI容器解析对象依赖项：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Apply</span><span class="params">(server *grpc.Server, ctn *registry.Container)</span></span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    protocol.RegisterUserServiceServer(server, NewUserService(ctn.Resolve(<span class="string">"user-usecase"</span>).(usecase.UserUsecase)))</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>v1.go将从* registry.Container检索到的包应用于gRPC服务。</p>
<p>最后，简单看一下DI容器的实现。</p>
<p><a name="registry"></a></p>
<h3 id="registry"><a href="#registry" class="headerlink" title="registry"></a>registry</h3><p>registry 是一个DI 容器用以解析对象依赖。这里使用了 <a href="https://github.com/sarulabs/di" target="_blank" rel="external nofollow noopener noreferrer">github.com/sarulabs/di</a> 作为DI容器。</p>
<p>github.com/surulabs/di  使用起来很简单：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Container <span class="keyword">struct</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ctn di.Container</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewContainer</span><span class="params">()</span> <span class="params">(*Container, error)</span></span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    builder, err := di.NewBuilder()</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> err := builder.Add([]di.Def&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            Name:  <span class="string">"user-usecase"</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">            Build: buildUserUsecase,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;...); err != <span class="literal">nil</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> &amp;Container&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ctn: builder.Build(),</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;, <span class="literal">nil</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Container)</span> <span class="title">Resolve</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> c.ctn.Get(name)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Container)</span> <span class="title">Clean</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> c.ctn.Clean()</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">buildUserUsecase</span><span class="params">(ctn di.Container)</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span></span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    repo := memory.NewUserRepository()</span></pre></td></tr><tr><td class="code"><pre><span class="line">    service := service.NewUserService(repo)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> usecase.NewUserUsecase(repo, service), <span class="literal">nil</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>例如，在上面，将 user-usecase 字符串通过 buildUserUsecase 函数与具体用例实现关联起来。由此，我们可以在注册文件中任意替换用例的具体实现。</p>
]]></content>
      <categories>
        <category>译文</category>
      </categories>
      <tags>
        <tag>译文</tag>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>Thanos基本功能总结</title>
    <url>/post/1f42eec9.html</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th align="center">Date</th>
<th align="center">Log</th>
</tr>
</thead>
<tbody><tr>
<td align="center">01/07/2018</td>
<td align="center">初始版本：根据杭州Service Mesh线下Meet Up中唐老师相关讲解内容和官方文档简单总结.</td>
</tr>
</tbody></table><p>Prometheus和Grafana作为监控界的仙侣组合为我们进行系统运行状况的监控提供了极大的便利，简单说，Prometheus对数据进行采集，Grafana对对数据进行图表形式的展示。当然它们也提供了更多高级功能。<br><br>在规模不大且结构简单的系统中，Prometheus的基本功能已经可以完全满足用户需求。但在一些复杂场景下Prometheus的应用会面临一些问题，Prometheus本身应对这些问题略显吃力。而Thanos正是Improbable-eng团队为解决这些问题而开发的一款开源中间层框架，它对Grafana提供与Prometheus一致的数据源接口，同时可以无缝地部署到现有的Prometheus环境中，不需要对Prometheus做任何定制。</p><a id="more"></a>

<p><a name="87f45c06"></a></p>
<h3 id="Prometheus面临的问题"><a href="#Prometheus面临的问题" class="headerlink" title="Prometheus面临的问题"></a>Prometheus面临的问题</h3><ol>
<li>全局视图<br><br>当Prometheus用于监控多个Kubernetes集群时，它并没有提供一种较好的全局统一的数据采集方式。举个例子，需要实现当有60%的集群处于掉线状态时监控系统进行报警，通过Prometheus该如何实现？如何将来自不同集群的数据进行聚合？</li>
<li>高可用<br><br>Prometheus如何方便的实现高可用？较为简单的方案是在同一个server上启动两个Prometheus实例，通过简单的反向代理实现高可。但问题是两个Prometheus实例的数据信息出现不一致时该如何处理，例如一段时间内其中一个实例的数据为空，另一个实例的数据可用，则在前端的不同查询可能会对同一时间段的信息展示出现完全不同的效果，影响监控人员的使用。因此需要进行数据合并。</li>
<li>历史数据的处理<br><br>Prometheus本身使用本地存储，为保证存储空间可用，会定时清理存储的监控数据，如果监控人员需要对长期的监控数据，例如1年的数据，进行分析，进而分析系统的潜在问题。对于Prometheus来说纵向扩充硬盘的体积是较为简单的解决方案，然而这种形式成本高昂，也不方便数据管理和迁移。</li>
</ol>
<p><a name="d66e0cef"></a></p>
<h3 id="Thanos的解决方案"><a href="#Thanos的解决方案" class="headerlink" title="Thanos的解决方案"></a>Thanos的解决方案</h3><p>Thanos致力于通过一种简单的可无缝接入当前系统的方案解决这些问题。其主要功能点通过Sidecar、Querier、Store和Compactor来实现，这里做一个简单介绍。</p>
<ol>
<li>Sidecar<br><br>Sidecar作为一个单独的进程和已有的Prometheus实例运行在一个server上，互不影响。Sidecar可以视为一个Proxy组件，所有对Prometheus的访问都通过Sidecar来代理进行。通过Sidecar还可以将采集到的数据直接备份到云端对象存储服务器。</li>
<li>Querier<br><br>所有的Sidecar与Querier直连，同时Querier实现了一套Prometheus官方的HTTP API从而保证对外提供与Prometheus一致的数据源接口，Grafana可以通过同一个查询接口请求不同集群的数据，Querier负责找到对应的集群并通过Sidecar获取数据。Querier本身也是水平可扩展的，因而可以实现高可部署，而且Querier可以实现对高可部署的Prometheus的数据进行合并从而保证多次查询结果的一致性，从而解决全局视图和高可用的问题。</li>
<li>Store<br><br>Store实现了一套和Sidecar完全一致的API提供给Querier用于查询Sidecar备份到云端对象存储的数据。因为Sidecar在完成数据备份后，Prometheus会清理掉本地数据保证本地空间可用。所以当监控人员需要调取历史数据时只能去对象存储空间获取，而Store就提供了这样一个接口。Store Gateway只会缓存对象存储的基本信息，例如存储块的索引，从而保证实现快速查询的同时占用较少本地空间。</li>
<li>Comactor<br><br>Compactor主要用于对采集到的数据进行压缩，实现将数据存储至对象存储时节省空间。</li>
</ol>
<p><a name="c23f4d1c"></a></p>
<h3 id="Thanos的生产可用性"><a href="#Thanos的生产可用性" class="headerlink" title="Thanos的生产可用性"></a>Thanos的生产可用性</h3><p>Thanos诞生还不到一年，目前最新的发布版本为0.1.0-rc.1，大量的生产实践还未看到，短期预计还不具备生产可用性，但是解决问题的理念值得长期关注。</p>
]]></content>
      <categories>
        <category>云计算</category>
      </categories>
      <tags>
        <tag>云计算</tag>
        <tag>Thanos</tag>
        <tag>Prometheus</tag>
      </tags>
  </entry>
  <entry>
    <title>物联网导论-读书笔记</title>
    <url>/post/3b6b3aeb.html</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th align="center">Date</th>
<th align="center">Log</th>
</tr>
</thead>
<tbody><tr>
<td align="center">05/05/2017</td>
<td align="center">初始版本，增加第一章、第二章笔记。</td>
</tr>
</tbody></table><p>本文汇总了在阅读&lt;物联网导论&gt;过程中所做的总结，记录，以及补充内容。</p><p><a name="e8be9f64"></a></p><h3 id="物联网概述"><a href="#物联网概述" class="headerlink" title="物联网概述"></a>物联网概述</h3><ul>
<li>存在的，就是上网的。</li>
<li>物联网是一个基于互联网、传统电信网等信息承载体，让所有能够被独立寻址的普通物理对象实现互联互通的网络。它具有普通对象设备化、自治终端互联化和普通服务智能化三个重要特征。</li>
<li>根据信息生成、传输、处理和应用的原则，可以把物联网分为四层：感知识别层、网络构建层、管理服务层和综合应用层。</li>
<li>从网络的角度来观察，物联网具有以下几个特点：在网络终端层面呈现联网终端规模化、感知识别普适化的特点，在通信层面呈现异构设备互联化的特点，在数据层面呈现管理处理智能化的特点，在应用层面呈现应用服务链条化的特点。</li>
<li>互联互通的对象从人延展到物体，不仅人与人要交流，物和物也要互通。在物联网时代，能主动认知和控制自己之外的对象的，可以称作是具有主动智能的，而有能力使得自身被智能主体所认知和控制的，可以称作是拥有被动智能的。被动智能也是智能。</li>
<li>互联互通方式的扩展，也就是网络通信模式的扩展，亦即更深层次的广泛与全面。</li>
<li>环境监测应用最为成熟，智能物流当前最为热门，智能交通正在起步，智能建筑还是未来的事。</li>
</ul><a id="more"></a>



<p><a name="747932b9"></a></p>
<h3 id="感知识别"><a href="#感知识别" class="headerlink" title="感知识别"></a>感知识别</h3><p><a name="b30050b3"></a></p>
<h4 id="自动识别与RFID"><a href="#自动识别与RFID" class="headerlink" title="自动识别与RFID"></a>自动识别与RFID</h4><ul>
<li>光符号识别技术：初衷是让机器按照人类的方式来阅读和识别，结果是促进了人工智能和图像处理等领域的发展。</li>
<li>语音识别技术：语音控制、语音输入、语音导航等。</li>
<li>生物量识别技术：虹膜识别技术-认证精确度高，多用于机场口岸； 指纹识别技术-犯罪记录追踪等。</li>
<li>IC卡技术：一种数据存储系统，通过内置EEPROM来存储数据，必要时可加入计算能力。公交卡（非接触式），电话卡（接触式）。</li>
<li>条形码技术：一维条形码-例如ISBN图书码；二维条形码-现已常用。</li>
<li>射频识别技术（RFID）：利用射频信号通过空间耦合（交变磁场或电磁场）实现无接触信息传递并通过所传递的信息达到自动识别目的。</li>
<li>RFID 一般由传送器、接收器、微处理器、天线和标签五个部分组成； 传送器、接收器和微处理器通常都被封装在一起称为阅读器。</li>
</ul>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>读书</tag>
        <tag>笔记</tag>
        <tag>物联网</tag>
      </tags>
  </entry>
  <entry>
    <title>系统测试-学习笔记</title>
    <url>/post/785a571c.html</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th align="center">Date</th>
<th align="center">Log</th>
</tr>
</thead>
<tbody><tr>
<td align="center">05/04/2017</td>
<td align="center">初始版本，增加测试基础知识。</td>
</tr>
</tbody></table><p>本文汇总了在学习视频课程&lt;系统测试&gt;过程中所做的总结，记录。<br><br><a name="8453e91e"></a></p><h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><p><a name="e2d6d0e3"></a></p><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><ul>
<li>测试的概念：整个研发过程中对文档、流程、产品等进行确认和验证的一系列活动。</li>
<li>证明软件不能工作。</li>
<li>破坏性的工作。</li>
<li>目标：发现缺陷，度量质量，预防问题。</li>
<li>技术能力：测试、编程、网络、数据库。</li>
<li>业务知识：行业标准、规范。</li>
<li>沟通能力：开发、产品、客户。</li>
</ul><a id="more"></a>



<p><a name="0705b877"></a></p>
<h4 id="软件研发模型"><a href="#软件研发模型" class="headerlink" title="软件研发模型"></a>软件研发模型</h4><ul>
<li>软件生命周期：从软件构思到发行或丢弃的过程。</li>
<li>大爆炸模型：没有组织、没有流程、没有文档，现已少用。</li>
<li>瀑布模型：每个过程顺序衔接，一次性通过，有严格的进入和退出条件，有大量的文档，不能后退，开发周期较长，适用于需求明确且很少变更的项目。</li>
<li>增量模型：采用随时间进展而交错的线性序列，每个序列产生一个可发布的增量、每个增量产生一个可操作的产品、第一个增量是核心产品；开始时不用投入大量资源，但需要开放式的开发体系架构，管控风险较大；适用于需求经常变更的场景。</li>
<li>螺旋模型：每一圈都经过计划、风险分析、实施、评估过程；由文档和风险驱动，有利于提高大型项目开发的质量和效率；建设周期长、风险大；适用于需求经常变化的大型复杂系统。</li>
<li>快速原型模型：快速构建原型，便于与用户沟通进一步细化需求，在新获取需求基础上进行系统开发；可避免需求模糊带来的风险；快速开发以及频繁修改可能造成开发质量降低；适用于用户需求不明的场景。</li>
<li>双V模型：开发与测试同步进行，开发保证设计被实现，测试验证是否正确；测试接入早，有利于保证产品质量；对于测试开发技术要求比较高；适用于需求明确的场景。</li>
<li>敏捷模型：将大的项目分为多个相互联系，但也可以独立运行的小项目，并分别完成，在此过程中软件一直处于可用状态；最重要的是尽早并持续交付可用的产品；对于工程人员个人业务素质要求较高；轻量、高效、低风险，适用于中小型开发团队；变化的模型，按需和其它模型结合。</li>
</ul>
<p><a name="663e8f15"></a></p>
<h4 id="软件缺陷"><a href="#软件缺陷" class="headerlink" title="软件缺陷"></a>软件缺陷</h4><ul>
<li>概念：破坏软件正常运行的问题。</li>
<li>术语：故障-fault；缺点-defect；失败-failure；事件-incident；偏差-variance；改进-improvement；缺陷-bug…</li>
<li>缺陷修复成本随开发阶段推进呈数量级增长。</li>
<li>引入原因：软件的复杂性、沟通缺失、设计与开发与测试理解偏差、程序设计错误、项目进度压力、需求变化、文档贫乏…</li>
</ul>
<p><a name="527628b9"></a></p>
<h4 id="测试分类"><a href="#测试分类" class="headerlink" title="测试分类"></a>测试分类</h4><ul>
<li>测试类型：功能-用的对、性能-用的快、安全-用的放心、可靠-随便怎么用、可用-用的爽、兼容-到处可用…</li>
<li>测试阶段：单元测试-对代码函数的测试，一般由开发人员完成；集成测试-接口或模块或子系统之间的对接；系统测试-产品完成可能包括软硬件；验收测试-内测（α测试），公测（β测试），生产环境测试，可能是在开发方（模拟用户）测试，也可能在客户方测试。</li>
<li>测试过程：分析-依据需求分析；设计-测试方案、用例；实现-用例的开发；执行。</li>
<li>测试技术：自动化；手工。</li>
<li>测试手段：静态-不执行程序，审查代码，文档；动态-执行程序。</li>
<li>测试方法：黑盒-系统测试大量采用；灰盒-集成测试采用，有时偏白，有时偏黑；白盒-单元测试采用。</li>
</ul>
<p><a name="d4ec14ac"></a></p>
<h3 id="测试的实施"><a href="#测试的实施" class="headerlink" title="测试的实施"></a>测试的实施</h3><p><a name="8818f2af"></a></p>
<h4 id="测试十大原则"><a href="#测试十大原则" class="headerlink" title="测试十大原则"></a>测试十大原则</h4><ul>
<li>测试是一个持续进行的过程，而不是一个阶段</li>
<li>测试必须被计划、控制，并且被提供时间和资源</li>
<li>测试应当有重点</li>
<li>测试不是为了证程序的正确性，而是为了证明程序不能工作</li>
<li>测试是不可能穷尽的，当测试出口条件满足时就可以停止测试</li>
<li>测试是开发的朋友，不是开发的敌人</li>
<li>测试人员应当站在公正的立场上进行测试，如实的记录和报告缺陷</li>
<li>测试自动化能解决一部分问题，但不是全部</li>
<li>测试不能仅仅包括功能性的验证，还应当包含性能、可靠性、可维护性、安全性等方面的验证</li>
<li>并非所有的软件缺陷都需要修复（时间、修复之后引入更多问题）</li>
</ul>
<p><a name="5d63c027"></a></p>
<h4 id="测试十大误区"><a href="#测试十大误区" class="headerlink" title="测试十大误区"></a>测试十大误区</h4><ul>
<li>调试（开发人员排故）和测试（测试人员发现错误）是一样的</li>
<li>测试组应当为保证质量负责</li>
<li>过分依赖Beta测试</li>
<li>把测试作为新员工的一个过渡工作</li>
<li>把不合格的开发人员安排做测试</li>
<li>关注于测试的执行而忽略测试的设计：分析和设计是很难的，是重点</li>
<li>测试自动化是万能的</li>
<li>测试是可以穷尽的</li>
<li>测试是为了证明软件的正确性</li>
<li>测试是鼓噪乏味，缺乏创造力的工作</li>
</ul>
<p><a name="0025b974"></a></p>
<h4 id="测试十大最佳实践"><a href="#测试十大最佳实践" class="headerlink" title="测试十大最佳实践"></a>测试十大最佳实践</h4><ul>
<li>尽早频繁地进行测试是降低项目成本，提高质量的一个好的实践</li>
<li>尽早的产生一个综合的主测试计划</li>
<li>对质量要求较高的产品或大型复杂的产品成立独立的测试组</li>
<li>在每个开发阶段，使用测试和评价的结果作为是否可以通过的标准</li>
<li>开发和维护一个测试需求和目标的风险优先级列表</li>
<li>把测试产出物作为产品的一部分等同管理起来，使用相同的评价标准和过程</li>
<li>提供集成化的测试工具和测试基础支持</li>
<li>加强测试度量工作和缺陷分析工作，不断的改进测试</li>
<li>加强测试的培训并且为测试人员提供技能发展的通道</li>
<li>加强沟通，让项目组内所有的人员都了解测试的重要性和测试工作</li>
</ul>
<p>参考资料：  <a href="http://study.163.com/course/courseMain.htm?courseId=1003097001" target="_blank" rel="external nofollow noopener noreferrer">系统测试-测试基础，类型，用例设计方法</a></p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>系统测试</tag>
      </tags>
  </entry>
  <entry>
    <title>喜欢的音乐</title>
    <url>/post/102c919d.html</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th align="center">Date</th>
<th align="center">Log</th>
</tr>
</thead>
<tbody><tr>
<td align="center">04/08/2017</td>
<td align="center">初始版本，增加’Stories’, ‘万神纪’, ‘手纸 拝启 十五の君’, ‘永遠語り～風ノ歌～’, ‘与君说’, ‘だんご大家族’.</td>
</tr>
<tr>
<td align="center">04/16/2017</td>
<td align="center">增加“锦鲤抄”。</td>
</tr>
</tbody></table><p>本文汇总了一些好听的歌。</p><p><a name="Stories"></a></p><h3 id="Stories"><a href="#Stories" class="headerlink" title="Stories"></a>Stories</h3><p>All Hail Lelouch !<br><center style="padding:0px;">  <p style="font: bold 20px arial,sans-serif; margin:0px; padding:0px;">All Hail Lelouch !</p>   <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=22805139&auto=0&height=66"></iframe>  </center></p><a id="more"></a>



<p><a name="ecafeeb0"></a></p>
<h3 id="万神纪"><a href="#万神纪" class="headerlink" title="万神纪"></a>万神纪</h3><center style="padding:0px;">    <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=459554803&auto=0&height=66"></iframe>   
<iframe src="https://player.bilibili.com/player.html?aid=8542373" frameborder="no" allowfullscreen="true"></iframe>
</center> 

<p><a name="2b628dc2"></a></p>
<h3 id="锦鲤抄"><a href="#锦鲤抄" class="headerlink" title="锦鲤抄"></a>锦鲤抄</h3><center style="padding:0px;"><br><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=28188434&auto=0&height=66"></iframe>
<iframe src="https://player.bilibili.com/player.html?aid=9119029" frameborder="no" allowfullscreen="true"></iframe>
</center>  

<p><a name="7c0c448e"></a></p>
<h3 id="手纸-拝启-十五の君-信-写给十五岁的自己"><a href="#手纸-拝启-十五の君-信-写给十五岁的自己" class="headerlink" title="手纸 拝启 十五の君 (信 写给十五岁的自己)"></a>手纸 拝启 十五の君 (信 写给十五岁的自己)</h3><center style="padding:0px;">

<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=550667&auto=1&height=66"></iframe><br></center>

<p><a name="23662a56"></a></p>
<h3 id="永遠語り～風ノ歌～-永远语-风之歌"><a href="#永遠語り～風ノ歌～-永远语-风之歌" class="headerlink" title="永遠語り～風ノ歌～ (永远语 风之歌)"></a>永遠語り～風ノ歌～ (永远语 风之歌)</h3><center style="padding:0px;"><br><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=31168232&auto=0&height=66"></iframe><br></center>

<p><a name="33c82892"></a></p>
<h3 id="与君说"><a href="#与君说" class="headerlink" title="与君说"></a>与君说</h3><center style="padding:0px;"><br><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=462688968&auto=0&height=66"></iframe>
<iframe src="https://player.bilibili.com/player.html?aid=7536941" frameborder="no" allowfullscreen="true"></iframe>
</center>

<p><a name="Nl9xl"></a></p>
<h3 id="だんご大家族-团子大家族"><a href="#だんご大家族-团子大家族" class="headerlink" title="だんご大家族 (团子大家族)"></a>だんご大家族 (团子大家族)</h3><center style="padding:0px;"><br><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=760533&auto=0&height=66"></iframe><br></center>


<script src="https://cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><br><script>window.onload = window.onresize = function() {  $(".fluid-vids").css({ margin: "0px", padding: "0px", height: "86px"});  $("center>iframe").css({ width: "97%" });  $("center>iframe").height($("center>iframe").width() * 0.60);  $("center>br").remove();}; </script>

]]></content>
      <categories>
        <category>音乐</category>
      </categories>
      <tags>
        <tag>音乐</tag>
      </tags>
  </entry>
  <entry>
    <title>Qt 常见编译问题汇总</title>
    <url>/post/da23d674.html</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th align="center">Date</th>
<th align="center">Log</th>
</tr>
</thead>
<tbody><tr>
<td align="center">04/07/2017</td>
<td align="center">Initial version: add “constant string to char *” and “comparison between signed and unsigned integer “.</td>
</tr>
<tr>
<td align="center">04/15/2017</td>
<td align="center">add “undefined reference to `inet_addr@4’ “</td>
</tr>
</tbody></table><a id="more"></a>
<p>本文汇总了在Qt  5.8中使用C++进行开发时遇到的编译错误和警告及其解决方法，基于C++11标准。</p>
<p><a name="eca07263"></a></p>
<h3 id="constant-string-to-char"><a href="#constant-string-to-char" class="headerlink" title="constant string to char *"></a>constant string to char *</h3><p>初始代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">char *p &#x3D; &quot;Hello&quot;;</span></pre></td></tr></table></figure>

<p>编译输出：</p>
<blockquote>
<p>ISO C++ forbids conversion from constant string to char *.</p>
</blockquote>
<p>修改代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">char const *p &#x3D; &quot;Hello&quot;;</span></pre></td></tr></table></figure>

<p>参考资料：</p>
<ol>
<li><a href="http://stackoverflow.com/questions/20944784/why-is-conversion-from-string-constant-to-char-valid-in-c-but-invalid-in-c" target="_blank" rel="external nofollow noopener noreferrer">Why is conversion from string constant to ‘char*’ valid in C but invalid in C++</a></li>
</ol>
<p><a name="0fd228ba"></a></p>
<h3 id="comparison-between-signed-and-unsigned"><a href="#comparison-between-signed-and-unsigned" class="headerlink" title="comparison between signed and unsigned"></a>comparison between signed and unsigned</h3><p>初始代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for (int i &#x3D; 0, max &#x3D; vec.size(); i !&#x3D; max; ++i)</span></pre></td></tr></table></figure>

<p>编译输出：</p>
<blockquote>
<p>warning: comparison between signed and unsigned integer expressions [-Wsign-compare]</p>
</blockquote>
<p>修改代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for (std::size_t i &#x3D; 0, max &#x3D; vec.size(); i !&#x3D; max; ++i)</span></pre></td></tr></table></figure>

<p>附加注释：</p>
<blockquote>
<p>一般情况下，直接使用size_t即可。</p>
</blockquote>
<p>参考资料：</p>
<ol>
<li><a href="http://stackoverflow.com/questions/7984955/what-is-wrong-with-my-for-loops-i-get-warnings-comparison-between-signed-and-u" target="_blank" rel="external nofollow noopener noreferrer">What is wrong with my For loops? i get warnings: comparison between signed and unsigned integer expressions [-Wsign-compare]</a></li>
<li><a href="http://stackoverflow.com/questions/3660901/a-warning-comparison-between-signed-and-unsigned-integer-expressions" target="_blank" rel="external nofollow noopener noreferrer">A warning - comparison between signed and unsigned integer expressions</a></li>
</ol>
<p><a name="d52d44a9"></a></p>
<h3 id="undefined-reference-to-inet-addr-4’"><a href="#undefined-reference-to-inet-addr-4’" class="headerlink" title="undefined reference to `inet_addr@4’"></a>undefined reference to `inet_addr@4’</h3><p>编译输出：</p>
<blockquote>
<p>undefined reference to `inet_addr@4’</p>
</blockquote>
<p>问题分析：</p>
<blockquote>
<p>这种情况是因为没有把 ws2_32.lib 或 libws2_32.a 加入到编译依赖项中。<br><br>一般情况下，出现类似的undefined reference to ‘…@…’都是因为只在源代码中引入了头文件，而没有在编译依赖中加入库文件。这种错误多出现在同时具有头文件，静态库，动态库的外部库的引用过程中。</p>
</blockquote>
]]></content>
      <categories>
        <category>Qt</category>
      </categories>
      <tags>
        <tag>Qt</tag>
        <tag>编译</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Qt 5.8 中的实用功能配置</title>
    <url>/post/65827044.html</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th align="center">Date</th>
<th align="center">Log</th>
</tr>
</thead>
<tbody><tr>
<td align="center">03/27/2017</td>
<td align="center">初始版本，增加”使用SVN进行版本控制”和”使用第三方代码格式化工具”两个章节。</td>
</tr>
</tbody></table><p>Qt 中已经集成了强大的扩展功能，根据需要进行简单的配置就可以更方便的进行开发。以下配置均基于Windows平台。</p><p><a name="42218e06"></a></p><h2 id="使用SVN进行版本控制"><a href="#使用SVN进行版本控制" class="headerlink" title="使用SVN进行版本控制"></a>使用SVN进行版本控制</h2><p>前提是你的项目中已经有SVN服务器，没有的话可以自行搭建，参考[TBD]。</p><a id="more"></a>



<p><a name="7721685c"></a></p>
<h3 id="下载并安装SVN命令行客户端"><a href="#下载并安装SVN命令行客户端" class="headerlink" title="下载并安装SVN命令行客户端"></a>下载并安装SVN命令行客户端</h3><p>推荐使用<a href="https://sliksvn.com/download/" target="_blank" rel="external nofollow noopener noreferrer">SlikSVN</a>。下载后按照提示正常安装即可。</p>
<p><a name="79262238"></a></p>
<h3 id="打开-Qt-进行设置"><a href="#打开-Qt-进行设置" class="headerlink" title="打开 Qt 进行设置"></a>打开 Qt 进行设置</h3><ol>
<li>打开Qt，点击菜单栏”Tools”下的”Options”选项，弹出如下图所示的设置窗口。</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2019/png/182657/1575440239388-be68ae19-ccea-4767-a0aa-66d7d99af9da.png#align=left&display=inline&height=677&name=image.png&originHeight=677&originWidth=1178&size=105310&status=done&style=none&width=1178" alt="image.png"><br></p>
<ol start="2">
<li>在窗口左侧导航栏中，选择”Version Control”,然后点击”Subversion”选项卡，设置”Subversion command”路径-上一步中安装的SlikSvn路径，”Username”和”Password”,然后保存并退出。</li>
</ol>
<p><a name="2109a010"></a></p>
<h3 id="通过-Qt-导入SVN中的工程"><a href="#通过-Qt-导入SVN中的工程" class="headerlink" title="通过 Qt 导入SVN中的工程"></a>通过 Qt 导入SVN中的工程</h3><ol>
<li>点击菜单栏”File”，选择”New File or Project”，弹出如下窗口。</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2019/png/182657/1575440346832-96128373-e3af-42e9-877c-0341b124c797.png#align=left&display=inline&height=629&name=image.png&originHeight=629&originWidth=962&size=85193&status=done&style=none&width=962" alt="image.png"></p>
<ol start="2">
<li>依次选择”Import Project”，”Subversion Checkout”，然后点击”Choose”选项，弹出如下窗口。<br></li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2019/png/182657/1575440378311-0ced6759-7122-4060-92cb-a21d594e9f44.png#align=left&display=inline&height=573&name=image.png&originHeight=573&originWidth=882&size=80786&status=done&style=none&width=882" alt="image.png"></p>
<ol start="3">
<li>在窗体中分别设置”Repository”-要导入的已经保存在SVN中的工程的路径，”Path”-本地保存路径，”Directory”-本地工程目录名（建议使用默认），然后点击”Next”开始自动Checkout，等Checkout完成，打开当前工程，即可开始开发工作。</li>
</ol>
<p><a name="64eed538"></a></p>
<h3 id="在-Qt-中进行SVN常用操作"><a href="#在-Qt-中进行SVN常用操作" class="headerlink" title="在 Qt 中进行SVN常用操作"></a>在 Qt 中进行SVN常用操作</h3><p>对工程代码文件修改后，可在菜单栏”Tools”下找到SVN常用的”Add”,”Commit”等指令，如下图。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2019/png/182657/1575440398604-6260a817-8f50-416b-ac37-d3bb7f06f34c.png#align=left&display=inline&height=781&name=image.png&originHeight=781&originWidth=977&size=210113&status=done&style=none&width=977" alt="image.png"></p>
<p><a name="3da7a94e"></a></p>
<h2 id="使用第三方代码格式化工具"><a href="#使用第三方代码格式化工具" class="headerlink" title="使用第三方代码格式化工具"></a>使用第三方代码格式化工具</h2><p>Qt 中内置了代码格式化工具，其默认快捷键是Ctrl + i，使用很方便，但是无法对赋值操作”=”两侧自动添加空格，这很不爽，我尝试修改配置文件，却仍然毫无效果，于是决定使用第三方格式化工具。<br><br>这个配置过程主要参考的是Qt Creator的<a href="http://doc.qt.io/qtcreator/creator-beautifier.html" target="_blank" rel="external nofollow noopener noreferrer">官方手册</a>，这里只是稍作翻译。</p>
<p><a name="316d92d0"></a></p>
<h3 id="打开-Beautifier-功能"><a href="#打开-Beautifier-功能" class="headerlink" title="打开 Beautifier 功能"></a>打开 Beautifier 功能</h3><p>选择Help &gt; About Plugins &gt; C++ &gt; Beautifier 来打开 Beautifier 功能，之后重启 Qt Creator 以使 Beautifier 生效。</p>
<p><a name="a420232a"></a></p>
<h3 id="下载安装第三方代码格式化工具"><a href="#下载安装第三方代码格式化工具" class="headerlink" title="下载安装第三方代码格式化工具"></a>下载安装第三方代码格式化工具</h3><p>Beautifier 支持 Artistic Style, ClangFormat, Uncrustify 三种工具，我都进行了尝试，Artistic Style 没有配置成功，Uncrustify 自带的代码格式化风格没有合适的，最后使用了 ClangFormat，这本是我最不想用的，因为获取其安装包的两种方式都很不爽，一种是自行编译-相当麻烦，一种是下载官方编译好的安装包 LLVM-包含了很多其它工具，非常臃肿。<br><br>其实 LLVM 是一款很强大的工具，只是在这里只用到了其中的 ClangFormat 功能，打开<a href="http://releases.llvm.org/download.html" target="_blank" rel="external nofollow noopener noreferrer">LLVM</a>页面，选择<br><br>Clang for Windows 32位或64位下载官方编译好的安装包，正常安装即可。</p>
<p><a name="ab8a866d"></a></p>
<h3 id="在-Qt-中配置-ClangFormat"><a href="#在-Qt-中配置-ClangFormat" class="headerlink" title="在 Qt 中配置 ClangFormat"></a>在 Qt 中配置 ClangFormat</h3><ol>
<li>打开Qt，点击菜单栏”Tools”下的”Options”选项，弹出如下图所示的设置窗口。<br></li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2019/png/182657/1575440424321-012b41a0-fc18-4ffe-8e55-920b51fd416b.png#align=left&display=inline&height=677&name=image.png&originHeight=677&originWidth=1178&size=95656&status=done&style=none&width=1178" alt="image.png"></p>
<ol start="2">
<li>在窗口左侧导航栏中，选择”Beautifier”,然后在”General”选项卡下勾选”Enable auto format on file save”使得文件在保存时自动格式化，并选择”Tool”为ClangFormat。</li>
<li>选择”Clang Format”选项卡，设置”Clang Format command”为ClangFormat安装路径，选择”Use predefined style”为你需要的代码风格，如下图，之后保存并退出。<br></li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2019/png/182657/1575440448145-ed66c2da-2ece-4773-b1f3-0bedc3286748.png#align=left&display=inline&height=677&name=image.png&originHeight=677&originWidth=1178&size=108392&status=done&style=none&width=1178" alt="image.png"></p>
<p><a name="386a789b"></a></p>
<h3 id="设置格式化快捷键"><a href="#设置格式化快捷键" class="headerlink" title="设置格式化快捷键"></a>设置格式化快捷键</h3><p>已经习惯了使用Ctrl + i 作为格式化快捷键，因此需要重新设置一下。<br><br>选择Tools &gt; Options &gt; Environment &gt; Keyboard，首先去掉默认的 AutoIndentSelection 的快捷键Ctrl + i，再为 ClangFormat 的 FormatSelectedText 添加快捷键Ctrl + i，保存并关闭又可以愉快地使用Ctrl + i了，如下图所示。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2019/png/182657/1575440471310-0ee910d2-b3e5-4747-adc6-a710d582a4b5.png#align=left&display=inline&height=677&name=image.png&originHeight=677&originWidth=1178&size=113437&status=done&style=none&width=1178" alt="image.png"></p>
]]></content>
      <categories>
        <category>Qt</category>
      </categories>
      <tags>
        <tag>Qt</tag>
        <tag>SVN</tag>
        <tag>代码格式化</tag>
      </tags>
  </entry>
</search>
